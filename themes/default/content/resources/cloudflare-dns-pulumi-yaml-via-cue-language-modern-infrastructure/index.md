---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Cloudflare DNS with Pulumi YAML via CUE language | Modern Infrastructure"
title: "Cloudflare DNS with Pulumi YAML via CUE language |..."
meta_desc: |
    In this LIVE Modern Infrastructure, David explores using CUE to provide a Cloudflare DNS abstraction for Pulumi YAML.
url_slug: cloudflare-dns-pulumi-yaml-via-cue-language-modern-infrastructure
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Cloudflare DNS with Pulumi YAML via CUE language | Modern Infrastructure"
  description: |
    In this LIVE Modern Infrastructure, David explores using CUE to provide a Cloudflare DNS abstraction for Pulumi YAML.  Pulumi-YAML: https://github.com/pulumi/pulumi-yaml
  sortable_date: 2022-05-27T14:47:30Z
  youtube_url: https://www.youtube.com/embed/YATPtKehD4o
transcript: |
    Hello and welcome to P TV. This is modern infrastructure. My name is David Flanagan. Although you may know me from across the internet as rock. No, we don't often do modern infrastructure life, but I decided to shake things up a little bit. This week today, we're going to be taking a look at using Ploy's new Yael support via the Lang or Q language. Um We did an episode on Lang around two weeks ago where we were joined by Paul Jolly, one of the core maintainers of Q and I've been experimenting with it a fair bit since then. Um I really think that Q is a powerful uh data language and if we want to generate Gammel to be consumed by Pulumi, it allows us to do some pretty cool things. So we're going to take a look at provision in cloud player DNS records. Now, the reason I'm going for DNS records is that they are very declarative. Um We don't need a lot of imperative code which means structuring it as data works really well. And what Q allows us to do is to build some abstractions around the way that we uh produce that declarative structure and I think it's really cool. Now, there is a fair amount of QE involved, but you rate it once and you can. So the code that we're gonna be looking at today is available at least as a pure request at this point in time on the Pulumi dash poum slash examples repository. All right, let's pull my screen up. Here we go. So the first thing I want to do is show you what this would look like in Yaml. Now, YAML is actually a really good format to declare DNS records. But I still want to convince you that using Q and a little bit of magic there uh will improve your uh Pulumi experience. Now with polio programs, our mission is to put all of our resources under a resources key like so every resource must have a name. So for all the domains themselves, I am literally calling them the domain with a dot substituted as a dash from there, we tell the type of resource that we wish to create. So this is a cloud flare zone and that zone has some properties. And really for the zone is nice and simple. We're just saying that the domain or the zone that we're going to manage is rock code dot de and that is our first resource. After that, we want to start adding records to a zone. So here we have rock code dev, no email. This may be a domain that I do not wish to configure email on. And when you don't want to send email from a domain, the best thing you can do is set up a text record to inform all the major email providers that, hey, this domain should not send, should not send any emails, which means that I'll end up in spam if some bad actors try to send it. Ok, then we have, uh, this name here followed by a type of uh that's actually a little bug. We, we don't, we're not fussed about that. It's OK. Uh Then we have the name of the record itself. Uh And then we have tape code for the record and then that says properties. Now we're using the YAML syntax to reference other resources and get outputs from them. So here you can see that we're referencing our zone, which is rock dash dev. And we want to know the zone ID, we can figure the name of the GTL, the type and the value and that is it. Now, this is very similar for the next example and only instead of no email, I've decided to actually set a few MX records. So we configure the zone as we did. And then down here, we're actually saying we're going to configure this for G suite and for G suite, we're just going to set up some MX records and there's a few of them. The last thing I did in this domain was add an A record that would just point to 1.1 0.1 0.1 entirely useless. But I just wanted to make sure that we could set that record if we wanted to. So ya works really, really well for defending DNS records. Something that you probably do manually. But having them in this declarative format that you can commit to get is actually really cool. No, we're not gonna use jam off there. The cord is there. You've seen it, you can do it if you wish, but I wanna show you something else. So let's pop over to my main dot Q now, it's not terribly smaller but the more domains that I add it, well, condensed down to much smaller than the animal alternative, what we do get some uh toil or chore removed from the typing experience and we'll cover that as we go over the queue. So the first thing is I am importing a helper utility that I have written. Uh and it's just in this directory. So I've made up my own kind of package name, which is examples dot p dot com slash DNS from there. We're loading something called cloud flare and we're looking for the controller module package. Same thing, we have our top level resources key just like we did. And the only after that things get a little bit different. So here we're using this convenience structure of the controller and we're saying that we want a new domain. This domain has a domain name which I've just called domain and it has an option for configuring the email. So I don't have to tell it what that SPF text record is and I don't have to tell it what all the MX records are for G suite. Instead, we've built in some little helpers. So here I just say that my email configuration is actually a controller dot no email and that hash symbol or pen symbol depending on where you're from, just tells us that we are using a Q definition, something defined. And Q excuse me, then we have our second domain. So we're saying, OK, we have one more domain. This one is domain rock code dot com only this time, our email is going to be configured as G suite and not no email. And then the one record that I added www am to 1.1 0.1 0.1. Now in order to get Q to squeeze in to the format that the Pulumi Yao provider expects we're using something kind of like a function call in Q. But really we're just requesting a subset of um some properties within the Q document. So I'm calling to create. So it kind of feels like a function but it isn't really a function. Ok. So how does this work? Well, let's open our controller dot you. So the first thing we do is we're going to import the strings package. This is one of those really cool things about Q yama. We don't have the ability to do it, string processing, regular expression search and replace anything like that. But when we use Q, we can actually import a lot of the Q standard library. And you'll see here that when we define a zone and we don't really know what that is yet, but that's OK. Uh Is that we pass in a domain which is a string value. The resource name is what we want to call the resource within the Pulumi program. Now, it can't have the dots in it. This is actually going to cause you an error. So we use the Q standard language or a standard library to do a strings replace on the domain, replacing all the dots with a dash and the minus one just says to replace them all. Another really cool thing about is that we get interpolation. So for the zone id, this actually references an output property on a resource. So what we actually need is the resource name with a dot And then zone id uh surrounded by a dollar sign and some curly brackets. The interpolation part of Q is this here we do backslash round brackets and then we tell it what we want to drop in there. And that is just the resource name at the same scope. We don't have the properties that are being passed in. Uh This is really just to keep them isolated from what we consider the input. And that's like a Q because I'm using this weird Q to function syntax, we want to kind of differentiate that. Uh And then we have our create function which is just a small subset of data that spits out the YAML that the plume program expects. So we use more interpolation to get the resource name and then we describe the plum Yaml resource. So we just pull it in properties and spread it out the properties, hopefully nice and simple in order to make DNS records work. I'm actually using a hidden field in Q but that is any field that starts with an underscore it just means that when I run Q export or anything like that, these won't ever be output as um data in the document. And also they are scoped explicitly too this package. So it cannot be used by anything else, which is kind of the behavior that we want to enforce here. We want people to use our public API and not our private API. And this is very much the private API. So we have a zone which we're saying as a type of zone, we have a type which is a closer record. We kind of isolate the properties that we need for the Pulumi resource itself, which is actually pulling from our zone. So you know, when we call the create function and the top level document we're passing in that zone and I'll show you that in a little minute where I said the name must be a string and we default to an, a simple, I could have made that whatever I want, depending on what you're doing. It may make sense to go with something else. But for me, that was ok for now, we have att L with a default 300 which is pretty standard. We're restricting the set of DNS records that we accept. So we only accept an AC names MX and text. However, you could make that uh whatever set of support you want to provide and what you'll see is I actually then further constrain these types on the more definite versions of a DNS record. Uh And then we tell it how to spell out the, that we need. Now, here's the more constrained ones. So we have a DNS record or a public definition that can be consumed that as an abstract DNS record and we further constrain it. So one of the decisions I made is that MX records and DNS records would be handled separately, which means if you try to use the DNS record definition, you cannot set it to MX. You have to use the MX record definition, which is actually locked down to only MX, which makes sense. Uh And the reason I did this is so that we can have the priority, which is uh only accepted on the MX records with the cloud flare api Hopefully that all makes sense now to, to handle email or email configuration for the domain. I set up two more definitions. I set up no email and I set up G sweep on no email. All we're doing is creating some sort of resource called no email, which is a DNS record with a zone and these properties. So these are the properties that set the text record that we want. And for G suite, we did the exact same only this time we spread out 123 MX records with the values that Gmail expects us to have. No, we preferred a, a kind of a public interface to our zone which I've called domain, uh which allows us to kind of encapsulate us all into one Q or YAML based kind of description where we say this is the domain, we accept no email or GG suite configuration and we'll take any number of records that you want to pass through as a DNS record. So you cannot pass any other MX records can only be configured via the email configuration block from there. We call uh create on our zone, create on our email. And then we use a comprehension in Q which is very cool. We have the to look over the records and this list and we create the record like so, so now that you've seen all of that, we'll go back to our main dot Q and you'll see, we have a controller for a domain configured with no email and to domain, we have the controller for domain configured with the domain G suite and some records. So if we jump over to our plume preview, ah, there's that bug that I broke, let's fix it very quickly. I was making changes. That'll teach me. Uh, uh, I was trying to clean up a different bug and I introduced a new bug, but we can fix this and I'll fix it properly what they got wrong. Uh You know what, I'm gonna stash all this ready to go. We make changes one minute before the stream. Uh But as you can see when we run a P preview, we have our two being created. We have our, a record for rock dot com. We have a no email for rock with Dev and then we have our G suite records for rock dot com. There we go. Uh Even though I've stashed all that, you'll see that very little has changed. This file is pretty much I was just trying to tidy up a few little things and clearly I made it a bit of a mistake. However, if you want to check out this demo, it is available at get help dot com slash Polu slash examples. The pill request is opened. I'm hoping this will be merged soon. I'm going to be doing a whole lot more with Pulumi. So if this interests. You remember to like the video, subscribe to the channel and leave me a comment. Let me know what else you'd like to see with Polio. Uh until next time. Have a wonderful day. Yes.

---
