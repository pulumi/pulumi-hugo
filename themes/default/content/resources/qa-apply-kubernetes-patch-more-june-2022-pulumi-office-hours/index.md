---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Q&A, Apply(), Kubernetes Patch and more | June 2022 | Pulumi Office Hours"
title: "Q&A, Apply(), Kubernetes Patch and more | June 2022 |..."
meta_desc: |
    In this session, David and Lee answer questions addressing Pulumi, and how pulumi works, certificates, Kubernetes and more. Links below:
url_slug: qa-apply-kubernetes-patch-more-june-2022-pulumi-office-hours
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Q&A, Apply(), Kubernetes Patch and more | June 2022 | Pulumi Office Hours"
  description: |
    In this session, David and Lee answer questions addressing Pulumi, and how pulumi works, certificates, Kubernetes and more. Links below: â–º How Pulumi Works: https://www.pulumi.com/docs/intro/concepts/how-pulumi-works/ â–º Pulumi Examples: https://github.com/pulumi/examples â–º Lee Brigg's Pulumi Examples: https://github.com/jaxxstorm/pulumi-examples â–º Lee Brigg's Article on Apply: https://leebriggs.co.uk/blog/2021/05/09/pulumi-apply â–º Pulumi Kubernetes Patch Pull Request: https://github.com/pulumi/pulumi-kubernetes/pull/2043/files â–º Join the Pulumi Community Slack: https://slack.pulumi.com/  ðŸ“‘ Chapters: 00:00 Introduction 02:44 Q&A - How do cloud providers communicate as they animate documentation? 04:05 How Pulumi Works 15:05 Q&A - Can anyone recommend a simple solution to generating a self-signed certificate and adding to the private key of a fargate PCS instance? 20:38 Examples Repository by Lee Brigg 26:36 Q&A - Can I rely on using essay dot email, this is an output on a service  account after calling service account dot new account  or does that run asynchronously and populate with promised late values? 33:13 Q& A - Is there any way of performing the equivalent of acute control annotate namespace default foo equals bar without using local command and cube control ? 41:40 Final words and goodbye
  sortable_date: 2022-06-30T03:45:45Z
  youtube_url: https://www.youtube.com/embed/fzdledb6uz4
transcript: |
    And welcome to the June edition of Pulumi office servers. My name is David Flanagan. I'm a developer advocate at Pulumi and I am joined by my esteemed and wonderful colleague, Lee Briggs. Hey man, how's it going? Good. Thank you very much. Yes. Uh We're excited to do. I think this is our second one now, right? This is our second officers. We started this in May and then some unfortunate events. We, we missed, we, no, no, we were going to start and we were doing so it's fine. We haven't missed anything. Yes, we just sneaked it to June like by the skin of our teeth. Um So it still counts. It does, it still counts. Awesome. All right. Do you want to just for anyone who is not aware of both of us? We'll do a quick introduction. I'll let you at least start. Do you want to see what you do? Pull me and anything else you want to share? Sure. Yeah, I've been around Pulumi and in all kinds of different roles, but currently right now I'm doing uh solutions engineering um which is primarily helping our customers be successful and that involves um you know, showing the value of Pulumi um early on in the process, if they're deciding to become customers or um helping customers after they've adopted Pulumi in getting the things that they need to do with Pulumi uh done. So that might be helping them figure out which part of the cloud they want to use or which part of the Pulumi language SD case they want to use. Um So it means I get to talk about lots of different parts of the product, which is always exciting. Awesome. Thank you very much for sharing. And my role as a developer advocate is to help make videos like this happen and get good people to join us and talk about uh to focus on contributory experience and write blogs and may just be trying my best to help make other people successful very similar to the. We're all, we're all doing awesome work. I'm very, very excited. All right now, really, this is going to work is I have scoured our Slack Channel and found a few questions that I think would be interesting for the United to, to just can't even talk now uh to discuss today. Uh We're going to answer them as we go, but we do want to try and encourage some audience participation. So if you're watching via linkedin youtube or Twitter, please feel free to comment and reply and let us know if you have any preliminary questions. If you're watching this after the fact and not live, feel free to use youtube comments or join our Slack community and ask questions. And there all the links are below in the description. All right. Uh I'm gonna pull up my pecan questions. I'm gonna fire the first one at uh and we'll just start talking. So our first one came from David Wang and our Slack channel. And David asked, how do providers communicate like a cloud provider or AWS provider? And is there any documentation? So David wants to know when I run a plume up command and we have all these providers, what is the communication model? What's happening? Do we speak to the cloud providers directly, et cetera? And so, um yes. So I, I think there's, there's different levels that we can talk to this in terms of like complexity. And I think the easiest answer to this question is that um if you run the command Pulumi plug in LS, you will get a list of Pulumi plugins that are installed and you'll see that they usually um you know, match up to a cloud provider you are using, whether it be A B or digital Lotion or Google Cloud that plug in is the actual process that talks to the cloud provider. API So it's generally a binary that lives in your, on your local machine or wherever you're running Pulumi from. And that's the thing that actually reaches out and talks to the cloud provider api now we can go a little bit deeper here and talk a little bit about how that works and, and what actually um you know, what actually happens behind the scenes. Uh And we have a really great page. I don't know if you have the link for this able to share like the, the how um how Pulumi works page. Um The, the how Pulumi works page is like the canonical documentation here for um how Pulumi is built and, and what it does and there's, there's three parts of Pulumi that I think are the most uh familiar for, for people to know. And essentially, they're all binaries that run locally on your um on your, on your machine wherever Pulumi lives. There's the Pulumi Cli um which contains the Pulumi engine. Um and the engine is a GR PC server that is listing on local host. Something that we sometimes see from customers that have very high, high security requirements on on user laptops is that it will say, hey, Pulumi is trying to connect to something and my firewall is telling me that, that I don't want to let them. And then we're like, it's on local host. Um It's not going out to the internet anywhere. The cli is talking to the Pulumi engine um on your machine. And so allowing that GR PC dynamic part on local host is, is, is a fix for that. And then there's the language host and, and the language host is the thing that kind of interprets the Pulumi code that you've written and passes it to the engine to build this decorative graph to actually build the um you know, the, the end state of the actual, um you know, the actual uh infrastructure that you want to build. Once that decorative graph is built, that decorative graph gets passed over to the, the plugins that we actually talk to A s. So there's three kind of bits here that are talking to each other and they're all, they all come together to, to create this Pulumi experience. But the the short answer. So this question is that um the the Pulumi plug in is a thing that talks directly to the cloud provider. Uh And it is all managed via these three different processes. Now, I used to work pretty closely with this. It may have changed slightly in the, in the last few months. But, but that is my kind of like most recent understanding of how all these things work. Um And I'm sure one of the, one of the engineers is listening and I've got horribly wrong. They will um they will reach out to me and say actually, no, that's not the way it works now. But, but at a very, very high level, those are the things that you need. And I think this comes in really useful if you are doing something like packaging Pulumi in a do a container yourself. You, you can't just have the Pulumi cli, you also need the language host, which is usually of the format Pulumi language something. So, we've got Pulumi language Java language go Pulumi language uh node. Um And then you also need the, the plug in. The only um caveat to the language host is the uh with the YAML support. You don't actually need a language. Oh, wait, no, we do have a language host for ya. So I'm just, I'm talking nonsense. Um So all of the languages do have a um have a language host that talks directly um to the Pulumi engine and, and that's like the high level idea of, of um of, of how it works. Very cool. That was a lot of information but very, very useful. Thank you, very appreciate that. So we hope that I always like to give like the short version which is like actually answers the question, which is the provider binary is the thing that talks to the cloud provider. And then like the actual context of how it all fits together is usually useful for me at least. So hopefully, um this, this, this, this page here is a really great read if you are starting out with Pulumi and starting to understand how it all works. So I would highly recommend reading it. It's, it's not super um you know, super in depth, it's just a kind of high level idea of all the different pieces. Yeah. I mean, I, I love the architecture of Pulumi and I love the fact that everything speaks over GR PC and everything is kind of its own thing. It can evolve independently, they can make changes uh because it's GR PC, you can create plugins and providers and pretty much any language you want as long as it speaks GR PC, which is very cool. So, lots of awesome stuff there. Yeah. All right. Let's move on to question two from my favorite user name of today's show Pulumi Novice. Pulumi novice asked how capable is Pulumi for Kubernetes configuration or is there another get up tool for this? Well, I think I'll, I'll, I'll, I'll start with this and then I'm gonna pass over to you Damien because I think actually you are very familiar with this space. Um I, I, I've, I've talked about this on, on Twitter before and so I'm gonna get take the opportunity to talk a little bit about it. Um You know, on, on a live stream. I think there's two there's two parts of your infrastructure's code experience. Um And you can compare all the infrastructures code tools and look at the different features. But the experience that the user gets is is really important. And the two parts of any infrastructure code experiences, the authoring experience, how it feels to write the infrastructure programs and, and what experience the users get when they're writing their infrastructure programs and then the execution experience like how you actually get that infrastructure program from wherever you've written it when and store, whether it's on your local machine or in a git repot or wherever that is living. And then how do you get that onto the actual infrastructure itself? Um One thing I always like to talk about, if, if you're in the Kuti space, you are probably pretty happy with the KTIS reconciliation experience like the the constant reconciliation loop. Um And lots of people are using uh tools like A O CD and flux and, and maybe they're even defining their infrastructure with a reconciliate um that, you know, is is going to talk to an external cloud provider for example, but the the authoring experience is always uh different uh for those things and it, well, so it's always the same because it's always usually YAML focused or configuration file focused. What I think is unique about Pulumi K experience is that you can have a different authoring experience that feels far more familiar to people who might not be working on a day to day basis. Um And so like the main, the the like to answer the question of like what is the experience with um you know, Pulumi and Kubernetes around gear up for me, the authoring experience when it comes to that stuff is really, really important, like being able to define abstractions in in node or Python or go that allows me to write a packaged up, Pulumi uh sorry uh resource, like a deployment service in ingress. That that's really where that Pulumi shines and being able to, to have a great um offering experience. Now I'm going to pass to you for execution experience, David because I know that you're really familiar with this, this kind of realm and I know you've used a lot of different things here. So in, in your experience, like once you've written your Pulumi program and you've got it written down and you are ready to actually apply it to a cluster. Like what are some of the options for an execution experience that you can do with Pulumi? Yeah. Well, you've already mentioned two of them. So we'll start there. You mentioned Argo CD and, and flux. So if you want to use those tools as your get up, tool of choice, your controller to do the reconciliation, then you, you totally can. And there's two ways to do that. You can use custom plugins with, with both of them, which allow you to execute arbitrary commands such as fill me up and that will work. Um You're not going to have a great experience though because the thing with Cotis is uh pods disappear pretty quickly and yeah, what you don't want is for your Pulumi up to be halfway through and a pod to disappear and Pulumi has to recover that state. So you can use two more options. First one is we accept a render to Gammel option on the Cobern provider. So a plume up will not modify the cluster. It will instead generate all the Gammel conflict fails allow an argo influx to apply them in a standard fashion. And that's a pretty nice way of doing it. However, we also have the polymer Cotti operator. So this is Bell with steps for remediation of the pods should disappear and it will handle doing a native poly without the to working with the uh in a much nicer fashion is what I use every single day on all my clusters is a fantastic tool. And like Lee says, like when you've got that rich authoring experience with types and auto complete in your ID E and code, um just moving that plume to another plume process inside the cluster and don't get up that way it works really, really well. So end to end, I'm pretty happy there. So, yeah, and I think we, we see this a lot in the community and, and actually something that, that um I talk about or I've, I've wondered about that, maybe um maybe have some insight. David is like, it's been a couple of years since I've used Argo CD in Anger and certainly a production level environment. But I seem to remember that, you know, once you actually have defined the app or the app of apps in Argo CD, A CD is great at doing that reconciliation, like they'll take the, it'll pull the um the manifest from, you know, some upstream git repo and continuously apply them. And, you know, I have a bunch of different mechanisms for like rollbacks and all that kind of stuff. But defining the app was always something that I found interesting in, in that kind of mechanism because I, I did it with J Sonic, right? Like back, back before Pulumi was actually, you know, um you know, uh in my life, so to speak, II, I wrote a bunch of Jay Sonic abstractions to actually define those Argo CD apps because it kind of seemed strange to me that you would have to go into this web application and create all of these um you know, these applications you wanted to apply. So, you know, I'm always curious when people say, well, we're not gonna use Pulumi because we've gone down the ARGO CD path. And I, I always wonder, well, how are you getting the applications onto ARGO CD? How are you defining them? Because surely there has to be something there that is like the bootstrapping mechanism and, and all that kind of stuff. And in your experience, how are people actually, you know, going and defining these Argo um ARGO applications and even the Apple apps model? Yeah, exactly. I love that you mentioned Jason it because I also went down that rabbit hole many, many years ago. And I think it's a classic example of there are tools out there to help provide abstractions and remove the verbosity of producing Javel and the kind of tedious nature that it can be. But the learning curve of these tools, particularly Jason, I don't know about you, but I struggled for a while before I finally started to kind of make heads and tails of it. Um So I think that's just, I don't think I ever really, I don't, I don't think I ever really did. I did a lot of Googling and a lot of like, well, this works and I have the output and I'm not really sure how I ended up with this, but it works. So I'll add a bit of that. Yeah, absolutely. Yeah. I mean, like defining just a simple Json string was always easy and then once you started to go down the abstraction route, it was really, really complex. So, yeah, I agree with that. Yeah. So you use your, your, the toes you're already familiar with. But II, I don't think that is something that should be understated like it's such a superpower. So yeah, we're really happy with ploy and Ktis. So thank you for your question. Pulumi. No. Uh We'll, I'm sure we'll do plenty more KTIS stuff in future. So, yes. All right. Let's take a look. We've got Trevor Ackerman who has a question. Can anyone recommend a simple solution to generated a self sign certificate and adding it to the private key of a fargate ECF instance. Now I picked this question because you actually answered this for, uh, Trevor. So I figured we could talk about that and, uh, share a link with our audience. So, absolutely. So, um, Pulumi has a, uh TLS provider which allows you to generate, um, all manner of certificates including sign certificates from an existing certificate authority. If you really want, uh, in this particular case, we want a self sign certificate. So I actually ran into this a long time ago. Somebody else asked a similar question about uh defining a bunch of certificates um for um a self sign mechanism. And this is really common if you're doing something again, actually in KTIS, if you're doing something in Cotis, you generally might want to sell sign certificate inside the cluster for like TLS uh communication between two services and so defining self sign certificates is, is something that you, you, you might run into at some stage. Um And so the TLS provider makes this relatively straightforward there. Uh There's a few ho like as with anything TLS and SSL based. Um There is a few hoops to jump to jump through and you have to have AAA reasonable, intricate knowledge of how it all works. Um But with the TLS provider, you can take all of those steps. And um I think if you look in the typescript folder in this, this is my Polu examples repo you take a look in the typescript folder there and then there is at the bottom, I think it's like a self signed uh certificate example, um which hopefully still works. Um I I maintain no um no contract of uh that any of these examples work, they're designed to be reference points rather than uh actual actual production examples. Um But here you can see, I'm just using the TLS provider creating a private key with a self sign that is going to pass that private key. Um And so we're going to create the certificate authority first. Um So that we can actually sign um any certificate with a certificate authority and then you can use that certificate authority all again, all with the TLS provider to create a uh a certificate signed by that. And obviously, you would have to do if you're going to use this for your local host or something like that, you'd have to trust that certificate um of, of in some way. Um And so you'd have to export that, that certificate C AC ac, but this creates a um a self sign certificate. Um And you could package this up into an abstraction, right? So you could um package this up into a Pulumi component resource or even a multi-language component resource that would uh handle a lot of the stuff for you. Uh You can see here that the things that I'm exporting are the things that I'm likely to use when I'm using this. Uh this this uh sign key. So like the certificate, pen itself, the private key for that certificate. And then obviously the C AC so that I can actually trust it. And this is uh a pretty, pretty canonical example of how to do this. Um One thing that I would think I never really talked about for this Fargate side of that question was once you created this self sign certificate with Fargate specifically, you need to decide really where you're going to put that certificate. Um uh You need to need, need to either embed it into the docker container with the application because with you don't have actually have access to the host itself to manage the certificate store. Um, or you would put it on a load balance like an EB or an A, I think, I think only five G spot on Aib. So you would have to install that certificate and the private key and the C A certificate inside the low balance as well. So that is the full kind of like end to end uh answers to that particular problem. But I'm really glad you brought up my examples. Report my little playground. Yeah. Well, we're gonna take a look at a couple more examples. But before we do, I want to follow up on one thing that you said there is, is actually quite pertinent is that you mentioned KTIS. And ironically, I don't know. No president, I'm not sure. Pick a word, but I have a blog post which is coming out tomorrow uh which is actually deploying an admission controller with cluster. And there's this really annoying gotcha with deploying admission controllers and that a they need a self certificate, but not only that you can't generate it in a cluster because you have to attach the C A bundle to the admission request, custom resource thing and doing exactly like Lee has done in this code here. Um Using Pulumi allows you to generate certificates, bundle up that key and attach it to your resource all within your environment is pretty sweet. The, the, the more we talk about this, the more I'm starting to wonder if we should create a multi-language package that is just basically self signed with the inputs being the SANS and, and like the, the list of SAN is the only input there and it does all of this for you and exports it. I think that would be a pretty useful multi-language package actually. So you don't have to kind of go through this process every single time. Um And, and just if you're not familiar with Pulumi multi-language packages, it's just a, a mechanism or an abstraction that allows you to write a um a reusable abstraction in one language and make them as uh consumable by all pou supported languages. Um And so the cell, this a self sign certificate would be really useful there. And so I might go and have a crack at that uh uh on my Friday evening and see, uh, see if I can get that, that pulled off. Awesome. All right. So let's talk about your examples repository. So, Jack Storm on get Hub J A double X Pulumi dash exam. There, there's quite a lot in here but there never, never pick your Nick, never pick your gib. Never put your gib nickname when you're 13 years old is all I will tell you. Um Yeah, that, that made sense when I was 13. Um So yeah, there's a lot in here. Yeah. Um So, so the reason that I started this, we, we have the Pulumi Examples repository uh which is at Pulumi slash Examples in github. And that has some really great like end to end examples of how you might deploy an API gateway as you can see there or, you know, deploy a community service or something along those lines. And, and I wanted a place to put um less canonical examples of how to do something in a way that um kind of like as a reference point for me, like when I'm solving problems for customers, I almost always come up have like have to solve that problem again later. Um And so I just created this, this examples repository to um you know, start down that path. Um And then I had the Wild hair to, to abuse um Pulumi Yael support and it got a bit out of hand with the, and the um the Pascal and the FORTRAN and the Lisp and, and uh I think uh one of my incredibly talented colleagues added a uh a brain f example um as you can see at the top there, um which if you, if you click on that, it will um really kind of give you a um an interesting experience of what it's like to, that's a, that's a valid Pulumi program to um to deploy a uh an Eks cluster in, in Kubernetes. And it works by the way, and I would highly recommend trying it because it just is crazy. Um But it does work. Um and, and part uh one of my extremely talented colleague um uh definitely um definitely try that out and it works. Uh But there's lots of different examples in here of um if you go into the Python example here, I think there's, there's some really interesting examples here that maybe aren't kind of ready for prime time in the uh Pulumi examples rebo. So if you're in my favorite example here, if you go into a, into the A WB uh folder and then there is a weight for load balancer at the bottom here. And I think this is a really interesting example of being able to actually use um the, so this uses the um ad BS boto SDK um inside and apply. And what it does is it uses the boto client to actually pull a load balance that I'm creating with Pulumi and uses the waiter mechanisms in the B two SDK. So on line 19, you can see waiter goes, client not get weight, a balance are available. And because Pulumi is asynchronous and you have that apply mechanism, you could actually poll things inside the apply and actually use the waiter to verify that the um the low balance is healthy and active. Um And so, um this is a really, really powerful example of what you can do with Pulumi. Um You can't always do with other infrastructure as called tools or if you can do it, it's going to involve a lot of kind of complexity and this is just off the shelf kind of available support in, in Pulumi. So, um yeah, this is, this is one of my favorite examples that I like to use. This is of course supported in all of the different languages. You would just need to install the, the SDK for typescript or go or whatever. And those waiters are now available in all of the different languages as well. So this is something that, um you know, this is actually something that I was using uh yesterday for an example um for Aws. Uh if you have used Aws, I am, you'll know that it's eventually consistent. And so if you want to do any kind of complexity with the role in your plume program, you have to wait for the I AM role to actually exist and be active and you could just use a way to inside and apply and it just blocks all of the other resources and um it allows you to do some really pretty uh pretty special things here. Yeah. And I had no idea you were going to pick this example, but I love it because it's one of those questions that I think you probably get all the time. I get all the time. And people are like, well, how do I wait for this or how do I check this or how do I address it? Pulumi doesn't have a function for that. And my answer is always, well, is the SDK like go to the AWS SDK is the GCP SDKDK because it's just code, just put in the library and then write the code or the logic that you need and it'll just work. And this is a wonderful example of doing that. Very, very cool. I just wish I'd done more more. So what I've done with this actually example is just write to a file. And I thought, well, I mean, if, if it was a little bit more of a complex example, you could like wait for the low balance to be active and then set a health check to start or something along those lines. I've just written this, uh just written the A RN to a file and certainly apply. But there's hopefully this is like the whole part of this examples is to um to give you an idea of what is possible rather than the actual answer. So, um hopefully that gives you a um an idea of the things that you could do with poum in the apply logic is honestly one of the most uh the most common things that people ask me about in terms of how to understand it. But once you get your head around it, it really does. Um It's really, really powerful. Well, guess what the next question is about? It's about apply. I'm guessing it's about an apply was surprise, surprise. OK. All right. Well, before I move on to the next question, we did get a comment from Harry who said amazing. I don't know if that was in regards to your waiter or to the brain for example, but we'll just assume both. Yeah, why not? Yeah, why not? Yeah. OK. So next question came from an and the question is, can I on using S A dot email? So this is an output on a service account after calling service account dot New account or does that run asynchronously and populate with promised like values? So, yeah, we're leaning directly into how the apply system works inside of. So do you want to explain what happens when you reference an output on another resource? I think the best place to start here is just to talk a little bit about uh what an output is. Um If, if you are familiar with any with other infrastructure code tools, this this might make sense to you explain in this way. But when you create uh something in a cloud provider, they all value your time in slightly different ways. So for example, um if you create an EKS cluster, it's going to take between five and 10 minutes to create that cluster. Um And when, when you create in that cluster, the properties that exist on that cluster come up in different orders and arrive in different orders and have populated uh at different times when you're creating that, that resource. And so you want a Pulumi up and you create an EKS cluster. Uh and Pulumi will the Pulumi resource provider, which we talked a little bit, the Pulumi plug in uh which we talked a little bit out about earlier will continuously pull the AWS API waiting for that EKS cluster to um to populate some of those output values. Like for example, the A RN of that particular EKS cluster isn't populated until the the full process is completed. Like the cluster is up and running and all those values now exist, we call those outputs. Um And, and you can pass those outputs to other Pulumi resources as inputs and that's how Pulumi builds its graph. You create an EKS cluster and then you pass that uh EC cluster API address to the nodes that are going to attach to it, for example. Um And in, in order for that to work, you need to wait for that cluster that, that API address to appear and, and actually exist. Um And so in this particular example, with the S A email like that is a, um I think it's an input and an output um because usually an input is also an output. And so we actually have to wait for that value to exist in the Google cloud API before we can actually use it. Um And so you can pass that to another Pulumi resource with, with no problem. And Pulumi builds that that dependency graph for you. So if you say create an essay dot dot email or whatever and then pass it to another resource. Pulumi goes OK. Well, I need to wait for this value to appear and then I can start creating this other, this other resource or um you know, that can be an input where this really gets tricky is if you are passing that value to something that doesn't support an input. Um That's where, where the complexity comes in. And what I mean by that is um sometimes you will need to pass those output values to something that um only takes a string value in the upstream cloud provider. API. So the very common example of this is with ion policies, um they only support string values, they don't support input values. Uh And what I mean by that is that you actually have to have all of the known values up front before you can populate it. Um And an essay email is a great example of that, like an I AM policy in Google cloud only takes a string. And, and so what you have to do there is you have to wait for the cloud provider to say that this value has been populated and and is is is allowed and then do something and then actually perform an operation. And building a string is is a great example of that. And the most common question we have in, in the Pulumi community is how do I convert an output string to a string? The answer is you can't, it's not possible like you cannot convert an output string to a string. All you can do is resolve that value and then you use it once it's resolved and that is essentially what apply is doing. Um You are waiting for the value to turn up and then inside a function you are able to like use that value. So to come all the way back to the question because I went around the houses a little bit here. Um The, the, the short answer is that it's, it's an AYC value, it is eventually pro populated. But once you realize that it's eventually populated, then there's things that you will have to do um depending on how you wanna use it. So if you want to pass that value to another Pulumi input, that's totally fine. And Pulumi handles that for you. If you want to use that in, say a um an I AM policy, you will need to use and apply. And I wrote a blog post around this uh uh about a year ago on my personal blog. Um And I usually keep things like this on my personal blog because it's not always the most professional writing. Um And so I like to, you know, throw a few curse words in there and, and all that kind of stuff. So, um you know, and, and, and mainly mock, mock my, I like to mock myself a little bit in these things. Um And so this is the blog post that I, that I wrote. Um I think it's about a year ago now. Oh yeah, over a year ago, um that, that kind of just explains my understanding of, of this. And the reason I wrote this is because I think I've only just fully understood how Pulumi apply worked at this point and I've been at the company for a year and a half. So, um you know, it was, um you know, it was my kind of like my mechanism to actually kind of know that I'd learned something about how this worked. I still think this is the best ever uh subtitle in a blog post that I've ever written. We eventually. What the hell back to input. I don't think I can get away with putting this on the Pulumi blog and apply me a river, I just think is excellent pun, by the way. Yeah, and a great example of using the apply to get a real string value for populated user data cloud. And so yeah, very, very cool. Uh Your blog is available at lee breaks dot co dot UK dot co dot UK. Awesome. Again, I will put all of these links into the description as soon as we finish. So don't worry about writing that down. It'll be available soon. All right. N fa any last comments on apply? Are you ready for the last question of today's session? I think I'm ready for the last question. All right, sweet, sweet. So we got a question from uh I've had in a while. I said Pulumi Office was my favorite name of the the episode, but I may be wrong. This name is Dag. It's been, it's been superseded by a better name. We got, we got, we got dag. Dag says, is there any way of performing the equivalent of a cube control? Annotate name, space, default food equals bar without using local command and cube control. So let me give some context about this question to anyone who's not familiar or doesn't understand what's been asked here. What DAG is saying is that on the command line, I could run coup control, annotates space, default through equals bar to augment an existing resource with some new metadata. And they want to know if they can do that in Pulumi, but without using our local command provider. So local dot command, coop control, et cetera. And uh the answer is lee soon you can. Yes. Um Yes, soon. Yes, soon. Um I think there's a little bit more context here as well that I think is, is always useful for. And again, I'm coming back to EK SI, I've said a lot about Eks today, but I think this applies to A KS as well when you create a managed service uh cluster, uh like I know you David have, have generally created clusters from scratch. A lot of the time use a cluster API or something along those lines. Um And what's nice about cluster API clusters is that you can basically have full control over how they work. If you create an Eks cluster, you get a bunch of like Eks provides you with a bunch of resources by default. So for example, uh the VPC CN I um uh demon set exists on the UK S cluster by default. And then AD BS has this a BS off config map which like maps. Um I am roles to service accounts and, and permissions in, in and those things turn up inside the cluster, but you cannot manage them with Pulumi without importing them as it currently stands. You would have to do a Pulumi import operation um in order to actually do anything to them. And it's always kind of confusing to anybody coming from the East land because you can use co and I call it coop CTL rather than coop control. So uh coop CTL apply or COUP CTL patch or, you know, just manipulate the existing resource and only change the fields on the cluster um because of the service side apply mechanism and that's always um really, really powerful. Um And so what we're doing and what Levi my incredibly talented and esteemed colleague, Levi, who does a lot of the work on a provider is currently working on is the um the server side apply mechanism in the Pulumi um Excuse me in the Pulumi KTIS provider. So uh we had a really great conversation. I know you were involved in this David about all the different ways we could potentially support server side apply because it's not as simple as just turning on a flag. Um I think what we decided on is we're gonna add new resources for each of the supported uh KTIS uh resources in the provider, but with a patch verb at the end of them. And so you'll have a deployment patch and a service patch and a config map patch which again will allow you to essentially have full control over the way that service side apply works inside. Uh I like to keep up with most of the infrastructures code tools. I won't name them, but I'm sure you all know what they are. Um And I don't believe that they support this at the moment for all resources like we're planning to um once, once the ships. And so if I, once this is enabled and turned on and we release a version of the provider, every single field on, on the um on the uh API will be patch, which I think is really, really powerful and is gonna, you know, solve a lot of um you know, pain uh around some of these managed resources and all that kind of stuff. And it comes back to the annotate thing that you already talked about. The default name space is a great example. It exists in every cluster. If you want to manage the default name space, you have to import it at the moment and when we turn on service side apply, you'll just be able to do a patch name space and everything will work great. Yeah, I mean, you've covered so much there, but I'll add a couple of things is that, you know, so far in Pulumi Ktis, like you can enable dry run on their provider configuration, which does a server side. That was our, our first podium to kind of support and service they apply. And that's pretty cool because it means that we take a look, we are always taking a look at what's in the cluster and trying to reconcile that appropriately. Um I think ever seen the play has already been merged. In fact, I I'm pretty confident that's already been done. Um But one of the, the challenges when we were discussing how to implement this is that for the patch, if we were to use the original resource, we would have to actually escape the type system. Because cnet says this really weird thing with servers I apply and that you can deploy or apply a deployment manifest that only has one field that replicas no containers, no images, no nothing, right. Um And it does that because it has a concept called managed field, which means that then that controller or that control command becomes the manager of one particular field on the resource. Uh and to support that and we don't want to allow people to use deployment and then not specify anything because for people that aren't trying to do a patch would lose that type safety of their deployment. So we've went down the route of adding a patch to all resources. I'm super excited about that for all of the reasons that Lee has already covered. I think it's going to open up just a whole new world of things that we can do. We've managed super noise clusters and even bare metal ones like it's just, it's really cool the way that we can do manage fields on particular aspects and still can swim other tools inside the cluster to do what they want to do, like maybe cert manager. So, you know, there, there's lots of really cool things we can do with this new feature. Very cool. Yeah, I think the, uh, the, the, the thing that I think is the other thing that, um, comes up, um, and maybe, you know, more about this, but we, we often see that with the, the provider, there's this last apply configuration, uh, field that exists when you're doing client side apply. And we haven't, uh we've, we've had an open issue here. Um And that this is one of the very, very few places that we consider ourselves to be a quote un, quote leaking secrets. We're not actually leaking secrets because the secret is still encrypted in state and is encrypted in, um you know, encrypted in the Pulumi cli and in the engine. But when you do, uh um a Pulumi up against a cluster, uh because of the way that the last applied, last applied configuration field works. If you have a secret value in your deployment, um like an environment variable, you've secreted inside Pulumi that turns over a plain text and, and that is very frustrating to users because as soon as they talk to the S API it, it goes into plain text. And my understanding is that that last apply configuration uh field no longer required for super service I apply. Um which means that you um don't have that, that value there, but I could be wrong about that. So um happy to be corrected there. No, you're right with servers that apply, we no longer need the last applied configuration. Um But I'll also point out that the secret being exposed and the last applied annotation is only if you're using Pulumi Secrets and then putting them directly onto the manifest and not storing them in a secret and consuming them through environments. So you're already kind of went down a bad path, which is the correct way. Yeah. So, you know, if you adhere to best practices, Pulumi will never leave your secret in your cooper next cluster. But you know, sometimes we skip corners because we need to fix something. P ones are a real thing. So I don't know, I'm not judging you do what you need to do. Um But last applied configuration will disappear and services apply and manage fields will be the default first. So very, very cool. It was also very strange to see this massive Json blob inside a Yano object for me personally, like you would see this huge Jason object in lastly configuration is that the whole resource? Um And it is so um yes, it, it, that is always um that is nice to, to not have that there as well, like a small quality of life improvement, especially compared to some of the other stuff we talked about. But uh I get um I, I get a joy out of those small quality of life improvements, for sure. Me too. Love them. All right. Well, we are approaching time. Lee, you've been wonderful. I just love being able to kind of sit here for 40 minutes, 45 minutes and just get that knowledge out of your head and share that with people because you are super smart and I really appreciate you joining us today. Uh You're gonna make me blush if you're not careful, but I appreciate you too and thanks so much for putting this together. Um You know, it's, it's always great to just have a chat about technology and hopefully we'll be able to do it in person again soon. I hope so. All right. So people watching the links will be in the description soon. Feel free to leave comments and questions and slack or on youtube again, all the links in the description and Lee and I will be back next month. So until then we'll see you all soon. Have a great day.

---
