---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Building a Dynamic Provider for Bitly with Pulumi | Modern Infrastructure Wednesday"
title: "Building a Dynamic Provider for Bitly with Pulumi |..."
meta_desc: |
    Learn how to write a Dynamic Provider in Python to integrate Pulumi with Bitly, the URL shortening service.
url_slug: building-dynamic-provider-bitly-pulumi-modern-infrastructure-wednesday
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Building a Dynamic Provider for Bitly with Pulumi | Modern Infrastructure Wednesday"
  description: |
    Learn how to write a Dynamic Provider in Python to integrate Pulumi with Bitly, the URL shortening service.  Learn more about Pulumi: https://pulumip.us/Get-Started  Want to propose something for us to build on Modern Infrastructure Wednesday? Drop a request in the comments or head to this GitHub repo to add a topic request or vote for your favorite with emojis: https://github.com/pulumi/pulumitv/issues
  sortable_date: 2022-03-09T22:11:29Z
  youtube_url: https://www.youtube.com/embed/PhwAL_jrvNc
transcript: |
    Hello, welcome back to P TV. This is modern for such a Wednesday and I am your host David Flanagan. Although you may know me from across the internet as rock code, people often ask me, why should I choose Pulumi over other infrastructure, good tools. And it used to be. The answer was pretty simple. You get to define your infrastructure and real programming languages. However, the more that I work with polymer, the more I realize it's not just having access to real programming languages, it's about smart interfaces that Pulumi expose that allow us to increase their velocity, expand our integrations and just ship tanks faster. There are two really great interfaces that Pulumi exposes component resources and dynamic providers. Now, I have spoken about component resources before. So I'm gonna see if they update on that for another video today, we're gonna dive in to dynamic providers. Now, before we start looking at the code, let's talk about what a dynamic provider is and when you should use one. Ok. So what is a dynamic provider? Let's imagine you're working on your infrastructure code and you want to go and integrate with some new cloud provider or you want to create some resources on some new product. Now, the chances are hopefully there's already a perder in the event that there is no, you've got to make a choice. Choice one. Well, I can go in for one of the boiler plate repositories. Start writing my own provider, create a continuous integration pipeline that produces a binary ship that to github releases or SD compatible storage, register it with the preliminary registry and everybody in the world now celebrates how amazing I am for making this public. And that is a great route. But sometimes just sometimes you just want to get working with the API and asper dynamic providers come in. You can ship the dynamic providers with your PLI program. In fact, they're just classes and typescript or Python and all they need to conform and be accepted as, as a di per provider is one function. The create function. Then of course, you probably also want to provide update and delete, but you can get away with just a creation step and you can use the libraries and packages available from those programming languages, ecosystems to go and speak to external API S, create resources and store whatever you need to and the prelim state file and just get integrated with that API ASAP. All right. Let's take a look. The first thing I'm going to show you is that we have the Bentley dashboard where I have searched for rock code best returns zeal results. We're gonna try and change that. Let's pop open to our Pulumi program, which is a single file underscore underscore main hyphen Pulumi project. And this fail, I have to find a provider and a resource and a plumy code just to keep it all together and simple for the devil. The first thing we do is create a class called bit links arcs. This is just a little bit of glue that allows us to define the inputs that our resource will accept. You can see that we accept a domain, the expanded URL and some tags. These are properties that I know the Bentley API expects when creating a short link. The next thing we need to do is create a Bentley provider which is also a resource provider. No, I could provide a token on this class, pull it in from the environment or from the Pulumi convict and do this in a really nice and convenient safe way. But I haven't. Uh We are hard coding it on the URL O. Now it's not important for today's demo but please not pull in your secrets and keep them secret. So next we have our create function here. We need to take a base URL and extend it with bet length API, end point. We specified the authorization header to pass the Bentley API and then a payload to the bill. API expects in order to create a new short link and this to know which domain do I want to create a short on at plume, we have the Polyus domain which is used for this purpose. If I were to admit it, I would get a Bentley link itself. Next, we provide the long URL or the expanded URL. What do we want Bentley to redirect? Or where do we want Betley to redirect people to when they come to our short URL? And then as an admin function, we can specify tags on these URL S. So when we're using the Bentley dashboard, we can slice stace, search and filter, right? All nice and simple stuff. And because this is Python, I have access to the request library. Awesome. I can just say that I want to send a push request to the URL with my JM payload and my headers and veil and verify the TLS certificate. So if we don't get a response that we expect typically a 200 or a 201, then we probably want to throw an error to give the Pulumi program a way to bubble that up and say, hey, I'm really sorry. This creation failed. Next, we pass the JSON response if we do get our successful 200 and then we use the create result class as a return the tail poum that we want to store this information at our state. That's it that we could stop there. But we may want to update our program. Next, we have update. Pretty much the same thing we have our bet standpoint only this time we pass the id on the path. Bentley only allows you to update the tags, not the expanded URL. So we're only going to accept the tags for any update request and everything else will be ignored. This time, we sent a request dot patch with the same data, the same editor checking and the same JM parsing only this time we return an update result with the short URL and the tag. Now Bentley doesn't support the leap and I didn't need to implement this delete function. However, we added it just to do a new, this would just tell Pulumi to remove it from state and then there's nothing that can be done on the remote API. All right. Next up, we have the resource. This is our bit link which is a resource type. It has the same glue that we've been using throughout the rest of this code instead of function, we call the on the resource class. We do the constructor method there passing in our bit provider and then the rest of the clue. And under 85 lines of code, we have created a dynamic provider that speaks to remote API and implements, create update and delete. That's pretty sweet. Then we have to consume and use our resources and our provider here. We create a bit link code link we pass in the Bentley length arcs, we tell it to use the domain polypus, a domain that we have available here at POLY. The expanded URL is gonna go to Pulumi dot com slash rock hood, which I don't actually think exists. And then we have some tags just so that I could show you this on the dashboard and filter it down to see our single link. We can then export the short URL so that I can also get access to that after my preliminary program runs and curl it. So you see that this really, really works. So let's go to the terminal and run our Pulumi program here. I'm using a local stack with a password passphrase. A. This is just because I don't really want to speak to the plume and because these are ephemeral throwaway stacks. My stack name is dynamic Pie and I'm gonna run a Pulumi up from the preview. We can see that we're creating a stack and creating a new link resource. We can add details. We'll see our domain, our expanded GRL and our solo tag we can have. Yes and P has created a new short link. You can copy and paste or renew URL and it tells me that it has moved to HTTP S good enough for me. So let's take a look at that on the Bentley dashboard, you can hit return and there we have it. Oh No, clearly, I have a bug. My dad have a provider and we have no tags. But that's all right. We have the update function which hopefully will work. Let's go back to our code and from here we'll see your tag. Welcome back to the terminal. I'm gonna run, pull me up one more time. Was he here? That we have a diff? It tells us that hate. We need to add a new tag. Let say yes, let me does its thing. We hit return. Hey, we have our rock the tag and our new tag. Perfect. The last thing to do is delete our stack. We pop up here instead of pulling me up, we run to dry and our stack is gone. Now, of course, we didn't implement an actual delete. So our resources will still exist on Bentley. However, you may be working with another API that will allow you to do so and that's it. Dynamic providers are a really great way to expand your integrations and work with new software. There may not always be a preliminary provider and this is a really great way to get your team moving forward. And under 100 lines of code, we defend a perder that speaks to the belly api create short lengths, update, chart length, it deletes chart length and we ship it right with our Pulumi program. So what are you going to integrate with next? Let us know in the comments and we'll see you again soon. Have a great day.

---
