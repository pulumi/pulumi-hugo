---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Building a Modern Web App | Modern Infrastructure Wednesday 2020-04-29"
title: "Building a Modern Web App | Modern Infrastructure..."
meta_desc: |
    In today's episode, we're building a modern web app using React, AWS API Gateway, and Pulumi. Code for this episode available here: 
url_slug: building-modern-web-app-modern-infrastructure-wednesday-20200429
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Building a Modern Web App | Modern Infrastructure Wednesday 2020-04-29"
  description: |
    In today's episode, we're building a modern web app using React, AWS API Gateway, and Pulumi. Code for this episode available here:  https://github.com/pulumi/pulumitv/tree/master/modern-infrastructure-wednesday/2020-04-29  The examples are in TypeScript but Pulumi makes it easy to stand up infrastructure in your favorite languages including Python, JavaScript, Go, and .NET - saving time over legacy tools like CloudFormation and Terraform.  https://www.pulumi.com/docs/get-started/?utm_campaign=PulumiTV&utm_source=youtube.com&utm_medium=video  This is the third and final part of a multi-part series.
  sortable_date: 2020-04-29T04:13:02Z
  youtube_url: https://www.youtube.com/embed/YyZoQLSOo4I
transcript: |
    Hello and welcome to another episode of Modern Infrastructure Wednesday. I'm your host, Lee Zen. We'll be finishing the third part of our multi part series on building a modern web application. The first two parts we covered were standing up a static react website that we hosted on API gateway that was in part one. And then in part two, we actually connected that to an API uh in API gateway where we're just making a very simple call. And then in today's episode, we'll be covering the last part where we're gonna take that API and instead actually change it to read and write from AD DB table and then update our code to actually read and write against the API as as well. So let's get started uh just as a refresher. This is kind of where we left off last time. Last time we, we made this API uh path and we had it as a, just a simple get a request that returns back a simple JSON uh valley which is just this Hello World status. And then if we go to the actual application code, you can see we actually call the API here uh in this fetch data call and then that's reflected uh via the state here. And so if we go visit the sites when we hit refresh, um you know, it calls the API and it gets back hello world as we would expect. And so today, uh we're gonna go ahead and uh add to this example by adding a, a table. Um So let's keep this open here. Uh And so we're gonna create a dynamo DV table for us to persist data into. Um So we'll, we'll just do a simple counter, I guess. And so uh we'll just call this uh D DB table and this will be a new uh D mod B table and uh a table has to have attributes and a hash key. Uh Basically, that's the, the, the, the minimum set of things you really need. Um So we'll have a really simple thing here. We'll give it an ID. Um And that will be a string type and then it'll have that will be the key. Um And then uh uh it'll, it'll give it some simple capacity, I guess, like, actually, I think these are per second if I recall quickly. So we just give it 1 to 1. All right. Uh It's actually that simple to create a table. And so now we're gonna write some code to actually talk to the table. So um we'll create two paths, we'll have this get path. Uh So we'll get we'll call this. Um And we also create a post path for the same thing so we can post against API, we can get against API and so get for now we won't touch this. Uh But let's let's update um uh what uh actually maybe, maybe we'll just, maybe we'll actually make this simpler. Let's otherwise we'll have to end up changing our application code to do two different things. Let's keep this as a get and let's actually just do everything in here. So let's uh first um have a client so we can talk to the uh table and we'll use uh the SDK, which actually is part of. So actually one of the cool things about the way Pulumi works is, um you can see here, uh even though AWS here is actually the uh Pulumi provider, uh you can quickly alias into the SDK itself. So you can see here alias SDK. And then uh I can actually just go ahead and new up my client here as well. So I can just do this. Uh And then I can uh try to fetch, let's try to fetch the, the value uh of that, of that particular uh counter. So we'll just do constant, uh it's called data is, um and we're gonna get a particular uh key here. Um And so what we're gonna try to get is the table name and that table name is going to be the D DB table. Uh dot name. And here, um we actually, we already know the name since this, this, this will have been in the serialized uh version. So we can do this and then we can do uh we can give it a key. Uh And here it's going to be just a counter. Uh And then uh we'll say consistent read. Uh And the idea here is that we want to have a strongly consistent read obviously, since we're using this as a counter. Yeah. So this should give us back the, the table data and then uh we will uh just get the value of it. So, and we'll have a count basically. So, um so this is the, the row effectively in our table. Uh And so here we should be able to do this, this isn't any. So this is actually uh account. That's so, yeah. OK. So basically, this is, this is either, you know, we either have the count or we have nothing. Um OK. And that's actually like most of the code. And then finally, we're just gonna put back the counter. Um And so we can just wait on the client. Oops. This is, and that's the sort of do that and then we can put back into the, into this particular table so we can do table. Uh And again, we can use this to actually, you know, rip this out and we just call it uh and do this here. All right. And we're gonna put the item back where again, we use the same ID. So actually, let's make this a constant as well. All right, and we can just give it this and, and you'll notice that this, this key, this particular, this particular field count is not defined at all on the table above like that we have ID, but we don't have count. And this is one of the, you know, nice things about using a Noel stores. You can, you know, it's not, it's not necessarily, you know, constrained by the schema, right? Uh So we can put that item back in and picture was a promise. All right. And then finally, we can return back the count that we got, right? So we can, we can actually return back. Um, let's call this count and give it back the OK. So I think I got most of this right. Let's see. Last time you watched the last episode, I made a bunch of mistakes actually getting the, uh, the API hooked up correctly just because of um, some odd issues I had with no cashing and stuff like that. So hopefully this just works. So let's see what we change. We change the, we're updating the function which is gonna in turn cascade down to updating the API with, with changing the, the deployment. And then also you can see, I actually need it, we detect that we need the permissions to change so that I can actually write to this table as well. So, all right. That supposedly worked. Let's do a curl on the, on that API here. So we can do a, a curl of um, let me stack, output API URL slash API. I believe that's my path. Yep. Let's see what this gives us. OK. Great. So that works zero. And now let's try it again and I should get one. OK. Good. So it's working. So uh the API works as we expected. It's basically, it lets me do it get against this. And then now it, it, it executes this handler function which uh which you know, costs to the table, gets the, gets the actual value from the table uh for this particular item and then puts it back with a plus one. So now let's go to our app and all we have to do is actually just changes a little bit here. We have this fetch API which is exactly what we're reviewing here. Um Down here, I have the status dot status thing and that's a little bit wrong because um now uh what we actually have to do is uh here I set the status to this S dot Jason. Um and that's not what we want to do, right? So now um what we actually want is to uh we can actually still do that. I guess we're just putting the Jason option in there. But now this is actually the value here is gonna be, the thing is called count. So let's call this count and we'll just change this to counter. So it's actually a little clearer what we're doing and let's go to APP and we, we will rebuild this. Oops, we're ready here. You know how to find. Yeah, I wonder if this is because, um, I, I copied some stuff around earlier. So I wonder if I just forgot to install the, uh, pack here as I did last time. So let's do that. And as soon as this is done, yes, React is not uh a small dev environment, certainly. All right. I hope I can get yarn build now. All right. So I, I mean, if we, if we go, you know, we, we didn't have to change the app too much and uh let's go back down here and we'll pull me up. So if I, if you look, if you look back at our infrastructure code, you know, very simple, we add this table and then we just modified the existing API function, we had to do these weed rights. Um You can totally imagine doing what I was thinking about doing, which is splitting it out into a get in a post separately and then changing the app itself to here have two different effects, right? One to do the get and one to do the post. Um But really for the purposes of the example, no, no big difference. So I decided not to do that. Um You can also imagine since it's all real code very easy to refactor. Uh So let's go back here refresh and now we have a counter of two. So that's pretty much what we expected to happen. If I refresh again, then three. So it's working as expected. And now we've actually completed the whole tutorial um if you wanna call it that we started off in the first episode, just getting the React site up with the API gateway. And then last episode, as I mentioned, we uh just put together a super simple API. And then today we finished it off by actually introducing some persistent state store and then actually changing our API to read and write from that store. So there you go. Uh a basic example of what you might see in a modern web app. And then of course, you know, if you were to go build something like this yourself, you would actually make the site pretty and do all this other stuff, you know, in terms of what the actual functional functionality you wanted to do was. And then of course, making your API shape like the API that you would want. And then of course, having your actual business logic in here um as well. But hopefully that gives you a gist of how easy it is to build a modern web app with React using Pulumi on top of a Wu Si Hope you enjoyed this episode and uh for future episodes, uh please subscribe and like the video uh feel free to leave comments, suggestions for future, for future episodes as well. Uh Follow us on Twitter and as always, we'll see you next time. Thanks very much.

---
