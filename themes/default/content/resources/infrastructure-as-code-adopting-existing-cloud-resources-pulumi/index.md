---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Infrastructure as Code | Adopting Existing Cloud Resources Into Pulumi"
title: "Infrastructure as Code | Adopting Existing Cloud..."
meta_desc: |
    If you have existing resources deployed by hand, using CloudFormation, or using Terraform, you can adopt them into Pulumi to start managing your cl...
url_slug: infrastructure-as-code-adopting-existing-cloud-resources-pulumi
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Infrastructure as Code | Adopting Existing Cloud Resources Into Pulumi"
  description: |
    If you have existing resources deployed by hand, using CloudFormation, or using Terraform, you can adopt them into Pulumi to start managing your cloud infrastructure using Pulumi instead.  This video covers: • Deploying some "existing" Azure infrastructure (resource group, networking and VM) using Terraform • Creating a Pulumi program that describes the same infrastructure using tf2pulumi • Showing that by default this will create new infrastructure • Using the new import: id feature to import a resource • Highlighting how Pulumi helps ensure you correctly described the desired state of your infrastructure (so that you don't accidentally replace adopted resources) • Getting the ids from the .tfstate file • Importing the full infrastructure into Pulumi • Showing that this allows managing the resources in https://app.pulumi.com (like linking to resources in Azure Portal) • Adding a tag to the VM with Pulumi and showing that we can now make changes to the existing resource using Pulumi • Discussing how to manage import IDs via config in cases where there are multiple instances (dev, stage) of a deployment • Discussing when import can/should be removed from code once imports are complete
  sortable_date: 2019-07-25T19:47:18Z
  youtube_url: https://www.youtube.com/embed/kX_3Wdft0Ms
transcript: |
    All right. Hi. So today, I'm gonna talk about uh adopting existing resources uh into Pulumi. So there's two things we could be talking about uh when we talk about sort of existing resources uh with poll. So the first is that we will have existing resources. We want a reference from Pluming program. Uh And we want to use those, those uh details of those resources to create new resources. So for example, maybe I have an existing VPC and I want to go and get that VPC and then use that VPC as an input to uh other resources that I deploy in my application. But I don't know yet want to sort of manage the life cycle of that VPC itself with my Pulumi program. I just want to reference it. And that's a scenario that's been supported for a while in Pulumi uh using uh the notion of dot get uh and get uh helper methods. Uh And so that one is well supported, lots of use cases of that, that you can look at online. Uh The example I want to talk about today is the one where we want to actually go and uh adopt that resources into uh Pulumi and make it be managed now by Pulumi. And in that case, we've got an existing resource and we want to say now I wanna have its desired state be defined by my polling program and the updates I make to my polling program. I'm gonna update that existing resource instead of deploying a new resource. Uh And this is great for when you have some existing infrastructure, you want to take uh take it and start managing it uh with polo, that's the scenario we're really going to focus on uh today. And so the example, I'm gonna go through today, uh I'm going to focus on uh a, I'm gonna use um uh form as the way of deploying my infrastructure. Uh There's nothing special about terraform here. We could be using, you know, I could have point and clicked to create my resources in the Azure console. I could have gone and used cloud formation in native us. Uh However, I had created my resources, uh the Pulumi adoption features work exactly the same. I'm also going to highlight Azure here, but of course, Pulumi supports a variety of different cloud providers, a Azure GCP cloud flare, et cetera and all the features I'm gonna talk about today work exactly the same no matter which of those uh I'm working with. And finally, I'm going to use typescript for this example, but Pulumi supports uh Python as well and all the same features are available uh in Python. Um So with that, let's kind of go ahead and get started. And the first step we're gonna do is we're gonna need some existing uh kind of resources in my cloud provider. And to do that, I'm gonna deploy something with terraform. Uh Just to give me uh an example to work with here. And so I'll touch a main dots here, open that up, paste that in and just run terraform knit to make sure I have the right providers and then terrain applied. And this will go ahead and uh create these resources. And if you look at this, this is, is a simple example of um kind of an Azure uh uh an Azure virtual machine, but it has to create five or serve resources. It has to use variables or resource groups, a network interface uh and then finally a virtual machine. And so we'll give it a little while to create that. It'll take about a minute and while it's creating it. Um Let's go ahead and uh start refresh console uh and start showing how we can sort of adopt and, and, and import this uh into the program. So the first piece is we need a pluming program. Uh That kind of describes what our infrastructure is. And so let me just start by saying Ploy new Azure typescript force. Let's just go ahead and accept the defaults to sort of get a new uh to get a new uh environment where we can create our ploy program. Now, the first thing you have to do is you have to have a plumbing program that describes the same infrastructure. Um And so to do that, uh we could write down, you know, if we point it and clicked in our console and then never written down what the desired state of our infrastructure was. We would probably have to write that program from scratch. Um But for some other sources of, of my um my desired state, I can actually import that and bring that over into Polo. And so in particular, we have a tool called TF to Pulumi, which will in turn my, my, my dot TF files into uh dot TS files that I can use with Pulumi. And so I can take that main dot TF file that I just wrote and I can say I wanna uh TF to Pulumi to convert it into a TS file. If I now open that TS file up, I see that this is the exact same uh contents as what I just pasted in there. Um So I just created a uh a Halimi program that describes the same infrastructure. Um So that's a great tool that tool has been around for a little while, but this is a useful tool for sort of bootstrapping um my import. So now I can go ahead and say Pulumi up uh to go and deploy this and as usual plume up will preview before it does deployment. And so we'll see in this particular case that that preview says it's going to create all these resources and that's what you'd normally expect from a pluming program. Uh since we haven't deployed this particular program before, we're gonna have to create new resources uh to manage. Now, in this particular case, what we want is not to create new resources. We actually want to go and say, hey, there are existing resources, I want you to adopt those into the management here. So we want to import instead of uh instead create. And so this is the new feature that we've recently added uh into Pulumi, which is that I can now say uh import colon and now I can provide an ID here, which is the ID of the resource under management in Azure cloud uh that I want to, to map in here. So what I need to do is I need to go and find the I DS uh for these resources. And so, for example, I have uh I have a TF state file here, which is what I just deployed. And for example, the resource group uh we see here is a resource group, uh id. Uh So this is the id of our resource group. So I can go ahead and take that and actually let me just split the screen so I can more easily do this uh going forward. Uh So I can go ahead and take that, put that ID in there. And for now, I'm just gonna comment out the rest of this just so we can see uh what this process looks like. So now if I do Pulumi up, uh we should see that instead of creating this new resource, uh plume is gonna understand, it's gonna try and import this and it, in fact, tell me that it's gonna import it successfully. I can see the details, I can see exactly what uh name and location it's going to sort of import um that match what I wrote. Now, before I go ahead and do that, let me just show you one example of what might happen if for instance, I've been writing this manually and I've gotten something wrong, like maybe I mistyped the name of the resource. So I was trying to import it with a different name than it actually had, which is something that shouldn't be allowed to happen because that name is a fixed part of the resource identity uh in Azure. So if in this case I ran pulling me up, uh what we would see is that uh when I do the import, I'll actually get a warning. Uh telling me that there's a diff between what I described and what the cloud provider had uh at the, at that ID. So it in fact tells me that the name is different and it says uh that imports, import do not match uh importing this resource will fail. And so if I tried to go ahead and continue with this, it would actually fail. And we can see here the details of what was different. It should have been resources, but I was trying to change it to resource. So this is a helpful thing that Pulumi does to ensure that you don't accidentally sort of import things with the wrong uh description. In that case, if you did that, that might cause you to immediately try to replace them and lead to some very confusing error messages down the line. So if we fix that up and say resources again, uh this will, as we saw previously just uh import correctly, let's go ahead and do the same thing for all the rest of our resources. So we have a virtual network here. Uh This is the Subnet and so let's go ahead and just put that on the subnet. I'll just go ahead and find other virtual network. I got some help tips that are taking up some space. OK. There's the virtual network and what else do we need to do? We need to get the nick network interface and finally, we need to get the actual virtual machine. So OK. OK. So there we go. Uh So now we should have all these resources. Now, if I flew me up, we should see this preview will actually tell me uh exactly uh that it's gonna import those remaining four resources. Uh In fact, all five resources because we didn't yet import the resource group. So see, there again, it tells me I did them all successfully. There's no warnings, which means I did get all the description of this correct. Uh That, of course, in this case, was done by the TF tool, but had I been doing this manually, I would have gotten that feedback loop on the way. And I could see the details of exactly what it's going to import. So I can go ahead and say yes, and this will just go ahead and import those and write them into the state file that I am now managing. At this point, I now have a deployment of this program that is tied to those existing resources, not to a new set of resources. So there's a couple of things I can do with that. So one is I can go look at this in the plume dot com back end and see the sort of history of this stack that I imported these resources and I can see the resources under management. So for example, that virtual machine that I I was just looking at, I can click this button jump over into the Azure portal um and see this research. Now, this is the exact same research I created originally uh with um with Terraform. Uh We can see it's been alive, you know, for the last six minutes or so. Uh, since we started this video, um, here's the tags and everything that I described originally with Terraform. But now I'm sort of managing, uh in this program and then to really show what it means to sort of be managing this, uh I can go ahead and sort of say, add something new so I can say manage, buy and say, uh, so I'm gonna make changes to the desired state and my infrastructure and I can go ahead and apply them. So now I can say, cool me up and here we should see that this is going to update this existing resource uh with some changes. So it's going to modify the tags. I can see the details of that. It's going to add this managed by Polu tag. Um It's going to do this in place as an update, not as a replacement. And so I can just go ahead and say, yes, that'll apply this change to my infrastructure. And I've now like actively managed this infrastructure in a sense uh with Pulumi. So if I come over here back into the Azure portal, uh we should see uh that we have an additional tag now. So there we go managed by pou tag. So we did update our infrastructure now using pollutant and now I can go ahead and uh do whatever I want to, I can continue to maintain this here or I could destroy the stack using Pulumi however, I want to maintain this. Now, one last thing you might notice is uh I kind of left this import statement around and it's actually OK to leave this import statement uh around as I'm making updates to my resource. Uh because the ID that my resource has is still the same ID. Um And so, uh if there's an existing resource and has the same ID, uh plume is not going to complain about them. If I did something which caused this resource to be replaced, I would need to remove this import because it would no longer be accurate. Um Because the idea of the resource would now be the new idea of the replacement uh of the replaced resource. Um But it's also safe to just remove this after I've done this process. And so I can go ahead and uh just remove all of these. Um now. And that should be the other thing to note is uh for each of these imports. You know, you may not wanna encode the uh the specific name, if you have multiple instances of this uh of this application, like you have a DEV environment, the staging environment, you may not want to encode the DEV I DS for all these resources, right? In your code. The other thing you can do uh is you sort of config um so you can access POY config and say, you know, Pulumi config dot uh a choir, you know, main resource group name or something, right? In which just group ID. Um So you could use this uh to then uh have this all indirect through configuration. Uh So now you can inside your uh config bag specify in your Deb stack here are the ID si wanna uh import from and in your staging stack uh specify the I DS you want to import from there and I won't go through that whole process here. But just to give you a sense that it is possible to sort of avoid encoding these things in here. If you want by putting this in code, we give you a lot of different options for how you configure these things, how you chain the imports into your existing applications for this case, since I've done the import correctly. Um I'm just gonna say plu me up now uh with all of my uh imports removed and this should have no changes uh Because I'm not actually changing anything of my infrastructure, I'm just removing those so that my crude is clean. So I go and say yes, uh make this change which has no impact. OK. So there we have, we've successfully sort of uh imported uh resources into uh polling from uh existing resources deployed with some other system. Uh As I mentioned, uh this process can work with, you know, terraform cloud formation or anything created manually within your console. However, you've deployed your resources, you can adopt them into pluming. You can also work with resources in Aws Azure, GCP, uh Kubernetes and any other cloud provider that Pulumi supports. And finally, if you're working with Python instead, that's exactly the same process on just adding these resource options to specify uh an ID to import. Great. Thank you for joining us. Bye.

---
