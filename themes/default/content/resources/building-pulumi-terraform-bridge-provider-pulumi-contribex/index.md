---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Building a Pulumi Terraform Bridge Provider | Pulumi ContribEx"
title: "Building a Pulumi Terraform Bridge Provider | Pulumi..."
meta_desc: |
    In this session, David and Paul will guide you through taking an existing Terraform provider and making it work with Pulumi using `pulumi-terraform...
url_slug: building-pulumi-terraform-bridge-provider-pulumi-contribex
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Building a Pulumi Terraform Bridge Provider | Pulumi ContribEx"
  description: |
    In this session, David and Paul will guide you through taking an existing Terraform provider and making it work with Pulumi using `pulumi-terraform-bridge`.  Source code: https://github.com/pulumi/pulumi-terraform-bridge If you want to wrap a new Terraform provider as a Pulumi provider, check out https://github.com/pulumi/pulumi-tf-provider-boilerplate  Using Terraform, but new to Pulumi?  Adopting Pulumi from Terraform give you options. You can choose to coexist, import existing resources or convert any Terraform HCL to Pulumi  code. Learn how it can be done: https://www.pulumi.com/docs/guides/adopting/from_terraform/
  sortable_date: 2022-05-26T00:52:54Z
  youtube_url: https://www.youtube.com/embed/ZjTFaqMrYvY
transcript: |
    Hello and welcome to our first Pulumi contributor experience event. My name is David Flanagan. Although you may know me from across the internet at rock code. And uh today we're going to take a look at building a plume provider using the Terraform Bridge. So we're going to dive to it and I'm gonna introduce our wonderful guest, Paul Stack. Hey man, how's it going? Hey, folks. Uh how's it going? Uh Thank you for having me on the show, David and um like, I hope we can make this actually a little more interesting and I hope we can actually show people how quite simple and straightforward we've tried to make this. Yeah, I think this is one of those really cool topics where, you know, we see a lot of questions and conversations and the flat community where, where people want to be able to use the Terra Farm Bridge. But Gun Star can seem a little bit intimidated and we're going to break that down for them today because like you said, it's not a very complicated thing to do, but you just have to see it once and hopefully we can make that very approachable for everyone involved. I'm actually gonna try and use this as official documentation. So I I'm always going to be pointing people to this video going forward if it works. So I think this is, this is in my best interest to do this. Awesome, I love it. Uh We got a comment from saying hello, everybody. I just seen you in. It was nice to catch up with you in person. Yeah, for sure. Um I, I didn't actually get the Even C engine at C which was disappointing. So there's always the next event. Hopefully we're back into a little bit of normality where we get to see all these faces again. So fingers crossed, we shall see, we shall see. All right. Uh So you ok. Yeah, I'm gonna, I'm gonna share my screen and I'm gonna start driving here. All right, please ask any questions that you need me to uh that you need from me because I want to get a lot of like information on this. So you should see my screen right here. So uh currently in Pulumi, we actually have a boiler plate rebo which actually takes care of a lot of what we're doing today. So it is uh Pulumi slash Pulumi TF provider boiler plate. And what this actually allows you to do is it gives you the guard rails uh and the guide um here in the repo of um what the different parts that you actually have to update to be able to go and create a um a bridge provider. So a bridge provider is actually exactly as it says, it, it, it is using the Terraform schema. It is using the Terraform crud. There is a misconception that it uses the Terraform binaries that is not true in any way, shape or form. We're actually using the GO modules and we're able to extract the GO code from Terraform and we're actually able to make uh requests that what we do inside the bridge is we, we, we interchangeably move from a Pulumi schema based object into a Terraform based scheme object. So that the Terraform crud methods actually know uh what pieces of functionality we're pushing into the cloud API. So this is a template repo and today um David has told me that it would be nice if we could because there was a community uh request to change the Terraform provider Confit cat, which is a open source um feature flagging tool. And uh we're actually going to use the bridge in order to, to, to point to this Confit cat and we're actually going to scaffold this. So this is a um a template repo as I said, and we can click this button that says use uh this template. So I am going to use the Pulumi Verse. Uh You can read more about the Pulumi verse on the Pulumi blog. It is an awesome community based um sharing program that was set up by some founding members, David included. Um and actually make it nice and simple and easy to be able to create and share uh and, and help with the maintenance of Pulumi based systems. Yeah, I think, do you want, do you want to push the? Of course, of course, I think this is really cool because you know what we're doing to what we're doing today is giving people the, the instructions on how to build a bridge provider. And we want to see the community getting those first contributions into the Pulumi project via Pulumi Verse and bringing in more of those providers for everybody to kind of learn and share together. And I think it's a really cool way for people to get involved in the project. Yeah. So, uh so I'm gonna give it a name. So usually our convention in Pulumi is Pulumi dash the name of the provider, but you can call it whatever you want. It is entirely your choice. It's up to you. But as this is gonna sit inside the Pulumi verse, we kind of want to follow a, a standard convention. Um I try and give some level of description. My, my writing is not brilliant. I'd rather code and then fix it later. Uh And it's a public repo. OK. So we're gonna create the repo right now and it's actually going to use that uh template and it'll just give us the base bare bones of everything that we actually want to do. OK, cool. So I'm going to clone this locally and I'm going to do everything locally. So I'm going to open my um terminal and you can see, I already have a folder that I use for uh Pulumi verse and I'm gonna uh use it github uh CLI and I'm gonna say github Repo clone and then I'm gonna say Pulumi verse uh Pulumi Con cat. I'm gonna clone it. It's made things so much easier for me, especially with some of our pull requests which are like 5000 files or more. And I just can approve everything via the cli know, which is just amazing. I love that you can just do GH 34 and it just does everything for you and it even changes the, the, the remote which makes again like life way much easier. And so I'm gonna open my uh my browser, uh my or my ID, my id of choice is intell you can use whatever you want. This is not a sponsorship you don't have, you can use them or Atom or any text based system that you, that you want. It really doesn't matter to me. OK? So first thing we can do is we can have a look at the read me. OK? Now the read me actually gives us a lot of information. OK? It says, you know, here are some instructions, this is kind of um designed for using a, an official provider. But today, we're going to look at creating a community provider. So we're going to bring in some of, of the different concepts that are not sort of there by default, but that are available. We're just not very good at pulling up, being able to expose in those those situations. And this is kind of what we're going to try and do here. So, you know, it even goes down to here first sort of command it says to run is make prepare, OK? And it says name, which is the name of the provider and the repository that is going to sit on that. Absolutely, I will change to. Here we go right there. OK? So what this actually does is that this is basically doing set in the background and it's changing some of the templates and moving some stuff around because we can say make prepare uh name equals config cat uh rep. I think it's Rio repository equals get dot com slash Pulumi verse slash Pulumi Con. And you'll see it just, it's basically around like some sad commands. OK? Now you'll see straight away what it's done is it's deleted some old uh rename, some old folders, move some things around, et cetera, et cetera. So there's a couple of places now that we actually have to go and get started. Main thing is is that we actually have uh a pack called uh Comfit and that actually relates to a two binaries within our system. OK. These two binaries have two very distinct jobs. We have a TFGM binary, that TFGM binary will allow us to, to be able to create the schema based on terraform. That's why it's got the like the acronym TF gen. OK. Now that is literally terraform generation. OK? And this is pretty simple and straightforward. It basically points into a terraform provider um that allows us to be able to extract that schema information so that we can build the Pulumi schema. The Pulumi schema is then used to be able to generate the SDKS. And also we actually ship a binary which allows us to be able to make the GR PC request back to the Pulumi engine. But we'll talk about that in a little bit. OK? So we have a couple of places that we have to change and stuff. So there is some hard coding I'm going to say uh based on uh the fact that we, we, we believe that everything is going to be uh Pulumi. Uh But in this case, we can see that the people is actually uh Pulumi config cat and its provider package version. And then of course, again, we need to change here. We're actually using the Pulumi Terraform Bridge. So this this one is is perfect as it is, I guess this is something you know, people are watching this, they could come and contribute some additional effects to the prepare command to catch some of these extra things that are just kind of emitted at the moment. Absolutely. And I'll be totally honest in the future, we're probably gonna move away from having these repository templates because they're not massively intuitive. Like we should, we should really be able to give people a much better experience of getting started. But time is an amazing thing and we've only got so many hours in a day and so many people on the team, but like we definitely like care greatly about making this experience much better. Um Instead of repository, are you suggesting maybe like something in the possibly, possibly, we just don't know yet. It's a surprise that everyone's going to get. It's even a surprise for me like going forward. So, so we'll see, but we definitely want to, we want to do something to make this experience much better. Ok. So that's kind of like our generate um command taken care of. You can see we pass in the name of the the provider Confit cat. We can actually pass in the version of the provider that we're going to build. And this config gap cat dot provider. Actually, I will show you that in a second. That is the mapping of the terraform provider to the Pulumi provider plus extra information that has to go with it. Ok? So we can close the TFG next, we can go into the resource, ok. The resource is actually the binary that gets installed on people's machine. OK. That, but so when we generate a uh an SDK at Pulumi, that SDK is plain classes, it has no logic in any way, shape or form all of the logic is provided inside of the binary. And the SDKS just use um a token um that the binary understands and the binary is able to make requests on its behalf back to the um the P Pulumi Cl A and the P Pulumi engine. And that's what actually makes the request. So our SDKS are pretty dumb. That's a bad thing to say. Our, our SDKS don't have a huge amount of logic in them. And all of the logic happens within the binary itself. But just to summarize that in a way, like what we're saying is that language SDGS that we provide as they are purely to provide the interfaces for the languages natively. But really, they all work in, I guess the GR PC binary, which is the P provider itself. Exactly correct. Couldn't have said it more succinctly myself. That is it. That is it. That is it. So you can see we just had 22 paths that we had to change here as well from Pulumi to Pulumi verse. Um And then lastly, we have, uh we just have to uh check that our goal mode is correct. OK. So our go mode uh by default will pick up that it's Pulumi verse and that is everything that's there. So the next day that we've got one more place that we have to change. Ok. And that's in resources dot gov. So there's a couple of things happening here that we hard code by default, which is not correct. Ok. So the first one is Pulumi verse. And the second one is that when we created this bridge, basically, all of the terraform providers sat inside a Terraform providers organization in github. But recently they've started moving out into like their own area and going back into companies and companies taking charge of their own, just as as the, the the Terraform ecosystem has had further offering improvements and made things better for people. So, you know, we just need to change this and we know that this is conflict cat. Uh because that is the provider, that is actually where, where it sits in the system. So what I can do right now is I can see the provider and I can go mob tidy and you'll see that it's actually pulling the dependencies that I need because it understands based on the, the files that are there currently. And you can actually see that it's even pulled the latest version of Confit cat. We can go and check that uh config cat. The latest version is 1.3. So it's actually uh go modules has found it correctly and uh it has everything that it needs in order to actually build and run uh run the binary. Now, I can run this right now. Uh I'm just going to remove all of my ambient plugins uh locally just because I don't like any side effects. Uh And if I run the command to make TF gen, uh what you'll do is you'll see that it, uh by default, we try and um get a plug in. So you'll see firstly that we actually have an issue because we have a reference to command uh TFN. And it just means that I have one more place in which I need to fix. Yeah, I think it's going to be org. Yeah, it's here. It's here because the org was uh not set by the fault. So it's not. Yeah. Um OK. So now we can make CFG and we will actually get a binary that is created. Now that binary doesn't include anything by default because we have not done any mappings. We have not done any set up. But what we will do is it will go compile and you will get a bin folder that pops up in your repo um That is get ignored so that you don't check this in by default. Um But it is trying to do something right now, but my machine seems to not want to play ball. So let's close a lot more things down. Actually, let's close zoom because Zoom always keeps bandwidth. Uh and that's also close signal. Uh And there you go right. So straight away, we're getting some output here. OK. We're basically being told there is no mapping between the terraform resources on the data sources into the Pulumi Project. So we're trying to like, we, we're fine tuning these warnings all the time and you're gonna see a wall of other warnings in a second that we're probably going to start hiding away. But we're trying to like, give people some information so we can go back on that. Absolutely. Yes. So if you go back to your terminal, now, all we've done is replace a few things use TF to kind of consume the term farm. And we are in a GR PC Pulumi provider. However, something here is telling us that we haven't done any mapping of resources from the farm side to the side. And so this is kind of like a wee to do list like, ok, you've got the basics, but now you've got to go do this other stuff. Exactly. Because right now this is, this is a shell of a binary. It doesn't know what we're actually trying to talk to within the terraform schema and it doesn't know what parts of the schema. It actually we want it to pull up. So there is nothing here at this moment in time like I can go in and I can show you what the schema looks like at this point. Ok, because we do have a valid schema and you can see that it's actually pulling the correct stuff. I need to change a few things here and the attribution. But, you know, we can see that which config values that has come. So it's pulled these out of the upstream schema where upstream had base path, basic off password, basic, off user name. And I can even go back to their provider and I can check that that is the correct schema configuration. So if I go to provider dot go and I go in here, I can see it has off user name, off password and base path. So we're able to pull, we're actually already starting to extract pieces of the schema. But we have these two resources, maps and data sources maps upstream that Pulumi doesn't know what you want to do, like which resources actually you want to care about. Which ones do you not want to care about. We don't have any automated mapping at this moment in time because it is very provider specific. So for example, in Amazon, we want to uh or excuse me, Aws, we want to be able to map each of the parts of AWS into the relevant sub module. So for example, a bucket would be an S3, uh an R DS cluster would be an R DS uh mem cache or uh elastic cache would be an elastic cache. So we don't want to make assumptions based on what the names are. We can like leave that up to the individual person themselves in the future, maybe we'll do something a little better here. But in this case, we have maybe 15 or maybe 16 resources in total to map. So it's quite easy. Ok. So we can go back to our resources dot Go and I'm gonna remove some of this. Um I'm gonna say that it's, I was gonna use a swear word there but I won't because um like, uh I, I, so yeah, so there's a few things that we want to change in here, right? So first thing we have a display name and the display name is actually used later in the process. It's when it goes on to the Pulumi registry. Ok? No, the Pulumi registry um is a place where you can list all of your packages and all of your setup and you actually can give it a different name based on what the provider name is. OK? So it's, it's pretty simple and pretty straightforward, but we don't want lower case like we actually want that to have the correct uh sentence casing. So we can call it Confit Cap. The publisher is not Pulumi, the publisher is Pulumi verse. You could point to a logo in here uh which you'll actually get it. And then lastly, we want to actually like be able to specify a plug-in download URL. So the plug-in download UL we kind of like suggest that you store this and get hub releases, we'll talk about this a little later. Uh Just because it's not that um uh difficult at this point in time, but we're going to say it's Pulumi verse. Um We're going to say it's Pulumi config cat and we're going to say it's releases and the last thing I am going to check on the syntax of this. Yeah. So it actually has to point into releases slash download. Uh And then it's the dollar uh and actually opening up code and we will change this at the time. Ok. So, so that's fine. So we don't need to worry too much about this. And then lastly, we want to set the github or by default, the github org is Terraform providers. And we saw that in our license attribution, we were actually pushing it back to terraform providers. That's not correct. That's not who created it. So we want to attribute this correctly and the github org is confit cat. Ok. Now, in the mapping, we can specify any configuration that we want. Ok. As you can see in the scheme, a Jason, we have pulled out the configuration by default upstream. Ok. These are the pieces that the terraform provider have, but we can actually um make that better. We can add extra environment variables that we want to allow people to look up and, and pieces like that. But in our case, we don't need to, right, because the upstream provider has a set of en uh environment variables already specified that you can pull out of what is already required. It even has like uh optional or you can actually set the defaults or anything like that. So we don't need to do anything here. So I'm just going to close off this conflict block uh because it doesn't really matter. Now, we have two more blocks. OK? We have resources and we have data sources and what we're going to do is we're going to create a map, OK? Now it is a map of string to a, a uh terraform resource info um struck. OK? And this is, this is actually where it starts to get a little more. Um I'm going to say uh strenuous, OK? You actually have to map this yourself, right? So we have a, we, we have the name of the terraform uh resource. OK? And then at that point, we have a token, that token is made up of a TF bridge dot make resource. OK? We are going to point to um main package, OK? So it sits in the root of the, of the repository and then it sits inside the main module. OK? So there's only one module, we're not doing any sub modules here. So everything will go in the top level module which by default is called um index. OK? And the package is called Conca because that's the name of the, the package that we created. And then lastly we actually give it a name of a class that we actually wanted it to look like in our, in our SDK. So in our case, a comfit cap product in a terraform resource would map to a product class inside our SDKS. You were going to say something there. No, that's just actually you going over that has actually helped me understand how those names are put together broader by working with providers. I'd always kind of been curious why we adopted that format and now that I see it, I'm like, oh, because I've always wondered why index and then it's like, oh because sometimes it might be like AWS EKS cluster exactly like look S3 and where you're actually using sub mode. If you want to put this product in the sub mode, you would just push it in there and it would be pushed into a subclass. So it's a way of us being able to organize the hierarchy of our packages in a simplistic way. And this is what I was saying about. You can't automate this process. We could like, we could automate it and we could put everything the top level. But if you're scaffolding a provider that has four or 500 resources, then that's not really like very usable for the user, right? Because they have, as soon as they click uh confit dot They'll get 400 things in a autocomplete. We want it to be a scope. That's possible I bet if I had picked a terra farm provider with hundreds of resources, you may have used that square word you were gonna use earlier. Yes, I would have because I actually scaffolded the OC I provider recently and there was like 2500 resources inside it. And it is, and having to organize that into sub modules. It was hard work. It was really hard work so I can show you that we have uh product right here. So if I rerun the generator, we'll actually see the product disappears um from our setup. So by disappears there, right? I mean, just by providing that mapping, we've actually pointed to the goal code for the terra phone provider and will that work as part of our provider? Absolutely. It will 100% work like there's some like uh HCL conversion errors, but that's around like uh actually documentation and examples. But that's like that's not a problem. OK? But we can see in the TF resources there is no, no product included in here and we can go back to our schema. And we can see in the schema, we now have a resource called product that has properties of description, name, organization. It picks up some of the um documentation that goes with it, it has input properties, what is required we even are starting to now denote this is a new feature that we just added yesterday. That's going to go into the documentation this property, if you change, it will replace um the entire resource, which means that it's like you haven't even seen this, this just went like yesterday, that's going to go into our uh docs this week across all of our uh pieces. And we can even see what's required. And then off, off the base of that, we could even see what are the outputs that's required. OK. So we've, we've been able to just do a simple mapping and at that point, we are able to start creating products inside conflict map. Now, I want to take this a little further. I want to show you actually um a couple of uh pieces we'll come back and we'll do all the other mappings in a second and we'll do some data sources. No, we have some package metadata that we actually want to take care of here. So javascript by default, every package inside Pulumi will have the name space at Pulumi, which is not correct, right? Because this one is actually not. So we're going to be able to say our package name in this case is at Pulumi verse slash cop COCA, I was gonna say copycat. So I've been making that type like all morning. OK. So that means that when we create an SDK, the package dot JSON of that SDK, the name of the package will be config cat at Pulumi slash config cat. So it won't try and assume that it's Pulumi by default, we can see that there are some dependencies in here and you can add overlays. We don't care about overlays for this session because that's quite an advanced concept. Um Next, uh we want to do the same thing with Python. OK. Because Python also will have a different package name format. Our package name in Python, we kind of suggest that it's like uh because Python has no name spacing, right? It's not as straightforward to be able to create. So what we're trying to go for is something like org underscore package um which in our case would mean uh that we're actually going to call it Pulumi underscore confit. Mhm. Ok. And that then allows us to be able to upload that Pulumi underscore conflict cat. Unless two people are creating Pulumi conflict cat. Then the chance of, you know, the fact that we're including the org name in there is, is uh as an underscore means it's a wee bit less prone to that conflict. Absolutely. Uh And then look, there was one more place in the gold package import path that is not correct. We need to have uh Pulumi verse and then we have one last area. OK. Which is the C# OK. Uh area which is around creating new get packages again by default, we assume that it's us creating this package, which is not really the correct thing. But what we actually can do is uh so it'll be in new, get it'll be Pulumi dot And we don't want that to be the case. We actually want it to be Pulumi dot So we can set the root name space which will be Pulumi verse. So we have a schema, we have some metadata that goes with it. We can actually start to produce our SDK. I need to push these metadata pieces into the schema very fast. So if I make TFG again uh to build the schema and if we have a look at our uh make file, I can clean up some. That's the the preparation in the make file. We can have a look, we can see that we can make our provider. OK? Our provider is pointing to the provider binary. OK? We output the provider binary on the, on the, the cli tool that we're creating on the binary that we're actually creating uh will be Pulumi resource in our case conflict on line uh seven, we do have a plume reference. Is that correct? Uh You are correct. That is not correct. That is not correct. Thank you for that. Let's just pop in. Yeah, that's all I could do is paper. Um Yeah, it's OK. I'm I'm very, you'll find a lot of them in my sessions a lot. Uh So we actually have our uh so the next thing we can do right now is we can run um make build sdks. OK. Now, RSDKS will take this schema and it will run the schema through our TFG tool. It already knows that the schema is valid. It knows that the schema has been created and it will allow that schema to be able to chop up uh and build the SDK that goes with it. So just so people are aware because I see this question also on the select community quite often is that when you are building a case for projects, you do need a node run type or you need node, you need the Python installed, you need uh the dot net if you want to generate the dot net repositories, et cetera. So you will need some to involved. So it's usually best to push this to ci I guess eventually. Absolutely. Like we, we're trying to offload a lot of this into C I but you can see their individual targets. So if you only care about no jazz, you only need no jazz. If you only care about Python, you only need Python dot net, go et cetera, et cetera, right? There's there's no hard and fast rule that says you need to create packages and all languages. We would love you to create packages in all languages. But there is no hard and fast rule, especially like now that there are new languages that come out around Java and there's, you know, new work that's going to be added to the provider for Java. We're not going to make it as intrusive as it is. We're actually going to give people a binary um that they can download and they can just run the Java binary rather than actually having to bake it into like their project or, or, or things like that. So you can see that we've actually sorry, sorry, you go, no, no, no, no, go, go ask, please, please. Well, I'm curious, like I understand how it works for, for no and Python and dot net and Java etcetera. But is there, how do you do it for Yaml? Like what's involved in that process? So there is no SDK for ya. Uh Yaml doesn't need an SDK. You just need the YAML binary that comes out of the Pulumi cli binary uh installation and you just write your binary as normal because Yaml doesn't have an SDK, right? We're actually uh or no packages. So if it's valid yama, we will try and uh apply that valid yama and we'll be able to upload it and, or excuse me, execute it and see if it works and it'll give you like an output. So it's, it, the only reason we need these specific sets uh in languages in each of the providers is because there's actually language specific packages that need to be created. That's a wonderful piece of magic. I love that. Yes. Yes. Uh So we've created an SDK and we can actually go and you can now see four new folders. I've been created in my SDK and I can look in SDK and you can see that straight away we have product dot CS and Product dot CS has our, our empty class. It doesn't really do all the logic. We can even see the plug in. Download URL. It's gonna download the plug-in from Pulumi verse. Um It has all of the input types and it has all of the output types uh in Go. We have a similar thing. Uh So product dot go and we can see, look, we've even been able to build some of the documentation and the import commands and like pieces of that. Of course, that's not something we want to ever uh bring in there learn dot dot com. So we'll figure that one out in a little bit. Um But we can even see that the, the source um API even works uh as expected. And you can see that the only logic in here is about registering a resource. And that's, that's the, that's the secret sauce. That's, that's what turns are very empty sdks into making uh resources because this register resource talks back to the uh plug in binary and the plug in binary that understands what exact uh command that it needs to be another question. Assuming, you know, people are watching this and are like, oh let's put the plug in, download your RL which is a get help to release, but I haven't actually published yet. Can I still use it. And I believe the answer is as long as the binary exists in the path, it won't try to download it 100% correct. They won't try it. So not even will not try and download it. They just use the ambient provider in the path first just because it's, it's right there. Uh You can turn that off, there is actually an environment variable. You can switch off using ambient environment variables. But while you're testing them, while you're messing around, there's like no problem in here, it's not an issue. Um And then lastly, you can see that we actually have a package dot Jason and that package dot Jason picks up the Pulumi verse conflict cat. So we set that environment or excuse me, we set that package name uh correctly and then just inside dot net, you can see it's Pulumi dot com cat. So that's correct as well. And then the last one is Python. Python is always the difficult packaging for me just because I don't know the Python ecosystem very well. But you can see it's Pulumi underscore confit cap. And in here we actually have our product up pie. OK? And you can see that it is the correct um set up and is all the internal classes. So we can like very easily go and add some of these other um mapping if you want me to do that because it's, it's quite simple and straightforward to do and there is no real sort of level of effort to do it. So I don't think we have to add more. But what I would ask, is there any difference between the resource mapping and the data source mapping? Are those exactly the same? Great question? Great question. So let's do products. OK. So there is a difference and the difference is is that we use a different convention. A data source is um an actual like create or a new resource inside Pulumi. Whereas a data source is actually what we class internally as like an info, it actually doesn't create anything. It is just a pure read or is a, you know, it is a a retrieval operation or a call operation, we call it. So here again, we can say con cat product, OK? We want to say it's talk OK? So it's token and that will be TF bridge dot make data source again, you'll see main package oh And you'll see main mode and then we change the convention here for the class names because it's we're trying to make it like very specific. So we start with get because it is a retrieval operation and in our case, it's get products so we can say get products. OK? Now I can just delete all the rest of that just so it doesn't really matter. Now, as part of this data source info, there are other things that we can actually set in here. OK. So we can set deprecation messages, we can control the documentation, we can like overwrite specific fields for specific names. This is what allows Pulumi to basically enrich um a terraform schema that is specific for the terraform ecosystem. Whereas we may have to override specific naming or change uh things to be. For example, let me see. I can actually say uh fields and I can say the field is a map of string to schema info and I can say organization ID. Uh And I can say secret truth. OK. So what that's actually going to do is like anywhere it's a pointer. So it'll be TF bridge dot true. Um And what that will actually do is anywhere where the secret uh or the organization ID is used. We Pulumi will treat that as a secret value regardless of what happens in the terraform schema. Uh because we have full control over our schema at that point in time. And we're able to do anything we want, we don't even need to do like that. We can set name. Uh we can set C# name because sometimes, you know, in C# members can't have the same names as the classes that they're actually in. So if you had a variable inside product called product dot net would panic or dot net would uh have a build failure and it would say that you can't actually do that. Uh We can say things like max items one. OK. So that's whether it's a list or not, we can say uh Mark as computed, only mark as optional. We have full fidelity of what we actually want to control within the um uh within the scheme and that we actually want. And then like, you know, as well as that we have the docs uh and you'll see, like my idea is given me all of the detail here, right? So um it's our docs is TF bridge dot Why are you not giving me the I just said that and it breaks, right? Like that's typical. Uh So dogs, there we go. It's a it's a map of string to uh TF bridge dot doc info. I take up like hover over docks again. Oh, it's just the dark info. It's just the dark info. It's not a pointer. I think I said resource info. That's definitely, yeah. And look, you can actually say look source mark done, attributes, import details include uh attributes and arguments. Like you can fully control the documentation. All it is is like the so like the mark done, you can embed full mark done in here. It's just a bit um which allows us again to be able to really control like the detail that we're actually pushing out into the users just to clarify. All of this is optional. This is pure enrichment at this stage if you just want to generate the provider and have it work then you're good with it all. But if you want to absolutely correct. Correct, correct, correct. So you can go as fine tuned and in depth detail as you really, really want to. And there's no problem. So let's generate what the um the data source is here. And now we need to make TFG again just because we need, it needs to be in the schema before it is done with anything else. And TFG will always generate the schema. Maybe it would be more useful for end users if we change that from make TFG to make schema because then it would actually be a much more specific call it to say make that schema first before anything else. Um So, and then lastly, we can let's just build no jazz OK? For now because it, it's not uh so slow to do that. And inside our no jazz SDK, you will actually see a new class very shortly that is called get uh products dot TS. I hope. Yeah, there we go has built it. Get products dot TS right here. And you can actually even see that it even has an example embedded so that you can understand how to get a product called conflict product. It's a simple invoke the invoke the invoke runs the, the, the same uh request as the binary um that goes with it. Uh And it has just all of the, the optional parameters and it has all the required parameters that's built in. That is how you build a Pulumi provider. Awesome. Any questions there, there was a lot of knowledge dropped there. So thank you very much for walking us through that. Uh I hope what this provides is just, you know, a way for people to come back and in less than 35 minutes, 40 minutes, like see how you've taken the conflict farm provider. Scaffolded out a brand new project. Yeah, there was a couple of small changes to make. And then it's just that mapping, like the, the main part here is that mapping of resources to whatever you want it to be available as in your SDK and then you're just running a couple of make targets and boom, you got a provider that that is it. Now to test this locally, we have a couple of um uh parts. So what we can do is we can actually uh make install no JSSDK. OK. And that effectively creates a yarn link. So that on my local machine, when I create a new Pulumi project, I can yarn link at Pulumi verse slash Confit cat and start writing a Pulumi program locally. And then lastly, I would Pulumi uh resource confit cap onto my, I use my go pa just because I clear my go path a lot and very, very often. And that allows me to have the binary available for local testing. All right. And if I can show you exactly how I can use that. Yeah, I mean, we could do a year in a preliminary preview and we would see that work, right? We could copy that example for the file that was just opened and it would, so let's, I don't have an API key but we'll get an error from COM API and that's OK. Like there's no problem. Then the preview will still show the create, right? The one that I read because there's no state. I think it will try and do the read. We'll see, right? So make their uh test demo. OK? So CD test demo and I'm going to run Pulumi new typescript which just creates a raw typescript uh template. It has no functionality in it in any way, shape or form. We'll call it te demo is no problem. Just give it a DEV stack, it'll install some dependencies and that we actually need it to do. Yeah. And then I can yarn link at Pulumi verse. So this is the equivalent of running an uh an M PM install. But I'm using a local built version of the yarn or the N PM package uh so that I can fake actually test this. So config cat and if I copy uh Ben uh Pulumi resource confit cat to my goal slash ben, then in my ID, I can actually go back inside test demo and I can say let me increase the size, import star as config cat from at Pulumi verse, it's there we go. Pulumi verse slash confit cat, right? So I'm starting to now be able to see it. So products equals config cat dot Look, I even get my ID. There should get products. Um We'll just, this is uh a excuse me. Um And then we can even step in to get products to see what it expects. Look, it expects a name filter rejects. Let's just copy this exact thing. OK? Because it doesn't really matter to us. We're not gonna get any data back. Um And then lastly, I can export cons uh product names equals products. So I want to unwrap the promise here because get products is a promise. Uh We want to unwrap that pro uh that um promise and then I can say then X dot Product uh and then it'll actually pull up the uh um actually, we can map um product name. I believe you'll be able to pull it out, but we'll just pull out the whole products. It's fine. It's not really too much of a problem, but I'm not. Now if I go and I run that, pull me up here, I, so I won't get a compilation error. And we actually see that it's going to create a Pulumi stack and it's going to make an API request. But you'll actually see there is no credentials that I have created. But I'm actually this is using the binary. Like this is actually calling into the binary right now because those, we understand the logic of what's a required field inside the Pulumi provider. And we can see that basic password, uh basic user name has not been configured. So you would have to like use those in order to do it. But we've been able to prove straight away that our binary works and we're actually able to understand the API call. I mean, if we commented out to get product stuff, we could create a new product which would actually get previewed for us, wouldn't it, it would not? Because again, the provider still requires a user name and a password, right? Ok, cool. I trust you. I trust myself. Look, you'll say con provider equals new con fake cat dot provider. Um, we'll call that test and if I go inside provider you'll actually see. There you go. That's what, that's, that's the error we're getting right here because under the hood, we assume that it's a default provider. We have an ex uh, given an explicit, but this is the, the check right here. That actually is basically saying you need to set these values. Awesome, sweet. So we've tested it end to end and it works as expected. Yeah, I definitely did. Cool. Well, let's pop back already. Yes. Well, that was awesome. Uh, I think we all have a really good idea. Now of how we can build our own providers. You explained that perfectly. Uh I'm really excited to be able to go to this myself now and grab some providers and start to fill up the plume with lots of new integration points for people. So I think it would be like, and we're always willing to jump on calls and help people uh as well. So if there's like a specific issue that is causing uh pain when you're scaffold in this, like, we, we can definitely like have a, a short call and, and, and work through it because we want to make this uh quite a smooth process. It's easy for me to do because I've done about 70 of these providers. Uh But I know that like, actually not even kidding, there's li uh maybe 60. Uh but you know, it, it, it's really a case of I've been through this quite a lot. I know the quirks. Um I know the areas in which to change, but we need to like make sure this is a smooth process. Um We're always willing to take documentation changes and uh you know, uh enhancements from the community to make this even better. All right. Well, thank you very much for your time today. Uh We'll leave it there and we'll be back for more contribute, contributory experience that very very soon. So now you have to make a very awkward face as we wait for the stream to finish. But uh thank you again, Paul. I'll speak to you soon. Bye. All.

---
