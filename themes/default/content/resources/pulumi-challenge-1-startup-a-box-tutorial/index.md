---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Pulumi Challenge 1: Startup in a Box Tutorial"
title: "Pulumi Challenge 1: Startup in a Box Tutorial"
meta_desc: |
    We're excited to announce our first-ever Pulumi Challenge! Pulumi Challenges are a great way to get hands-on experience with the Pulumi platform. C...
url_slug: pulumi-challenge-1-startup-a-box-tutorial
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Pulumi Challenge 1: Startup in a Box Tutorial"
  description: |
    We're excited to announce our first-ever Pulumi Challenge! Pulumi Challenges are a great way to get hands-on experience with the Pulumi platform. Completion of each challenge wins you a piece of Pulumi Challenge swag. Take the challenge: https://pulumip.us/Startup-Box-Challenge  This challenge is Startup in a Box, where you will build and deploy your very own website for your startup on Amazon S3, AWS, using Pulumi. The code is in TypeScript.
  sortable_date: 2022-09-01T15:00:13Z
  youtube_url: https://www.youtube.com/embed/NU7uOy273jQ
transcript: |
    Hello, my name is David and I'm a developer advocate at Pulumi. Today. I want to introduce you to the Pulumi challenge. Not only introduce you but gaze you through, start to finish so that you can see how you can also complete the Pulumi challenge and win an exclusive piece of swag. So what is the polemic challenge? The Pulumi challenge is a set of exercises that will introduce you to Pulumi trying to solve a relatively real world scenario that is deploying a static website to Amazon's S3 fronting it with closed front CD N added an html and web checks with checklist and all at the same time showing you some cool unique features of Pulumi such as dynamic providers and component resources. So enough for the chat, let's dive right in. Ok. So how do you get to the Pulumi challenge first, go to Pulumi dot com slash challenge from there. You'll see our current challenge and some upcoming challenges select start up in a box and you'll be presented with this screen here. All of these challenges are step by step instructions that allow you to construct a build limited program that solves a real world problem. The first thing we have to do is check off the prerequisites plume account, check aws account, check, check my account check list. Come on. So step one, we want to create a first Halloumi program. We're going to run Pulumi New and then we provide a template name. The template name for today is AWS dash typescript. We can leave the project name which is generated based on the directory, accept the default description and I'll set my stack name to production because you only loved ones. Next, I'll set E US two as I am in Scotland and we will let M PM install the dependencies. Next, we want to create our first resource here. We have the code to create an Amazon S3 bucket and an AC L to ensure that the contents of our bucket are available for public read. This means the S3 bucket can be used as a static website. When we generated our preliminary program. It creates some basic resources also a S3 bucket. So to help you get started, we're going to remove that and paste down the code from the challenge. Next, we'll want to just rename this bucket to be something that is universally unique and makes sense for you. For me, I'll do plume Fallon David one that should be OK. Next, we're gonna add some code to populate our S bucket with files. But because Pulumi uses the standard no GS API S, we can use those API S ourselves to read files from the disk so we can copy this code here and drop it in here. And all this is saying is that we need to import the fail system API S. We set a constant for the directory and then we're going to do an FS reader sync. This just means synchronously get me a list of all the files within a director. We can then create a new bucket object based on that file. Remove the extra copy. And we should be good now because we're using VS code which has access to language server protocol, which has really great support for no gs javascript typescript, et cetera. We can see that we have an error message and a code that's just telling us that it can't find me to fix that. We can do an M PM installed name. And because I'm using typescript, I can add tapes ma we hit return and those packages are installed and then we come back here and consume them just like regular javascript. Could we have save error message goes. Bye bye. Next, we have to copy and paste some static resources for our website. So first we have our index dot html. Remember that we need a directory call website which needs to fail code and to html. Next, we need to add Stale dot CS. S lastly, we copy it normalized CS S from github. We click the raw button all and drop in. Now, it's a little bit time. We try to pull them up and make sure there are no unexpected. Des first, we could run a preview and this looks very good. It's telling us that it wants to create a new bucket with an AC L and upload three bucket objects, the three files that we just copied into the website. Right? Trip. Next, we can run the li me up skep preview and that's it. All right, let's carry on. Next. We want to expose our SG bucket through a cloud front CD N. This is great because ears costs of SG buckets can add up to be rather expensive fronting your SD bucket with cloudfront means that you get to distribute all of those assets to edge locations all around the world where the assets are cashed and delivered with great performance as close to your customers as possible. So let's add close front in front of our S3 bucket. No, we can copy this, jump back to our code and just pasted it. We'll see here that we configure the origins using our bucket's original domain name. Everything else here is pretty much boiler plate and we don't need to worry about it. Now, creating a cloudfront distribution does take a little bit of time. So let's start that now and carry on. Now, we can test that. This works by popping down here as the export con URL equals credit for distribution domain name their domain name on the cloudfront distribution is an output property that is available after the resource becomes under management. And if we save this file and run again, we'll see that there are no changes to make. Other than exposing the, you can also run the limit stack output to reference these values at any time. There's also a neat Jason flag. If you want to be able to consider this programmatically next, you can curl the cloud front L and we'll see the html from our static website. Nice, right? But because we use them Pulumi for our infrastructure, things can be a bit nicer. Step five introduces us to component resources. Let's copy and paste all of this and then we'll run through it quickly. So what's happening here? Well, first we're creating a new class called CD N website. This extends the Pulumi component resource class. This provides all of the boil plate that Pulumi needs to understand that a component resource is a logical grouping of other resources. We can set some properties on this class here. They're just all private and used only within the class itself. And then we need a constructor. When we call the super instructor, we can provide a resource name here. Pulumi challenge CD M website. And then we just propagate all the other properties right through to that super constructor. The next thing we do is just create the exact same resources. First, we create the bucket, then there is the L then the cloud front distribution. This is all the exact same code except for one small change. This last parameter to all preliminary resources allows us to provide resource options. One of the resource options we can provide is a parent resource for each of these resources. We're providing a parent of this. This being the component resource itself. This allows us to structure and visualize the hierarchy of our resources when we run PIC commands. So how do we consume this? Well, first we go back to index dot TS and we delete everything. We jump back to the start up in the box challenge website and click copy here. You have to make sure that the name of the file that you you pasted your code into matches this file has an export called CD M website, which is a class that can be constructed. We can provide a name for this resource. Let me challenge one. I had the and that's it. And in fact, if we come back, right, pull me up, we'll see that it's going to delete all of our old resources and create new resources. But more importantly, let's notice the hierarchy. These resources that are being deleted are all a flat hierarchy, meaning they're all one after the other with no tree structure, no hierarchy. However, take a look at their new resources. We have something called the Pulumi Challenge studio website which creates a bucket, this bucket has three objects. The bucket also has an AC L and a cloud front distribution. The Pulumi preview gives you this hierarchy, giving you more context and understanding of the resources and how they interact together. So let's say yes and let it do its thing. All right, hold deleted, new spun up. However, we've lost our URL. Fortunately, the component resource that we defined provide a GEM method as far as that output variable. So we can add back our export S URL equals website. And our get method URL. A quick run with skip preview will get us that URL and no time. No, we can copy it Pearl and we're back in business. Awesome. Next, we're gonna add a new provider from the plume registry. This is the check la provider check la provided a great service. It allows you to run AC TP based checks or API based checks against your software by simply doing an M PM install and then setting our secret. I'm pissed. Now we need to set our checking account idea. This is not a secret, but we can type it in play tag. Maybe we can add some code to configure or check the check. So now we can just paste down the code from the website. Uh Here we expect something called website URL. However, we only have it available as URL. So I'll update that, delete this extra copy and head save and that just works. So what this is doing is saying that we want to create some check called index page which runs every 10 minutes. It's a browser based check and we want to run it in the AWS region E US two. Now the script itself, we could use a string which has javascript code instead of it. However, then we lose access to BS code language server protocol and syntax highlighting. So our preferred approach of Pulumi is to fs read, think the check. So we can actually create the file, check, click and be dot GS. So now we just have to copy the code from the challenge website. We can scroll down to here. We have syntax high, which is great. Now we're not gonna have autocomplete because we don't have playwright or expect as part of our dependencies. However, you could open your package based on add them as dev dependencies and those would be available here. We're using a handlebar style mustache syntax so that we can interpolate that value from the Pulumi code. Because our website, our website URL is computed if we jump back to index dot TS. You see here, we just do a replace with the URL now because this is a computed output value. We don't actually have access to the roster, which is why we're using Pulumi apply, this gets built into the dag and execution life cycle of the Plum program so that when the string is available, we can read this file So let's test that this works. We can run, pull the me up and we'll keep the preview. The preview shows us that we have one check to create. We can ha yes and let it go. Awesome. The last section of the Pulumi challenge is to implement a dynamic per provider. This is for when you want to work with an API that there is no existing provider within the preliminary registry, but you don't want that to slow you down. Used in Pulumi typescript or Python. You can rate dynamic providers in just a few lines of code. Let's take a look. First thing I'm gonna do is copy all of this and drop it into a file. We'll call this swag dot Yes and have pissed. So what we have here is an air table web hook URL which we're using to collect all of your entries in the plume challenge because we're using typescript, we can define our interfaces for all of the inputs and outputs or D cos that we need across all of our different classes. Before lastly implementing a swag provider which implements a dynamic resource provider. Economic resource provider is in a class that implements create. In fact, if you click on the resource provider, you'll see that we have some optional methods, check de read update and delete create is the only one that is mandatory. It can take any input and returns to create result promise. So you can implement your own dynamic providers with a single function. We've got some red squiggles because we need an HC two P library which comes in common GS format for that, we're gonna use a specific version of gut. So in order to add that version of Got, I'm gonna open or package that on and I got 11.8 0.0 this was the last version of Got that comes in common jazz format. We can now run M PM install and if we jump back to a could just quick go away. So on our create provider, we require a go and we launch a post request to our air table submission URL with some headers and some JSON properties that are passed. Then as resource properties, we know that the swag create response that comes in JSON format and God handles that all far as for generic types. Next, we just return to create response. Next, we need a little bit of glue. It tells us how we can construct a new swag provider and resource. If we jump back to the preliminary court that Plimer challenge, you'll see the invocation code here. Let's go back to index OTs and underneath for check, paste this particular import to match the file name that you used and fell on the farm. I'm David, pull them and David at Pulumi dot com. I'm not going to fill in my address, but now we can specify the size. I'll pretend I'm alert, we save this and now we're gonna run her prelim preview. We can see here that we have a dynamic resource called David. Pull away. Let's run up with a skip and give it just a moment. We have not completed the prelim challenge. We've taken a look at deploying a static website to S3 fronted by close front with real time H to P browser based checks from check. We structured that with a component resource given us in a visual contextual hierarchy of resources from the Pulumi cl A was then integrated with a random API on internet. In this case, air table, be able to pass your information so that we can send you a kill better swag. We do this with a dynamic provider and only a few lines of code. We think this is pretty cool. We hope you've enjoyed the Plum challenge and we'll see you for the next one. Have a great day. Here's a bonus tip if you write an article, publish a Twitter thread or make a video on completing our Pulumi challenge. Email us at D A at Pulumi dot com because we've got some special swag just for you. Have fun.

---
