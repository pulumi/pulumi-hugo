---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Serverless GitHub Webhooks with AWS API Gateway | MIW 2021-03-03"
title: "Serverless GitHub Webhooks with AWS API Gateway | MIW..."
meta_desc: |
    In this episode, we build a GitHub Webhook backed by a serverless function
url_slug: serverless-github-webhooks-aws-api-gateway-miw-20210303
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Serverless GitHub Webhooks with AWS API Gateway | MIW 2021-03-03"
  description: |
    In this episode, we build a GitHub Webhook backed by a serverless function that's hosted via AWS API Gateway. We talk about how ComponentResources are a very useful abstraction to build resuable components.  Code for today's episode is available at https://github.com/pulumi/pulumitv/tree/master/modern-infrastructure-wednesday/2021-03-03  Today's example is in TypeScript, but Pulumi makes it easy to stand up infrastructure in your favorite languages including Python, C#, and Go - saving time over legacy tools like CloudFormation and Hashicorp Terraform.  https://www.pulumi.com/docs/get-started/?utm_campaign=PulumiTV&utm_source=youtube.com&utm_medium=video
  sortable_date: 2021-03-03T04:39:15Z
  youtube_url: https://www.youtube.com/embed/wipwix3SU6s
transcript: |
    Hello and welcome to another episode of Moderate Infrastructure Wednesday. I'm your host, Lie Zen. Today we're gonna be talking about building a github Web hook, uh serverless github Webhook actually, and I already have the code kind of written up. I just wanted to walk through it because uh didn't really feel like live coding it today. Um I already had some of this lying around and kind of piece it together and maybe we'll do some live coding because it may not work because I, I really just pieced this back together from some stuff I had lying around, but I thought it was kind of a fun example to show. Um So let's, let's get, let's get to it. Um Let's start with the, the main code here. I think this is the most interesting and, and yet at the same time, kind of the least interesting parts. And what I mean by that is um this is actually where all the functionality happens. Uh but it's actually not where all the cool bits are. Um And so you can see here we, we instantiate this new github web hook component and what we're gonna be doing is we're gonna be creating a github web hook that uh actually invokes um a servers function that does whatever we want on our behalf. And so you can see here we kind of pass in some parameters. We say, hey, you know, the repository should be pulling me TV. Uh You, we should look for these events. In this case, it's events related to issues and then we're gonna um also uh give it our gi our token, uh which we, we need obviously in order to use the github API. Uh And then we have a handler. This is just an in line function that we get to write. This is actually gonna be part of our lambda that gets executed. This is part of our service function that's gonna get executed uh on our behalf. And this is a fairly simple uh uh function. You can see we create a new uh instantiation of the Octa kit. This is the rest API SDK uh for github. And then we just check to see if it's a closed action. If it's not, we ignore it. Uh If it is, uh then we'll, we'll, you know, we'll check the labels. And uh here, let me just add in some additional logging. And so if we, if we find this fixed uh label, then we won't do anything. Uh But if we don't find the fixed label, then we're gonna reopen the issue. So, you know, you can totally imagine using some kind of work flow like this in your own repository where, you know, you wanna make sure that the uh that any issue that's closed is actually fixed. And so or has some kind of a fixed label to it, right? Or a fixed, not the fixed, so any any label. Um but here I've chosen fixed and uh yeah, we just, we just make the relevant uh uh SDK call. So this is all very simple. But like I said, this is actually where all the, this is, this is the actual meat of the program in some sense. But none, none of the interesting bits are here. And the reason for that is because everything's abstracted away by this github web hook thing. And what is this github web poke thing? Um That's actually where it gets really interesting. And, you know, I, I think, and on modern infrastructure Wednesday, we haven't talked as much actually about component resources in Pulumi. Uh And that's what the github web pok is. Um It's a component resource. This actually isn't a resource. You can see that's part of, you know, it's not part of uh the, the, the get up provider, it's not part of the provider, it's a component resource that we wrote ourselves that I wrote here in this case. And so what component resources allow you to do? And now I'm in the definition of this component resource is it allows you to really uh build usable components that you can vend to other people. And so, you know, in this case, like this github Webhook is a reusable component. Like I could use it for lots of other webhooks, right? I could also instantiate, you know, three other web posts here that do different things. They could look at different events, they could have different handler code, they could do totally different things, but it's using the same underlying abstraction. That's one of the cool powers of Pulumi, you know, because we're using languages, uh We get to use all the language uh constructs including uh you know, classes and in this case abstraction through this component resource. And so what does our component resource actually do? And you can see we, we kind of have this thing here to kind of register this component resource with a specific type. Um And then we create a bunch of other underlying resources that kind of this component resource abstracts away. Uh So first, it creates this random string which is effectively a shared secret. Uh If you've ever used github webhooks before, uh you, you'll know that uh you can have a shared secret that this way um any calls coming to your end point uh have to have the secret to in order to prove that it's actually coming from github. And then we use uh API gateways uh API to then have a service function sitting behind it. And actually here the access is the crosswalk library that I've shown a few times uh on modern infrastructure. This this API component itself is actually a component resource. I mean, so you can compose component resources within component resources. Um And so this api actually abstracts away a lot of the uh complexity of actually standing up an API gateway end point here, you know, we we're actually able to just provide a very simple route uh with a path a method. And then here another event handler and this event handler wraps actually, you can see later on uh the handler that we end up passing in. Um And so this, you know, takes care of that initial logic around uh decoding that secret and making sure that it actually is uh proving that it actually is coming from github. And then later we can parse the rest of the event. Uh And then we can actually um then pass this to the handler that's passed into this particular component resource. So this handler is whatever is passed in, in our case, we passed in this code. Um And so now we will, you know, pass back the token along with the request, the event information as well. And then, uh you know, whatever happened, the event handler can do whatever he wants to do. Um And then, you know, we'll, we'll finally return success. And so that's actually where all the meat of this happens. Um And then uh we then kind of. So we have, we have this API endpoint, we've created, we have the shared secret. And then finally, at the very end, we create the repository web hook. And so the repository web hook is going to, you know, uh listen to those events on this repository. And then for the configuration, it'll have that secret and it'll register the URL for our API gateway end point. So let's actually run this and see if it works. Um So let me run, blew me up and I'll see what happens because I actually haven't heard this yet. Um All right. So one thing to note, actually, in terms of configuration here is uh I have already configured my stack to uh use us plus two using the Pulumi organization and obviously have my token as a secret. Um OK. So let's look at the preview. So we have this, this is the component resource we defined and you can see kind of underlying this component resources that API we talked about which will have the actual function. Um The this this function is actually gonna be attached to this API and then we also have uh uh the secret and then also the repository web book. So that sounds good. Let's create all that. And while this is running, I guess we can pop open our browser and uh get, get going here to see if uh this actually works. So they bring up a browser window. Um OK. Great. So it worked. Uh And you can see here uh we had the stack output. Um Actually don't remember where I put that, but I think we must export it somewhere. Uh And so you can see we have this URL um which is great. And so yeah, so let's, let's try uh our webhook. So actually, there's a, there's actually a weird bug in github that I already know about that. I'm gonna circumvent real quick. So let's look at our web books. So you can see it's registered for issues. Oops, let me log in here with my key. Um So you can see this is the the payload URL, this is what we defined earlier. And uh so this is all being you know, driven uh by Pulumi and uh the, the bug I know about by the way is that here for whatever reason, even though you can see here, it has application Jason. And uh here I've actually also defined um that they should use application json as the configuration content type. Uh And it is here. Uh for whatever reason, the very first request uh github sends is using this odd uh the other content encoding which is the URL form encoded. So um just hit update web book just in case. Um And I believe subsequent invocations should do the right thing. So let's let's create an issue still typing 2020. Um OK. Cool. Cool. So we create this issue now let's actually go back to, uh, let me just open a new tab. Let's look at our webhooks and Well, oh, great. It, it success. And you can see that, that it is delivered this, this opened issue and you can see we, this is the issue we just opened. So let's look at actually what that looks like on the API gateway side. So if I go back here, oops, and actually let me authenticate first to a few things before I show this to you. I'm gonna pause. My recording will authenticate a couple of things. I'll be right back. Ok. I just want to make sure I was actually connected to the right Aws account. Um And that I was uh correct here. Ok. So, so, yeah. Ok, so great. So we looked at, um let's look at the activity. So this is, this is our update and uh it created, this is, you know, everything here. Uh And if you go to the resources, we have the actual functions, let's pop that open uh in the Aws Council and here, uh we can actually see the invocations that that took place. So if we go to uh monitoring and we look at the logs and cloudwatch, we should see our own uh log in that we had in our function. So let's verify that that's true and verify that it's working correctly. Oh, boy, my connection is really odd today. Um ok, cool. So let's look at this. So this is the first issue that, uh, seems like it had some weird. Er, but you can see here that was the first one where they had the wrong payload type. Uh, here you can see ignoring, ignoring non close events. So we opened an issue. It's not a, it's not a, it's not a close event so we don't care about it. Ok, let's go back to this issue. We'll close the issue and if we, oh, and then it, I, you'll notice I didn't touch anything and it reopened. So if we go back to here and we refresh this log, we can see it says, you know, checking labels because, uh, if we look at our code um in our handler, uh you know, if it's, if it's, if it actually is closed, it's gonna keep going. It's gonna check the labels. And after checking the labels, it's gonna realize there's no fixed label, it's gonna reopen the issue and that's exactly what happened. And so now if we actually affix the fixed label, oops there's no fixed label in this week. But let's, let's use resolution fixed and let's update our, um, let's actually up, let's get rid of that need to be, let's do this and then let's actually update our code to also look for uh resolution fixed and I can run Pulumi up and just like other Pulumi programs. This is again, it's a desired state model. So we really shouldn't have to update, you know, we don't have to update the web hook, we don't have to update too many other things here. We really just need to update the actual function code. Um And so, uh, let's, let's run this and this should only update the, the function code. Just give it a sec. Something. That's very odd with my internet connection today. There we go. So you can see the only diff we had was the code. So yes, let's update the code. And, uh, as soon as the code is updated, we can then, uh, close the issue and make sure this all all works. Ok. So that's great. So now that the code's been updated and we'll come here, we have resolution fixed. Ok. This is, yep, resolution fixed so close. Think this can be closed now. Cool. So let's go back to, uh, so let's wait a sec. All right. Didn't, didn't reopen it. That's a good sign. Let's go back to our, uh, our logging here and, um, let's refresh this so we can, oh, there we go. There's our new log stream and you can see checking labels but didn't have to do anything because, uh, I guess I could have added more logging to, you know, say, hey, if we did have this, you know, log something else, but you can see we didn't log the reopening part because, well, in fact, we had the right label. So, yeah, I just wanted to kind of walk through today, this idea of having a component resource and how useful it is to actually build uh these abstractions with component resources. Uh You know, you can see this, this actually abstracts away an api uh it abstracts away this API gateway that's uh fronting this Lambda. And then it's tying that together with this github repository web hook. And then that way this this particular component, you can, you can totally imagine I can N PM publish this particular package and anyone could use it. Um So yeah, hopefully you enjoy today's episode and we'll see you next time on modern Infrastructure Wednesday.

---
