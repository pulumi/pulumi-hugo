---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Pulumi Help: Resource Inputs and Outputs (Node.js)"
title: "Pulumi Help: Resource Inputs and Outputs (Node.js)"
meta_desc: |
    Learn how resource inputs and outputs work in Pulumi's Node.js programming model (JavaScript and TypeScript).
url_slug: pulumi-help-resource-inputs-outputs-nodejs
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Pulumi Help: Resource Inputs and Outputs (Node.js)"
  description: |
    Learn how resource inputs and outputs work in Pulumi's Node.js programming model (JavaScript and TypeScript).
  sortable_date: 2020-05-11T16:27:42Z
  youtube_url: https://www.youtube.com/embed/lybOxul2otM
transcript: |
    In this short video, we'll learn all about resource inputs and outputs. We'll learn what they are, why we have them and how we use them. When creating a resource, you pass arguments to its constructor. These are called inputs. They can be one of three things concrete values like strings, numbers, bullins, arrays or other structures, asynchronous values such as promises or outputs from other resources. After creating a resource, we can access any of its properties. These are called its outputs. Outputs are resolved to values once they're known. But because of previews, they might not always be known at run time. As we'll see, this can cause some challenges when we're dealing with them to illustrate these concepts. Let's look at a very basic resource here. We have a load balancer as input. It takes a target and a port and its outputs include an address and also a port. Notice that the address can't be known in advance, it will only be known once the load balancer is created. Whereas the port can be indeed the output port will match the input port for this particular resource, meaning that it may be available during previews. Now let's see this in action. Before diving into some code first, we create a virtual machine that has an IP address as its output. Next, we'll create a load balancer just like the one we saw which has a target and port as its inputs. We'll pass the virtual machines IP address as the target because we want the load balancer to point at it. And then we'll simply pass the number 80 as the input port. The outputs of the resulting load balancer will then be available the generated host name and the port which itself will also be 80 note that this captures a dependency. So the load balancer knows that it's now dependent on the virtual machine because the target points at the virtual machine's IP address something to be aware of is that when you're running Pulumi up, you may encounter outputs. For example, in this case, we're creating the virtual machine and load balancer that we were just discussing. And if we click details, we'll see that the target is listed as an output of string. That's because during the preview, its value isn't known. Notably in this particular case, the port is known as a because it was a concrete value, but it's possible that the port could come from another resources output or something that was computed. In which case it might show as output of number. Now let's dive into some code here. We've created a virtual machine resource keeping with our running example, it's important to remember, you can't access the values of outputs directly, they might not be known. So for example, trying to print the value to the console won't work. In fact, you'll get an error. Instead, the most common way of interacting with an output is to simply pass it to another resource as that resource is inputs. In this case, we've allocated the virtual machine and we're passing the IP address as its target as the diagram earlier depicted. Another thing we can easily do with outputs is simply export them when we export an output. Pulumi captures that value and makes it easily available on the stack. This includes at the command line in the Pulumi console. And even if you want one stack to depend on another, those are some easy cases. Now let's look at some harder ones. Imagine we want to interact with the concrete value of an output. For example, here we want to parse out the subdomain of the computed load balancers hosting. Normally it would just be a string and we could call functions like subs string and index of on it directly. But in this case, we can't, it's an output. That's where the apply function comes in. Apply, takes a callback that is given access to the concrete value. Pulumi will invoke the callback at the right time when it knows the concrete value because that value may never be known at preview time. Apply returns another output and that output can be treated just like any other. For example, we can export it apply can be used any time we need to gain access to the concrete value of an output. That includes for example, printing its value to the console, be careful when doing side effects like printing to the console. However, because the value of an output might not be known. For example, during a preview, your apply might never execute. This is particularly dangerous when doing things like allocating resources inside of an apply because the resource may not show up during a preview. Those are the basics before wrapping up. Let's look at some convenient helper methods. Pulumi offers for dealing with outputs always remember if one of these cases don't work for you apply is the most general purpose thing you can use that will always work in most cases apply is used simply to access basic properties of the underlying value. If all you want to do is call a method on the string or number or whatever the underlying value is. Pulumi offers a convenient way of accessing the members directly even though it's an output. For example, in this case, we're simply calling the function to upper case a string without having to use. Apply. In certain cases, we may want to use the concrete values multiple outputs. For example, here we're concatenating the load balancer host name and port to create a complete URL. Although we can accomplish this by nesting multiple applies. The plumy all function makes this easier. The all function takes multiple outputs and returns a single output which can be used in the usual ways. For example, calling apply. It turns out string concatenation is so commonplace that Pulumi offers a helper for this too. The interpolate function allows you to reference outputs without having to call apply or all on any of them. Finally, if you ever find yourself in a situation where you need to create an output from a raw value. Pulumi offers functions to do that too. This video has shown all of the ins and outs of resource inputs and outputs. What are they? Why do we have them and how do we use them?

---
