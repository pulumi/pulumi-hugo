---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Introducing the Pulumi Spinnaker Plugin"
title: "Introducing the Pulumi Spinnaker Plugin"
meta_desc: |
    Pulumi now works with Spinnaker to help you continuously deliver both infrastructure and application updates using your favorite programming langua...
url_slug: introducing-pulumi-spinnaker-plugin
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Introducing the Pulumi Spinnaker Plugin"
  description: |
    Pulumi now works with Spinnaker to help you continuously deliver both infrastructure and application updates using your favorite programming languages on any cloud.  The examples are in TypeScript but Pulumi supports many languages including JavaScript, Python, Golang, and .NET.  GET STARTED: https://www.pulumi.com/blog/unlocking-spinnaker-with-pulumi/
  sortable_date: 2020-06-25T13:30:01Z
  youtube_url: https://www.youtube.com/embed/V3FxNh6KQkE
transcript: |
    Puneet and I are here to talk about some interesting uh new developments integrating Pulumi with the Spinnaker ecosystem. My name is Dan Hernandez. I'm a customer engineer with Pulumi. Uh I've spent most of my career working with organizations on their infrastructures code and cloud modernization projects. Um With that experience, I've seen a lot of common patterns and pain points and that's what really brought me to Pulumi. And it also happens that many of our users are really curious about um what the story has been between Pulumi and Spinnaker. And uh that's why I'm excited uh to show um what we're showing today pretty neat and, and I'm Puneet Loki. I'm a software engineer at Pulumi and I work on our service and cli tools. I, I am absolutely excited to be showing off our Pulumi plug-in for Spinnaker today. So I can't really wait for, for us to get to the demo slide. And today we're gonna um talk about Pulumi for a couple of minutes uh for those of you who are unfamiliar and we'll talk about um how we got where we are today and why and we'll spend most of the time walking through a demo. So a little about Pulumi um Pulumi is really the next evolution of infrastructure as code. And I like to say that it puts the code back in infrastructure as code, meaning you can define your infrastructure decoratively using the real programming languages. So no, Yaml JSON or proprietary DS L that you need to uh learn or, or stub your toe on. Um You can use any language that you prefer. Uh As long as it's a javascript type script, uh Python dot net or go and Pulumi is a full engine. Uh It's a cli tool, it's a SASS product. Um And it really makes it easy for organizations to adopt modern cloud technology and infrastructure is code best practices and I won't dive into each one of these. Um And that said, um you know, I, I really want to get into um what we're here to talk about today and, you know, we've seen uh a lot of interest in the story between Pulumi and Spinnaker from our users and, and from our customers. And um so we joined the Spinnaker gardening days back in April as a way to kick off our involvement in the Spinnaker ecosystem and to talk more in depth about how we see Pulumi and Spinnaker working in concert. There are multiple ways uh that can kind of piggyback or turtle uh on one another. Um First, you can bring up a spinnaker cluster using Pulumi. Uh that is a Pernetti cluster and in the right side of containers and, you know, all uh defined and deployed using Pulumi. Uh we haven't done this yet. Um But we've been playing around with it and it would be really awesome to see some uh open source examples around this from the community. You can also um actually manage the resources inside of the vinegar cluster uh like a pipeline uh using Pulumi, you know, Pulumi has a concept of providers just um that just require an api uh a while back. Um We took a stab at this for an internal hackathon, so it's not officially supported but uh you know, completely possible. And uh another great open source project opportunity to consider. And finally, uh and more specifically uh where we started in the hackathon is deploying cloud resources in a spinnaker pipeline using so think base infrastructure like cnet's clusters to uh cnet's apps to s3 buckets. And you know, really any other cloud resources uh that are needed to build a modern cloud application. Um in the hackathon, we, you know, we made some really good progress but, you know, it was certainly hackathon and the result wasn't quite ready to be consumed more broadly. So since then, we've um put in some additional work to really bring that solution uh into preview, um uh absolutely ready to use um open sourced and we're really excited about getting folks using it, uh giving us feedback and collaborating on improvements and um with that said, uh I'll hand it over to Pune to show us what he's been working on. All right. Uh Thanks Dan. Um So, as I said, as I mentioned before, um I've been working on the um plug in with uh Dan and um the folks at Armory. Um And it's been really amazing to, to um to basically understand um the whole concept of uh the Spinnaker ecosystem and, and the Spinnaker um service itself. Um And so, um I wanted to uh first start with a uh with an overview of the plug-in that we've built um as well as show the Pulumi app that we will deploy using a um an example pipeline in Spinnaker. And we'll also look at making changes to the uh Pulumi app and deploying that using the same um pipeline. Um So throughout this, um basically, I will be shifting between um my vs code and my uh local Spinnaker instance uh which has been enabled by um um Armory Minier. So, um without further ado um let's go look at are pipeline. Um So, um when we worked on the plug-in, we wanted to keep in mind that um users should be able to uh work with any V CS uh where their source code is um located. Um And this could be a public or a private repository. Um And given that Pulumi allows you to write uh Pulumi apps um or or author your infrastructure in um any of the supported programming languages. You also need a way to um you know, restore any dependencies that you're um pulling. The app can be depending on. And also because we roll out cli releases, you should also be able to um pick a specific version of Pulumi that you would like to run your um run the Pulumi cli against. And um and also uh because the cli supports a lot of commands, um We also wanted to allow you to specify the command that you would like to run and pass the arguments um that you want uh for the command. Um And Pulumi also has this concept called um a back end um which, which is basically like you um pull me whenever you run Pulumi preview or pulling me up. Um Pulumi uh tracks the infrastructure state uh with a specific service back end. Um And so this back end out of the box is the managed service backend identified by api dot Pulumi dot com. And of course, you can change this to be a self hosted back end or it could be even a WX S3 or uh or G CS or any of the supported back ends. Um And you can look at the documentation for using a um using a backend on plumy dot com slash docs. Um And lastly, we also wanted to um give a way to um specify secrets that you would run with the Pulumi app. So for example, if you're running a Pulumi app that deploys resources to AWS or GCP or uh or any of the other supported providers, you need to be able to pass those secrets to uh to, to the execution environment in which the Pulumi cli is running. So for this, basically, you will define a coti secret resource and then the secret resource will contain, uh can contain any of those environment variables that Pulumi expects for each of those providers. So um so basically that's, that's uh that's those are all the inputs that uh the plug in itself provides. Um And for the example, pipeline, um I thought it would be really good to demonstrate um deploying a kubernetes resource into the same cluster that the spinnaker instance itself is running um as well as um trying to deploy some AWS S3 resources. And so um ah our sample app for uh S3 will will basically deploy a static website which involves creating an S3 bucket and then configuring bucket policies on that and then also uploading um some bucket objects which which will then be marked with that bucket policy. And for the engine X um resource, which is going to be a kubernetes deployment resource, the um engine X uh container will be deployed with default configuration. Um And, and so we're not gonna be exposing the container um outside of the spin cluster itself, but because we're deploying it within the cluster and, and this is a local installation, we can ping that default installation and see um see the response from engine X itself. Um So let's look at the uh to the Pulumi App itself. Um As you can see um the we're making use of the Kubernetes package to define the various resources. Um I have a config map with some key value pairs that um that my deployment cares about And you can see it's pretty easy and uh idiomatic to um typescript in this case, um you know how you would create new resources and um basically reference those resources as as simple as just uh local variables um throughout your infrastructure resource. Um And so my config config map resource is used by my deployment resource which uh which tells Pulumi that the deployment resource cannot finish, um cannot be created until the config map resource itself is, is, is created and ready to be used. Um And, and, and of course, we map the name of the config map resource as the rep for uh pulling all the uh key value pairs out of config map and mapping them as environment variables for, for engine X container. Um And so uh when we, when we run this, um when we run this pipeline, um we can see that um Pulumi basically um creates the config map and then starts to create the engine X deployment resource. You can see that um Pulumi orchestrates the creation of this engine X uh or, or this deployment resource and then waits for the pod to be ready before it marks the deployment as complete. And so once the pot is ready and initialized, um it, it bas Pulumi basically ends the uh deployment execution and um and then gives you the results um which you can then view on the Pulumi console using this Perma link for this update. Um And if we look at the S3 update itself pretty simple. Um You know, we, we create the bucket policy um the bucket um upload a couple couple of buck bucket objects um with the same bucket policy that we defined. Uh which if we look at that, um it's basically um a regular um bucket policy that allows public access on any objects uploaded to that specific bucket. Um And we want to do this because um this is specifically for a static website, which it's OK to have anonymous access and specifically public access because normally you don't want to have um private act or public access on, on sensitive buckets. Um So let's take a look at creating or or making an update to this. Uh Now, now creating these resources is great. Um And creating this in my spinnaker instance or Spinnaker cluster is, is, is great. Um But the thing about these two resources is I've not specified the name space here, which means these two resources are created in the default name space and that's not really great because uh typically uh teams want to have their um their resources name space accordingly. Um And so, in this case, I want to have these two resources in an app name space because this is something that um the all of my app resources, I, I want to put all of them into a specific name space. Um And so, um I've already saved the code for doing this, but um let's take a really quick walk through this. Um um So the changes that you'll, you'll notice is that um there's a new resource now which is basically uh create a new name space and then using that name space with throughout um the rest of the app itself. So basically, that's our config map and our deployment resource. We're gonna use the name space itself, um which involves spec specifying the name space property um inside the metadata for the config map and deployment resources. So, um so this is really great. Um Let's go ahead and commit this and push this up. Um Normally you would go through the ops workflow and uh make sure that your code changes are reviewed and you have APR workflow, which you can even use Spinnaker to, to get a web hook trigger for your pull request such that you can run a pipeline that runs a preview for the changes that you're proposing. Uh But because we're, we're doing a demo here. I'm gonna skip past some of those things and I'll show you um the pipeline view of what happens when we apply these changes um as well as also look at the preview itself um to see what that looks like. Um So, oops, let's go ahead and save that resource and push it up to master. Great. Um So, um I've already gone ahead and made uh and um run an execution of that pipeline which um which has those changes with the name space um edition. Uh So let's take a quick look at the preview itself. Uh So as you can see the preview basically says that there is now a um difference in the metadata from what was previously deployed. And so Pulumi detects that it needs to replace the config map and the deployment resources. Um And before that, it needs to first create the namespace resource. And so Pulumi automatically orchestrates the creation and replacement of these resources. And so first proposes creating the uh the name space resource and then followed by creating the new config mac resource and then finally removing the old uh config mac resource. And then the same thing happens with a deployment resource for the engine X container which gets created in the new app name space. And then the, the old engine X container uh which was running in the default name space, then gets removed or deleted. And so once that's done, then Pulumi basically says the deployment is over, uh sounds pretty simple. Um And if we look at the S3 changes, we actually did not change anything, which means the five unchanged output is totally valid because we did not touch a thing. Um which means nothing should be updated. This is exactly what I would expect. And um as you can imagine if you're doing a pull request, this is exactly what you would be looking for when you have um you know, a triggered build for pull requests. Uh Basically evaluating if your infrastructure is being changed, um uh you know, unnecessarily or, or accidentally because you change something else. Um And um finally, um if we look at the actual update stage itself for our um changes where we added the name space, we can see that um the name space gets created. Um And then the new config map gets created and the new name space um and then the old one gets removed. Uh And then the same thing happens for um for our engine X container itself, you know, creation followed by a replacement and then eventually also waiting for the container to um to fully initialize and then basically completes the deployment. And once again, we get a Perma link for, for this update um to see what uh you know, what were the resources that were changed? And um what was the detailed diff between the previous state and the current state? Um So, that's great. So because the deployment is complete, uh we can go ahead and query our app's name space in our cluster and see that we do have an engine X pod here uh with an internal IP address of 10.42 02 40. So let's go ahead and query that. Um And you can see that I get a default engine X response which is totally valid because I've not done anything other than just deploy the default engine X image um as a container in my existing cluster. Um And you know, and it's accessible within the cluster. Uh And I get the valid response. So looking great. Um So when I'm all done, um I can go ahead and run a destroy job which a destroy job uses our plug-in again. But instead of running the um pull uh the preview or the up command like I showed before it runs the destroy command, which goes ahead and tears down the infrastructure. So you can imagine how putting these two commands together, you could quickly come up with a pipeline that simulates sort of an E testing environment. Um So you could think of scenarios where you have a um you have an application that you uh want to test in the real world scenario. So you want to set up some infrastructure um run some smoke tests against it and then quickly tear down their infrastructure. Uh This is really uh possible with Pulumi because um it, it doesn't take uh a whole lot to actually achieve that scenario. So, um so I'll, I'll go ahead and kick that um and let the destroyer run and, and delete my resources um for me. But um that's pretty much all that. I had to uh demonstrate for you all today, but I hope that you will check out the Pulumi plug in for a spinnaker. Um It is open source. Uh We hope to uh get some feedback from the community and um hopefully, we can work with you to add more features to it. So with that, uh I will give it to Dan and next steps um for the uh for the viewers. So um get started with Pulumi. It's really easy, you know, it takes about 15 minutes um through our getting started guide um join our community Slack. That's a great place to ask questions and, and understand um everything that's going on um surrounding Pulumi and, and being able to interact with other uh folks in the community. Thank you.

---
