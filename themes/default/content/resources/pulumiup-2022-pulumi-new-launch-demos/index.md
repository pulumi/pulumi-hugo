---
preview_image:
hero:
  image: /icons/containers.svg
  title: "PulumiUP 2022: Pulumi New Launch Demos"
title: "PulumiUP 2022: Pulumi New Launch Demos"
meta_desc: |
    Demos will be shared including new Pulumi features in this hands-on, coding-heavy session. You will learn how to build, deploy, and manage cloud ap...
url_slug: pulumiup-2022-pulumi-new-launch-demos
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "PulumiUP 2022: Pulumi New Launch Demos"
  description: |
    Demos will be shared including new Pulumi features in this hands-on, coding-heavy session. You will learn how to build, deploy, and manage cloud applications with infrastructure as code, powered by popular programming languages. You can expect to pick up new best practices for taming cloud complexity and supercharging your productivity when building with modern cloud architectures.
  sortable_date: 2022-06-13T01:00:10Z
  youtube_url: https://www.youtube.com/embed/BXU__gE5lJA
transcript: |
    All right, let's get started. Let's kick off a practitioner track with uh Kat Cosgrove who will be joined by engineers Kyle Dickler and Aaron Friel who actually built the Java and the support to show you some cool demos and dig in even deeper. Hey, y'all, thank you for joining us at Pulumi up. I hope you enjoyed the opening keynote. We had some pretty exciting announcements but we didn't have quite enough time within the keynote to do justice to the two things. We were most excited about the introduction of support for Yaml and support for Java. I am here to help with that. My name is Kat Cosgrove, staff developer advocate here at Pulumi. I will be your guide and I'm joined by two colleagues today, Aaron Friel and Kyle Dickler. We'll be giving you an overview of both features including demos and some ideal use cases. So let's dive in for the ops folks in the crowd. We're excited to introduce Yaml support for Pulumi. This is designed with simplicity in mind and it's ideal for smaller and less complex deployments. If you're coming from another environment that uses Yaml, this is gonna look very familiar to you if you have experience with Kubernetes deployments, this is going to look nearly identical. L for Pulumi has access to all core features of Pulumi. It's also able to consume outputs from other Pulumi programs and can even use components written in other supported languages. So it's it's pretty flexible uh now because it is YAML, you don't have access to things like loops. But if you do reach a point where the expressivity of a programming language is required a Pulumi program written in YAML can be quickly and easily converted to the supported programming language of your choice using the Pulumi cli. So what does that look like to help? I've got my coworker Aaron Freel here to show off some possible applications of Pulumi for Yaml. So I will now toss it over to him. Yeah. Thank you, Kat for introducing me. Uh I'm here to walk through a few quick demos of the new Pulumi Yaml language support. Um We're gonna walk through demoing setting up a S3 static website. You can probably already see that on the screen. Uh We're gonna stand up an Eks Cluster, we're gonna play some things to it and then we're gonna do something a little more magical. We're gonna convert that YL into Python and typescript uh to start out with. I want to talk through uh this S3 website pluming program. So, uh if you're familiar with Pulumi, you've probably seen the Pulumi dot YL project file before we've extended it with a few new things. I'm gonna go through these sort of top to bottom here. Uh and highlight uh we are setting the run time to YAML that's gonna use our language host and uh that will ship with the Pulumi cli uh built in. You're gonna be able to clear resources in your Pulumi dot L. Uh We are declaring a my bucket resource and we're using our API docs to get this type string here. Uh The top first part of the type string is the Pulumi package that's providing it. Um And some packages we'll use a hierarchical scheme. A US has a wide variety of resources. So we're gonna be looking under the S3 colon bucket for this uh resource and we're gonna be declaring some properties. We support all of the rich properties that we have in our API do for ya. So we're gonna give this an explicit name. I've already uh practiced standing this up. Uh We're gonna give this uh a website declaration, so we're gonna have it serve a static website. Uh And then we're also gonna give it a uh an index uh document to be able to store in that. So we're gonna create a bucket object resource, declare uh properties on that bucket. And this is where we, because we are controlling the YAML uh execution. If you will, uh we can do things like variable interpolation so we can uh use a dollar sign and curly brackets to refer back to this resource. Um You can do this in either order I could put the index above my bucket. And uh what we'll do is when we read this EML document, we're gonna reorder anything uh in order to avoid cycles for one thing uh and detect those and, and by an error. Uh but also to um ensure that resources are created in the, the appropriate order, right, the bucket has to exist before we can create an object in it. We're gonna insert this uh object as an index dot html and we're going to then uh put a asset uh as the source. So we do support our assets and archives. We have six flavors of those from file assets to uh nested uh sort of like tar file, sort of assets where you can specify multiple files within a single asset. Um We're just using a single static string here. Uh We're gonna serve this uh malformed H two L five document that just has a, a heading saying hello with uh with love from Plumy. Uh We're gonna set that to public read of course. Uh And then we're going to set the content type uh so that we can actually pull that down with curl and get a, a nice output. Lastly, um in order to actually get that output into my cli, um we're going to declare some outputs, we're gonna set the bucket, endpoint uh output to, again, we're gonna interpolate this uh variable reference using the dollar sign. Curly brackets. Refer to my bucket, refer to the website out endpoint output on that bucket. So just do a quick demo of what that looks like. Let's go back here. I'm gonna do a stack in it. DEV and I'm gonna do put config but need to set a region and me up. So again, this is baked into the plume cli as of today. And my mistake there, let's uh select yes on Flew Me up and you'll see that this creates AAA S3 bucket, puts that object there uh and makes that accessible uh via the S3 URL. Uh And I'm just gonna give that about five seconds here uh to ensure that uh I don't uh hit a, a negative DNS cash uh when I try to curl that. So I'm going to do a plumy stack, output bucket pin point. And I see that I have successfully pushed this uh index dot html uh into this bucket. So I can use plumy to deploy static websites um with sort of arbitrary complexity there. Um This is a fairly straightforward example though. And uh we think that some of our customers are going to want to use things like our component resources uh such as our eks provider where they will bake in sort of best practices or good defaults. Uh And I want to show an example of what that looks like here with an EKS example. So um starting out, we have uh a, an additional uh key here. We have a variables decoration in those variables. We are declaring two variables. And uh if you're familiar with deploying to ad us, you often need to do things like get the default VPC ID uh or get the list of subnets within a VPC. Um Those would be considered functions in our API docs and we do support those in Yem, this is what one of those looks like. It's a function in voke anywhere we support a uh an expression in our syntax, we support replacing that expression with just an object. So this is an object containing a single key function invoke. And you can then specify again from our A P A dot API docs sorry. And then you can specify from our API docs, the uh type of this function or the, the name of this function, uh any arguments that it requires. And optionally if you have a single return uh key that you would like, uh you can ask for just that single I id for example key. Um or you could get back an object and store that in the variable and use again our uh interpolation syntax to be able to retrieve properties off of that similar thing with the Subnet I DS. We're going to be invoking the easy to get Subnet I DS function and we're gonna be passing it the VPC ID that we previously acquired. And then I think this is the really magical part here is this entire cluster declaration is only nine lines of code using our Eks provider uh specifying Eks colon cluster, specifying the VPC and subnet I DS that we declared earlier and declaring a fairly small size cluster for our use case here. Um with just uh two instances T two medium. And uh and then for us to be able to actually operate on this cluster, we're gonna pull out the cube config that uh an S or uh app team user uh might need to access that cluster. Now, I'm gonna spare folks uh having to go through watching an entire ES cluster go up, but I will show what that looks like in terms of a preview experience uh before we move into a sort of a pre baked cluster to deploy some resources on top of it. Um So you can see here uh even though I specified only a single EKS cluster of resource, that component contains a wealth of other things that are required in order to securely and correctly deploy EKS into an Amazon uh account. So uh I will go over all of those uh subs resources. Uh But this is I think the power of packaging up component resources in our registry. Uh And we hope to expand that in the future lastly for our uh YAML uh program demos Um I'm going to take that EKS cluster and demonstrate how we can use that cluster decl declaration to deploy some Kubera resources onto the cluster in the same YAML program. So obtaining some of the same uh levels of sequencing and complexity that you can get in a uh in one of our other supported languages uh without having to buy into all of the complexity of well having to run and run time or compile a program for those other languages. So I'm adding a few new things into this uh document. First, we have a configuration key. Uh This is equivalent to in our other language being able to say uh the config dot get boolean get string. Uh This is in case you have a default value that you want to provide uh for referencing, config we can specify a default here. And if then a user were to override that and I'm gonna switch over to the stat config I could set image name to anything I chose here. And that would then override uh the config on a per stack basis for that uh project. So now I'm gonna stick with though my default of uh just a simple uh web server image that I've pushed up. And I'm gonna go over uh some of the new parts of this document. So I've taken the existing EKS cluster that we just previously looked at and I've highlighted using uh my editor some of the new changes here. So first, I've added a new variable which is uh not a string or boolean, but it's actually a map and it's a, it's a Yel or Jason S uh map and it's defining a key map, a key app, sorry. And it's defining a key app uh with the value of engine demo. And that's just to avoid some repetition later on in the document. Um For folks who are familiar with KTIS, you often have to provide this uh labels uh property in multiple places. This just simplifies that. So how do we deploy onto a cluster waiting for that previously defined UK S cluster uh to spin up? Well, we start by deploying a provider resource. So this is going to then provide the configuration for future resources that we want to deploy into a particular community provider. Um And the flexibility this offers is you could potentially have multiple uh PP sorry. And the flexibility that this offers is that you could potentially have multiple cum providers in the same uh Pulumi program and deploy into multiple clusters. Uh One, you know one resource into the first cluster, one resource into the second and coordinate more complex uh deployments. In our case, we've declared a single KS provider resource. We're gonna pass in that cube config that we had shown earlier as an output. We're gonna deploy a demo name space and we're taking advantage of plume's automatic naming. So when we deploy this demo uh name space Pulumi is going to generate a suffix of uh demo dash and then it's gonna generate some base 64 esque uh uh suffix so that we don't conflict with any other resources deployed in the cluster. Um So all we have to provide is that provider option. The next uh two resources here um should be extremely familiar for cumbers professionals. Um We've got a uh apps V one deployment and the content of this resource, the properties is almost verbatim what you would see via cube cuddle get uh output into em. Uh The only difference being that we have uh these app labels uh as I mentioned earlier. Um and the ability to then interpolate in, for example, uh what that auto generated name, space name is going to be. So uh lastly uh as well, uh we have that image name pulled in from our config so we can have a different image in each environment that we want to deploy to for each stack. Uh We declare a service um again, very, very similar to uh what a KTIS get service output would look like uh just with these interpolated uh invariables and we have an output of a host name uh again, pulling off some output that would we have to it would sorry. And we have an output of a host name that depends upon the uh the status of the load balancer having completed. Um So we we will correctly await for that service uh to deploy and for an elastic load balancer host name to be assigned to it. Uh in order to be able to provide a useful host name for the user to use immediately after the stack uh is deployed. All right. And now let's look at what it looks like to Pulumi up this cluster and the resources into it. So, uh we're starting out with an EKS cluster that I had previously deployed. So we should only see the provider uh name space deployment and service to access that deployment. Uh spin up in this preview. That's indeed uh what we see and make the terminal a little larger. You can see the whole plan here and the host name is an output because we don't necessarily know what the elastic load balancer is going to assign to that service. We're gonna have to await it after deployment. So let's watch that happen here. Um This should be pretty quick uh is a little faster deploy than uh Eks. And uh then we're gonna get that elastic load balancer uh host name as a output. So you can see the deployment is finished initializing. Um We're waiting for that service to acquire a internal and an external IP and now the elastic load balancer has assigned a host name to it. Excellent. Uh We've waited a second for that host name to be available. We're now going to uh request it and we can see that we've pushed up uh this engine X Doer image with a very simple web page available on ELB. So that's how you can structure uh Plumy L projects from, from simple to fairly complex. Um But uh there may be some cases where you need to uh exit out of the YL environment and go to uh Python or typescript or any of our other supported languages. And we do want to uh enable our cloud engineers to do so uh when they reach that point where they need to reach for a loop or they need to reach for some more complexity or an external library. Um So I'm gonna go back to that first uh S3 example to highlight our last and I think the most exciting feature of the YO launch. So we are introducing a uh what we call Pulumi convert. Uh We're gonna be able to convert from a source to a destination language and project um starting with our Gammel uh language support. So Pulumi convert, I'm gonna convert this S3 website example. So again, this is just the static website uh deployed three. I'm gonna convert that to Python. I'm gonna write that to the as Python directory. And uh while it's experimental, I got these nice little hearts displaying and you're gonna see it spinning up a Python virtual environment, uh installing the necessary dependencies. And uh shortly we're gonna see that it's gonna tell us that we can just CD into that directory. Uh And plu me up and we should have our program now converted to Python uh with full fidelity. All right. So it says that I can change directory is that says that I can run flew me up and we should see no differences here. Um Again, this is a full fidelity conversion of the YAML program into Python. And what does that look like inside as Python? Of course, we have some of the uh extra directories that Python has created. We have a virtual environment. We have a main dot pie, which is where our Pulumi program now lives. And uh inside, we have our same resource declarations, but now converted to Python including as you can see uh handling things like uh the supply in order to be able to get the website endpoint and then interpolate it into a string. So you can see here where there are some advantages of YAML uh where we've actually shaved away some of the complexity. But uh when you do need to go to a Python or a typescript, we do support that as well. And um just to demo that typescript support, I'm gonna now convert that to typescript and we will shortly see uh a typescript version of our program again, installing dependencies, we invoking N PM here and uh we're gonna pull down everything you need in order to be able to run a plume me up in that project uh as if you had originally written this in typescript. Fantastic. And now we have the same program again now in typescript using typescript syntax formatted uh and using our fluy dot interpolate syntax there. Thank you so much for your time today and thank you, Kat, back to you. Thank you for that demo reel. And for those of you interested in the JB M, we are excited to announce support for Java 11 and higher including languages like Ska Cot, uh closure groovy, whatever you'll get the same support for Pulumi core features that you enjoy using any of our other supported languages. Plus the feature rich rich ecosystem of the JB M that you're already used to. That means the ability to use any number of JB M languages, all of the autocomplete and error support you get from your favorite ID ES testing frameworks and more now for your infrastructure, not just your application code will soon also be introducing Java support for the Pulumi automation API policy is code and multi-language component authoring. This is a huge step for our mission to make infrastructures code accessible to all flavors of developers. And a huge boon for JB M developers who want to be able to manage their infrastructure programmatically without learning A DS L ready to see it in action. I would like to introduce to you Kyle Bixler who's here to show off some of our favorite use cases for Pulumi and Java. Take it away. Kyle. Hi, I'm Kyle. I'm a developer on the Pulumi Java project. And I'm here today to show off two stacks that deploy one of them deploys an EKS cluster, which is Amazon managed Kubernetes uh and an S3 bucket that's able to be accessed by that cluster through uh role based access con uh role based access control. Uh The other stack I'm demoing is going to be a Java Spring application that you're gonna be able to deploy to that cluster using uh Java itself. So a lot of the Java does out there that, you know, are really happy about using java and might want to be able to use Java for more than just their application code. Don't have to, you know, write the L or configuration language in order to do it. So the first stack that I'm gonna show today is gonna be that Kuti stack. Uh This is more of a stack that an operations team would be working on. And first, I'm gonna open up the build dot gradle in order to get started with this, you're gonna want to, well, one, I'd recommend just copying the build that gradle itself because it's set up properly and it has the dependencies you need. So if you have uh com dot Pulumi Pulumi, in order to be able to use the engine and then you have whatever providers you want to use right here. So if you want to import an AWS provider. You would do com dot Pulumi and an aws. If you want GCP, you put GCP here instead. Ok. So now that we've, uh covered just kind of the set up stuff, I'm gonna go right into the stack itself. So if you see here, we want to import Pulumi, uh comes out Pulumi Pulumi. And then in our main function, we want to use this run method on that class to be able to call this function over here. This function takes a context object in order to be able to, you know, cry define exports and to be able to interact with your poli config. So if you look here, we have support for, you know, in teen, you can see like what what uh methods are on this object and you can kind of consume them. It's really, really nice. So down here, you see we uh we export from the stack, the cube config and the bucket name that we're deploying. And because we want to be able to use this in our spring our spring good application stack to be able to deploy it to the C cluster we're deploying here. So at the end of this function, you're gonna want to return the context dot exports uh call and uh or the context dot exports uh return value. And now that we've kind of covered this uh function, we want to move into the stack that's deploying this. So if we look or the function that's deploying this. So if you look in here, we've got pretty basic setup. You wanna create a bucket call by calling the constructor and you want to create a policy to read from that bucket by, you know, calling the constructor for this policy. They're imported uh through this uh through normal java imports. You see the policies pulled in through the IM wild card and you pull in the bucket through this S3 import. And one thing you'll notice is that we have overrides to be able to er overloads to be able to, you know, call it with just the name and then it constructs it with the default arguments or you want to pass in a, you know, the arguments that you wanna configure your resource with. So for the policy, we want to configure what the policy actually is. So we have this policy function on here to set it on the builder. So if you look over here, we have the, we grab the bucket name and we grab the bucket name over here and we in line it over here, there are probably a lot of, you probably want to do some parameter checking on this if you do it, if you do this yourself. But for the sake of this demo, we wanted to leave it pretty concise. So we have some helper functions down here to return the name of the bucket and also the read policy because we want to be able to use that later on in order for our EKS cluster to be able to read from this bucket. So the next part is going to be deploying the EKS cluster. So we use our EKS provider to do this. So if you look in here, we have uh we have a cluster that we're declaring. So you'll notice that this has 33 arguments. You have the name, you have the arguments for this cluster and you have this uh resource options builder. And you'll notice that we set protect to be true. We don't want to accidentally delete this for our demo because it takes a really long time to spin these things back up. And one thing I'd like to mention is that you can, you get the nice rich intelligent that everyone loves about Java and inte to be able to like get a type information of what you, what you can configure and what you can put in there. So that, and in order to build this cluster, we need to get information about the VPC ID and the submit I DS. So we have some functions up here on this ECG functions class that can get that for you. So if you see here, we call this get VPC method and then we pass it some parameters and then it gives us the VPC ID as an output. You can see inte tells us it's an output string. So another cool thing is that EC2 functions, you can see all the functions you have at your disposal through in teen, which is really nice. I think that the get AMI one will probably be the most useful one to most people. But um other uh so you have other methods or other data source methods that you can access. For example, since we're pulling in the I AM import, we can actually check what IM functions are here. Can see that a lot of these things would be kind of a pain to look up in documentation or right here at your fingertips, tips and including some of the documentation ourselves uh that we put in here ourselves. Now, the documentation that we have is in markdown and Java doc takes uh html. So we're still, we still need to format that a little more nicely, but hence this is preview and I am writing this in pre preview. So if the things look a little bit, uh if things look a little unpolished, it's uh it's just gonna get better. So, all right, we deploy our cluster over here and then we want to attach the rules that we passed in through the arguments, you know, classic Java, you know, classic Java stuff and we attach the role to be able to read from the bucket to the cluster. So now when someone deploys an application to this cluster, they will be able to read from that bucket. So now that we've kind of covered this stack, you'd probably pro so, all right, I might wanna mention, I should mention we have some helper functions over here to get the cub config and we have a function over here. Try not to look at it too much. It might hurt your eyes but working, but working with the L and Jason inside of Java is not necessarily my strong suit, but I'm sure that there are a bunch of very seasoned Java developers out there that know that have ways of, of, of uh working with this easily. So we export these from our stack and then we export the bucket name from our stack as well. And let me just run a Pulumi up. I've already, I've already run this ahead of time because like I said, the cluster takes a very long time to spin up. Also note that we marked the cube configure secret because there is a certificate in there and we don't want to leak that on the screen. So help with this or so it says the cluster is ready. It's running, the stack should be good to go while this, while this is running, I will go into the other stack that I'm that uh I wanted to show off. It looks like it finished. You can see the keep configures output here, bucket names, output here. Now let's look into the other stack I wanna use. So as I know. So this is a spring boot application. So if you look here, we have a rest, we have our uh controllers and we want to build it and deploy it to a cloud provider. So, what I'm gonna do is I'm just gonna run, uh, so we want to run repackage and build this as a war and we want to run Pulumi up on it. So I'm gonna run these now in order to, you know, because it takes a little bit of time. So it's running the test suite that you guys probably that, you know, normal uh Java would probably put together and making sure that it's sane and it's gonna put together the war file and, and uh start pulling me up. So while that's going on, uh let me show off the stack in here, we see the familiar Pulumi run the imports we had before in the Pulumi stack. Now, we actually, we, we actually use this context object here to get the config and then we are going to use this cluster stack reference uh parameter that we have in our config in order to uh be able to reference the stack we just deployed. Now, if you notice here, there's uh two stack references while working on this, I found a little, a little bug in during pre preview uh and it, and it's uh fixed now, but so just disregard this line. So if you look here, we get the output of bucket, we get the bucket name and the cube config and we save them to variables and then we're go we passed in the jar path which is going to point to this uh this wire file over here and to specify to this jar deployment that that's what we want to put on the uh put in the S3 bucket. So if you notice here, this is not ARG, this is actually a function that passes in an ARG builder. So one of the cool things about Java is everyone's is uh do not repeat yourself. So if you know what this is going to take, you can, you can have it take a function that gives you what it knows it's gonna take and then you can configure it yourself. So in here we have this builder that's able to configure it properly. Now, one of the so might as well show off the uh deployment arcs. And if you'll notice here, we use Lamb box. So Lambo is this nice annotations library that adds a lot of really boiler plate stuff with just annotations. And a lot of there's a lot of people that like it and some people that might, I guess maybe some people that might not use it themselves, but it's there. And I just want to show off that you can in fact use, use it for your uh your Pulumi stacks. So now that we've shown off configuring the arguments, I'll step into this char deployment. So if you look here, we are inheriting from this uh component resource and we call super in order to set it up, we get the arguments and then we're going to deploy that jar to the S3 bucket we got in. So if you look here, we create a file asset with the file path and then we upload the jar to S3. Now, you're probably wondering why we want to do that. So in order, so for running this demo, I didn't want to have to put together a Docker file because that's not Java. So I instead had it so that we have an a kit container that pulls down the s the application from the S3 bucket and then mounts it to a volume and then she then the Java or the open JDK runs that jar from that mounted volume. So you don't have to. So it's very fast. You don't have to worry too much about Docker. At least in this demo. Maybe you want to use it for, maybe you want to use it yourself because you know, there's obviously benefits for having saved artifacts, but really it's really up to you. So we pass in this custom resources option, we pass uh we tell it that the parents of this resource is this component, the custom resource. And then we return to the, the jar that we just uploaded. So the next part is going to be deploying the application of kubernetes. So we pass in the cob config that we got from our other stack and the bucket object that we just deployed. And we go in here. And first we create a the resource options that has the cooper netti provider set up so that it can control that cluster. So it sets it up in here. If you look here, we have the config into this uh provider and then we also set the parent to this so that all of the resources inherit from it or not inherit from it are attached to it. And then we go down here and we're going to create a name space. So we want to build a name space, we want to create a name space and then pass the cluster resource options to tell it that this is the cluster, we want to create the name space in. So down here, we have created our app labels, we create our metadata builder and then down here, you'll see the deployment. Now, this deployment can look scary at first. But if you've deployed something, you know that this is kind of how yeah, well represents their stuff. It's it's basically a tree document structure. So the Yamal is pretty much like a little bit 1 to 11 of the nicer parts though is that we do get completion. So if you don't know exactly what's supposed to go here, it'll tell you that you can't put something somewhere and it makes it, uh a little more comfortable, a little safer and more comfortable to use instead of trying to, uh navigate blindly in the dark about what the value is supposed to be. Now, one thing to note is that it has, we have type safety, but one of the problems that you still have is that your strings, you, you have type safety. You know, it's a string, but you don't know that the format of the string is correct. So if you've noticed this is a huge blob of code over here, there's like a lot of lines. So you can actually split this out into your own function with parameters and then add some uh some asserts or checks to make sure that the parameters are same. So if you run into a problem where the value is getting passed in, that shouldn't get passed in, you can catch it ahead of time and not and save yourself like a night of debugging to find that one of the parameters you're passing in is not, it has a slash in it and slashes aren't allowed and Guberti just complaints about that. So in order to accomplish the thing that I mentioned earlier with grabbing the, the jar from S3, we have created a volume over here. We've configured it with uh with uh empty, with the uh basic options for empty directories and we are going to mount it to this init container and have this init container use the AWS Cli Docker image and then pull this re pull this asset from S3 into this volume. Then we have this Java container that mounts that volume right here and then it runs it over here, which is pretty cool. We expose the port over here the 80 80 then we have a service over here that will make it available for you to use. Now, now that this is done built since this is finished building already, I will run the supply function and hopefully it should work out. Let me full screen this a little more. So it's a little prettier. So this this code will also output an end point from it so that we can just kind of go navigate to that end point and you know, it's more convenient, this might take uh like 30 seconds to a minute. So while this is deploying, I guess I can, I can open up the Pulumi Java Ribo. Uh And if you look here, you can see that we have some templates available. So we have some templates available, you know Aws Java, Azure, Java, GCP, Java. And uh so you can like be able to run Pulumi new and be able to use these templates. Uh Another cool example I have is a running a Groovy program or a Groovy Halloumi program. Uh because like cat mentioned, we do support the JVM. So you know, a lot of people might have a little bit of fun seeing what they can run on there. So if we look here, this thing is finally finished deploying and we're gonna navigate to it. So I have to put a slash here because I use HT BS everywhere. And if we go here, we should see that the connection was reset and look here, we can see that our app was now deployed. So see, since we know, oh, definitely works because we saw that, you know, uh we saw an error message that was very dynamic. All right. And that's pretty much my demo. So tell us what you think about uh how our library is set up. Tell us what you like what you don't, what could be better and you know, it will help us be able to steer the direction of this uh of this uh framework. All right, and back to your cat. Thanks for that Kyle. And thank you everyone for joining us for this introduction to Pulumi, support for Yaml and Java. We're really excited for this launch and we hope that you are too code examples for all Pulumi packages now include sample code for Yaml and Java as do our getting started guides. So take them for a spin and let us know what you think. Enjoy the rest of Pulumi up.

---
