---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Upgrade Strategies with Python and GCP | Modern Infrastructure"
title: "Upgrade Strategies with Python and GCP | Modern..."
meta_desc: |
    In this episode, explore upgrade strategies for your infrastructure and IaC programs using Pulumi with Google Cloud (GCP) and Python. If you need t...
url_slug: upgrade-strategies-python-gcp-modern-infrastructure
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Upgrade Strategies with Python and GCP | Modern Infrastructure"
  description: |
    In this episode, explore upgrade strategies for your infrastructure and IaC programs using Pulumi with Google Cloud (GCP) and Python. If you need to upgrade your infrastructure, you probably need to think about how to do so without downtime. We'll briefly touch on blue-green deployments and canary releases before diving into some code to show off Pulumi's micro blue-green-like deployment strategy.  Code for Modern Infrastructure Wednesday episodes is available at https://github.com/pulumi/pulumitv/  Today's example is in Python, but Pulumi makes it easy to stand up infrastructure in your favorite languages including TypeScript, Javascript, Python, C#,  Go and Java.  Try Pulumi at https://pulumip.us/Get-Started
  sortable_date: 2021-11-11T01:09:24Z
  youtube_url: https://www.youtube.com/embed/vviIVCloMKQ
transcript: |
    Hi there. Welcome back to the reboot of Modern Infrastructure, Wednesdays. I'm Laura, your host. And today we're gonna talk about upgrade strategies for your infrastructure. We'll be building on GCP or Google Cloud with Python and Pulumi. You can use any of these strategies and details with whatever cloud you like or whatever language you supported by Pulumi. Uh So the official ones, if you're keeping track are typescript or javascript go C# and as we'll see, Python, let's say that you have a bunch of infrastructure up and running in production. First, let's take a quick diversion. We're going to talk about upgrade strategies. We're going to use this diagram right here to talk a little bit about it. When we're wanting to upgrade a set of infrastructure, there's many paths we can take. And with the Pulumi program, we generally think about things just as we would think about deploying an application like a new version of an application. One common path is called a blue green deployment in a blue green deployment. There is a current set of infrastructure or a current application that we're going to refer to as the blue infrastructure. This blue deployment or blue infrastructure is currently running, it's running just fine in production, but we want to upgrade it to a new version. So what do we do? We stand up or commission an entirely new set of nearly identical infrastructure or a nearly identical application using the new version of whatever we're trying to do. We stand that up alongside of it and that is called your green deployment or your green infrastructure. Once it's stood up, we verify it, make sure that it's working as we expect it to and then we switch all of the traffic off of the blue deployment. Once we're sure that the green deployment is working properly under load, you then take down the blue deployment. The colors don't actually matter. I honestly have called it rainbows and unicorns deployments before. No one really cares. The idea though is that we really don't want to tear down existing infrastructure without being sure that the new infrastructure is working properly and without moving all of our traffic over because we don't want a user to actually experience anything different. They should just see the upgrade and, oh, look, hey, that's awesome. It works a wiring error whether virtual or physical can really wreck havoc on your weekend if you deploy a new set of infrastructure and shove an application onto it without verifying that it actually works before tearing down the Infra that had been working quite nicely. Thank you very much. I've been there it's not fun by any stretch of the imagination. There's other deployment strategies too like canary releases, canary releases slowly move traffic over to new infrastructure. So you would do the same thing where you have a current set of infrastructure, you build up a new set of infrastructure that has the new version. But instead of actually just switching all the traffic over, like you would flip on a light switch, instead you're sitting there and saying, I'm only gonna send maybe 5% of my traffic over or 10% of my traffic over using some kind of load balancing system depending on how exactly you build it. This shares the load across deployments rather than making that complete shift, which can be great. If you're trying out something new, like a new method of load balancing across your infrastructure, you slowly increase the load and measure your capacity while having this like safe spot to go back to. Should everything always go sideways? Pulumi itself has a create before delete strategy, which basically means that it creates a resource tests that it works by making sure the rest of the deployment all works together and then deletes the old resource by after moving all the traffic over. So this isn't exactly a blue green deployment because you're not actually standing up the entire set of infrastructure altogether. However, you can kind of think of it more like a micro blue green deployment because each individual resource is getting that update, it stands up, the new resource moves over the wiring validates that it's working, then tears down the old resource and repeats that process for any resource that needs to get actually updated. That's pretty neat that being said though, enough about just diagrams and stuff. Let's go look at some code. All right. And here we are with our code. This is a fairly basic web server. Um This is this little startup script here that says bin dash. Hello world. Uh So when we actually curl the endpoint in the end, we'll get just Hello World. That's really how we know it works. The application here doesn't matter though. We're talking more about the infrastructure. So let's kind of move forward a little bit here. You'll see that over here. Other way, you'll see that over here. You will see the compute image. So we are using DB N nine right now. We're gonna actually move up to DB N 11 because that's available. That's the update. We'll actually do. We have a network and Subnet and a global address and a firewall. Basically, all of this together is putting together our network so that we have a IP address that we're gonna hit no matter what. We'll see, we'll have a proxy a little bit later as well along with a forwarding rule. Um But all this really is all gonna do all of the networking pieces, just say, hey, when we have all of these instances of compute, which will show in a moment, all of those are gonna get mapped somewhere and they're going to lead just to a single IP address that we're not assigning to a specific compute instance because if you do that, you can't reuse it. So you wouldn't actually be able to update in place. So instead we're going to just have this one that's out there that we're setting that then uses some load balancing to get to. So that's where we have all of this information here. We do have port 80 open. That's just because we're using HTTP because we're just doing a quick curl. This is not gonna stand up very long. We do have a health check because it's always good to have a health check. Basically that says is everything up and running and healthy and ready to go. Um And here's our instance template. This is where it gets a little bit interesting. We have a tiny, tiny little uh machine we're asking for. There you go. We're right over here and there's the startup script, which is that little simple http server that we're calling the disk here is using the source image that we defined up above. So this is where we're actually gonna be changing that little bit. And it's just saying here's our network interface and make sure it allows a health check. We have a group manager and this is again pretty standard if you're familiar at all with Google Cloud. The versions here just says use the instance template for it. We have port 80 open and then here's this update policy. This update policy is actually really important because otherwise if you don't set an update policy, you can update the template. All you want. The V MS will not update, the virtual machines will not actually update until it does something until you knock it over or otherwise go into the U I and actually hit replace or into the cli and send a replace request. So in this case, we have a minimal action of restart. Because in general, if there's a change, we don't necessarily want to restart all of our virtual machines and rebuild them because that can be a little bit invasive when it comes to keeping everything up and running and your user sees nothing. So we actually are using restart. In this case, what it'll do is that's the minimum action. We'll see that it'll actually replace our V MS when we run the update because there's actually a change to the underlying image. So we do want a proactive change though. That means that whenever there's a change, it's going to try to do something to the V MS. There's another one called opportunistic, which basically says if there's something else like that happens, great, we'll update things while we get there. Otherwise we're not gonna do anything that's not all that helpful in this case. So that's why we're using proactive. And in this case, we really only want one VM unavailable at a time. That way the user doesn't experience anything different because we have two total V MS. And we'll get a chance to see that in the U I here in just a moment. Then we have a backend service. This back end service is basically acting as our load balancer along with the rest of our networking. So you'll see that it's talking about an external load balancing scheme. It's sending everything through, through HTDP. And it's going directly to the instance group. That's the manager that you see up above. We have a URL map and a proxy and forwarding rule. All of this again is just setting it up so that we have one address that we're gonna be able to hit to actually get where we want to go and we're sending it to port 80 again. And then last, but not least this is the nice thing about Pulumi, we are programmatically getting all of this information once it's created so that we can use it as we go. So right now, and you'll be able to see that I've already run this once we're gonna actually run that curl on our stack. There's that Hello World do do do do. Now let me just quickly flip over to demonstrate where we are. All right. So this is our group manager that's currently up and running so you can see everything here. Let's take, let's drill down into one of these V MS. It's gonna take a moment to load and when we actually take a look at this, we'll scroll all the way down here. Here's the instance it's running off that instance, template. We have everything there, there's the subnet, you'll note that it is under Deviant nine. This is the piece that we are about to go fix. So let's actually go and do that. All right, we are gonna go up to our code here. Let me see. Let's go change that code, scroll all the way to the top. There we are. And we wanna just change this to DB N 11. Always make sure to save and then we're gonna do a Pulumi up and when we're actually doing this Pulumi up, we'll get our preview. So we're gonna take a look at that real quick. You'll notice the instant template is getting replaced, the group manager is getting updated. So let's take a look at those details. And again, here's the instance template getting updated in various places. The source image is getting changed to 11 Bulls eye, which is great. That's exactly what we want. So let's hit. Yes. And we're gonna see everything go live. Now, let's flip over while this is actually going through, we're gonna flip over and go take a look at our instance here and we're gonna go back and take a look at our actual instance here getting updated. So we should see we have a status of updating already. That's a good sign. So we'll see this instance actually change. So we're gonna see a little bit of moving magic here and we're gonna let everything update. All right. And as you can tell, you can see the difference in creation time. So this later one is using the new instance template, so we can see that it's in the process of deleting the old one, making sure that it's up and running. So as we go through here, we can tell that there it is Debian 11. I hope you enjoyed this episode of Modern Infrastructure Wednesday. As we explored some update strategies that you can do with your infrastructure and tried a little bit of GCP code while we were at it. If you like this video and want to see some more, please do like and subscribe to our channel and also check out the Modern Infrastructure Wednesday playlist. Also, if you want to see something specific, some type of build that you haven't seen yet with Pulumi, please do leave me a note down in the comments. I do read them. So let me know what you would like to see. And on that note, thanks so much for tuning in and I'll see you in two weeks. Take care. Bye.

---
