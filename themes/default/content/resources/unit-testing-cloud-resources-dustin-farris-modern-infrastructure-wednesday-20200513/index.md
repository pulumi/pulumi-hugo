---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Unit Testing Cloud Resources with Dustin Farris | Modern Infrastructure Wednesday 2020-05-13"
title: "Unit Testing Cloud Resources with Dustin Farris | Modern..."
meta_desc: |
    In today's episode, we're joined by special guest Dustin Farris, who walks us through a testing example from his work in higher education. You can ...
url_slug: unit-testing-cloud-resources-dustin-farris-modern-infrastructure-wednesday-20200513
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Unit Testing Cloud Resources with Dustin Farris | Modern Infrastructure Wednesday 2020-05-13"
  description: |
    In today's episode, we're joined by special guest Dustin Farris, who walks us through a testing example from his work in higher education. You can find the code for today's episode at https://github.com/pulumi/pulumitv/tree/master/modern-infrastructure-wednesday/2020-05-13  The examples are in TypeScript, but Pulumi makes it easy to stand up infrastructure in your favorite languages including Python, Go, and .NET - saving time over legacy tools like CloudFormation and Hashicorp Terraform.  https://www.pulumi.com/docs/get-started/?utm_campaign=PulumiTV&utm_source=youtube.com&utm_medium=video
  sortable_date: 2020-05-13T13:03:25Z
  youtube_url: https://www.youtube.com/embed/ydR61dZmKgU
transcript: |
    Hello and welcome to another episode of Modern Infrastructure Wednesday. I'm your host, Lee Zen. Today I'm joined by our special guest, Dustin Farris, he's an engineering consultant in higher education and he's going to be talking to us about testing infrastructure as code Dustin. Welcome to the show. Thanks Lee. It's great to be here and I understand you're a super user of bloomy and your daily job. Uh Maybe you could talk to us a little bit about what you guys do with bloomy. Um Yeah, sure. So we use Pulumi a lot. Pulumi is our infrastructure as code solution. Um We use Pulumi to stand up data lake infrastructure where uh we have various Amazon resources that bring in data from across the university. Um centralize it, run some ETL and then make that available to other services and other analysts and departments that need that data for their own uses. Awesome. And I guess we have some of the code here today that's kind of representative of your actual code. Maybe we can uh jump into some of this and see what's going on. Yeah, sure. So um one of the most critical uh aspects of a data lake is the security of it, especially in Higher Ed. Um There's a lot of sensitive data that you wanna make sure that you're protecting. So we take security very seriously. It's something that uh we're constantly thinking about and we use Pulumi uh to stand up infrastructure, um that is just dedicated for just that goal. Um On the left here is some sample infrastructure that uses Pulumi to stand up a Lambda um that brings in data from Aws config and for anyone who's not familiar with Aws config it gives you kind of a report on all the Amazon resources that you have in your account. And then there's another lander here that hits the Pulumi API and brings in information about our stack which has all the resources that Pulumi thinks are in our account. And then we kick off a spark job that compares those two data sets and lets us know if there's anything that's in our account that Pulumi is not aware of. And, you know, we get a report that we can look at and analyze and audit to see if you know, there's something we need to look into. Maybe a developer spun up a resource and forgot to tear it down without using Pulumi or, you know, maybe there's a security concern that we need to look into. That's awesome. I love that there's like a very meta aspect of using Pulumi to audit to make sure that all your resources are managed by Pulumi. Um And so I assume, you know, obviously the, the, the correctness of this code is super critical as well. Um And so you do a lot of testing for this. Yeah, absolutely. Um Yeah, like I said, I can't, I can't overemphasize how important security is to us. And part of that means writing unit test to make sure that our policies and our roles and everything else is configured, the way we think it's the way we think it's configured and stays that way. Um So we have a whole, you know, a load of unit tests um near 100% code coverage to make sure that everything that we've instantiated in Polonius configured, the way we think it is. That's awesome. That's awesome. That's super impressive. Um If you don't mind, could you walk us through just the kind of how, how the testing is set up? Sure. So, um a little bit of history uh when we first got started, um we were unit testing by pulling in resources and then using a, a sign on and no Js to mock various things um that became kind of problematic. Uh because in order to do that, we had to like constantly reload um the uh node modules, um which could be time consuming. So our test suite took a while um with the recent release of Pulumi Pulumi 2.0. Um there's now the ability to mock resources baked right into Pulumi and using that, um we're able to actually mock out the things we need to. Uh And it's really quick. Uh Let me just show you this test setup file. So this is an example of how we use the new set MOX feature. Uh And what, what this is doing for us, it allows us to take any resource that gets instantiated in Pulumi. Um set up a call back, that sort of intercepts the inputs that come in and we can sort of set up uh a uh an output, a set of outputs for that resource. And this is obviously all in test mode and that allows us to mock things like the A RN things that would normally be given to us uh at run time by the provider that we don't have available to us when we're testing. Uh This allows us to sort of step in and insert some mock values. So for instance, here, online 14, you can see that whenever a new resource is a new resource is uh created. Um We're giving it an A RN which is set to the value of the thing's name dash A RN. So obviously, this isn't what the real A RN would be, but this is something that we can know in advance we can assert against when we write our unit tests. Awesome. And so this helped you test a lot faster, I assume. Oh yeah, like I said before, in order to do this, we were using sign on to mock the A RN of various resources whenever an A RN was needed for a unit test. And in order to have that mock put in place before the resources instantiated, we had to put the mock in place and then sort of reload the module and we had to do that for like every test. Um And we have hundreds of them. Uh and that ended up in a run time, you know, upwards of 20 minutes or more depending on like what machine we're running it on. Um When we switched over to this new feature, the set Mox feature um that reduced our run time from like 15 to 20 minutes down to like 15 to 30 seconds. Wow. Amazing. Cool. Um And obviously, you know, for this show, we're not gonna have the time to go through all the tests. Uh But maybe we could walk through, maybe writing a couple tests. Yeah, sure. Uh Like I said, um this sample code you see here sort of simulates um what I referred to earlier architecture that uh compares aws config data with our Pulumi stack information and lets us know if there's any outlier resources. And as part of this, um there's a Lambda role in policy um that's already been written here, there's a Lambda role um that, you know, that the Lambda uses when it's invoked uh when it executes and then there's a policy um for that role. Um you know, that allows that LAMBDA to do the things it needs to do uh to get the data from Pulumi. So I've got a role, I've got a policy. What's missing here is an attachment. I need to attach the policy to the role. That's a, that's an aws uh notion. Whenever you have a role of policy, you put the two together via a uh an attachment. So for test driven development, what I might do is open up a spec file which I've got, you know, I've kind of got an empty one here and describe the thing that I want to test the thing that I want to create. So what I want to add to this uh infrastructure code is an attachment and what should that attachment do? Well, it should attach uh the Lambda policy and it should um you know, it should attach to uh it should attach to the, the lambda roll. So attaches the policy and attaches to the roll. And uh if I, if I run this using MOCA, which is a common no Js uh testing library, um You can see I've got two pending tests here and this is kind of like a to do list for me now. Um So I know the two things that this attachment needs to do. And in my watcher over here, I can see uh what's still pending and now I can start to fill in some of these tests and for attaching the LAMBDA policy, really, I just need to assert that the uh that the LAMB does policy A RM is equal to the land of policies they are in and to, to get these values, I need to actually get at those outputs. So I'm gonna wrap both of these like so and so that's like a helper function. You've, you've written, I guess, right? So this get output function. You can see I'm importing it from test helpers here. Um That's a helper that takes a Pulumi resources output and kind of converts it into a promise which allows me to await it here in this uh a sync test. So it's nothing super fancy. Uh It just allows me to do this a quality assertion. Uh So you can see, I've got two, I've got two compiler errors here in my editor. Uh And that's because I haven't actually imported these yet. So I can import uh attachment and the lambda policy from the Pulumi extract module. OK? And I can save that. And now I'm gonna get another compiler error because I don't actually have um attachment defined yet. And you can see over here moca the Moa Watchers blowing up because I, I save that mocha reloaded and I'm getting that compiler over here as well that attachment isn't defined. Um So I can fix that, I can go back into the uh the implementation here and I can export um the attachment and just for kicks, I'm gonna just set it to just kind of a random string here just to see just to kind of show what happens, wanna reboot my Emo Watcher. And you can see I'm getting another compiler and this is saying that the property policy A RN does not exist on the type of string. And this is another way that Pulumi helps us uh be productive. Um not just by the ability to do test driven development, but because we can use a type safe language like typescript, I know right away when things aren't put together quite right. So I'm getting this, uh I'm getting this type error, you know, policy error doesn't, well, that's because I don't have this, I don't have, I'm not using the right type here. I can fix that by saying this is actually a and I am role policy attachment and I'll just give that a name. This is for my lambda roll policy attachment. And again, you know, being able to use to type safe language is great right here in my editor, I already know that I have required arguments for the second argument. This must be a, a type that has policy A RN and role. So I know right away what arguments I need to provide for a role, policy attachment. I need a policy A RN, you know, and I need a role uh OK, So I've defined this. Um, this is, you know, passing the type checker uh because I have the required arguments. You can see, I, I haven't actually put any values yet, but as far as uh the compiler is concerned, you know, that's fine. Um You can see now I've, you know, I've eliminated all my compile errors in my test as well. So I'm gonna go ahead and reboot uh the Moca watcher here. Yeah, I I can. Well, that's rebooting and see how this is totally the, the kind of test that's super critical for this kind of infrastructure. You wanna make sure that, you know, this role doesn't have the wrong policy or the, the the set of permissions it shouldn't have. Exactly. Yeah, it's like we said before, I mean, you take security very seriously and this policy, this attachment, you know, if this attachment was putting the wrong policy that was maybe too permissive onto this role, there's a potential for this lambda to be able to do things and access data that it's not supposed to be, it's not supposed to see. Um Yeah, so it's, it's just critical that we have this good unit test coverage. Um So you can see that I've got this failing test now. Um And that's because, you know, my policy, I is not equal to um the LAMBDA policies they are in and what I want to call attention to on the right here in the output you know, you might expect that an actual um I'm expecting this, my actual was this bogus stream that I put in and this lambda dash policy dash A RN that's coming from the Pulumi resource monitor mocking feature that I showed earlier where I was able to mock the A RN of any resource by just providing a mock value of its name dash A RN. So this is how I'm able to write a unit test against something that would normally only be available after this was applied. Um So again, we've got a failing test here, we can go ahead and fix that. So we're gonna set this policy A RN to be uh the actual LAMBDA policies A RN. And now you can see I've got one passing test and one pinning test and then just real quickly, we'll go ahead and, and put in this other guy um that it attaches to the lambda roll. This is, we can just copy and paste this. Uh This is gonna be the, the role and we want it to be equal to the lambda uh role of the lender rolls name. How this can I give you want the function to be uh A? That's right. Thanks. OK. So, um again, I'm getting a compiler because I haven't imported the Lander roll. So I'll go ahead and fix that. Uh no more compile errors, but it is a failing test because the expected name, Pulumi extract Lamb the roll is not equal to this empty string value. I've got up here, I can fix that by just putting in the Lander roll name and I've got two passing tests. I've got a successfully implemented uh attachment and that can go into our test suite and be checked every time new code is committed to this repository. That's awesome. That's so great. And yeah, so I guess in the future as you make changes, you'll always know that this is working the way you expect it to. Exactly. And because it's so fast now, I mean, you can see, you know, two milliseconds, three milliseconds, I mean, the whole, you know, we've got hundreds of these and they run, you know, in, in like, you know, 10 to 20 seconds, you know, developers are not um developers are encouraged to write these because they're so fast, like they're easy to write. They actually help you write good code by, you know, engaging in test driven development in this way. Awesome. Well, thanks so much for joining us on the show, Dustin. Thanks so much for your, for walking us through all this. This was great. Uh Hopefully people who are watching at home, you too can check out the testing features in Pulumi uh and uh get all your code uh tested the way that uh that Dustin is great. Thanks a lot, Lee. Thanks so much and uh please like subscribe uh and uh continue following Pulumi on Twitter and we'll see you next time on moderate infrastructure Wednesday. Thanks very much.

---
