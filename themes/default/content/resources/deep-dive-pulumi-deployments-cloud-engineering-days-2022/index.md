---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Deep Dive on Pulumi Deployments | Cloud Engineering Days 2022"
title: "Deep Dive on Pulumi Deployments | Cloud Engineering Days..."
meta_desc: |
    Meagan Cojocar and Bryce Lampe introduce Pulumi Deployments and other features. Learn more about Pulumi deployments at https://www.pulumi.com/blog/...
url_slug: deep-dive-pulumi-deployments-cloud-engineering-days-2022
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Deep Dive on Pulumi Deployments | Cloud Engineering Days 2022"
  description: |
    Meagan Cojocar and Bryce Lampe introduce Pulumi Deployments and other features. Learn more about Pulumi deployments at https://www.pulumi.com/blog/pulumi-deployments/  Pulumi Deployments removes the cloud as a bottleneck and unlocks it as an accelerant for your business. It is available in preview today. Deployments are free during the preview, with usage-based pricing to come. Check it out today:  
  sortable_date: 2023-01-04T19:44:23Z
  youtube_url: https://www.youtube.com/embed/UOTLH7vXUY4
transcript: |
    Hello, everyone. Um My name is Megan and I'm the product manager here at Pulumi and I'm joined today by Bryce, a software engineer on the Plume service engineering team. And in the next 30 minutes, Bryce and I are going to walk you through Plumy deployments, which you just heard about from Joe and Luke, which is a new service feature that's launched today in preview, feel free to ask questions throughout the talk and assuming that the demo gods are in our favor today, we plan to spend some time at the end, um answering questions live now before jumping into it, I just want to kind of give a, a big thank you to the team at Pulumi that built Pulumi deployments. Um Bryce and I are really lucky to be the ones showing you it, showing you all it today. Um But it's been quite a journey for us. We've had multiple cases of COVID. We had someone on paternity leave. We had someone summoned to jury duty throughout the past few months. It's been a big project for all of us to come together and get this out to you and here today, hey, Bryce And here today, we're so happy and we'll show you what we've built and uh we cannot wait for you all to use it. So, really looking forward to your feedback and your thoughts and just to kind of share the excitement of everything we've been doing with you all. So let's get into it. Firstly, I'm gonna walk us through an overview of the feature and the new functionality that it enables my goal here is to answer frequently asked questions and highlight use cases for each one of these tools. Then once you're familiarized with the nouns and the verbs, I'm gonna hand things over to Bryce and Bryce is gonna walk us through the feature live end to end. He's gonna show you an example of the types of systems that you can build on the deploy plumy deployments to meet your organization's needs. And then I'm gonna come back on and we'll talk about our future plans for the future. So what are plumbing deployments? Plumbing deployments enable organizations to scale their infrastructure, automation. And so you've heard a lot about this today from Joe and Luke. But what we're gonna touch on is go through each layer of um complexity and talk to you how you can leverage it in your organization. So you plumbing deployments, you can run any pluming program and therefore deploy any infrastructure on the plumbing service instead of your own system. De pundits can be triggered via the U I via get push via the rest API or by using a remote workspace in automation API. So let's talk through each layer of this functionality. The first one is click to deploy starting today. You can deploy infrastructure with the click of a button from the plume service console. At launch. We support running a plume preview, a plume update, a plume destroy and a plumy refresh all from the dropdown actions in the console. Now, in order to leverage this functionality today in preview, it requires the installation of the plumbing github app. We plan to extend in the future um to other version control systems support. And now you might be thinking, wow, this is great. I can't wait to use it. This will make my life so much easier. But also there comes that next question which is does it make it easier for us to accidentally destroy infrastructure? Plumbing deployments can only be configured by the admin in your plumbing organization and the deploy actions follow the stack access model. So a user will need to have right permissions on the stack to be able to use it. Some use cases in which you might want to leverage a clip to deploy are if you want to clean up a bunch of stacks or, and resources that haven't had activity in the past year and you just want to be able to go to the console and click through easily, you might want to run a refresh to bring in cloud state changes, you might wanna update config and not have to make any code changes. All these kind of ad hoc operations that come up that might not be part of your normal infrastructural processes. So that's the first layer, that's kind of the easiest one to digest. Um And then the next layer of complexity you're gonna get into is get push to deploy. So get push to dely allows you to configure automatic infrastructure deployments in response to get push events. Now, what does this mean? Essentially you can connect a plume stack to a GIT repo branch. And when you open a pull request plume will automatically comment on it with a preview of your infrastructure changes. When the code is then merged, Plumy will automatically update that infrastructure. So the run of plum this enables your organization to set up a GIT based workflow for safely rolling out infrastructure changes. You can also choose to enforce successful previews in order to merge the setup is fairly straightforward for this, which I've included um in the next slide. Similarly, just click to deploy. It requires the installation of the plume github app and you'll then select your repo and your branch where the pluming Yamma file lives. And from there, you can enter environment variables that the program needs and optionally any um pre commands that you want to run along with your deployment. Environment variables can be marked as secret but we're, we will also mark anything that looks like secret to us. And lastly lastly, you can optionally uh include commands which I already covered. So it's just these few kind of dropdowns and then you're set up and ready to um you're ready to go and uh connect your infrastructure to a get based workflow. So both can click to deploy and get pushed to deploy are layers built on top of the plume deployments. Rest API. Now, the Pulumi deployments rest API is a fully managed API to run plumbing programs executed by the plumbing service. And so if you're already using some in-house deployment dashboard or tool, you can plug this into it. It allows you to build your own building blocks on top of it. Um The types of uh functionality that the deployment rest API uh provides is creating a deployment. Uh getting a getting deployments you can get using the ID or the version, get details metadata about a deployment. You can list deployments um get the logs for a deployment and you can cancel a deployment. And so all of this really enables you to build your own cloud delivery tools and functionality. And so an example of this could be that you want to set up an automatic plumy refresh that runs on a current job. And so let's talk briefly about what the payload looks like for the deployments. Um API. So you'll need your plumbing access token. You'll also need um source contacts. And so source defines where the source code for your project is located currently. Only GIT repos are supported in preview. And then the operation defines how the pluming project is to be executed. So the type of Pulumi operation, a refresh of preview and update I destroy and then the um environment variables and pre run commands. And with that, you can either curl it, you can set it up in any language of your choice or leverage our integration with automation API then once you've set up these things um and you have deployments showing in your Pulumi service console, there's this other great tool you can use, which is the visualization of the deployments. So in the Pulumi service console, you'll be able to see the deployment status, the logs of that deployment, the update logs that occurred in the Pulumi update, the environment variables that were used and the git commit for that git deploy for that deployment were connected. And what this really enables for your organization is collaboration. If you're working on something and you're putting out a deployment, you can share that URL with your team member and say, hey, this is what I'm waiting on and they can see the logs, they can see if it fails, what happened and help you debug it. So it really enables that collaboration. And then another great benefit is auditability. So hopefully you don't have a case where production goes down. But in, in the case that you did and you're doing a postmortem, you can look back and see, OK, here is a history of everything that happened and you can check audit logs for when secrets were accessed. And um all that audibility information is available in the plum service console. So the last thing I'm gonna touch on before Bryce gets into bringing this all to life with a demo is the remote automation API. So plumbing deployments can be run via a remote workspace in automation API. And we're gonna touch on this a little bit later. But essentially, you can think of it as there's two new concepts within automation API A remote workspace, which is a class that represents a workspace for running Pulumi operations remotely via plumbing deployments and then remote stack, which represents the isolated um independently configurable instance of a plumbing program which is um managed via the pluming deployments. So this is the overview of kind of all these frequently asked questions and how do you set it up? And then Bryce is gonna actually walk us through the live, bringing it to life and illustrating it all. Um So the first thing I wanna show you is uh the click to deploy use case that Megan mentioned and we're actually gonna start from scratch. So I have a uh a fresh stack here that has never been deployed to. Um You can see that I have previously installed the github app and this is all I need to do to, to enable um uh click to deploy. What we're gonna use here for the purposes of the demo is just this um small little stack. Nothing fancy. It just creates an S3 bucket. Um But let's go ahead and, and set up uh click to deploy with this. So I'll head over to my settings. Deploy. I'm in the deployed demos repo and we have a, a CE P branch and I'm in the Pulumi programs bucket time directory. As Megan mentioned, um There's an option for pre run commands. Uh This could be helpful if you have some uh prerequisite steps, maybe you're generating some code or, or doing something else that you need. Um We don't have anything like that here. So let's just echo a hello world and then we'll see that eventually in the logs when I click save, I now have almost everything I need to deploy. You'll notice we have some environment for ables to set down here. So because I'm creating an S3 bucket, I need ad BS credentials. I don't want to see you paste, see me, paste in my secret. So I'm just gonna run a quick little command to populate those secrets and that did not work. Oh, no. Oh Here we go. OK. Great. There's just a little delay there. Uh This is why we love live demos. You never know what's gonna happen. Cool. OK. So we've set our environment variables. Um This gives our stack, everything it needs to actually deploy. And if we are lucky, uh we should be able to click update here. See a deploy happen. So I just clicked a button. It takes me to my first deployment and now I see some logs while this is working, I can explain a little bit about what's going on behind the scenes. So um what this has done is spun up my own isolated, secure virtual machine and it's um doing some, some setup, it's cloning my source code. Uh Because I have that github app integration, it's able to clone my private repository and then it's doing this. Uh it, it's grabbing my dependencies and it's going to automatically um you know, build my code. Um So I don't need to, to worry about, you know, installing packages or anything. It's just doing that for me, which is super helpful. Uh We don't have much here. So this should be, this should only take a moment. You can see there's the pre run command coming up next and that should uh momentarily show us the uh the hello world that we echo. Um And at the end of this, we should expect to see. Yep. OK. We ran a pre run command. Hello world. Great. Now we've got our Pulumi operation going. Um This should create that S3 bucket that we had set up and there it is cool and we're done. Great. So in a matter of a couple clicks, I was able to start from a totally empty stack to um uh fully deploying it. Um And this is great if uh you know, you have some, some uh use cases where where one off or ad hoc deployments are helpful. But uh now I want to show you the push to deploy uh workflow which sits more in the, the typical day to day developer flow. Um So what we're gonna do is we're gonna make a small change to this stack. And let's just, yeah, let's change. Uh Let's change the bucket to something. Actually, oops create a new branch. Can the bucket name had to get home and let's create a pull request. That bucket name change, we're gonna do the pull request against the CE D branch have some conflicts. That's OK. We'll resolve those. Oh, so the conflicts are resolved. Uh There we go. Yeah. OK. Sorry about that. We are changing the name of the bucket to my cool bucket. Um If we head back to Pulumi Cool. All right. So we have a couple of deployments that showed up. So what's happening here is uh based on this first uh commit that I pushed, it's kicked off a preview action and what that's gonna do, it's gonna um simulate the bucket name change against the existing stack and it's going to post a comment back to my request. Um You will notice that uh there's another deployment queued up here. So I, I had to make two commits there because I made a mistake. Um And this next deployment is actually for uh the, the later commit. Um I'll talk about that a little bit more, but it's, it's cool to note that we're queuing these things up. Now. I uh I'm happy with what I see on my pull request. Comment, the bucket name looks correct. I'll, I'll say this is if they go and we'll merge this and momentarily, yep, we see another deployment pop up. This is actually going to perform the um the update. Let me go ahead and cancel this preview. We don't need that back here. That deployment was canceled. Now, the actual update is taking place. Um And when this finishes, uh we would expect to see some feedback on our pull request that's gonna tell us um that this bucket was successfully created and deployed. So while that's running, um I will say that this workflow is really excellent for um prototyping or maybe you've got some standalone applications that are self contained enough to just kind of like deploy on every single commit. Um But uh lots of you probably also have other use cases that are more complex. Like Megan said, maybe you have some existing pipelines and tools that you're using to deploy um your infrastructure resources. And so next, I want to talk about the rest API um which really allows your existing um pipelines, workflows tools and so on. Um To take advantage of this um without needing to uh to, to give you the flexibility to take advantage of it wherever you want. And while that was uh running, you can see now that it uh successfully deployed our branch and we created the new bucket name. Sweet. OK. So uh you want to take advantage of plume deployments in your existing tools, we've got this rest API for you. Um There's a, a lot here and I'm not gonna go into all of it, but I will say at a high level, you can accomplish all of the same things that we just did um in this push to deploy, case on your own using rest API calls so you can create deployments, you can cancel them, you can list them, you can tail their logs. All of this documentation is available on the um API reference online and just to, to, to show you that I'm not pulling your leg. We can a couple of these, I've got a couple curl commands queued up. I've got an update and destroy. Um Yeah, let's just go ahead and run these. So let's let's do destroy, let's do uh let's do a couple updates and again, we see pre deployment. So there's my destroy, followed by two updates. Um Again, I'll say that this queuing um that we're seeing it's super helpful. Uh I don't know if you've ever tried to run uh multiple flu cli commands concurrently. But if you have, you would find out that you're actually only allowed to do one thing at a time on a stack because we don't want um these things to compete with each other. So if you're trying to do this yourself, these things would error out, you would get an error saying sorry, there's something in progress. But because we're going through Pulumi deployments, we're able to queue these things up for you and we're able to, to take care of them all in the order that they're submitted. So there's my destroy that finished. This is gonna create the bucket again. I'll cancel this one because we don't need it again. Super super helpful that it's queued up and uh handled gracefully like that. Cool. So uh that's a, a super high level um tour of the rest API. But lastly, I want to talk about the automation API and how that has been updated to support deployments. Um If you've never um used the automation API I highly recommend checking it out. It really does take things to another level when you start programmatically managing stacks like you would any other cloud resource. So uh automation API is awesome and we've updated it to work with Pulumi deployments. Uh I can show you an example of what that looks like. So this is a typescript example um where I'm simply just destroying a stack. Um The context I provide is similar to what you saw me put in um the website where there's some github uh details, there's some credentials and all this is gonna do is destroy a stack. This is typescript, but I think it's also available in Python dot net and go. Um But how do we actually like apply this in practice? So I've got this automation API that's gonna destroy a stack. Well, Megan mentioned this example where uh you could have some sort of time bomb stacks or stacks that destroy themselves. So for example, uh if my developers are deploying stacks in development and I want to make sure that they clean those things up, I want to clean up the resources um Instead of letting them linger for weeks, uh we could accomplish that with a uh an architecture like this where I can tag my stack with ATT L. So suppose this 30 it could represent minutes, days, whatever. So suppose I tag it with att L of 30. After deployment happens. Pulumi has a feature called web hooks which can inform our lambda that something happened with the stack that LAMBDA can then schedule a step function that sleeps the appropriate amount of time and then it can wake up, trigger another LAMBDA which triggers this automation api to destroy our stack. That's a lot. Um I want to uh I, I will say that I've previously deployed uh this half of what I'm describing. And so um there's another nifty feature called Pulumi logs. If you've never seen it super cool. I can just tail all of the um components uh involved in my stack and I can watch um lambda's git um invoked for example. So uh what we could do, like I said, we can add a tag, tt L tag. I'm gonna give this a tag of uh att L of zero. So we're just immediately gonna destroy the stack. I don't wanna make you wait. So it's got a tag. Now we kick off an update and again, after this update hap happens, it's gonna sleep for zero seconds, wake up another lamb die and it's gonna do a destroy um While that's uh while that's while we're waiting for that to happen. I'll just briefly recap what we just demoed. Um You saw click to click to deploy. Um We were able to set that up with a couple clicks in a matter of minutes and deploy a brand new stack from scratch using github repo showed you push to deploy. So we were able to incorporate that um preview and deployment functionality into our pull request workflow. I previewed the rest api behind all this. So you can incorporate prelim deployments into your existing tools and workflows. I showed you automation API and lastly, we're seeing how this can all fit together in a, a hypothetical use case where um we clean up stocks after cool. OK. So we're watching the logs that LAMBDA, it found the TT L uh tag on my stack it in queue to destroy operation. And if we pa hop back over here, we see another deployment was kicked off by this automation API code and this is going to be our destroy operation. It's gonna clean up those buckets and Yeah, great. We see that two resources were removed. And with that, I am done with my demos and I will hand it back. The last thing we wanted to touch on is just an overview of um where we're planning on going with this feature. So today, we're launching plumbing deployments in preview and in preview, the feature will be um free, but we are planning on pricing it once it becomes generally available, what that looks like will depend on our preview data and usage, but it potentially could look like compute minutes. So we charge for every minute of um update time. And so when the feature does go generally available, the types of things that we expect to be building are things like self hosted agents um which allow you to run it within your own environment for protected um stacks or sorry for, for um uh things with firewalls and whatnot. And then we also, as I mentioned and I think Joe also mentioned um are planning on adding additional to github um other version control system support. Then Bryce today demoed um this kind of temporary stack environment. Um We are planning on having functionality like that or drift detection and more so we're really looking forward to all of you trying out plumy deployments and giving us feedback on, you know, this is the types of things we built with it and that can inform our road map. Um And we're looking forward to seeing what you do with it so we can skip the summary, I think Bryce covered this. Um So thank you, I've dropped the URL here. Um You can go there and request access and enjoy a happy building.

---
