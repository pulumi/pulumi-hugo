---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Ep 006: Automating GitHub with Pulumi"
title: "Ep 006: Automating GitHub with Pulumi"
meta_desc: |
    This week, Luke and Matt will show us how to automate GitHub with webhooks, serverless functions and Pulumi http://blog.pulumi.com/managing-github-...
url_slug: ep-006-automating-github-pulumi
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Ep 006: Automating GitHub with Pulumi"
  description: |
    This week, Luke and Matt will show us how to automate GitHub with webhooks, serverless functions and Pulumi http://blog.pulumi.com/managing-github-webhooks-with-pulumi
  sortable_date: 2018-07-18T19:50:37Z
  youtube_url: https://www.youtube.com/embed/OlyUnNXBqK8
transcript: |
    All right, good morning, everyone. Uh Welcome to this week's episode of Pulumi TV. Uh My name is Luke Hobin. I'm here with Matt Ellis, uh also from the team here at Pulumi. Um And today we're gonna talk a little bit about Pulumi uh and about, in particular, um using Pulumi to manage github web books. Uh So, for those of you who haven't uh joined us and uh checked out one of our uh streaming sessions before uh Pulumi is a development platform for the cloud. Um So it makes it easier to get your code to the cloud faster uh and collaboratively. Uh And so that can include a variety of things from, you know, uh deploying containers to deploying serverless apps to deploying raw cloud infrastructure. Uh And then ultimately to combining all three of those things together uh to build apps that use the sort of best of each of those worlds. And actually, the example we're going to talk about today is going to touch on kind of some of the servers piece and some of the kind of combination with uh other cloud resources and even resources that people don't think about necessarily as being the cloud but are, but are part of kind of products that people use uh quite frequently. Um So, yeah, so today's topic um is going to be talking about using Pulumi to do github web books. And this was actually a project that Matt uh worked on recently. Um and then wrote up a great blog post uh about. And so I'll switch over to the blog post. I think today we'll just kind of walk through the blog post and talk a little bit about some of the concepts that he covered there. Um So first, uh Matt, tell me about kind of where this project came from. Why did you end up working on this? Yeah. Right. So at Pulumi, um we use topic branches for our workflow uh on github. So instead of forking Pulumi and submitting a pull request from your fork, you push a branch up to the main Pulumi repository, um open a pull request from there or iterate on it. And then when you're done, you merge the polar requests. And if you're a good developer, you click the delete branch button right away, but I am not a good developer. I always forget to do that. Um And so what happens is we end up having a bunch of these topic branch linger. Um And so when you go to github, you'll see a bunch of branches that are like topic branches that are months old and have already been merged in and it just clears things up. Um, and so sort of realize, well, I'm never gonna be able to, to learn to click that delete branch button, but what I can probably do is tell the computer to go click the delete branch button for me. Um, and so I thought, ok, I want to go do that. Um, and it seemed like the kind of thing that would be natural to do in Pulumi. So I just sort of got started on that. And so it's actually, I mean, this is kind of one of those interesting things where, you know, you think, oh, I can just go and tell the computer to do that, but that sort of requires doing a bunch of work right now. Um So what, what kind of, what, what do you need to do to make uh to make that work? Right. Yeah. So uh the has this uh very nice uh thing called web hooks, which is basically you can register with github in HTPN point and any time an event happens in github, you can say you can sort of filter the events you want to listen on. Um It will hit your hhpn point with a Jason payload that says here's information about the event that just happened and once you have that you can kind of inspect that and say, oh, I want to go take this action, right? Um And so uh what sort of end up happening is that like inspecting that event and taking the action is like a kind of a small amount of code, like, especially because um github has great svks for like, hey, I want to, so we just go delete a branch, you know, that's like one function call in, in their SDK. Um And then, so what you have is sort of, you're like, OK, well, I need an HTPN point and, you know, now that's sort of the thing that I have to go solve, right? And then you kind of sit there and like, well, man, I really don't want to be in the business of like maintaining the web server or whatever to serve this HTN point. Like I just wanted to call these like three lines of code when this thing happened. Um And so Pulumi makes it really easy to get that HTPN point. And um sort of let me focus on writing the 33 lines of code and use abstractions that manage, like getting the actual HTPN point that set up. And it's one of the things I always noticed that, you know, there's all these different uh sort of offerings like github that have lots of great web books and things they develop, but the buried entry for those tends to be pretty high and they only get used when they're really important. Not for all these little things that people would like to use them for, to just improve their quality of life just because it is a lot of work to kind of go and get that set up even though they only want to run a couple of lines and not just set it up, but then manage it and keep it alive and then see what its status is and everything. So, so why, why was Pulumi kind of a good fit for this? Like why did you think, hey Pulumi can help make this easier for me? Uh Well, so I mean, the, the, the main reason was I knew I needed this HTPN point. Um And I knew Pulumi had this package AWS serverless um that made it very easy to expose an HTPN point uh backed by LAMBDA um with, with relatively little ceremony on my part. Um And you know, the sort of nice thing about that by using the AWS serverless package is I get uh I get this serverless function. So Pulumi, the company is not paying, you know, $30 a month or $5 a month or whatever to have some web server that's sitting there idle most of the time and periodically like responds to adjacent payload for, you know, 100 and 50 milliseconds and then goes back to sleep. So serverless was a, was a nice sort of um deployment model for this thing. And then Pulumi just makes it super easy for me to uh put code inside a serverless function basically is CC is like just, you know, the idea of paying only for the, the compute that you need to use, especially for something like this where the total amount of compute is tiny and it's going to be spread out over time and, and not very consistent. Uh lo um, that's, you know, seems like a perfect fit. So let's look at like maybe how kind of you, you started off, I think you started this with kind of an example of the bare bones thing, you would use that library. So, so let's look at that. Um OK. Yeah. So, so this is kind of like hello world um serverless uh the, the AWS serverless package, right? So um you uh we have this resource called serverless API I gateway API uh you create it and then you have some information about the route. So here I'm saying I want to listen on slash for posts and then when a request comes in, um I can just define my handler in line which is like, actually really, really cool. Um And so all I do right now is just say, hey, I got this event. And so um the github web host, when it comes in one of the headers it sends is this github uh event thing. This is just like a, that sort of uniquely identifies the event that you're processing. And so I log into the console and then I just return 200. OK. And then, so at the end here, I just uh this API uh when this thing is created pine, it actually makes that HTP N point and this property on that API is the PN point. So when I uh deploy this application with Pulumi, it goes and builds about I think 10 or 15 resources for me. Um And then at the very end, it, it spits out, hey, here's the actual HTPN point um that will go respond to this. Yeah. So, I mean, I think that's one of the interesting things about this. It kind of, you know, when I read this, I think, oh, this looks like kind of just a, a normal, you know, obviously this is this javascript we're using here and it kind of looks like maybe a new Js app that, you know, uh builds a web API and it is that, but, but the key thing, I guess, you know, saying this actually deploys some resources in the Aws, right? So when I do the Pulumi update, um I get real uh running resources in Aws that are ready to handle that, that API it's not just a process running on my local machine. Um So OK, so, so this, you know, this example works. So um there was a couple of things here, this is javascript or um I guess maybe is this, yeah, this is, I guess this typescript, maybe it's like a typescript uh when I needed types to sort of shoot my sanity. Right. Yeah, fair enough. Uh, but yeah, we could, you know, we can use javascript or type for this example. So, uh, this a W serverless package, you know, we're using here, this, um, API type. Um, can you talk about like, what, what is this a service package? Um, kind of what? Yeah. Yeah. Right. So, um, so like AWS, uh, service package, I guess is kind of like this sort of higher level framework over Pulumi um raw Aws package. So Pulumi has this uh at Pulumi AWS package which basically just gives you um wrappers over all of the physical pieces of infrastructure that exist in the AWS cloud platform, right? Um And so it turns out that if you say, hey, I want to write a serverless function, um the pieces that you end up needing, um when you do that in Aws, there's actually a lot of moving parts, right? So you need this Aws lambda object, which is the thing that actually holds your code. And then, um that's kind of just existing in Aws and you're like, OK, well, now I want to make that uh have an EPN point attached to it. So you have to build this thing called an API gateway. And the API gateway needs a bunch of configuration of like what are all of the routes, what are they hooked up to blah, blah, blah, blah, blah. And so API or AWS serve list basically provides an opinionated framework that says, hey, this is kind of a nice way to go write a, an API and internally the implementation of this resource. It's just something that manages the life cycle of those, you know, 15 other resources, the lambda that you actually have your code in the API gateway that actually puts it on the internet. All the I AM permissions that are necessary for everything to talk to one another, right? And so I don't have to like, think about any of that stuff, right? I just say, oh, I've got this thing that has this like shape of an API and it's kind of got this nice interface that I can reason about. Um and all of the complexities of like all of the stuff that needs to be spun up on AWS are sort of hidden from me and managed by this um abstraction that we've written um for people to use. OK, great. So you get to deploy realist resources but using the sort of higher level API that's kind of like how you think about doing it. OK. So when you, when you try and deploys with Pulumi, uh what does that kind of look like? You know what? Uh yeah. So, um so, you know, after I've uh I sort of uh built this, um since it was a typescript, you know, I would run TSC. Um and then I would do a Pulumi update. Um It sort of uh spits out this nice preview of uh what it did, right? And so we were talking about the number of resources that got created and you can kind of see them here, right? So this API gateway is actually an abstraction over um this rest api this deployment uh LAMBDA permission and a um an API gateway stage, which is like an API gateway concept of uh if you wanted like production and staging from the, the same API. Um They, they have a nice way to do that. Uh I didn't have to know what that meant, which was a nice one to use this. Um And then you also see the function. So this is like the actual LAMBDA that gets created and you can see it, it holds not only the AWS lambda, but an im role in some role, policy attachments that grants permission to API gateway that says, oh API gateway, you can enjoy this sort of thing. So it builds all of that stuff for me. And because I had used this output property, I had exported the URL property of this API from my program. Um at the very end, it printed out. Oh, here's the actual API to go use. OK. So now you could hit this API and you'd actually, you know, run that piece of code, right? Yeah. So you could, you could go curl this uh with, you know, dash X post and um that console dot log would run, you wouldn't see that. But what would come back is a um status code of 200 in a blank body, right? So you could see through curl like, oh, that API exists and it is returning 200 right? Um Great. So I guess this gives you away in a couple of seconds and you've got this deployed and uh um and running an address. So one of the notable things about that, that code, um you know, it contained kind of both the description of the routes, like, you know, the path and the method and things. But then as you kind of pointed out, it also contains the code that's actually going to run in response to that handler. So that's kind of a different thing. Oftentimes we see things where kind of, I use a file or some sort of configuration language to describe the kind of routing and things like that. And then I, you know, put my lambdas in, in javascript or P or whatever here, we're kind of combining those. So like why, you know, is that, is that a good idea? Is that why is that interesting? I mean, I, I like it because like, well, it, it, it's just like, I don't know, it just feels right, I guess in a way, right? It's just like, oh why do I have to have like two files that I'm like, all tapping between or whatever? Right? And like you know, um I guess the kind of the other nice thing here is that like, so the, the um the API gateway when you, when you act or so, um yeah, in Aws like API gateway, the function that you actually export uh that, that Aws is gonna call, right may have a different signature um than sort of what we have here, right? If they take a couple extra parameters, um there's probably some uh work that has to be done to, you know, decode um heads and this sort of stuff, right? And so all of that stuff, I kind of didn't have to worry about like there's this already, this abstraction is like handling some of that stuff for me. So it is interesting that like this code here, this is the code that I wrote. There is a little bit of clue code that the person that wrote server P I gateway API wrote that sort of says, OK, I'm gonna transform the request that came from AWS into something that like kind of feels more natural to work in. And so that's kind of this other nice thing about being able to merge those together if you get like it's sort of natural to build those kind of interactions. And I think, you know, also here like, you know, these are small pieces of code. So if you had to put these five lines of code in the different file, it feels a little you know, little silly, right? You just want to kind of express the handler right here. Um, of course, if these became larger, I guess you could move them into a separate file and manage it all. Yeah. And, and, and so instead, uh handler being some, you know, arrow function defined in line, it could just be a reference to some function that I find in the different file or whatever. Yeah. So you talked about the, the log statement there, kind of, you know, you obviously don't see it when you curl this thing because it's, you know, it's logging in inside the, you know, the server where the lambda is running and things. But so how can you get that? So you obviously put it here so you could use it to kind of debug and iterate and things. So, yeah. So, uh Pulumi has a, a Pulumi logs command. So you run Pulumi logs and you can do Pulumi logs, dash F and it will sort of follow everything. So, um, once I had taken that URL and hooked it up to, um to github, um one of the things github starts to do is it just starts to send those events and kind of the first event that it will send, uh when you set something up is a little ping event that lets you sort of know that the web hook is working. Um And then in this case, I like actually went and opened a pull request. And so you can see here that when I ran Pulumi logs, I got kind of two events. The first is this ping event that uh came from when I registered the uh event hook on github. And then the second is this pull request event which happened because I opened the pole request because I wanted to test things, right? Um And so at this point, I know like, OK, the infrastructure is solid, right? Like I'm, I'm connected to github. I'm getting the events and now I can start to focus on like my application logic. So I mean, a couple of things I noticed just looking at this, you know, one is obviously these things are running in very short periods of time for each one of these handlers is that first one is a little slow probably because the the land is warming up or something. But the second one, you know, is one millisecond, I guess lamb is the minimum duration of for billing is 100 milliseconds. So each one of these is easily uh running in that time. So, you know, the total amount of compute here is tiny as we were kind of talking about before. We can actually see kind of a bit of detail about that from, from these. But it's interesting um you talked about kind of hooking this up on github. So, so kind of tell me about like, how, what do you have to do to hook this thing up on, on github. Sure. Right. So, um so you sort of start by, if you go to your repository and you go into the gear and settings, there's like a web hooks thing. Um is like settings, web hooks and a web hook. And then when you do that, it sort of gives you this form, right? And you fill out a bunch of stuff. So one thing you have to give it is the URL, right? Um The other thing is you give, it is the content type. So we can send either like form encoded data or application Jason. Um In this case, since we're doing everything in javascript, it's easier to just say like, hey have the payload be application Jason instead of form data that I have to like go parse and, and turn into some job check. Um Another thing that they do is so the way webhooks work, as I mentioned is you've got this HTPN point that's just sitting there on the internet, right? And it's completely unauthenticated um because they have to like make a request to it. Um And so one of the things that they encourage you to set is a secret, um And so you just basically give them some un guessable value. Um And they use that to sign request that they send off, so you can use that in your web hook to validate that the request is actually coming from github and someone's not saying like, oh IO closed apr that like, you know, deleted this branch and or that that was from this branch and then you know the goes and deleted. So that's um kind of cool. Another thing I mentioned earlier is you can pick what events you want to subscribe to, so you can subscribe to everything and then just do filtering on your end or you can have github do some filtering, right? So in this case, I only cared about for request events. So um by doing that, it just means my uh server dysfunction runs less frequently, right? I don't get a a notification that I don't care about when an issue is opened or when a comment is made on an issue or something, right? Um Got it is, I mean that that like is uh it makes, you know, makes sense, it great to kind of have these capabilities uh to hook into the, the interesting thing is kind of all that is kind of a bit of point and click, right? You kind of have to go into the get console and, and manually configure all this stuff. And uh and if you want to stand up another instance of this, you know, with Pulumi, it'd be easy to stand up another instance of this API but then you'd have to go and redo all this manual work uh to do these steps. So I guess that's something we're going to talk about a little later is kind of how we can maybe extend this to, to take care of some of that part for you. Um But uh but yeah, uh show me about, um you know, you talked about the secret part. Um And so we obviously have to have kind of a secret that we both, you know, we get in the github and that's fine. We can make sure we're on htps and everything over there. Um How do we then do that in the Pulumi program? We want to get that secret into our program and make sure that it's not just sitting in plain text in our github repo or whatever. Yeah. Right. So, um so Pulumi uh has this uh configuration system. So you can basically um set uh configuration values for uh every Pulumi stack. So Pulumi is concept of when you spin up a an application, basically, you get a stack. And so if you want to spin up multiple copies, you can have multiple stacks. Um And so the config system allows you to basically uh set values that sort of vary per stack, right? Um And so if I wanted a uh uh a secret that sort of very per per stack, I can use um Pulumi config to do this. Um One of the things that you can do with Pulumi configures, you can pass this dash dash secret. Um And what this does is um the the secret ends up in a a YAML file that is sort of next to your application. Um but it is encrypted with a key managed by Pulumi dot com. And so when you go to deploy your application, it will uh decrypt that secret and present it to your application so your application can work with it. But um at rest, it's encrypted so I can go check that YAML file in and if someone like has access to the github repository, it doesn't mean that they have access to my secret, right? Um Yeah, great. So, so then we have a way of kind of passing these secrets in and using them at deployment time to embed into the, the code that we're gonna run in the cloud. But um but I can separate them from the actual code of my github project. OK. Um Great. Uh So is the next step. So you kind of talk about, um you know, I guess here, here you kind of ended up building the uh the actual ability to sort of decode some of the signature and things and all that. So just kind of, you know, doing the right things with github API S. Um uh But the, the next section you kind of talk about uh building an abstraction. Um So why, why did you at this point kind of think about, you know, building an abstraction? Well, I guess the reason that I, that I thought about building an intra is I'll bring the code back onto the screen. So it's like a screen worth of code and all of this stuff is ceremony, right? So like literally the the only thing that I have here application rise is like this console dot log, right? So if you think about the code, how it had changed from what we had before, sort of all of this uh this region here is new code that is basically just dealing with decoding the request and making sure it's on github, right? Um And so every hook that I write, I don't want to have these like 25 lines of code to do this. Um And so I thought, oh, well, building a abstraction would sort of let me deal with like, let me hide all of this complexity and say, OK, you know, make sure that the the request is valid and then like call into my actual handling code, right? Um And so then as I do this, I don't need to like, remember how to write this like 30 lines of code every time, right? Or copy and paste it from somewhere. So, you know, this is all code that's sort of just about uh building github webhooks. Uh Not, not about the web book that you want. Right. Exactly. Right. Um So what, so what did that abstraction look like? Right. Uh So it sort of began is um I just have this, you know, general function, uh just a regular javascript function uh called Create Webhook. Um And basically, it takes in um this handler. Um And so the handler this uh is gonna be the actual application logic that I care about going back to the first example that would be, you know, the console dot dot event. And later, it's gonna be the thing that actually like figures out if we need to go delete a branch or whatever. Um And sort of all this abstraction does to begin with, right? Is it just creates a creates and returns this uh service API gateway API type. Um And then you can see sort of in the uh in the body of this thing, like here's all the ceremony again and then we uh call my handler, right? Passing in the request and parsing the the Jason body, right? So my request is gonna get or my my handler is gonna get the API request and then also just adjacent object, right? So it's handling all of that decoding parsing for me. Um And then once that handler completes um we just and status code 200 if, if this handler had an error, then this thing would fault and API gate would return, you know, 500 internal server error. Go look at it, right. This is, you know, one of the interesting things I think about this, you know, we kind of skipped over the beginning where, you know, we have this kind of system with Pulumi where you can use javascript and program languages to kind of deploy cloud infrastructure. Uh And here, you know, we're taking advantage of one of the main things that that gives us, which is we can create, you can use functions, right? So, so you know, you have this uh this great webhook function and you're just able to say, hey, this is a bunch of code that's kind of common and I want to have to give it a name, I wanna, you know, parameterize it. Um And I can just call that a function, right? It just feels obvious that I would do that. And as soon as you saw that all this was kind of boiler plate that was logically separate. You just said, hey, I'm just going to give that a name and separate it out. Um So I think that's, that's a really kind of neat kind of thing to see is just that, that process of how you get to, to creating, you know, the attractions. And I think when we use the word objection, it feels maybe a little heavy but you know, here objection just means, hey, I function, right? It's like, it's like, oh there's something that I'm doing a bunch, right? Like I'm gonna put that in a common method and, and separate out the actual like piece that changes, right? And, and so like, yeah, it's, I mean, this is like, it's something that, you know, when you're programming, you do all of the time, right? You're just like, oh, I have this method and I'm doing the same thing, you know, let me figure out how to, like, extract that into its own method and make up sort of this reusable thing. Um And so it's so nice to be able to like, do the same thing with um cloud infrastructure, right? Like, um and the other thing I thought was interesting kind of looking at this, you know, you, you have this handler that you pass in here and then you kind of wait it inside. So this is, this is a code again that's gonna run at run time because it's part of this, you know, part of this main handler you've got here. Um But you're actually taking part of that is from one component and then it's calling code that's gonna come a callback that's gonna come from another component and that I guess it just works. And in fact, like this sort of pattern is similar to the implementation of um of the AWS serverless API, right? And we sort of saw that uh before with the output, like there was this a AWS server list function that got created and then had like an aws function underneath it, right? And so like this idea of like, oh I got and you know, set up code or whatever and I want to make that comment and then I'll like take in a handbook that actually is the the users um code to call, right? Like it kind of this common pattern and, and it's very useful when like building these abstractions, especially given the fact that we can like pass first class functions around in javascript and sort of like compose them in these interesting ways, right? Um No. So, so what does it end, you know, you've built, you, you've checked this away in the great web book. So what does it end up looking like? So we go down a little further. So, um so now sort of if we pretend all of this stuff was in a different file, um which is hard to do in a blog post, but easy to do on your uh file system, right? Uh So now we sort of have this api create web hook, I say the hook and then I've got the request in the body and now I've changed my concept a lot to be like God event, here's the event. And then I can also show what the action was, right. Um And so this uh this body object is just this Jason object that you have been sending to us, they've documented the shape of it. Um And all of them have this action which in this case would be pull request because we'd only subscribe to uh pull request events. Right. Right. And so this, now this great web book is something that, you know, anyone could go and, you know, copy this in or you could publish this up to N PM or whatever and someone could use it and then just with these couple of lines of code here, actually, you know, start building their own web books. Um, ok. Uh That's awesome. Um, uh So what kind of, what point was that at now? You were able to kind of build the, the app you really wanted to build in the first place, right? Yeah. Yeah. So um like, yeah, so sort of given what I have here, um I can, you know, call create web book and I can go in the body of this um AYC function sort of go build all of my application logic. So, like we sort of care about looking at. Um so, you know, body action when it's pull request, there's some additional data on the body that says, like, what, what is this event about the pull request? Is it, is it because the pull request is opened or closed or whatever? And so we can say, oh well, if it was closed, then we can start looking at like, well, what was the source branch? What was the target branch and start doing uh some filtering on that and like actually say, oh OK, in this case, we actually want to delete the branch, right? Um And so I think they kind of show um some, some more of that stuff down here, right. So, um here you sort of like have the uh create web hook thing, this hasn't changed. Um And then I have my call to create Webhook and I'm sort of doing these tests, right? So I'm saying like, if the action is closed and it was merged blah, blah, blah, blah down here, I'm basically just using the github SDK, right? So, um I just get the uh get this kit, which is the official github SDK. Um II, I authenticate with it uh using a github token. Uh The github token is another thing that we um use our config system to pull in as another secret that's also deployment time secret that we can. Um And so I say, oh OK, well, if it's sort of um hit all these cases, then I'm gonna log, then I'm gonna go delete the, the reference, right? And then I just use the github API to go delete the reference. So this is like the code that I wanted to write. Like this is the interesting bit, right? Um And all of the uh the ceremony now is behind this like create web hook thing which is like pretty nice. Um And then, yeah, so that kind of just all works, which is pretty cool. Um It's, yeah, when I, when I was doing like this, it's like always fun for me. It's like you do the thing and it's like, oh I told the computer to go do something and then you like click the merge button on github and you, and you then like a minute later, you know, a couple of seconds later the, the bot deletes it, right? You're just like, oh, actually work, right? And it's just this like, super cool feeling to be able to like, build these sorts of things that like, you could have, you know, you always were able to build them, but it was just so much work to go do that. You're like, do I really want to put in an hour and a half to like, go do this? Maybe I'll just learn to click the delete button, right. Yeah. And lots of people, lots of people stay there for a long time. So, so, you know, obviously, you know, we've talked about kind of, you build this up and you deploy it. But, you know, one of the things I can find is, is just as challenging, like, you know, like there's a lot of things I could go and stand up, you know, a Roku or whatever to run one of these things. But then there's always this fear of, oh, well, I need to manage that. Now, how do I go and see what the state of it is? What resources if I need to update it later, how do I do that? So, kind of uh you know, one of the things with Pulumi, I guess is this is you know all that, that state of the running application is actually in, you know, the Pulumi back end and you can go and see that. So, uh do we have an example here? So we, so I've deployed uh this application using Pulumi, of course, um and it's deployed into our Pulumi organization. So one at the Pulumi company can sort of like go look at it if we bring over uh sort of um the web console view. Um I can see some information, right? I can see that I've deployed it to us West two. We mentioned that we had this configuration system and so I've got these two secrets here. One is a token for at, at one time when I want to authenticate with the github API um what I use and then the other is the token at deploy time. Um because I may need a different token to actually install the hook. Um And we'll sort of get to get to that. Um because that's sort of pointing at something we haven't talked about yet, but we will talk about soon. Um But then you can, you know, just sort of also see like, oh, here are all of the resources. If I wanted to go to the AWS console for any of these things, I could very easily click this and it would pop up another tab and um have me look at it but, and then the activity we can kind of see, you know, so you can see me failing uh very, very, uh often as I uh try to do this, um trying to get the uh correct tokens with the correct permissions and learning. Oh, this account doesn't actually have the ability to go register the hook and so I need this sort of thing. Um, but actually, I often think that's interesting that, that, that aspect of kind of uh the iterative development and kind of, uh, you know, the getting errors and, and using those to go and fix problems and things like, but being able to do that in a very tight loop. But while deploying to a cloud provider right here, you're kind of all, each one of these is an actual deployment, you know, into get into, uh, into AWS, but, you know, you're iterating on this and, you know, seconds. Exactly. Yeah. Um, so I think it's, it's actually, you know, they're failures, they look, you know, they look scary but they're actually part of the process, um, of kind of, you know, quickly, uh, you know, exploring and building new software. I think it is actually very cool. So, so you said, you know, this is one book that we kind of have to talk about. So, so what was, you know, like, you're kind of at this point you've got a working thing, like, what did you feel was, was not yet, uh, you know, not yet all the way there. Yeah. So, I mean, the like we sort of mentioned at the beginning, you know, how do you this up to github? Right? And, and the answer is kind of unsatisfying for someone who is helping um build tool uh which was open a web browser, go to a web page and like click buttons, right? Um And so like that is that like just isn't the sort of thing that I want to be doing, right? Um I would love to be managing that with a repeatable processing code. Um And the github SDK actually has a way to go, you know, register a webhook so I could write a, a small um no Js program that would actually go and do that, right? Um And so that's like kind of better and I could hook those things up with scripts, right? I could run my Pulumi deployment first. I could use this um Pulumi stack output command to actually get that URL and I could pass it as input that URL to another program that was just going to use the github SDK to like, go to some bits on github. Um And that would certainly be better than me having to uh go into the github console and like, poke around and things. Um But it's still a little bit unsatisfying because, well, now I've got this shell script that like merges these two programs together and like, that's kind of just like another thing. Um but the, the sort of really interesting thing is that like Pulumi can, you know, Pulumi can manage, sort of like any cloud resource that has these crud operations, right? Um And so these github Webhook registrations on github side, they have these crud semantics, right? I can, I can update one, I can remove, uh you know, read one, I can delete one. And so Pulumi since it's like, it's bread and butter is supposed to be able to manage those things, right? It felt like, oh, managing this thing in Pulumi is probably what I'm gonna want to do. And then I sort of get back to my program which not only deploys infrastructure to A W US, it takes some of the uh results of that infrastructure like the URL and then goes and deploys infrastructure to github, which is this github uh hook registration. Um And so Pulumi has uh many ways to sort of do this. Um So the, the architecture of the system is such that these resource providers are out of process components and we uh interact with them through GR PC. Um And so I could have gone and like taken Pulumi uh Gr PC interfaces written my own little like go program or, or java program or whatever that like actually implemented um this thing. But it turns out that uh another thing that we have in, in our um node SDK. Pulumi, no SDK is this thing called a dynamic resource. Um And this is something that we built at first for testing. Um because it lets you define a resource provider in line in javascript sort of with your application. Um And that's very helpful for testing when we say, oh, we want to construct these interesting, you know, object graphs and then go delete things to make sure we don't have bugs. Um And you don't want to have to be like, oh, I'm gonna spin up 38 WS buckets. So Aws resources, right? You just say, oh, I just want to like kind of create this object graph. Um And so the dynamic provider gives you a way to do that by basically implementing um this GR PC interface in javascript in your program. Um And so once you have that, you can say, OK, well, now I can go implement the provider um in javascript in my application and I can use the get SDK under the hoods to actually do the, the co operation, right? Um So I guess, you know, the idea here is like we the the examples before we showed, you know, um Pulumi has an AWS provider which is kind of uh you know, exposes the whole surface area of aws and all the resources that can be managed there and has, you know, providers for Azure and Google cloud. And uh you know, I think we recently added open stack. So a bunch of these providers, but here you kind of had another thing which you, so I sort of thought of as the same way, get help, kind of has some resources that you want to be able to manage the life cycle of. Uh, and you thought, well, you know, hey, can we, can we add a provider for that as well? And this was a really simple way of doing it where you could just write it right in line inside your javascript programs. Ok. So, uh so what does that end up looking like? You know, I guess you're saying you talked about court operations. So, uh so there's kind of um there's, there's when you're, when you're using these dynamic providers and these dynamic resources, there's kind of two things that you do. The first is you, you actually implement the provider. And so this is the thing that like is actually handling the credit operations and then you build resources on top of that, that use the provider to manage their life cycle, right? Um And so what I basically, um there's like, I think four or five methods that I had to implement this check, di create uh update and delete uh thing. Um And basically, this is just the, the GR PC contract that we have for resource providers. So um check ensures that the set of parameters like you basically have all of the required parameters, right? Um And so, uh basically, I know that you, when you create a, a web, you need the URL. This is the web hook that you're gonna hit, you need the owner. This is the repository that the hook is going to be installed in or the the owner of the repository, it's gonna to be installed in and then the repository itself. Um And so I can implement this check method to kind of give a nice failure if you try to create a uh a resource that doesn't have one of these props said. Um So diff uh diff is sort of the thing that um lets me figure out, oh, has has something about this resource changed, right? Um And today, diff uh actually the Pulumi engine does a lot of the diffing logic for you. So it will, it will look at the old state of the resource, the new state of the resource and see if anything changed. Um The one thing that it, it can't figure out is um when is, is to understand like, oh, would it change mean that like I can just update the existing hook registration in place or do I have to actually delete the hook registration and create a new one? And it can't know that. Um And so this di method, one of its responsibilities is to tell you that, right? And, and so basically what I do is say, well, if either the owner of the repository has changed since the hook registration is tied to the owner repository pair, like we need to delete the old one and create a new one. But if like the events you're listening for or the secret have changed, um we don't need to delete it, right, we can update it in place. Um And so then like the, you know, we won't go through the details of all the credit. But, you know, I think the interesting thing is in these versions, this is where we actually make calls to using the library to, to github and we actually make changes uh to the set of registered web books, right? And so uh and so I guess here, you know, we, we create it, you know, we update it and we delete it, right? That's kind of exactly what you expect. Um But we have now because we've embedded that logic in here now we can just go and create one of these get web book uh resources and then manage its life cycle just as we would any of the resources. So what is the, the code that uses this look like? Yeah, so um this uh so this interface here in this class is sort of like what you would think of as the the actual thing program, right? You don't program against the provider directly instead. Um Just like we have that, you know, serverless API type, we now have this github web hook resource type um that you can new up and you can pass as input uh arguments to it, sort of the, the owner of the repo these, the things that are, are necessary. Um And uh you, when, so now when you new up one of these things you pass in um this arcs bag of these sort of things and it works with the provider, uh which itself works with the Pulumi engine to manage the life cycle of that resource, right? So I don't have to think about any of this complex code up here. I just say, oh, I can do new github web hook resource um and, and handle the registration as we kind of show down here. Yeah, so I guess then the end result is that, hey, like the user of this just writes these, you know, four lines of code and, and as a result, they now have a github web book that uh you know, and if they go and when they first deploy this, it'll deploy, you know, this web book. But hey, if I go and change this URL, perhaps, like if I end up replacing my uh my API gateway with a new one or something, uh then it was just update in the place. And if I change the owner of repo, it will actually go and, you know, tear down the old one and recreate the new wave for me and Pulumi will take care of all that life cycle stuff. Right. Yeah. And, and so like the other, the other thing that's great is because Pulumi like handles that entire object graph, like you mentioned, oh, if the URL changed, right? Like if the UL changed um now the program is gonna handle everything for me. Whereas previously, if the URL changed, I would need to sort of remember. Oh, hey, I I saw Pulumi change the URL. I've got to go back to github and like go change the URL and the registration. otherwise github is going to be sending messages to an endpoint that doesn't exist and be upset, right? And that actually points out an interesting thing here, you know, you passed this API dot URL, which was the output of the API that you created using the S A server, be able to sort of take the output of that component and pass it as an input to this component. Uh How does that work? Uh Like um you know, like does that create some relationship between these to make sure that, you know, you're saying that now we know that. Yeah, exactly. So like Pulumi understands like when you, when you follow this pattern where, oh I've, I've taken an output. Um and I've flown it as an input to, to another resource, it understands, oh, those things now have a relationship together. So for example, um it understands that it shouldn't delete that URL. Um It shouldn't delete that resource before it's deleted this second, right? Um And uh it, it gives you some like other interesting dependency tracking information um that, that the engine is able to exploit. The other thing that I get excited about about this is that, you know, kind of I mentioned earlier, you know, if I want to go and stand up a new one of these or, you know, maybe we have a production environment and a testing environment. And I'm like, um now if I want to go and stand this up, I can just run the same program targeting my new environments configurations and it will both deploy the API that runs the service. But it also, you know, configure this against github, right? Um And I don't have to then go and remember to run that script. Exactly, exactly to do it separately. So um so that, you know, that part I think is really exciting, I can give someone an end to end kind of working uh thing here. Um So speaking of kind of an end to end working thing, I think, you know, uh you, you then went and sort of took these, you know, you now have two useful components. This one that is this abstraction over kind of how to create a github webwork implementation like API and then a thing to manage the github web books. Uh But I guess then you kind of want to go even further, like put that all together and just give people a single thing they can use to kind of do this whole. So what is, what is uh yeah. So, so Pulumi has this concept of components and components are basically resources that abstract over other resources. So like you have a component, uh the API type in in server list is a great example. Um It's this, it's this resource that holds on to a bunch of other resources. Like it needs information from AWS about the API gateway, about the lambda blah, blah, blah blah blah, like all that sort of stuff, right? And you can go build those um yourself. Um So I sort of did that. So um what I did here was I basically said, OK, um Instead of new up uh API or calling that create webhook thing or whatever, um We're going to just say, OK, you're new github web. Um And when you call it, you're gonna pass in three things, the owner of the repository you want installed on the repository itself and then the handler, right? And the handler has this signature that is bespoke to the problem I'm trying to solve, which is it takes in the body that's the uh Jason payload that was handed to you by, right? Um And so this thing now sort of ends up looking a lot like what create web hook did, right? This is the part here that kind of looks like create web hook. And so there's all of the ceremony and then at the end we call the actual handler. Um And then after it's created that resource, it also says, OK, well, I had defined that resource to be API and so I'm gonna create a uh registration of that hook using API L, right? So if you think about the code that you would have written at top level before, uh it would have been like a call to create um web hook and then a call to um new github web hook resource, right? But now all of that stuff is abstracted and you just say, oh, I'm going to do new github web hook, I'm gonna put my hand learning. Um So I think we have an example of that sort of here, right? So now like this code is basically exactly what I want to, right. Right. And it not only handles spinning up uh all of the infrastructure for the HTPN point, it also handles registering the hook with github and man managing the hook's life thing like, right. Um And so here, there's basically nothing that is not focused on the problem I'm trying to solve, right? Um And like that is super appealing, right? Um Yeah, the thing I find fascinating here is, you know, this doesn't even mention like API gateway, it doesn't talk about, you know, at this level. You don't have to think about how did I get this code and end up having it running somewhere. I just write the code and I describe, you know, kind of what it's attached to the repo and, um, you know, like you said, that's sort of when someone comes up this problem that's, you know, this, what they first envisioned, right. And then they think, oh, well, now how do I do all the other pieces? Um, but we can actually just wrap all that up and make it a reasonable comment. The other thing I like about this is, uh, you know, this is really is a totally reasonable component, this get web book you have here could be used to sort of install any kind of way. And um so, you know, in fact, you know, even the the switching of what kind of actions you want to handle and everything like it's being done just in here. Uh So this last example, I just, I love this idea if you can make it that simple and think about the problem at that level and now we can go and take this get, I don't know if you already put this on, get hope of this component. Yeah. Yeah. So, so actually I uh in the blog, I sort of have some uh it's always like you, you do in the, in the textbook, right? At the end of the chapter, you're like, oh here's some interesting problems that like the the motivating can go do, right? And so I sort of mentioned um some, some things. So one thing that I had mentioned is we talked about this secret, right? I had to go generate this secret in uh in you know, random dot org or whatever and set it as configuration to my application. Well, like the secret is an implementation detail, right? And so it kind of is sad that that's pushed to the layer of, of the user, right? Um But using the the dynamic resource, I can actually make a dynamic resource that basically creates say a random number and remembers it, right. So when you create the resource, it generates a new random number and then that thing sort of never gets updated, right? Um And so if I if I had done that, then in the implementation of this component, it would not only create the API gateway. Um and the the resource registration, it would also create that secret that, that that secret number and sort of hand it off to both the API and to the um the github resource registration. Yeah, it's a fascinating example because that, that secret is actually something you know, you initially needed it because you needed two kind of unrelated systems to sort of know about each other. You were doing API get over here and you were pointing and clicking and get him over here. But now that you've got a single component that's always going to create both, you know, that thing can sort of allocate a secret and then have it just be an implementation detail and you don't even, you don't even have to know what the secret is exactly. Uh, it can just be something which is, you know, the first time you create this thing it gets allocated and then when you tear it down it just gets tossed away. So, I think that that's a really neat sort of thought that, like that, that can be sort of self managing in some sense. Um, yeah. And then you can, uh so that they did have api for um web hooks, they basically bifurcated it. So web hooks can be either installed for an organization, which is what we ended up doing for our branch to leader because we wanted it on everything in the blu organization or a specific repository. So you could imagine changing in the shape of github web hook reo or um sorry of, of github web hook in some way. Uh Maybe it could take a bunch of owner repository pairs or like a bunch of organizations that could follow the same hook everywhere. Uh The really cool thing about that is you can actually reuse the same um HTPN point for all of these hooks, right? Um And so I sort of did some of that stuff because it seemed like a fun thing to do. Um And I sort of shared the code on github uh under, under myself. And then I also uh published a package on N PM. So you can install this package on N PM and it exports one thing which is github web hook and then you can uh sort of use that and offer your web hooks and then use Pulumi to manage it. So anyway, anyone now can go out and kind of use that package and just write an example that looks just like the, you know, this last example here and uh and hook that up and, and then you know, how long, how long about does this take to, to deploy to do both the API about? Like I think maybe we'll say a minute for the initial deploy and then updating is quite fast. So every time they want to change this code and test out something they could do that in a second set. So that's pretty cool. Like you can make that whole thing be simple. Uh That's great. Yeah. So I mean, I, I this example kind of, I, I love this idea. There's so many topics that we covered here that I think are really kind of interesting. Um But at the end of the day, the thing I find most interesting here is just, hey, like this idea of, I want a web book uh seems like a simple thing, you know, I want to take advantage of this. There's tons of offerings that kind of have these web books. Um It always feels like it's going to be a lot of effort. You know, I have all these tools I can go and point and click and do these things, write L files. But, uh, but here, you know, I can just manage it with code and I can, you know, go and use the Pulumi console to sort of understand the state that those things are in. Um, and I can do it at the level of obstruction, that kind of, uh, that I, that I'd like to. So, you know, this kind of thing just uh looks beautiful. Yeah, these are, these are like the exact sorts of things that I love writing. Like these like kind of, you know, 75 to 100 lines of code, sort of little things can just make your day to day a little nicer. Um And so it's so nice that like you can do it in a way where there is no real ceremony, right? Like I can just focus on what is the thing that's going to make my day to day better? Like if I need a hook that goes and does, you know, X or whatever, right? Like emails me uh every time, you know, someone opens an issue but doesn't comment on, right? Like um I can go build those things, right? So like that's really, really powerful. Yeah. So uh this is great. Um Thanks so much for, for both building the example and writing up the blog posts and, and joining today to, to talk about it. Um uh If anyone has any questions on this, feel free to uh, reach out to us on Twitter, our, our Slack um uh uh channel is, is right here on uh Pulumi dot IO. Um If you want to try out this example or any of the other ones we have, uh, you can come to Pulumi, download the Pulumi Tool. Um, check out our docs, check out our examples, um, or check out uh, mats, uh get web book, um, uh uh uh tool. Um That's it for us, uh for today. Um, uh, reach out to us if you have any topics, uh, you'd love us to cover in future um, live streams. Uh, and we'll be happy to, uh, to jump on those. Um, have a good rest of your week. Uh We'll see you again next week. Thanks a lot. Thanks. Thanks, man.

---
