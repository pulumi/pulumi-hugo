---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Getting Started with Infrastructure as Code using Go"
title: "Getting Started with Infrastructure as Code using Go"
meta_desc: |
    Pulumi makes it easy to manage any cloud using infrastructure as code and Go. Pulumi engineer, Evan Boyle, shows you how to define, test, provision...
url_slug: getting-started-infrastructure-as-code-using-go
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Getting Started with Infrastructure as Code using Go"
  description: |
    Pulumi makes it easy to manage any cloud using infrastructure as code and Go. Pulumi engineer, Evan Boyle, shows you how to define, test, provision and verify resources.  To get started using Pulumi visit: https://www.pulumi.com/docs/get-started/  Examples for this tech talk are located here: github.com/pulumi/examples
  sortable_date: 2020-04-03T23:48:45Z
  youtube_url: https://www.youtube.com/embed/s91qF5MLy14
transcript: |
    I'm uh Evan, excited to talk to you tonight about uh cloud infrastructure and go with blooming. So tonight, uh I have set up a couple of polls um interaction with the audience just want to hear what you all have to say along the way. So if you go to this URL here, uh pole ev dot com slash Van Boyle 164, you should be able to answer these polls and see live results uh excited to see who can get there first and answer the question. So I'm just kind of curious from the room. Uh What is your, what is your background? Uh Are you uh an engineer, devops, background manager, it uh student maybe just curious getting started. OK. Other um devops, some engineering, anyone from the uh other category wanna um curious to hear uh in chat. Uh what background do you come from? So things we're gonna be covering today first provisioning uh and this is, you know, treating our infrastructure as cattle, not pets. Uh We wanna be able to manage this stuff in mass. We don't want to give things names, we want to spin it up, we want to spin it down, we want every developer to be able to have their own stack, we want to be able to experiment. Uh Second, we're gonna cover uh architecture using things that we would traditionally use in software design abstraction, encapsulation, sharing these best practices across teams, creating architectural components. And the last thing we're gonna cover is testing. So it says unit and integration test that give you confidence to move quickly deploy software, often uh give you the confidence to hit that green button and not have to uh babysit your deployments. So prerequisites uh some of this material will send out ahead of time. But uh if you're still curious uh and want to follow along and you haven't done this yet, I'll leave this up here for a second. You can walk through plume dot com uh slash doc slash getting started. This will help you uh download the Pulumi cli and get set up with uh the AWS cli. Uh We have installation instructions for Mac Linux, um windows, et cetera. Uh Then all of the content that will be coming uh covering tonight is from the Pulumi examples repo. So if you wanna clone this repo into your GOP path, uh you can follow along, run the examples as we go and uh there will be live demos uh at almost every step. So I'll leave this here for just a moment uh in case anyone wants to uh enter those URL S in their browser real quick. Mhm And also if you Google Pulumi getting started and or if you just search for Pulumi examples, github, you will uh find this content on there. OK. So uh one more question for everyone before we get going here. Uh If you could head back over to the pole, I wanna know where are you in your uh cloud journey? So some of us have no experience at all. Maybe we're uh developing web applications and we have another team from manages the infrastructure for us. Um Maybe we're just getting started. We're hobbyists on the side. We're excited to move into this area. Maybe, uh we're already managing cloud services and production. We're on call, maybe we're deploying some lambdas or EC2 instances or, you know, Uber on these clusters. Awesome. Wow. So quite a, quite an experienced uh crowd tonight. Very cool. So you wanna go to the cloud, go to the clown. Well, how do you get there? There's an awful lot of choices and it's fairly confusing. You know, you could start by creating a VM and seven easy steps in the Aws console or use the Aws Cli or the SDK or cloud formation or Terraform or chef or puppet or answerable or? Wow, that hurts right. There's an abundance of choice. So let's just slow down for a minute and take a step back. What do we want out of our cloud development process? Devops Wild West. Yes. Uh So what do we want out of our uh cloud development process? We want maintainable, correct system, first and foremost, you know, uh tool process that works for the whole teams like software doesn't exist in isolation, right? We have to be able to, you know, work with others. Uh We want confidence making changes, you know, we don't want to babysit our deployments and we wanna be able to iterate. Uh don't wanna have to spend lots of time constructing a developer environment that needs to be babysat and upgraded and patched. And you know, are these goals really any different from traditional software development? I don't think so. So you know why not use the same development tool chain that we're using elsewhere, same tools that we love and that good old gopher. So let's start out with a demo. I want to create a simple web server. So that's gonna involve creating a security group with public address on port 80. Then looking up the latest Amazon Linux, am I create an EC2 instance using those two values? And we're just gonna specify to start a simple launch script that sets up a server on port 80 export that public DNS. So here this is the part where you can grab your computer. So uh what we did here was just make DIR dash P go pa source github gloomy uh CD into that directory and then get clone github dot com. Plumy examples. OK? And so now we're CD into, if I just do a PWD here, uh We're CD into Go pa source, get hub ploy examples, Aws go web server. And I ran this command ploy stack in it. This is gonna create a new ephemeral developer environment for me to deploy into uh and organize my resources with. I went ahead and set uh the AWS config. So let me, let me do that real quick. Pulumi config that Aws region and I'm in uh us West two because I'm on the West coast. So that's where I want to deploy my ET two instances into. And then from there, I can do plume up and while that's going, I'm gonna go ahead and uh switch over to the presentation and here are these uh steps here so that you can um so that you can follow on yourself if you want to. And uh I know we haven't looked at any of the code yet. We know where we're going. We're deploying a web server and we're using this command line tool called Pulumi, but we don't really know much more than that yet. Uh Well, folks are uh getting this set up for themselves. I'm happy to answer a few questions here in the meantime. Yep, I will walk through the code. OK. So why don't I go ahead and uh and get started doing, doing that? So let's break it down. What do we have here? So this is uh our, this is our shell and just to, just to show y'all what the, what the code looks like in its entirety, you know, it's uh about 50 lines here, but I'm gonna break it down piece by piece for you. So we uh start off with just a simple import to the Pulumi uh core engine uh go bindings and these just define a set of types, uh some convenience functions um uh context object that uh is very similar to the context object you might use in your normal Go programs. And we have here, this Pulumi dot run function which gives us uh a context in which to create cloud resources, attach cloud resources, et cetera. So inside of there, we're now gonna start actually creating cloud resources. So we've imported a set of findings to the AWS uh SDK here, uh The Pulumi Aws SDK. Uh And we're creating a new security group and you can see this security group uh defines uh simple ingress uh over TCP from port 80 to port 80 defines a Cider block spend just another second here in case anyone wants to read through this looks fairly similar to other go code. You might see the Pulumi dot String and Pulumi dot It may look a little strange. Uh But we'll get to that in just a couple of slides from there. We're gonna go and look up the AMI so we have a utility to do this where we can use this uh this pattern expression here uh HVM dash star to look up uh the most recent uh Amazon Linux, Ami. So from there, we're gonna use uh that Ami and that security group ID here to create a EC2 instance. And our web server is a fairly low tech. It's just a bash script. It's gonna echo uh hello world into an index html file. And then we're gonna run Python in the uh in the background. We're just gonna run a simple H TB server on port 80 which uh we've already exposed through the internet through our ingress. So let's go back to our window here and see what happened while we previewed our update, it showed us that we created this new stack, this container for our resources. Uh We created our security group and our EC2 instance great and it looks like we also exported some resources here. So let's go back and look at that context dot export, public IP and host name. So we can take these results off of the uh server that we created and export them, which gives uh access to uh tooling either through the command line. Other Pulumi programs can now uh reference and import these values. This allows you to break up your infrastructure into manageable chunks. Uh So that when you do a deployment, you don't necessarily have to worry about updating, you know, hundreds of pieces of infrastructure. So if we go ahead and do a curl uh on this. We see hello world great. And the other thing that's really cool about this is uh we can actually do sub commands to Pulumi. So Pulumi has a Pulumi stack output command. We can say, what was the name of that? That was our uh public post name. So if we do a sub command here that still works, Pulumi goes and retrieves the value and uh and curl reads that in and hits the server. So yeah, stack outputs are great because they're highly compos, highly tool allows you to uh create automation, you know, de tooling, things like that. So let's uh go ahead and stop here for some questions. I saw one question right off the bat which was is Pulumi like Heroku and the answer to that is no, Pulumi is not a um is not a cask. Pulumi uh is, is a set of libraries and an engine and a cli that allows you to interact with like any cloud. So you can deploy resources to uh we, we have all the resources of Azure, Aws GCP uh modeled uh vsphere from VM Ware um lots of other things like that. So Pulumi is a, is a SDK for um building and defining your cloud applications in any cloud uh larger font for code. OK. Perfect. Any other um any other questions uh before we, before we move on here, how is state managed? So there's two options here. So state is either managed in the Pulumi sacks. So we have a, a free SASS back end. It's, it's free to individuals, free to open source community uh for anyone to use. Um And there's obviously like paid plans if you have like a, you know, larger enterprise or something like that. But we also have um open source uh backends for you to store your state either locally just on disk or you can store your state S3 uh Google cloud storage as Azure storage. So we have plug back ends that um that, that you can use for, for different cloud storage, but by default, it is managed to inter so here's a pop twist for everyone. And what I wanna know is, is Pulumi based on what you've seen. Is it imperative or is it a declarative desired state configuration? Trick question? Hey. All right. Yeah, why not both? Yep. Uh Anyways, the answer is both. So uh let's go ahead and take a look at this real quick. We're gonna do a Pulumi stack export. OK. And so this is gonna go ahead and grab that uh desired state configuration that we're looking at. So let's uh see what we can find here. So this is an EC2 instance. It's uh our web server WW up. And so you can see this is a type AWS EC2 instance. Uh we have our inputs here. And so this is what was used to create and uh we, we allowed some defaults to get specified here. Uh Here's the ami that we wound up looking at, they got resolved at run time. Here's that user data that we specified. And we also have some outputs and things that uh were created by AWS and then returned to us. Awesome. So what does that mean? We write imperative code Pulumi executes it produces a declarative, desired state file and then drives to that desired state. So ephemeral environments polluting creates reproducible isolated instances of your projects, we call these stacks. So each developer can spin up and tear down environments that will you can create stacks in multiple cloud accounts. You can uh have stacks in your production account and you can have your development in a separate account that's completely isolated. Uh And this allows you to treat your resources like cattle, not pets, you can spin them up and down. Uh As you please, if your stack comes work, you can just uh blow it away and create a new one. So the workflow for this looks something like Pulumi snack in it, which is where we create an isolated environment. Pulumi up is where we deploy to it. And Pulumi destroy is where we uh clean up all of those cloud resources so that we don't continue to get charge for them when we're not using it, then if you wanna remove that stack and delete all of the history associated with it all of the config Pulumi stack. Rm. So I'm gonna actually go ahead and do that real quick because I, I don't wanna keep getting uh charge for those resources. So I encourage anyone else uh who may be following along at home. Pulumi Destroy Dash Dash. Yes. And this will get your resources to them. OK. Any questions? Is it possible to use multi cloud for a stack? Yes, you can uh create stacks that deploy to multiple clouds? Absolutely. You can even create uh stacks that deploy to multiple different Aws accounts. Um We have uh this notion of something called a provider. So if you want to create a provider that goes into separate aws accounts, you can do that and configure them with uh different credential. And then when you create a resource with a given provider explicitly, uh it gets placed inside of that account. How feature complete is this compared with cloud specific solutions? Uh extremely feature complete. So um the Pulumi uh the Pulumi providers uh actually um are currently based off of the terraform providers. Um So that means that uh with like, you know, there's communities of uh thousands of developers contributing and, and uh using these things across the globe. So oftentimes within uh days, if not hours um uh uh of features being announced uh that there's support in the providers. Um So some of the providers we've actually built ourselves like uh we use the open API spec for Kubernetes. And so this past week when uh 0.18 came out for Kubernetes, we actually had uh our update released before Cober Netti had their branch cut, which was, uh which was pretty cool because the whole provider is uh is co generated. What is my take on the AWS CD K? How do you think this will impact plumy development from official supported frameworks? Yeah. So I think CD K is a, is a great tool. Uh One thing that we're seeing with, uh, you know, uh our, our largest customers and, and a lot of our customers is that uh these days, uh, you know, companies are not just taking advantage of one cloud. It's, it's not necessarily that uh in one stack, they're deploying to multiple clouds, but, you know, they want to be able to take advantage of uh the machine learning assets, GCP or they don't wanna be uh tied in on price. Um We have a lot of tuber 90 workloads where uh people want to be able to lift and shift the clouds and don't want to be locked into a particular vendor. Uh CD K is a great tool but, uh you use CD K for your Ad Aws development. Uh And then what are you gonna use for your, a development? What are you gonna use for your, um, what are you gonna use for your, um, PC P development? Um So anyways, Pulumi Plumy is great because it gives you and your teammates a consistent, um, programming model allows you to use the tools you're, you're familiar with, uh, across clouds and if, if your company decides that they want to keep that option open, you don't have to retrain relearn. Ok. So now we're gonna do a little bit of plumy one on one. I kind of brushed aside some of those things that we saw there, like, uh these strange types, right? What is the Pulumi dot in a plume dot String? Yeah, that's TCP port 80. What's going on here? Right. So, fundamentally, cloud deployments are asynchronous, right? Some values are, are static and we know them at, at, at uh you know, authorship time, right? Uh For web servers, we want always want to expose that port 80 but others only resolve at run time. So what is that public IP of R EC2 instance? Well, you don't really know until uh A W creates it for you and returns it back. So we have this notion of inputs and outputs and Pulumi. So we're gonna just get into some very light kind of type theory. If, if you haven't seen this before, it's OK. It's, you know, it's, it's uh we, we'll explain it every step of the way. So, you know, let's just think t is symbolically, is like some type. So T is maybe it's a string or maybe T is an inch or maybe it's an array of strings or perhaps it's a structure, right? So tea is just some raw concrete value, an output of T uh something that maybe is produced by a cloud resource, right? So an output of T is an asynchronous object that resolves with the value of type T. So for us, we could think of our uh public DNS name as an output of types string. It doesn't exist when we write our program, but we know that when we run it eventually, it's going to resolve with a string. Uh So it's kind of like a promise for any of those of you who are familiar with javascript in the web. And, you know, when we create that ec2 instance, it's not just that public DNS, it's every member of the results object is an output. So it has to be uh a sync, we really, you know, can't know these values ahead of time and we wanna be able to propagate these values, uh you know, from our EC2 instance or from our security group into our EC2 instance. So we have to model these, these uh outputs asynchronously. And now an input, an input of type T is either an output of T, which is that uh that, that future that we were talking about. So uh an input of T either promises to eventually give you A T or currently has A T. So it either says I will give you back an in eventually or I have an in right now. It's either one and you know, this allows us to uh support both promptly available arguments like our, our port is always 80 or something that's maybe computed. Like we're gonna create this resource group and that resource group is gonna have an ID and we're gonna need to wait for that ID to be created for us to give to our EC2 instance, right allows us sort of this this coordination. So every input, when creating a pla uh a cloud uh resource is going to be uh an input of T and every output is an output of Yeah, it's it's a little, little redundant. So why all of these custom types? Right? We have Pulumi string, Pulumi. And what does this, what does this have to do with prompt and available values? Right. Well, Pulumi uses generics uh over union types to represent inputs in other languages. So input of T is the union of T and output T, right go as we all know, lacks generics for now. So we must define our own custom types. So for Pulumi, a combination of these custom types uh using interface and reflection under the hood allow us to represent this type system while stro uh still offering a strongly typed API uh on the consumer facing side of things. So, you know, we have these uh asynchronous values, these outputs, right? And sometimes we need to manipulate them very common to take a protocol, a host name, a port that's returned, want to construct a fully qualified URL. Well, you can't just, you know, print fa uh a future, right? Like that's a complex uh structure, right? You can't just print F that thing. Uh And, and you may not uh you may not have that uh those values available when this statement of code executes at run time, right? These are features that they, they resolve when they resolve uh may also wanna for instance, set a value of a structure based off of um something that comes back from an output. Yeah. What if these values are I think? Well, that's why Pulumi has something called apply and apply allows us to specify a fun callback function that manipulates the underlying of value when it becomes available and produces a new output. So we can call, apply on our uh port and then return a URL that contains that port after the fact, here's a great example here. So we've created a VPC and that VPC has an output, which is a DNS name. So this DNS name is a uh is an output of type string, a string output in Pulumi go terms. And we're gonna call apply string on this. Uh And this callback function will uh be called with that DNS name when it becomes available. And we're just gonna append a HT TV S on the front of it to uh return a fully qualified URL. And so now URL is uh not actually going to be a string, it's an output of type string, right? Because this applies string is asynchronous and returns another asynchronous value. So it's kind of like promises and uh chaining dot Then together uh if you've ever done anything like that. So sometimes we need to coordinate multiple uh outputs like maybe you have a database and a server that are getting created and you want to create a connection string. So all is how we coordinate multiple asynchronous output types, uh creating a new output, right? We can combine this with apply to manipulate asynchronous values together, right? So here we have a SQL server that's been created and we basically call Pulumi dot all to await the server and the database. And we say hey, when both of these are ready, execute this callback and return me this connection string. And once again, connection string is not a string, connection string is an output of type string, right? So that means that connection string is an asynchronous value that promises to eventually resolve with uh a formatted string. Uh once SQL server and database have resolved. So Pulumi uh trying to, you know, uh us personally trying to create some more idiomatic and uh useful uh go have, have created a utility function. So if you're doing this just in the basic case where you're awaiting a couple of strings, this is very common. We have a Pulumi dot Sprint F which uh hides all of this from you. But now you know what's going on under that questions here, how can everyone uh how can I wait for the output to be ready for further usage? So, uh the way that you handle that is uh you, you never uh access the raw out value within an output directly. When writing a Pulumi program, you always use Pulumi dot all and uh Pulumi dot apply um to basically schedule these. So Pulumi basically builds uh a big dependency graph, right? Like every time you write a Pulumi dot all, every time you write a Pulumi dot apply, uh Pulumi creates edges inside of this uh this um you know, graph basically. Uh and then eventually does a topological sort over top of that graph and then just looks at what is the first node that I can pull off and start executing and resolves those dependencies and continues to do that and does it in parallel wherever possible. So, uh more or less you, you have to use all and apply. Um Because the like the cloud just by nature is asynchronous is the Pulumi SDK feature set identical between GO node dot net and Python, uh which language implementation gets developed first. OK. So the Pulumi SDK uh for GO is uh is is been in preview for a little while now and we've been working really hard uh over the last quarter and uh we are actually uh G A and launching 2.0 of the Plume platform, which includes G A of all of our languages. Um So all of our languages are officially supported now. OK. Um So moving on here, we're gonna talk a little bit about, you know, architectures code, we hear a lot about infrastructures code uh but, you know, not so much about creating uh reusable components and, and architecture. It's certainly possible to do in, in L and Ds, LS. But this is uh our bread and butter when working with uh programming languages, right? So we want to encapsulate our design, we wanna compose our infrastructure into useful units. Uh We want to extract these into functions, publish them into libraries, unit, test them and be able to share these best practices across our teams. Uh Sometimes you have, you know, maybe a junior engineer on your team who you wanna be able to uh allow them to create a web server and maybe, maybe put some html inside of it. But you don't want them to necessarily change the network configuration. Like maybe, maybe they don't have that expertise or, you know, may maybe you uh are a security engineer and you've set up these best practices and you just wanna uh hide the level of uh or control the level of abstraction that's exposed. This is something that we do all the time in software design, but something that's not so common in infrastructure. So let's take a look at that uh web server example that we just had. And uh here we've encapsulated this into this create infrastructure function and create infrastructure is gonna return this infrastructure object which contains a security group and a server. And here we've actually said, hey, you know, we're very happy with the functionality of our web server. We don't want to provide any configuration to our customers at all. Uh So uh we're, we're just gonna control the entire thing. So uh some things to note here instead of using a uh user data stream to start up that uh web server, we've actually baked a an an Ami ahead of time. So that, that web server will start up automatically. And here now our uh code executing the side of our plume dot run, uh you know, looks a whole lot simpler, right? We just call this create infrastructure function that returns this infra object that has our uh our security group and our uh server inside of there, we can still export those values as as we did in our previous uh program. And these improvements are shared, right? You know, so we, we bake that uh web server, like I said into an AMI instead of having to use user data, there's no worry about uh let see, you know, if, if, if I'm a, if I'm an engineer and uh you know, I'm just getting started and I'm like, hey, you know, I, I instead of saying hello world, I wanna say hello world, hello mom. You know uh oh I just made a big mistake in my, in my shell script, right? So we have the ability to, to write abstractions that you know, we could parameter, parameterize this html. This, this message that gets echoed into this index file uh and build that ami we have the ability to do that with and control that with these um Encapsulations. So, so testing, let's get into testing. All right, since we're in the GO ecosystem, you know, can we use all of our favorite tools that we use for, you know, go test, right? The built in one. What about the tools we use for mocking or code coverage tools? And the answer is of course, yes, yes, we can use all these things. We want to use all these things. These are the things that we're using every day. So let's write a unit test against our create infrastructure function. We want to verify a couple of things, right? So we're building some operational tooling around tagging. You know, we wanna make sure that we're able to query uh every EC2 instance with, with the web server tag on it. So we want to verify that that name tag uh is on there. Uh We wanna make sure that no one is specifying user data, right? Because we have already uh baked in with the AMI uh that web server and we, we don't want any conflicts there and we also want to validate SSH is disabled. We don't want any of our public phasing web servers to have SSH on them. We wanna make sure that none of our user data is at risk. OK? So that's another opportunity to go ahead and grab your computer. And once again, we're still inside of this Pulumi examples. Repo. So if you're inside of the Pulumi examples repo, all you need to do is CD into testing dash unit dash go and run, go test. So let's go ahead and do that. Great. And while that gets started, let's go ahead and look at uh at some of this code. So we have this, this uh test function here, test infrastructure that instead of running inside of Pulumi dot Run, we run it inside of Pulumi dot Run air which allows us to specify a set of mocks. I'm not gonna go through these mocks. They're not particularly interesting. It's just uh a couple of lines of boilerplate, but they're in there in the examples repo if you'd like to look. So we run those mocks, we create a weight group that corresponds with the number of assertions and the number of uh like tests that we, we'd like to run here. And then uh we do those assertions uh run that weight because these assertions are gonna happen asynchronously inside of our all and apply calls and then we assert that there's no error at the end. Let's just go back here. So we see go test passed in half a second. Excellent. So what do these tests actually look like? So we wanna be able to check, do we have a tag with the name field? Right? And we want to check for each server. So for now, we're only creating a single server, but we wanna make sure that when we report an error on that server, we know which server in case we add more in the future, right? In case we're doing this inside of a loop. OK? So we have uh pass in the ur end of that server and pass in those tags, wait for all those to be promptly available are eventually available and then execute this apply to where we take that first value, which is gonna be the urn the second value that map of tags. And we're gonna check to make sure that map contains the tag name. We're gonna call it done in that weight group. OK? Next, we're gonna text and make sure that all of these user instances do not have user data specified. So similarly passing in the urn and the user data and calling all to make sure that those values are promptly available or eventually available. Once they're eventually available, this apply T function will execute and we will assert that uh the user data string is nil, right? If it's not Neil, we're gonna throw this air believable use of user data on server server, urn once again, calling, done on that we group. Finally, we're gonna test and see if port 22 is exposed. So this one is uh is um is uh you know, a little, a little bit more involved. So we're going to iterate through all of the ingresses uh and check for uh that wide open Cider block there, right? And if that wide open, if we find that wide open Cider block, we know we're open to the internet, right? And we're gonna break out and we're gonna check and see uh is the, is the port that we just uh that we just found a, a public Cider block for 22. If so, if we're open to the internet, then we've got uh an illegal SSH port and we're gonna fail the test. This ensures that none of our uh none of our tests um are uh none of our web servers are open to the internet. It's a nice thing to be able to verify locally. So, you know, once again, this is unit testing, we aren't verifying the functionality of a particular cloud service, the behavior of your in infrastructure. You know, we, we don't have uh this is an extensive mocking. So we can't make a an http query. You know, we're not mocking out all of the cloud services, but what we can verify is the control flow the logic, the propagation of expected values through your code, right, the number of times that the create call to a given resource uh gets made, right? So the behavior of your code in isolation and not the cob you know, and the great thing about this is it's blazing fast. You can do it locally without the cli without an internet connection, you have a tight feedback loop. So, you know, we also sometimes we do want that full confidence. We we do want to take the time to spin up an ephemeral stack and execute and then workflows, right? Making requests against our uh our live infrastructure uh verify like these integration of these different pieces of uh of cloud services, this end to end request flow. And then we want to automatically clean up that environment, whether or not the test succeeded, we don't want to leak resources, we don't wanna keep paying for that, right? So Pulumi has a test harness, our integration test harness uh that allows you to do just that. And in just a few lines of code, see we configure here a directory which says this is where my Pulumi program exists. Uh a config map which is uh the list of values that are required to inject into the program for it to be able to run. You saw when I initially ran my program. Uh II I did Pulumi config set AWS region. Uh This allows us to do that inside of code in this automated test harness. And then this extra runtime validation function uh is going to be run with the resulting stack. So that stack is going to be populated with stack outputs. So we'll be able to access that website UR I uh append it to a um like turn it into a fully qualified URL and assert that when we make an HTTP request against it, we get that hello Pulumi back. Um And then we just do an integration dot program test passing in the, the the go testing object and the plume test configuration, this program is going to execute, spin up my web server stack, uh do the extra runtime validation and then tear it down, reporting the results. And I don't have a demo for this uh in real time. Um You know, it can take a, a couple of minutes to, to spin up cloud resources, execute these requests uh and tear it down. You know, these, these uh tests are, are very, very valuable, but they are a little bit more expensive in terms of time. They're not necessarily as great in that tight feedback loop, but this deploys real cloud resources and validates their behavior. So this can catch bugs and things like I am and access control, making sure that your request can flow end to end through the system, making sure that LAMBDA has the ability to pick up that file out of X three, make sure that propagation of secrets happens as you would expect. Uh It also allows you to do some really interesting things like um this uh this integration test option allows you to specify a directory, but it also allows you to specify an edit directory. So you could have a second version of your program, perhaps checked out to uh a different uh revision of the code and then simulate an update. So you could spin up your resources uh on the initial Pulumi up. And then uh by specifying that editor uh do a second Pulumi up on a new version of the code simulating a deployment. This may allow you to measure up the up time, make sure that you still have database availability, make sure that none of your resources uh get deleted. So this is a great way if you're making kind of a risky change and you're uh concern, you want a game day ahead of time, looney makes it really easy for you to do that. You can also do things like verify health checks and alarm configuration. So like I said, this is much slower than unit test. This is not always a great thing to have in your tight dev feedback loop. But you know, before you go to make that pull request, you wanna verify every corner case of your infrastructure that maybe you didn't touch when you were working on this feature. Uh And, and you know, that brings great confidence and enable C I CD for your Infra, which is, you know, something that's not always that common, it's common to more common than you would hope to have to babysit uh these builds and babysit these deployments. So we want to be able to hit that big green merge button and you know, sit back just off our hands and uh and, and go work on something else. We don't wanna have to babysit. Uh uh So without anyone have questions about uh integration and testing. So uh just taking a look here at the ecosystem. So ploy is tightly integrated with, you know, all the source code providers, all the identity providers that you would expect. Uh We support a suite of languages for authorship, including typescript, go no, Js Python, all of the dot net languages. And with those languages comes the tools that you're used to the package managers, you're used to the editors, you're used to the C I CV integrations, right? On top of that, we have support for all the cloud environments, Aws, Azure, GCP, Kubernetes on any cloud that you want. Open stack. VM ware. The list goes on. So just in summary today, we talked about how do we provision our application treating our applications are our infrastructure, apps as cattle, not pets, right? We spin these things up, we spin them down, we onboard a new teammate onto the team. Uh you know, you send them through the plumy getting started flow. Uh And there you go, they're up and running and ready to deploy your application. Uh That, that's it. There's, there's no creating resources through the console, no complicated custom setup. We also talked about how do we take a cloud resource and turn it into a piece of architecture that we can, this, this abstraction that we can encapsulate a best practice that we've defined within our team and share it, share it at that, at that correct level of encapsulation at that correct level of abstraction for that giving consumer, right? Expose the things that you want to expose, maybe, maybe allow them to specify the html that gets rendered inside of the web server, but don't allow them to configure the the network configuration. Don't allow them to change that right? Pulumi allows us to do that. Uh And then finally, we talked about testing. So the unit and integration, integration testing strategies that give us the confidence to move quickly and deploy often. Uh So, you know, I just wanna say thank you and thank you to hatch it for setting this all up. And thank you uh to all of you for coming here and uh talking about go and talking about Pulumi tonight with me. Uh Here's some more ways for you to learn about Pulumi if you want to join the the community. So we have everything from uh Slack uh to github where all of our work is done out in the open so you can go and see pull requests that I've been working on this week or the rest of the team has been working on in preparation for our 2.0 release. That's coming up in the next two weeks. Uh We have uh video tutorials. Uh You can always uh reach out to me directly on our community slack. I'm there all the time and we have more workshops coming up a lot of them in, in languages other than go, if there are those of you out there who, who uh might be interested in learning some other languages as well. So.

---
