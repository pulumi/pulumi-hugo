---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Unit Testing Infrastructure in Python | Modern Infrastructure Wednesday 2020-05-06"
title: "Unit Testing Infrastructure in Python | Modern..."
meta_desc: |
    In today's episode, we're using Pulumi's testing superpower to unit test a Python infrastructure application. Code for this episode available here:...
url_slug: unit-testing-infrastructure-python-modern-infrastructure-wednesday-20200506
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Unit Testing Infrastructure in Python | Modern Infrastructure Wednesday 2020-05-06"
  description: |
    In today's episode, we're using Pulumi's testing superpower to unit test a Python infrastructure application. Code for this episode available here:  https://github.com/pulumi/pulumitv/tree/master/modern-infrastructure-wednesday/2020-05-06  The examples are in Python but Pulumi makes it easy to stand up infrastructure in your favorite languages including TypeScript, JavaScript, Go, and .NET - saving time over legacy tools like CloudFormation and Terraform.  https://www.pulumi.com/docs/get-started/?utm_campaign=PulumiTV&utm_source=youtube.com&utm_medium=video
  sortable_date: 2020-05-06T05:11:05Z
  youtube_url: https://www.youtube.com/embed/wH6WpiLrEdc
transcript: |
    Hello and welcome to another episode of Modern Infrastructure Wednesday. I'm your host, Lie Zen. And today we'll be covering unit testing, infrastructure in Python. Specifically, we're going to take an existing Pulumi example. So we're not gonna go build a ton of new stuff today. Uh But we, what we, what we will do is build a ton of tests or a bunch of tests and we're gonna take an existing example, add some tests to it, make sure that it's doing what we expect it to do and really just explore the superpower of unit testing in Pulumi. So this is one of the new features we've added in Pulumi 20 a couple of episodes ago, I mentioned kind of some of the things we are doing to 20, how to upgrade to 20 and one of the superpowers in 20 is unit testing which you would expect to be able to do for code. So let's get started. Uh I've already actually um gone ahead and copied over uh an existing example. It's called GCP PY functions. If you go to uh github dot com slash Pulumi slash examples, you'll find hundreds of examples that we have in our repository. Uh This is just one of them. It's a fairly simple example if we look at the uh main py here, uh really, it's just, you know, we're going to do some configuration and then let me get rid of this terminal. Uh And then we're going to uh create a bucket and then take all the things that are in, in the source code path, which is uh up here. So it's just right here. Uh We'll take those things, put it into an archive and then stick that into a bucket object. And then we will uh create a function uh along with a IM member as part of that. So if you, if we actually run a PLU can actually see what this would look like if we were to run this and we could run, pull me up and have this actually uh create the function and everything. But that's not really testing, that's manual testing. That's not unit testing. That's not really going to be a good way to ensure we have maintainable code going forward. So let's actually write some tests. Uh So the first thing I'm going to do is uh mention a couple of things. One is uh I added pi test and pie test watch. So if you're following along at home, um you'll have to add these two requirements. I've already installed these requirements using PT. The other thing I'm going to do is I'm going to uh refactor the code a little bit and move everything from here before the exports into here and here all imports 20 import. Um Thanks. So if we let me pre our refactored code, which should still work, which it does obviously. Um And now let's do some testing. So let's create a file. Let's call it test funks and let's import by just, and we also import really. And we can totally imagine just like, you know, let's just get this going here. We'll, we're one pie test watch and um we'll create, you know, we can, you can totally imagine like, you know, test something and uh we should see this pass. Great. So that's, that's expected. And let's actually go and find the docs for testing because I can never remember exactly what I have to do here. So um let's go to the unit testing page and OK, so great. I was already on Python. So I need to uh add the Mox, let's do that. So do this. And then after we set the box, we need to actually write the test. So we need to um import our actual code and then we need to uh write a have these as, as part of our test. So let's, let's do this uh do some copy paste for this. So we're gonna test funks and um let's look at what we want to test. So let me close some of these. So I think the first thing we probably want to test is that um, this bucket actually matches the, the bucket that we uh create up here, right? We wanna make sure that we're actually wiring this in correctly versus, you know, sticking this object into some place we don't expect. Um So let's, let's do that. So we'll call it test uh object in bucket. And uh as we saw in the example earlier, I should go back to here. What we typically will do is we'll take, you know, some of the outputs that come and then we'll just make sure that the things that come from those outputs uh are correct. So, uh we'll do the same thing here. So we'll return and what are we gonna check? We're gonna check uh Funk's uh the bucket that was specifically the name and we're also going to check that the uh source archive object uh that these match. So create this buckets, match function. And so we know that the actual bucket name and the source bucket. Yeah, arts de structure that and then we'll just assert that these are the same. So let's see if this runs. OK, great. So we got a passing test as we should expect and to make sure we're not doing anything too crazy here, let's change this to, you know, something and we should have this test fail, right? And so now we can see that uh this is not, this is not correct. So, let's undo that actually is interesting. You can see this is, this is none, uh, because there's, there's nothing past here, um, to this bucket name. But we can, you can totally imagine, uh, if, if I wanted to spend the time, I could also go up to here in the mock and also, uh, modify some of the mock to make sure that those all get set correctly. But. Ok, great. So we do that. Um What else should we test? Let's also see. Um ah Right. OK. So we should make sure that we have the right run time. Uh And we should also make sure that this entry point actually works. So let's, let's make a couple more tests. Um So we'll call this, um, test function run time. Actually, we don't have to do this. We just have to say, um and here we just want to make sure that the art the run time is Python 37. So, uh what is it not like that? Oh, it probably doesn't like that. This is on its own line. Yeah. So let's make a function for this uh run time, check, run time. And this just takes one argument which is the RT. OK. So we should have two passing. Oh, and I forgot to annotate this. That's why you can see it pace, it says it's a skip test. Uh Now we should have two running tests and they're both passing. Great. OK. And then the last thing I wanted to check was that this entry point is actually a valid entry point. Um And one of the cool things we should, let's see, I, I think this should work. Um But let's make sure. So let's copy this and test function entry point. Um OK. So what we're gonna do is we're going to first uh going to import the actual function itself. So that's um functions dot main. So if we go back here, you can see that we have uh this here. Um And then uh we want to functions dot main dot get, we actually wanna get the attribute off of this. And what we want to get is um the entry point. So that's ep so we basically, what we're doing here now is we're introspecting into that module to attempt to get this attribute of the um of the module. And then we're going to assert that it's colorable. So just put this all into one line actually. And I think that should work and it does. And uh we can actually make sure if we're doing the right thing here, let's change this to like get, you know, something and that should not be gullible and you can actually see it has no attribute and get something which makes sense. Um And what's also cool is if we go to the function here and we changed this to let's, let's just create a, a value here, let's just call it like, you know, some v equals true. Um And we test, we change this to uh some vowel. So the way that this will fail now is that, you know, it's not callable. So unlike before, where we couldn't get the attribute here, there is actually a thing in there called some vowel, but it's just not, it's not just, it's just not callable. So, um we're, we're verifying that the, the entry point is actually a callable function. Um You can imagine doing all sorts of additional introspection to make sure that the function returns things that, you know, in a certain way or has a certain signature or whatever it is. Um in terms of, you know, really making sure that uh the function we're providing to, to GCP is what we actually wanted to do. So I think that's, that's probably where I'll stop. I think you can, you know, just wanna give you a sense of how to write some tests um in the unit testing framework. Uh we use some introspection to really get a sense of whether or not we're passing on the right thing. Um And uh yeah, it's actually, you know, you can see in a few lines of code, it's very easy. I can use Python test watch, to uh pie test watch rather to, to uh to actually, you know, iterate all my tests as I'm going through and hopefully, you enjoyed this episode. Please subscribe and like this episode, uh if you have ideas for future episodes, please leave them in the comments. Always happy to uh respond to feedback and yeah, follow us on Twitter and we hope to see you next time on Pulumi TV. We have a special guest coming for next week. I promise you will very much like what we show next time as well. We'll cover more testing but even more in depth uh next time. So have a great week and see you next time.

---
