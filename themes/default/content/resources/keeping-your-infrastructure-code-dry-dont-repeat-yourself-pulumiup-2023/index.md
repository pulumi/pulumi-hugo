---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Keeping your Infrastructure Code DRY (Don't Repeat Yourself) | PulumiUP 2023"
title: "Keeping your Infrastructure Code DRY (Don't Repeat..."
meta_desc: |
    Sam Cogan, Solution Architect at Willis Towers Watson, will show how you can build a library of reusable modules that you can repeatedly reuse in y...
url_slug: keeping-your-infrastructure-code-dry-dont-repeat-yourself-pulumiup-2023
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Keeping your Infrastructure Code DRY (Don't Repeat Yourself) | PulumiUP 2023"
  description: |
    Sam Cogan, Solution Architect at Willis Towers Watson, will show how you can build a library of reusable modules that you can repeatedly reuse in your IaC projects. This is not just about boilerplate code but real, usable modules that provide value to your whole team, help you comply with standards, and build infrastructure faster.  
  sortable_date: 2023-06-26T13:45:14Z
  youtube_url: https://www.youtube.com/embed/5xw04T20lto
transcript: |
    Hello, welcome to my session. We're gonna talk about creating a reusable infrastructures code library. My name's Sam Cogan. I'm a solutions architect with a company called WTW. And I spend a lot of time working with infrastructures code and helping teams implement it within their projects and applications. If you spend any sort of time writing infrastructure code with any tool, you will find that you are rewriting the same code over and over. There are only so many ways you can deploy a virtual machine or web application and particularly if you've got corporate standards around security and compliance, that's gonna force your hand even more to using essentially the same code on lots and lots of different projects. If you're recreating that every time you're wasting your time and you're opening yourself up to issues. Um And that's what we're going to tackle today is how can you create usable modules that prevent you needing to do that? So why bother, what's the point in creating reusable modules? Well, the first one on the list there, we've kind of tackled already saving time. If you can pull in a module you've already written for deploying that VM rather than writing the same code that you wrote last week, you've saved yourself a load of time. You've also saved yourself frustration and boredom of having to do that same task over and over. So that was fairly obvious. And it's a good reason even just to have your own personal collection of modules is to save yourself that duplication and that effort and save time. But there are other reasons to do this as well. If you're working with more than just yourself or even to be honest with yourself over time, promoting consistency is a really important thing. If you're deploying lots and lots of virtual machines, you ideally want them to be deployed in the same manner every time or whatever resource. Um And if you're rewriting the code every time you are gonna get differences between each deployment, even if it's just you doing it. But if you add in a team of people who all have their own ways of doing things, you are gonna end up with things deployed in a, in a different way across the team. So if you can use a module, you can write a once a way of creating this particular resource and everyone uses that module, you're gonna get a consistent deployment of that. Maybe you use the same naming conventions, maybe you use the same type of resource and the same skew or all those sort of things. But you can build consistency into your module and everyone will use that. Thirdly, we can look at hiding some complexity with modules as well. Modules allow us to present a simple interface to a complex problem. And this can be really useful if you've got people who want to be able to deploy infrastructure, but don't want to be the ones writing complex C# or typescript or, or whatever code you're gonna use to write it. They just want to be able to deploy a web application and get it configured and running and be compliant with all the standards and so on. They just want to be able to do that if you create a module which makes a lot of choices for them. You know, you, you are taking them down a path with, with this. But you are saying this is how we should deploy a web application. You just give me a few parameters that allow me to vary it a little bit based on your needs and I will take care of the rest. You don't have to understand about what different options are available or what things you should have turned on or turned off. Um That can make it really easy for people to consume things if they're getting started or just don't want to have to care about the workings of a resource. And this then leads on to the fourth option there which takes that a step further and it's applying standards. So if you work at any size company, you are gonna have security standards, you're gonna have compliance standards, you're gonna have just corporate standards around what type of resources you're allowed to deploy, what sizes those sort of things. If you're having to go away and read all those standards every time you create some infrastructure as code, um and make sure you're compliant with it, it takes time and it, and it's very difficult for people to do consistently. So if you create a module and you make sure your module is consistent with your standards and will will deploy a resource that is compliant out of the box, then people can just consume that. And they know if I run this module, I'm gonna be compliant with, with security, they're not gonna come breathe down my neck because I know it's already compliant with those standards. So a few good reasons why you might wanna look at modules. I'm sure there are many others as well, but these ones that really stand out. So how do we create modules? Pretty much every infrastructure as code language has a way for you to create modules. So if you're coming from the Azure Space, um and you are, you can look at either arm templates or BICEP, you can do it with that. But arm templates have nested templates, bicep has modules, aws there's cloud formation modules and that will do it in that platform for Pulumi, which is what we're gonna focus on today. Obviously, we're looking at component resources and then a further extension for packages, if you want to look at that and for terraform, you've got modules. So whatever language you're using, you can find a way to create these reusable resources. So let's have a quick look at what this actually looks like. How do you create one using Pulumi and a component resource? So I hop over to VS code. And in here, I've got a module that I've created. This is written in C# but it will be applicable to any of the plume languages. Um And this module is basically trying to do some of the things we talked about. It is deploying in Azure Cotti cluster. A KS. Um And it is firstly hiding a lot of complexity. There are lots of options and configuration values you need to set for A KS that if you just want a plain old cluster for development. Um You might not care about, we're also applying some security standards and we're making it really easy to deploy a Cuber's cluster. So the module has two components. Um The first one is the resource argument. So this is where you specify any parameters that are going to go into your module. These are the interface into your module and this is just a plain old in the case of C# it's just a plain old class. Um But it inherits from the resource arcs class, which is a Pulumi class. That comes out of the box. Um And all we have to do there is specify any um input values that we want to feed into the module. So I'm asking the end user to provide some things like a resource group name, uh a name for the cluster, how many nodes they want in their cluster, the size of the nodes and then some networking information. And I'm giving some sensible defaults for some of those. So they don't even have to supply some of them if they don't want them, that's the resource arcs class. And that's a very simple one. And then the second one is the actual module. So it's a little bit more complicated but not too much. So firstly, again, in C# it's a class um and you inherit from the component resource class and this is, this tells Pulumi that it is a component that we're gonna create here. Um And we've got some output set here, which is our sort of external output interface to the, to the module. These are the results of running the module that will be given to the user when you run it, that can then be consumed by other things downstream. And then we've got the constructor um which is kind of the key part, which is where we actually run the Pulumi code. And the constructor is just accepting a, a name for the resource, the um resource arguments class that we created uh previously uh for the options and then a component resource options class which allows you to specify some default settings for how the actual deployment works, but that defaults to null. Um So you don't have to use it if you don't want to, we've got a base there that we then use, which is just a sort of a urn for the identifier for the module. And then under that, we just write plain old Pulumi code to create the resources. So whatever we actually want to create within the module we define here using normal Pulumi code, nothing special about this in terms of creating the module. So we see that we're creating a resource group, we're creating a virtual network. Um We then deploying the A KS cluster into that virtual network. Um And then we set all those options up and we get some outputs including the Q config file um and pass those out. So there's nothing special about the Pulumi code there. As I say, you could just write whatever you want then when it comes to consuming that. So this is our actual pluming application what we're doing in deployment. Um I'm just using my module. Um And then you can see here, I am deploying a cumulated cluster with this module um passing in some of those parameters that we need. So the cluster name, the resource get name and the node count everything else I'm accepting the default. So it's gonna pick the VM size and the networking settings for me. Um And that will then when I run that we'll deploy that cluster. So you can see this is a really simple, you know, three argument um option to deploy the cluster. And behind that there's a load of complexity which is hidden to deploy that resource group, that vnet that close with all those options and those security defaults and those sort of things. But as an end user, what I'm seeing here is if I want a development cluster for, for I just deploy this and it's really easy. Um And I'm not having to rewrite any of that code. So one really important thing about the modules is actually how do we get those to the end user? It's all very well writing some really fancy module codes, but if nobody uses it, then it's not gonna be helpful. So we need to deliver them to the end user. Now, you could zip them up and send them out to via email, I suppose. But that's gonna be really difficult for people to use in bulk. They're gonna have to talk to you, to use it and getting updates out there is also going to be painful. So most languages have a means of delivering those to the end user. So for the Azure space, you've got template specs um and you've got bis set registries or just plain old storage accounts in um aws, you've got car formation registry for Pulumi. Um You've got any of the packaging mechanisms that come with the languages that you're supporting. So we were writing A C# there, we would probably create a new get package to deliver that to the end user. If you're using time script, you could use M PM Python, you could use pi pi whatever the the distribution method comes with your language, you can use that to deliver your modules or your component resources to the end user, which is a really nice feature. Uh With Terraform, you can either use git reposted to deliver your modules or you've got Terraform registry if you're using the enterprise version. So you've got ways to get them to the end user, which is nearly as important as actually writing them. If people can't get them, they won't use them. And speaking of not using them, there are a few tips we're gonna talk about here about creating good modules so that people do actively use them. Um So let's just quickly run through some of these. Um So firstly, your module really should do one thing and do it as simple as possible. So don't go and create really complex modules with lots of different options and parameters that can do multiple different things at one time. I want to know that if I use your model, it's gonna do one thing and it's gonna do that for me in a simplest way as possible. So that module we created for cup is deploying a Cupids cluster. Yes, it's deploying a various different resources but they are all in support of that cities cluster. We're not going and creating a web application at the same time to do something else. That would be a separate module for web applications. You want to provide options like we saw with the COTIS module. We we provided some parameters to allow some level of customization but not too many. You don't want to present people with a great long list of arguments they can pass into your module because it makes it really difficult to actually get started with. You have to know what values these are all gonna set. Um Some of them are likely to be quite complicated. So keep it as small as possible, make it useful that there are pieces in their parameters that are actually providing a useful parameter organization. It's something people are gonna need to be able to vary. Um but don't give them a really complex interface to your module. Similarly, your module needs to do something that adds value. There is no point creating a module that just wraps something really simple and doesn't add any additional features. So take a resource group in Azure, a resource group is a very simple resource. It takes three parameters, I think um a location, a name and some tags. Um There's no point creating a module that just wraps a resource group. What value could you add on top of that? Um that that warrants having extra layers between the native resource and the end user. So make sure that your module is is doing something useful for our KTIS module. It was simplifying the interface, it was deploying some security defaults. The user didn't have to make a lot of choices. They just got a very easy to deploy cluster, there was value there, you need to make sure you version your modules, people are going to consume them. They're gonna want to know when there are new versions. They are going to want to know that you know what changes have happened in the new versions or whether there are any breaking changes and make the decision themselves when to update to the the new version. So make sure you apply a versioning scheme somehow to your modules. A lot of the distribution methods we just talked about will have a versioning features but make sure you use them, we mentioned it already but making them easy to obtain. So use those tools to deliver those modules to the end user, whichever language you're using so that they can easily go and grab them and update them in the future. Um Adding any sort of tension between them getting and using the modules means people won't use them on the same wavelength, keep them updated if you don't update your modules and there's new features coming out to the resource that you're deploying people want to use those. They can't use your module. They're just gonna bind your module and use the native resource and do it the complicated way. Um So make sure you update your modules on a regular basis with new features so that people keep using them and don't bypass them when you start your journey with creating modules, start simple, pick something relatively simple and it's gonna tell it gonna take you a long time to, to create the module four so that you can get that released and get that out to people. So and then they can understand the value of it but also give you feedback as to, you know, what could be improved, what it does. Well, um those sort of things don't try and create the, you know, the the complex and, and really difficult to use module to start with, start with something simple and go from there. And alongside that, make sure you create documentation. If you want people to use your modules, they need to be able to go and find the docs and see what the parameters are, see what the outputs are. You don't want them relying on having to come to you and ask those things because people won't um you want to give them the documentation so they can find out themselves um and they can keep up to date with that as you change the module. And then lastly, you need to let people know these modules exist, go out and talk to people who are going to consume them, show them the modules, show them why the benefit is tell them about the, you know, the features you're going to add in the future, the updates you're gonna apply, make it. So people can see it as a really easy really or really purposeful reason for using those modules, even if it's just as simple as you have to comply with these security rules or you can't deploy anything. And this will do that for you that in a lot of cases will be more than enough to drive people to using your modules rather than have to figure that out themselves. So just some tips on creating modules from, from experience um that hopefully will help you get going and we get, you get people using those modules, which is a really important thing. There's no point creating a fancy library of lots of complex modules if nobody uses them. And then lastly, I just want to talk about a further step you could take if you're using Pulumi, you're creating those component resources. You saw when we created that CTI module, we wrote it in C# at that time. The only person who can consume that module is somebody who's writing their Pulumi code in C# as well. It needs to be in the same language, but we can take it a step further and use Pulumi packages and Pulumi packages allows us to wrap that component resource with a schema and auto generate some sdks that will allow us to use that module or that component resource in any of the Pulumi languages. So you can, if you've got teams that are using multiple different languages and you, you, you gotta pick a language to write your component resource in, you don't want to have to write the same thing multiple times in different languages. So what you can do is use packages. There's a little bit of extra work. You have to develop that schema. But once you've done that, your package is now available to anyone who wants to consume it in any language. So this can be a really powerful thing if you are using different languages within um your in your enterprise or if you want to create Pulumi component resources that you release to the world, you know, you put them on github or the uh Pulumi registry and they can then get consumed by anyone. But you wanna make sure that anyone can use it in whatever language they want. So you don't have to do this. If you're, if you're a single language shop and you don't, you don't care for other languages, the component resources will do you just fine. But if you want to take the next step and make them multi-language ploy packages is something to look into and that's it for today. I hope you found that session useful. I hope it's inspired you to go away and start creating some modules of your own. Um All the code we looked at there is available on my github repo there. Um So if you want to go have a look at that, please feel free to. Um And also I blog a lot about this sort of topic. A lot of infrastructure is code and, and reusable code and those sort of things at Sam Cogan dot com. So please feel free to take a look at that as well. Um Again, I hope you found it useful. I hope you enjoy the rest of the sessions at Pulumi up and I will talk to you later. Thanks.

---
