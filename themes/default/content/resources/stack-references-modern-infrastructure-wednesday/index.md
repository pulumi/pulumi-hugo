---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Stack References | Modern Infrastructure Wednesday"
title: "Stack References | Modern Infrastructure Wednesday"
meta_desc: |
    In this episode of Modern Infrastructure Wednesday, David, one of our developer advocates, walks us through passing outputs from one stack to anoth...
url_slug: stack-references-modern-infrastructure-wednesday
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Stack References | Modern Infrastructure Wednesday"
  description: |
    In this episode of Modern Infrastructure Wednesday, David, one of our developer advocates, walks us through passing outputs from one stack to another with StackReferences.  Learn more at https://pulumip.us/Get-Started  Code for Modern Infrastructure Wednesday episodes is available at https://github.com/pulumi/pulumitv/
  sortable_date: 2022-01-14T16:48:17Z
  youtube_url: https://www.youtube.com/embed/QJuyf9trMmc
transcript: |
    Hello and welcome to P TV. This is Modern Infrastructure Wednesdays and I'm your host David Flanagan. Well, you may know me from across the internet as Rockwood in today's episode of Modern Infrastructure Wednesday. We're taking a look at stack references. But before we dive into that, let's cover a few of the basics eli project is any folder which contains ali dot yaml file. A project specifies which run time to use and determines where to look for the program that should be executed during deployment supported runtime are no Js Python dot net and go every pluming project needs one or more stacks to actually be executed. A stack is an isolated, independently configurable instance of a pluming program stacks are commonly used to denote different environments that organizations use to build out their platform pipeline such as death dating and production a stack and export values stack outputs. These outputs are shown during an update. They can be easily retrieved with the Pulumi cli and are displayed at the Pulumi surface. They can be used for important values like resource I DS computed IP S DNS names or even credentials stack references allow you to access the outputs of a stack from another stack. So what would be a real world use case for stack reference platform engineering is a common practice in today's software landscape organizations invest in teams whose sole purpose is to increase the velocity of the application delivery teams by providing a platform that those teams can deploy their applications to. It's pretty common for those application teams to not have a great deal of knowledge about the platform itself. Perhaps really only annoying that it's based on cabernet's and days gone by. We would have possibly sent the secrets to our application teams manually. We did this via email IRC and sometimes we even read them over the phone. More modern teams may opt to use something a bit more secure such as one password. However, that's still a relatively manual process. Once the application teams could simply consume the credentials of code, let's take a look. If you wanna try to set yourself, the code is available at github dot com slash Pulumi slash Pulumi TV. From there, you'll find a directory called 2022 for this year and then 01-12 da da da references. There's three directories and this repository one for the platform engineering team to build out their platform and two from an application team who want to deploy to that platform and just for example purposes and a whole lot of fun. I've decided to implement that on tape, script and F sharp, I have this code checked out locally and we have VS code so that we can take a look. So we'll start with the platform team who have implemented their platform and go using the Pulumi Go SDK. Uh This is not very convoluted and not something I would consider a production platform. But it is a good start here. We're using ST cloud to create a new network and firewall. Once those are created, we then create a coup cluster. And at the very bottom, we export the cube conflict. Now this is extremely primitive. It is a vanilla Cober api with no backups, no monitoring, no observably, no logging, no nothing but it will allow us to consume it. We have a stack reference for our application teams. So we said at the start that these outputs can be consumed in a multitude of ways. First, we can use the plume stack output command to get all of the outputs in the terminal. You see that this is the secret value and it has been hidden from us. However, we can overrate this behavior with sure secrets. There we go. We can also use the PLI SAS back end here. You'll see the Pulumi V project and our platform stack from here, we can see a list of all of our outputs as well as all of our configuration passed in because again, because this is a secret, it's sophisticated from us by default, but we can click on details to get the raw value is this is still very Mantel. So let's automate the consumption of the secret of our application code. So let's start with text scripts. Here. We have a prelim project on an index dot TS. The first thing we need to do before we do anything as an application team is get access to the platform that we wish to deploy to. You can see here this is really easy to do in Pulumi with one line of code, we're able to create a property or an object called platform, which is the stack reference referencing are Rockwood slash platform slash platform stack. This name is just my Pulumi user name followed by my project name followed by the stack name platform platform. Then we can create a new Kubernetes provider. We just pass in the cub config saying that we will require an output from our stack records called cube config this require is great. It means that if our platform team isn't exposing the credentials that we expect, then our program will fail relatively early. So we do have a contract between the platform team and the application delivery teams from there. We can then use our Cobern provider to deploy an arbitrary workload here. I'm deploying engine X. So let's run this and see if it works. I'm going to deploy to static code. Application dash TS is now consuming of the stack reference from the platform team check in to see if we have the keep config value and it looks pretty good. It's happy that we have a provider and a deployment to create. So let's click. Yes, our provider was created. Our deployment is created and the job is done so we can confirm this. That's exactly what we expected. If we jump back to our app, our platform application, we can run Pulumi stack output and rate this to cube. Config no, we don't want all the outputs. We want a very specific output. So I'm going to add the name here. This will create a cube con fail in this directory which will allow me to query the COTI CPA I can now export my cube config to be equal to the current working directory slash cube config and now I can do cube config get notes. Perfect. Now we should be able to run get pods and we should be able to see that our application team was successfully able to deploy their stack and we can see this internet deployment was created 81 seconds ago exactly what we wanted. So let's see what this looks like. And F sharp, we can open up our F sharp director and we open program dot FS. This is very similar to the tape script that the kids are extremely similar. The first thing we need to do is create a stack reference by saying that platform equals stack reference passing in that same identifier of user name project stack from there. We create our provider passing in and using require output to ensure that our preliminary program will fail early if we don't have that contract agreement with the platform team. Next, we deploy our KTIS deployment. The indentation has gone a little awry here. So I'm not going to go through all of that. And then at the very end, we tell it to run the emperor function, We can run Pulumi up here and we will see it exactly the same as we've seen over our typescript application first. Pulumi reaches out and checks the stack reference exists. So it's consuming our snack reference, telling us it needs to create the three different resources. We can approve this change and just like magic, our new resources will be created. What? So let's just confirm once again that we get what we expected. We can run cube control de parts. We see our engine X deployment from six months ago from the typescript DK. We see a new deployment from 11 seconds ago from our F sharp SDK. So that's it. Stack references are a great tool to pass things from one team to another, whether you're doing platform engineering or something else, you can use stack references to deliver credentials or other values in a safe way. They work across all of our SDKS. So all your teams can use different languages ever. You wish go have some fun. We'll speak to you next time. Have a good day.

---
