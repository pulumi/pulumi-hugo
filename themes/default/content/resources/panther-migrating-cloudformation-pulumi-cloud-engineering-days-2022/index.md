---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Panther - Migrating from CloudFormation to Pulumi | Cloud Engineering Days 2022"
title: "Panther - Migrating from CloudFormation to Pulumi |..."
meta_desc: |
    Dennis Webb, Staff Software Engineer at Panther, describes best practices and his team's journey to move their infrastructure code from CloudFormat...
url_slug: panther-migrating-cloudformation-pulumi-cloud-engineering-days-2022
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Panther - Migrating from CloudFormation to Pulumi | Cloud Engineering Days 2022"
  description: |
    Dennis Webb, Staff Software Engineer at Panther, describes best practices and his team's journey to move their infrastructure code from CloudFormation to Pulumi. He provides tips and insights to teams considering modernizing their own infrastructure.  ► Panther's case study: https://www.pulumi.com/case-studies/panther-labs/ ► Migrating from AWS CloudFormation: https://www.pulumi.com/docs/guides/adopting/from_aws/ ► Try Panther: https://panther.com/free-trial/  ✅ Get Started with Pulumi: https://pulumip.us/Get-Started ✅ Create a Pulumi account. It's free: https://pulumip.us/Sign-Up-OpenSource.  00:00 Intro: Migrating from CloudFormation to Pulumi 00:23 Infrastructure  01:16 CloudFormation Pains 06:40 Migration Strategy 07:07 -- Migration Phases 08:56 -- Deployment Steps During Migration 10:14 -- Migration Order "Outside In" 12:27 -- Release Cycles of Migration 14:43 -- Pulumi Bulk Import 17:13 -- Pulumi Preview 20:11 -- Pulumi IAM Permissions 21:25 How Long Did the Migration Take? 23:13 Closing Thanks 23:52 Q&A
  sortable_date: 2023-01-25T23:27:56Z
  youtube_url: https://www.youtube.com/embed/BA11lhWSxZk
transcript: |
    Thank you for joining me today. My name is Dennis Webb. I am a staff software engineer at Panther. Uh This past year, we took on the challenge of migrating our deployment code from cloud confirmation to Pulumi and we were successful at it. So for today's session, I wanna kind of go over you what the process is and hope you can take something away and apply it to your organization. So the first thing I do need to cover is I want to kind of cover the structure infrastructure of what we have at Panther just so you have an understanding of what we're working with. So, Panther is a cloud native scene. Uh We have over 1400 resources per environment and unlike most uh solutions who have, you know, one production account, we have a dedicated production account for every customer. So every customer of Panther gets a separate deployment of Panther in a dedicated aws account. And each of those deployments has well over 50 LAMBDA functions, numerous dynamo, DB tables, S and S topics, sqsqs, S3 buckets. And we also of course use other AWS services like API gateway, cognito and of course, VPC and networking. So why did we decide to go to Pulumi? Well, we had a lot of pains with cloud formation, as you can imagine. Uh Some of the pain that you always deal with your cloud formation that we ran into was first off. Uh You have a hard limit of 500 resources per stack, which means when we've got 1400 we had to have multiple nested stacks and we actually wound up with, I think eight nested stacks when we started this migration due to just keeping things separated and kind of organized a little bit different. A state drift must be fixed by hand. Cloud formation confirmation is good at creating resources. It's good for updating. It's not good at auditing your existing resources that it's already built and making sure that it's still, you know, in good shape. And to the spec that you asked it to be inside of your cloud formation, uh There's no support for some services and there's some resources that it just doesn't have any support for, especially third party, there's no support for github or anything like that. And so when you do need to support things like that, you have to write custom resources which are typically, you know, lambda functions that you trigger uh no cross account or cross region support. So when you run confirmation, as you probably know, it is stuck in that account in the region where you're running it, if you need to do something in another region. That's gonna be a separate stack in another account. That's gonna be a separate stack in that account. Uh lots of repeated code and lots of hard to read code. You wind up realizing there's no support for Yaml Anchor. So you, you, you notice real quick, 50% of the code in your stack is repeated boiler plate that you, you know, really would like to not have be so repeated. And the hard to read part if you've ever done much with nested, if logic inside of cloud formation, it gets pretty tricky to read. Sometimes I caught myself even during the migration, having a hard time understanding exactly what we had done previously to get it to work in cloud formation. So I could translate it to Pulumi and finally confirmation slow. It doesn't do as much parallel as I feel it should be able to do parallel. So let's go ahead and now cover what the Pulumi solutions are to these problems. Well, first off Pulumi has no limit on the number of resources in a stack. We've got 1514 1500 right now. I don't see any reason why we can't go to 3000 or even more uh per stack. A state drift is fixed automatically. This is a huge issue that is great to have. If for some reason, a Dynamo DB table has a configuration change or a Lambda has something changed in it when you run Pulumi, it sees that that does not match what you've got desired in your Pulumi code and it fixes that for you and make sure that all of your deployments are consistent. And as you expect them to be has brought a support for AWS services. It has support for things that confirmation doesn't have support for. One of the funnier things that I discovered early on was confirmation doesn't support cloud formation policies on subs stacks. And I just found that kind of interesting that even cloud formation itself doesn't support all of its features. Whereas Pulumi actually will support that if you deploy a cloud formation stack with it, but it also has support for all the other aws services data do github as your GCP, you know, most of your major providers, there's gonna be support for uh multiple providers in the same stack. This is how we achieve cross account support and cross region support in a single stack. If we're doing a deployment into us West two, we actually need to make AC M certificates in US East one for you with API gateway with cloud formation. We had to have a totally separate stack that was handled in a totally separate environment to do that. Now, we're able to actually jump over and do that within our same Pulumi stack and the same thing for route 53 records. We have a dedicated account for our DNS uh records beforehand. We had a whole another process for creating those records. Now we define them right there in our standard Pulumi stack. And Pulumi has the access to go over there and manage those records for us. That's been a great improvement. Uh As far as the hard to read code and lots of repeat repeatability, you get all the benefits you get from your programming language. So all the features of Python Gola typescript, whatever you choose to work with, you get those benefits and that's huge. And Pulumi is fast, it is highly parallel and fast. If you look up the parallelism settings, it is set to unbound from the start. So it will try to create as much resources as it can. We've experienced a 40% decrease in deployment speed by transferring to Pulumi, even though during our migration, we increased our infrastructure count by 20%. So we actually got even more speed benefits and we can actually calculate because we actually grew our application. And that's another big deal. We were not, we did not have to stop adding resources improving our application during this migration, both were able to happen at the same time. So let's talk about the migration strategy because that's really what you've got to have down and what you've got to know to be sure that you get this done safely and correctly. So I'm gonna cover the migration phases of an AWS resource, every resource you have in cloud formation. Will go through these stages. Sometimes I'll go through these stages with other resources. But in the end, they all go through the same stages. The first stage is the existing stage. It's a resource, it was created and managed by cloud formation. This is what all of your current infrastructure that you built with cloud formation is in the next phase is CFN prep state. This is where we go after we've picked out which resources we're gonna migrate or which resource. And we add a delete policy retained to every resource in cloud formation that we're migrating with this current release. With this current pr what this tells cloud formation is when we remove you, when we remove this resource from cloud formation, do not delete this resource in AWS as you typically would instead just remove it from your state. But let it be the next phase. After that is the adoption phase. This is where we define the resource in Pulumi and import it into our Pulumi state. With that, we now hit what I call the joint custody phase. This is where both cloud formation and Pulumi are aware of the resource have it in their state and both are managing that resource. Hopefully, this will only last for one release cycle for this resource because the next stage is cloud formation removal. That's when we go into cloud formation, we remove the resource from cloud formation, we update our stack at that point. Cloud formation will see that retained policy and not delete the resource, but it will drop it from its state and stop trying to manage it. At that point, your resource is fully migrated. Confirmation no longer knows about it is no longer managing it. Pulumi is 100% in charge. Every resource you have must go through these stages and none of these stages should be skipped. So moving on from that is what are the deployment steps during migration? Like what order do you do things? When do you import? When do you run cloud formation? When do you run Pulumi? We always still ran cloud formation first because especially at the beginning, cloud formation still is holds most of your infrastructure in it that needs to run first after your cloud formation has been updated. The main thing it's getting at this point are those delete policies, you run your migration script. This is gonna be a script you write for each of your releases that generates the bulk import file we're gonna use during the Pulumi import. And I'm gonna cover the bulk import file in a later slide. The next phase is running the Pulumi import command where you will run Pulumi import specify the bulk import file. And Pulumi will then read those resources actually go out to AWS pull all the properties from that resource and put it into your Pulumi State file. So at that point, Pulumi knows about the resource and it knows all of the actual properties of it out on Aws. The final stage is at that point you run Pulumi up which then applies your Pulumi code to it and updates the resources as, as needed. All right, migration order. What order do we migrate these resources? You have 1400 resources. How do you pick where you start? Well, for starters, you, you do it from the outside in if you take resources that have no objects dependent on them and migrate them first, that makes it so much easier because you don't wind up with this weird chicken and egg issue. Uh If you've got nested cli formation stacks, that's a good place to start. You kind of know your deployments. I knew with mine when we did deployments, there was this one stack that was the last nested stack that always was uh applied by cloud formation that told me that's where I wanna start at because it's obviously dependent on resources and other stacks. Once we get into that stack, you then have to pick off resources once again from the outside in. So for example, with the lambda function, let's just say there's four kind of resources that are all related to that Lambda function. We've got the alarms for that function. We've got the log group, we've got the function itself and we have the im role to move those over. We have to do them from the outside in. So the cloudwatch alarms don't have anything dependent on them. So we pull those over first. Next, we have to pull over the lambda function because it's dependent on the log group and the IM row. So we migrate that next. And then after that's migrated, can we then migrate the log group and the IM row? That's more of an example, more likely if you're doing APR and you're gonna migrate a lambda lambda function, you're gonna migrate all four of those at one time. But it's just to give you the idea of what order to kind of grab things in. And of course, your core resources are gonna be things you migrate last your VPC, your S3 audit logs buckets, lots of things depend on those. So those are gonna be at the very end. Also resources that are referenced by lots of other resources. We, we know what those are like dynamo DB tables, those are going to be used by Lambda function. So we need to migrate all the lambda functions that rely on that table before we can actually migrate that table. And as you get started doing your migration, it becomes pretty clear the order of things. Now let's go through the release cycles of a migration. I've talked about, you know, release cycles, we use SIM, we do releases every two weeks here at Panther. So I wanna kind of give you an example using our release versions to give you an idea of what the steps were. So for Panther version 1.40 this is where we started our migration. So of course, we went to our cloud formation. We added the delete policy to all the resources we were migrating in this release. We ran the update stack. Even if the only thing we changed in that stack for that release was adding those delete policies. It is very important to update the stack because that way cloud formation will update its own internal state to say, do not delete this resource when it gets deleted because it's gonna go away soon. Next, we run our migration script that creates our bulk import file and then we run Pulumi import. And then finally, we've already added our resources into the Pulumi source. We run Pulumi up. Those are the steps we took in release version 1.40 of Panther in version 1.41 of Panther, we've took all the exact same steps except there's a new step here in the cloud formation. The second step and that is we remove the resources from our cloud formation templates that were migrated in the previous release version 1.40 as you go through and do more and more releases, you're going to sit there and keep repeating all of these steps from the Panther V 0.141 stage. And slowly your cloud formation is gonna get smaller, your Pulumi source is gonna get bigger because you're gonna be migrating more things. And eventually you're gonna hit the point where is, where you wanna be, which is Panther. Uh 1.45. That is when we had everything migrated to Pulumi. And that was a really fun release because all we had to do for confirmation was delete the stacks. There were no more resources, no more migration scripts, no more importing. And all we had to do then was run Pulumi up for versions 1.46 and own toward the future. The only step we do now when deploying our application is we run Pulumi up. So we talked about the bulk import tool and I'm just gonna cover in the next couple of slides. Things that Pulumi offers that are, that were a big deal and made our migration a lot simpler and the bulk import file was one of them. This is a file we build with automation. It's just a JSON file. There's an example over here to the right. And what we do with this file is we define what resources we want to import during that release. And you'll notice here that the first thing we've got under here is type and we're saying we're gonna migrate an AWS EC2 VPC. That name is internal to Pulumi, every Pulumi resource has a documentation page out in the Pulumi docs. You go find your resource, you're importing, click the import on the navigation pane and it'll tell you exactly what the name of the type is and what the format is for the ID to import it in. So the Pulumi Docs are major during your migration. Now, some things you know the ID because you named them, you had named things like you had a dynamo DB table named users. But for a lot of things like VPC S, you don't necessarily know the name because they're generated and unique for every environment. And as I said, we had thousands of these. So what we did with our script is we actually leveraged cloud formations, list stack resources function. And we could read from cloud formation. Here's the logical idea of this resource and cloud formation. Let's say it was called user table and then cloud formation would come back and give us the exact AWS resource name for it. So that's how we built these files out and these were all unique and individualized for every one of our customers. But we didn't do this by hand. This was always done with automation. And so like we said, there's three things that have to be inside of your bulk resource file, the type, the name of the resource. This is what I call the Pulumi ID. This is the ID or the resource name, you give the resource inside of Pulumi. And then the final is the ID and this is the cloud provider identification for that resource. And in this case, it's our VPC ID as for an internet gateway, you get the internet gateway I uh ID, but you get, you get the feeling of it. So only those three simple things is all you need for Pulumi to actually have enough info to go out, read your resource and pull it into its state. The other thing that was really useful is Pulumi preview. Uh If you type in Pulumi preview, it will go through and it will give you a preview of what it's going to do on your next uh Pulumi up. This is very useful to make sure that when you migrated a resource and you defined it inside a Pulumi that you didn't transpose a number, you didn't have a typo and over to the right is a snippet from when I was migrating uh our cognito user pools and right here, um We've got three resources. I just kind of want to run through them real quick. So the first resource is a user pool and if you notice to the right of it, it says update, that means Pulumi needs to update that resource, which means how it's defined in Pulumi doesn't really match what I already had out in Aws. Now you get a great diff here and it tells me I'm going to add a tag called application panther. What we do with our tags in Pulumi. It's a great feature called transforms. We have a tags transform that says we want these tags applied to every AWS resource that supports tagging and Pulumi magically handles that. So it wants to add this tag. What happened was in our cloud formation? We, we didn't have this tag, we forgot to add it and it went, you know, months a year without anybody noticing, it wasn't until we went to Pulumi that the governance rules inside of that transform caught that. So I'm I'm good with this change. I'm like good. The next one is user pool domain. Now this one is a perfect example. It says same next to it, which means this resource N aws that we imported is defined in your Pulumi code exactly like you wanted it to. And that's, that's a great sign that tells you you did your job, right? You're, you're gonna be good to go on that one. The next one is a little confusing. It's called the user pool client. Even though it shows same, there's differences here. So you have to really start paying attention to these. The differences on these two is actually pretty simple. These are two lists in aws, everything was ordered open ID aws cognito then email. But inside of my Pulumi code, I had the order of email, open ID aws cognito in this circumstance, I know that the order of that list does not matter. So I'm good with that change. But if I wasn't, if the order did matter, then this tells me, hey, you don't have this defined right in your Pulumi code. Why don't you go update your Pulumi code, get the order correct. And then the next time you run Pulumi preview, you should not see these differences. So Pulumi preview kind of gives you a lot of confidence that your Pulumi code matches what was on Aws and what was on Aws was created from cloud formation. So that kind of gives you a warm fudge that you didn't typo, you didn't miss out on something you didn't misspell anything. The other tip I would give anybody is manage your I am permissions for your Pulumi. Your user don't work without a net. The biggest fear anybody in management and anybody doing this job is gonna be, we don't want to lose stuff. We, you know, we've heard nightmare stories of people accidentally having cloud formation, drop a resource or you know, somebody type out something so protect yourself. First off your Pulumi user you run Pulumi up with should not have any more permissions than it needs to actually do a deployment. Don't, don't run this with admin permissions. It's not necessary and give yourself another little safety net. Add deny statements to your IM policy that says my user doesn't have permission to delete buckets, doesn't have permission to delete tables or sqsqs EFS file systems. Anything that has non replaceable data, put a deny in there more likely during this migration, you're not gonna be deleting buckets or dynamo DB tables that just gives you just a little bit more confidence and gives everybody just a little bit of a better feeling of, you know, can we do this safely? And the answer is yes, you can do this safely. So one of the questions that I think everybody always wants to know is how long did it take y'all to do this? Like, you know, you're talking 1500 resources. How did you actually, you know, how long does it actually take? Is this gonna be a 12 year project? And it all depends of course, on how many people you can put on the project. But it also just takes getting a little bit of experience. We started our migration. This chart right here, by the way, is just of our resource counts in Pulumi. Uh You can actually get this on the uh Pulumi you have when you log into your Pulumi console. But what this uh shows is starting in May is when we kind of started our migration and you'll notice it's not much movement in May. And that's because we were, we were feeling things out. We were trying to get our patterns, we were trying to do. We were learning a lot of the stuff that I'm trying to cover today. We were just figuring out what order of operations do we do? Which resources do we go first with? And then finally in June, we start picking up some speed and a little bit about mid June. After that release cycle, we didn't move as much on the next one. We were taking time to kind of tweak some things, some lessons learned or whatever. But then after that release, you'll notice we kind of have a pretty steady increase. And until you get to about September, you start to see these huge jumps in number of resources. And that's because by the time you get to the near the finish line, you've pretty much probably migrated almost every type of resource you're gonna migrate. The first lambda you migrate. It's gonna take you twice as long to migrate as the next 10 because you've already built the patterns out. So getting started is slow, it can be a little daunting, but honestly, once you get the ball moving, it just snowballs and before you know it, you've migrated your last resource out of cloud formation. And it's like, wow, we get to delete cloud formation. This is, this is gonna be awesome. And that's basically what I've got to cover today. I was appreciate everybody's time. I hope you took something out of it and I think we've got time for a little Q and A if there's any questions. Yeah, thanks so much Dennis. I just want to thank you for your time and for this amazing talk. I think it's been very illustrative for other customers who are looking at doing this. So I really appreciate it and appreciate Panther's partnership. I mean, I've really appreciated working with you all and the feedback you give us. It's been an amazing partnership for Pulumi. Um If we want to take some questions, I think there's a couple that we can look at. Firstly if someone asks you, how can I try? Panther? Uh Actually we just launched, uh go to panther dot com. We just launched for, you can now request a trial of Panther. So panther dot com is the web address, uh sign up for a trial. And I think you get provisioned in instance pretty quickly once again. And all of that's built now with Pulumi. Awesome love to hear it. Um Another question is with the graph you had, what were the axis on it? Uh The um going up and down the uh vertical A or yeah, the vertical axis was uh resource camps. So it started at zero and went up to the top number. I'm, I'm not allowed to tell what the top number is. Uh just the trend. Yes. Ok. Awesome. And I think the last question we have in the chat so far unless anyone's quick and can add on is um oh, it sounds like you can't answer this actually. How many resources you migrated? Well, it was uh 14, 14 to 1500 per account. It was about 1400 of them per account. And like I said, we've got thousands of accounts, but they all took the exact same approach. I mean, they used all the same scripts. So when we would do a deployment and we, you know, we deploy like anybody else, we do a few at a time and then, you know, slowly ramp it up. But every time every customer had the exact same migration scripts running. So that's why you would see big jumps every two weeks. Got it makes sense. Well, like I said, this has been really awesome to illustrate the value of Pulumi. We appreciate your time, your time, we appreciate you, you know, coming in here answering questions with the community. Um Thanks so much. All right. Thank you.

---
