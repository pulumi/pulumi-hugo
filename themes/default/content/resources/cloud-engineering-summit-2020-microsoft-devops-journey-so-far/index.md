---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Cloud Engineering Summit 2020: The Microsoft DevOps Journey (so far)"
title: "Cloud Engineering Summit 2020: The Microsoft DevOps..."
meta_desc: |
    "This will never work here" is the sentiment we often hear from companies just starting their DevOps transformation. The good news is that change i...
url_slug: cloud-engineering-summit-2020-microsoft-devops-journey-so-far
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Cloud Engineering Summit 2020: The Microsoft DevOps Journey (so far)"
  description: |
    "This will never work here" is the sentiment we often hear from companies just starting their DevOps transformation. The good news is that change is possible. In this talk, Sasha will explain how Microsoft moved from the 3-year waterfall software delivery cycle to deploying multiple times a day! Using the example of the live engineering environment for Azure DevOps Services, Sasha will walk through the process of updating older systems, transforming the automated tests, implementing CI/CD, and the major cultural changes that were needed to make it all possible.
  sortable_date: 2020-11-11T00:29:42Z
  youtube_url: https://www.youtube.com/embed/kgDdywJTBZ4
transcript: |
    Hi, everyone. Um my name is Sasha Rosenbaum and we're gonna be talking about the Microsoft Debs journey so far today before we get started, let me just introduce myself. So I started my career as a developer. Then I did a start at OPS. Um I was an architect for Microsoft for a number of years. And then, um now I'm a product manager for github and that's how I'm wearing a github t-shirts, did a t-shirt today and talking to you about the Microsoft de up starting. So let's talk about why we actually need devs. Well, um you know how every company in the world is a software company today and this is not just a cliche, it's actually happening, right? You used to be able to just produce car tiles, tires and just, you know, not have any digital presence and be ok. But today, if you don't have a website, a mobile app and something that is very good user experience and stuff like that, you're gonna be disrupted by someone who does, right? But then when we move into software and every big enterprise in the world moves into building software, they discover that Hey, there's this paradox, right? We can either deliver something quickly or we can deliver it reliably, or at least that's what we used to think. Right. So we, we said we can't have both quality and speed at the same time. But actually if we look at the s um, research that we've collected numbers for a number of years now, um, then we see that companies that move fast are actually the companies that also perform better. Um It's like developing a muscle, right? If you are deploying to production every day, you're actually gonna get really, really good at it versus a situation in which you're deployed to production and every six months or even every year, right? And that's a really, really traumatic event and lots of people have to work really hard on that. So if we look at the numbers, we see that the deployment frequency is close, closely correlated with actually having lower percentage of failure on change and faster times to recover. So all of the good things that come from continuous integration, continuous delivery and in general like Dallas practices, then if we talk about Microsoft, why do we actually need to talk about transformation? I mean, Microsoft was doing pretty well, right. Microsoft is one of the only companies that's been on the top market cap list of um S and P 500 for the last 40 years. That's the say, right. So why did we need to transform this, well, this comic is drawn by someone who used to actually work at Microsoft and it looks uncannily true for many companies, but also looks true for anyone who worked at Microsoft a few years ago. Right. This is what it used to look like. All these orgs actually kind of were out everyone for themselves. Right. And people didn't trust each other and didn't want to rely on each other's, um, sort of tools. But so because if my bonus is um sort of tied up in a, in your team's performance, then you can just, you know, go away and not work on my goals and then my bonus gets affected. So as a result of this, basically, every team at Microsoft deploy developed their own deployment structure and their own testing framework and everybody was kind of working on their own things and this was lots and lots of duplicated work. And that was a problem for a lot of people. And so when such an adult took over, one of the things that he said was, hey, I would give up working on features any day to just so we can work on the tools that produce our own productivity. And that's I think an advantage that comes from having an A CEO with an engineering background that he understood that shiny bells and whistles of features are only great as, as long as your software is reliable, as long as your productivity doesn't suffer So these are internal Microsoft numbers and I don't update this slide that often. So this I think is February 2020 but we deploy to somewhere in the world internally at Microsoft at roughly 82,000 times a day. And we have roughly 100 and 10,000 engineers using our own, what's called one es one engineering system, including like a and um our own and stuff like that. Right? So now we're learning from our own experience, right? Every engineer at Microsoft is testing your own software, which is a great, great advantage that we can have. And so if we talk about productivity, if we take just a swag number, right? 100 and 10,000 engineers are using Microsoft uh one engineering system. So saving one second a day is saving 3.7 people. I don't know what 0.7 means, but um basically saving four hires for the entire company. If we save one minute a day on these tools, then we can talk about 163 people that we just added to Microsoft. And if we save one hour a day uh for everybody at Microsoft, then we are talking about almost 3 billion in a year. And these are not the numbers that we use to incentivize engineers. That's a very bad idea. What's a good idea is if you show up to your leadership meeting with these numbers, then really people start buying into, hey, it's not just about the features, it's not just about, you know, delivering the latest shiny thing, but also working on our own productivity and better delivery. So I'm gonna just really briefly show you a timeline. So we started in 2010 with a tool called TFS. At that time, some people still use it today. Um and it shipped on DVD S at the time, right? And it took us about two years to get to the first version of that DVD that even worked, ok, because we started with like it works on my machine and like, ok, barely passed the test and then piled in a ship, right? And then you needed to hire a consultant to get in to install the TFS server because it just wouldn't work out of the box. Um And then we basically made a major, major transformation from this and we went into life size services, right? We went into software as a service with vsts um in 2012. And we started providing that tool as a service in the cloud. And that meant that we had to learn a complete the new muscle, right? We had to learn how to actually run the service for our customers, not just ship a DVD. Um And then not worry about that. Um And then there was a bunch of other things on this side. I gonna go deeply into much of them, but we switched Windows development to get to distributed version control instead of TFVC, which was a major kind of crazy thing. Um We joined the Linux Foundation, which again sounds crazy to a lot of people still. And in 2018, Microsoft acquired github, which is how I'm here. But yes, we have uh we are in roughly sprint 1 77 right now. Um And we have about 25,000 engineers working for Microsoft and Microsoft Payroll contributing to open source projects, which is a crazy thing for a company like Microsoft that used to say that open source is cancer. But OK, let's go into how we actually made this happen because it's not an easy transformation. So we are gonna uh talk about, for instance, creating clarity. So how do you actually align on your goals in your organization? Well, so this book comes from John Dorr. Um It talks a lot about Google actually. But um so basically the OCRS are older age today and what OKR is, is objective and key results. So you start with an objective which is like grow a strong customer, happy customer base, right? So you define what your goal really is and then you go into key results which are so typical key results, typical good key are something that you can measure, right? So you have to be able to attach a number to it and that has to be a sort of objective number as objective as you can get it. So something like net promoter score or customer satisfaction or Q time or something like that, but don't say we are improving things, right? Improving is very vague and you can't really measure that. Um And so if we're talking about like measuring results, not activities. So for instance, measuring activity is we are we have published uh you know, we delivered five new features this month. Ok. Well, you delivered features, is anyone using them, right? So a better metric is our customers are happy with the features. Now, you have to ask yourself how you measure the customers are happy, but that's a conversation that we're gonna go into a little bit. And then another thing is there's committed Krs and there's um aspirational Krs. So when you say that everyone is committed to delivering everything, 100% people start send bagging, right? Because I don't want to be committed to delivering every single aspirational goal that our organization has because I don't want to lose my performance indicators and stuff like that. So people start telling you that things are harder than they really are. So basically, but at the same time, you do have some committed Krs because let's say my site reliability is a committed Kr I strive to 100% availability. Maybe I won't hit that, but I definitely need to strive to that every single day, right? So we have aspirational Krs that you can deliver some part of it and you want to strive for bigger kind of have stretch goals and we have some committed KRS which are, we must deliver this and we also of this product alignment. So it kind of starts at the top and it goes into server and then service and then it goes into teams and then sometimes even into individual cares. So basically, you have leadership responsible for the big, big picture, right? A strategic goal is that Microsoft delivers Xy and Z, but then you have teams responsible for particular details, right? So the leadership doesn't micromanage every single team um delivery. So let's talk about what we actually undeveloped teams especially measure, right? So we measure usage. So customer engagement, customer satisfaction, customer ch and how many people dropped off, right? How many people are using the feature? Then we measure time to build self test, deploy and stuff like that, that it pertains to C I CD and we measure lifetime health. So like time to communicate and incident detect gate and stuff like that sl A per customer because sometimes you can be overall performing really well, but your particular customers can be suffering and you want to look at sl A per customer, not just as a in general. More importantly, this is my favorite thing we don't watch for things. Some things are very bad indicators. So we don't watch if you met your original estimate, right? It doesn't matter. And you again, don't want people to start sandbagging you on this. This is why we don't look at team burn down and team velocity at capacity rate. These numbers are not that important. And if you say velocity is very important and people are gonna start estimating things differently. So we look at things that we have completed, not at how long it took us to complete it because we're not oracles, we can't predict the future. Sure, we don't know what feature is gonna be harder or easier to deliver. But, um, we don't look at lines of code, my favorite one, right? Lines of code definitely don't measure productivity. We also don't look at number of bugs found, right? It's a bad metric because then people start finding all sorts of bugs. Um, and it does nothing for your actual customer satisfaction, but you know, you have a lot of bug hunting going on. So we are customer obsessed. So all these metrics, if you notice on a previous slide, actually come from talking to customers and looking at what customers really want. So basically, the evolution of done at Microsoft went through these like very and I think this happens in a lot of companies. I think this is relevant for a lot of people. So basically, we started with works on my machine, right? I delivered the feature when it compiles and works on my machine. That's not a very good definition of done. So we got into OK, it merged into development branch right. So we have a development branch and it actually merged in today, which means it works with some other code from some other people a little bit better. Then it went ok, it merged into a main branch. So that's even better, right? We are getting closer to trunk based development and all the good things. Then it passes all the tests. So that's great. Right. It's kind of like, ok, we're there, right. We're done well, of course not. There's also some other stages. So live in production. Then basically we thought we arrived, right. Live in production, we deliver the feature, it is working it, nothing is breaking great. But there's one more stage to this, which is actually more important, which is live introduction and customers are happy with it. So basically it is only delivered when your customers are happy with it. And you have to have ways to estimate if your customers are happy with it. Otherwise you just kind of work being in your own engineering bunker and you don't really know what's happening in the outside world. So we used to actually say, OK, we know what our customers want and we are going to build it all by ourselves. Now we do something that's called hypothesis driven development. So basically we go and we say, OK, we think customers want want a YC, right? Then we go to talk to customers, we actually do customer usage. We uh understand how to develop a feature, how to design it. But then once we deliver it, we actually look at customers, how many customers are using it, how many customers are happy with it, how many customers are recommending it to their friends and stuff like that? So basically all of that is the definition of done. And I think that makes Microsoft products a lot better than they used to be. So um we also gather customer feedback. So there's a little bit of ways and there sometimes are too many ways. But um we basically gather stack overflow in MS DN forums. I think that's been renamed from MS DN. Now, I need to update the slide. Uh but basically, we are um gathering information from customers talking about our features. We also gather feedback in the product. So actually what we into these dialogues actually is estimating how much to do so that it's not distracting and customers don't hate you for this, but you basically can report a bug. Even if you're in a free tier, you can make a suggestion, right? So you can measure customer experience in your own product. So if I just discovered a new feature and I hate it, I can tell Microsoft about it or if I love it, I can tell Microsoft about it right, then we have something that's called customer champions. So basically, we talk to our largest customers and we actually attach like an engineering champion to a customer So that allows us to, you know, that situation that I talked about when most of your customers are happy, but some customer is not, especially for the largest customers. A big enterprise may not be in the same situation that are free to your customers are. So basically, we want to have a person who talks to them maybe on monthly basis and actually finds out what their experience is like and can champion for them inside the organization. Say, hey, you know what this and this enterprise is struggling with X or they really want to feature Y. So please please please product team, we need to work on this, right? So that allows us to keep in touch. Um And then also OK, I'm kind of switching gears here and I'm going to talk about something that matters also is the how we build our teams. So it basically started with Microsoft having program management development and testing, right? And development and testing used to be different, different things, right? Um We decided that it wasn't representative. So we basically switched it to everyone is a software engineer, whether you write tests today or you write code today, you are a software engineer. And then basically we have program management um SRE sort of discipline and then engineering. Um and then the major change was actually combining all these teams into feature teams. So instead of going horizontal and so I work on the data and you work on the U I and if the customer is unhappy with the U I, it's your problem, we now go vertical, right? So everyone who's working on a feature is in this vertical team and that we find increases the sense of ownership for everybody on the team to working on the feature, right? And to actually delivering customer satisfaction. So every team has a, you know, someone who's responsible for deploying it and someone who's responsible for data and someone's responsible for API and someone's responsible for design and stuff like that. And maybe you don't get a full, you know, full time design on your team, maybe you get 1/5 of their time, but actually designer is part of that feature and part of ownership of that feature to the customer, right? So again, it increased the sense of ownership and people are actually instead of blaming people in the other levels, um are just looking at how happy customers are with actually the feature they delivered and then we do something. So I think I've only encountered that at Microsoft, I've never seen it anywhere else. Um Basically, we do something that's called yellow sticky notes exercises. So every now and again, usually not more often than once a year. Um but it kind of depends on what's going on. So every now and again, we have this situation where product managers come in and they pitch their feature or their workload to the team and engineers can go and switch teams and choose which team they're working on. So, what we see is most of the engineers don't switch through. It's less than 20% people switching, but it encourages this sort of self forming team. And if I'm not interested in this and I want to learn some other technology or I want to work on some other problem, then I can switch. It's also encourages people to kind of stay um alert and emerged in their work. So this is also something that um I've seen that Microsoft that I haven't really seen in other places, which is people are encouraged to change jobs inside of Microsoft. You don't have to hide it from your manager that you're interviewing for another team because uh your manager will support you in taking a new direction because Microsoft understands that people are happy when they're challenged. And so you don't want to stay in the same job for, you know, way too long. So you basically want to keep moving. Um So OK, and then let's talk a little bit about how to collaborate on code. So open source is this big thing that happened over the past, you know, I don't know, a few decades and then basically open source also influenced how we work inside our organization. So one of the things that Microsoft is currently working with is inner source, so that's when you allow other people to sort of change and contribute to the code that you are developing. So basically, this funnel is more for open source, but it works the same way for inner source. Basically, most of the people that consume your code will just consume your code, right? They will take your code and they will use it and you will never hear from them. Then a little bit of people contribute time. So they will log a bug or they will improve your documentation or something like that, less people will contribute code. Um So they will do a bug fix or develop a new test or do something like that. And then very, very small amount of people will actually own the project, right? So they will actually be part of your team, they will influence the direction, even if they're on the outside, often you end up hiring them um that that is what happens. So basically, if you want people to contribute to your projects, you need to do a few things. So you need to have a really good read me about what the project is about. You need to have a really good contributing MD. So you describe how to get started, right? Because if people show up and they don't know how to get started, they're not gonna contribute, right? So you have to be very, very specific about how to work with your project. Um And then you, it's also really useful to maintain a list of good first issues. So if someone shows up and they want to pick up and contribute, um they can actually pick up an issue that's been designated as something simple that they can learn and contribute very quickly. So if we look at internal Microsoft data, 90% of four requests originate from the same team, but then we do have about 9% of four requests originating from nearby teams and then 1% from very distant teams. So this is actually very cool because if you think about it, sometimes as an engineer, I am blocked by a different team, right? So I want a particular feature that another team is responsible for and they actually, it's not a priority for them. So they don't actually are are not getting to delivering that well, with pull requests and approval process, I can actually go and contribute that feature and they can test my code, make sure that it works, make sure that it's up to their standard and actually go with it, right? And that enables me to unblock myself and by contributing to other people's teams. So to do that, we actually did um change incentives inside Microsoft. So instead of being rewarded on sort of only your personal contributions, we are now rewarding people on contributing to other people's success and leveraging other people's work, right? So when your bonus depends on competition, you're gonna compete. But if your bonus depends on collaboration, you are more likely to collaborate. So the other thing and again, starting new topic a little bit um is iterating over pain. So this is a lesson for any doubt of transformation ever, right? You start where it hurts the most and then you move slowly and you fix the most painful thing and then you pick up the next most painful thing and stuff like that. So a good example that I like for this is where we were with the test automation. So Microsoft actually started with tests that for. So for a the product, um the tests were running for 24 hours, actually, a little bit more than 24 hours. So basically, you couldn't release the service every day because you couldn't even run the test every day, right? It wouldn't complete in a day. So basically, all over time, we moved to this situation where we actually have 85,000 tests that run in under seven minutes, right? This is a real screenshot. So usually when people see that they're like, oh my God, how do you do that? Well, it took a long time. It took about three years to get to this state. So basically, we didn't say, ok, we're now gonna work only on improving testing, right? Because customers don't usually understand this, right? Um We basically took a little bit of time out of every sprint to improve the test. We eliminated flaky tests, we eliminated actually, most of the U I tests because they were very unreliable and they took a long time and basically we switched it tiny bits over time. And so now we got to this and this is just actually just the test that run on every pull request, right? So this is not even the full test suite, but it runs in under seven minutes. So basically, one of the things that I highly recommend is using pull requests as a sort of gateway to production, right? So you can both review the code on pull request and you can run lots of automated tests on pull requests. So basically, before your code even makes it into the main branch, you know, that you've verified uh the coding standards on that code and pull request is tremendously useful to that as a tool. Um And then you can have the uh you know, the approach of only green builds can make it to production. So this screenshot everything is green, not everything is always green, but only the green builds actually make it to pro right? There's no such thing as, oh, the tests were red, but we push them anyway because they're flaky eliminate flaky tests. Flaky tests are, are sometimes worse than no test, right? So we want to make sure that all of our tests are 100% reliable and they're actually verifying the um quality of our software. And then something that kind of goes hand in hand with all the deployment stuff is trunk based development. So basically when I talk about how Microsoft develops on the main branch all the time, right? And everything goes into production all the time. People are like, oh my God, that's impossible, right? Like I can't do that. Like I need to have a development branch. I need to, you know, have a staging branch to run my test and stuff like that. So I have a question to you. Um Do you test in production? Usually people, people get a heart attack and stuff. But the answer to this is if you've ever fixed the bug in production, then you are testing in production. Basically all the code that you're pushing all the time is getting tested by your users, which is not ideal, right? You want to test being tested by testers or your code being tested by testers, not by users. So basically how do you develop a three months worth of feature um and push the production all of the time? Well, I'm not ready with my code and how could I possibly do that? The answer to that is feature flags and feature flags are tremendously useful. So all of the code is deployed all of the time, right? But you actually have control. So in Microsoft products and github products, we have control um on both sides. So basically the user can opt in a new feature and also the uh team on the back end can turn on the feature, right? So we can choose for instance to turn on the feature for a subset of users or stuff like that, right? And so all the code is pushed all the time. This is essentially dark launch, right? We're not dark launching our code all the time, which is way safer than developing something for three months and then pushing it into production for the first time right before it's getting used, right? And then the other thing that we do is ring based about deployment. So basically we start small and kind of roll through the data centers in into which we deploy stuff. And so for us, we're lucky and we have internal users, like I said, 100 10,000 or so engineers at Microsoft working with our tools. So basically, we have lots of our own testers. So if something does work, we're gonna go get a call from a team next door and be like, hey, you broke a feature, right? Not everyone is this lucky. Um So if you're not this lucky, you need more elaborate testing, more elaborate Q A procedures, but we do push first through internal users. Um and kind of have we have a waiting period of 24 hours before that goes through the first external customers. OK? So some more notes and this kind of abbreviated version of some of these um so secure, the software supply chain, security is really important and it's really hard. We have much more developers than software than uh software security professionals. So we need to worry about the code we're pushing all the time. So one thing we know from software software reports is that the more code we push the more security issues we actually introduce. Right. So it's, it's really, we're not learning from mistakes. We're actually pushing security vulnerabilities with every line of code. So what you want is to automate this as much as possible because people don't like to talk about security. A lot of people don't understand security, right? And again, we can talk about security for another hour. But in general, you want to basically um add security procedures into your pipeline as much as you can, right? So you can have ID security plugins, you can have threat threat modeling, which involves real people discussing features, right? Um You can have pre commit hooks and peer review on pull requests and stuff like that, right? Um Dependency management is really, really important because most of the hacks uh today are actually done by vulnerability known using known vulnerabilities to attack deployed software. Um And then you can have, you know Infra Code actually is very helpful because if you can rotate your infrastructure, then you have no longer standing servers. And when you have no longer sting servers, it's less likely that the hackers are gonna be able to sort of camp in, in your infrastructure, which happens actually, a lot. So, um rotating your software, rotating your infra rotating your keys as, as much as possible. Right? And then of course, you get all the way to the deployment and you have pen test and all sorts of security controls and again, no one wants to be the next headline. Right? Um, I know sometimes security is, it seems like a pain but it is really important to invest in it. And then we want to build for resiliency. So we want our apps to be resilient and highly available, right? So again, we can talk for hours about Slas and Sl Os and all that stuff. But basically, we want to have a life side service that is available at the time. We're in a very different predicament than we used to be a few years ago. And we actually want to make sure our customers have a good experience with that. So yeah, the point of this slide is being transparent with your customers. We've learned that actually communicating stuff to our customers about the incidents works better than trying to pretend it never happened. Ok. So I'm kind of getting at time. So I'm not gonna dive super into all this. Um But of course, the journey continues. So we're investing in remote work now. So this is something that's not new to github, but very new to Microsoft Microsoft used to be co located for the most part. And so now we are trying to work on empowering knowledge sharing between our teams. And one thing that I want to recommend is a book uh called Making Work Visible. Um So this is something that I think more important in the remote world that it ever even was in person because you can actually make sure that what people are working on is visible. And so people understand the productivity and the workload and the level of burnout on teams and then cool things that we're working on is MLS. So basically, um ML scientists are struggling with completely new and sometimes the same problems that developers were struggling with 10 years ago. And so basically, Microsoft is working on releasing tools for making that workload easier. And a journey of 1000 miles starts with a single sprint doves isn't magic. If Microsoft can do it, you can too. So thank you so much. I am divine ups on github and on Twitter and I hope to see you soon.

---
