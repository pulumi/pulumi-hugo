---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Cloud Engineering Summit 2020: Introduction to GitOps"
title: "Cloud Engineering Summit 2020: Introduction to GitOps"
meta_desc: |
    In this lightning talk, you'll learn how to take DevOps best practices used for application development such as version control, collaboration, com...
url_slug: cloud-engineering-summit-2020-introduction-gitops
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Cloud Engineering Summit 2020: Introduction to GitOps"
  description: |
    In this lightning talk, you'll learn how to take DevOps best practices used for application development such as version control, collaboration, compliance, and CI/CD, and apply them to infrastructure automation.
  sortable_date: 2020-11-11T00:28:53Z
  youtube_url: https://www.youtube.com/embed/Tqy8ZMxy57s
transcript: |
    Hello, my name is William Chia. I serve on the product marketing team at GIT lab and in the next 15 minutes, I'm gonna show you how to manage EKS Kubernetes clusters on Aws with Git lab and Pulumi using GIT ops principles for collaboration and compliance. At the end, I'll walk you through all of the code that I'm using to make it all happen so that you can try it out yourself to get started. Let me go ahead and share my screen. This is an introduction to GS and I'm happy to be here at the Cloud Engineering Summit. As I mentioned, my name is William. You can find me on Twitter, linkedin and I would love to connect with you all. And as I mentioned, all of the code and the links I'll be showing today are in this glab repository glab dot com slash William Chia slash AWS dash py dash EKS, I've mirrored all the code here so you can check it out yourselves. And if there's anything uh interesting or you have any questions, please do go ahead and tweet it out. You can tweet me at, at the William Chia. Use the hashtag Cloud Engineering Summit or hashtag GS. So I wonder how many of you have ever run into this scenario might be a little familiar. You are logged into the AWS console and you need to do some type of infrastructure management, but it's not exactly designed for collaboration. For example, here I have uh an EKS node group that's part of it uh Kubernetes cluster and I can see that it's got a four node maximum with a three node desire state. And I've heard from my Dev DEV team that this is uh this is kind of a bit large really, this should be smaller or I really only need two nodes. This is a small service doesn't get a lot of traffic. So can you please go and, and update the, the node sign? So we're not using as many resources? Well, one way to do it is I can just click around in a gooey and edit and make the changes and go ahead and save those. But the problem is, who knows about it? How did I know I make the right changes? What kind of review did it go through? Where's the record of the actions taken? And is that record in context of all of my other infrastructure changes? You can see and for that matter, if somebody else wants to do the same thing again, you have the same problem arise or the same situation arise and you want to modify the Infra to, to match that. Where's the record of that? How do I understand any of those things? I don't get any of that if I just go in and click around. So instead what I wanna do is I want to use, I wanna use infrastructure as code using Pulumi to manage this. So let me show you what that looks like here. I have a repo and uh I've taken this repo as a sample from Pulumi examples. They're all here in the github repo. I'm happy to use the uh Python Eks one. But if you look at these examples, you can find almost any cloud in any language. There's a lot to start with there. Additionally, I've set it up for GIT lamps C I CD and that uh instruction is here, I'll walk you through this code at the end and I've even set up something that's new this Pulumi Git lab integration. And with this web hook, you get some cool interaction that'll show a bit later on in the demo. So let me show you a ops workflow to go ahead and update that cluster. The first thing is, let's say someone on our DEV team is gonna log a new issue in GIT lab and they're gonna say uh reduce the node size um using too much power, need less power. Usually we need more power, but in this case, we need less power, we wanna slim it down. So what's nice about this is now we can collaborate uh on this project. I can leave comments and this sort of thing. And let's say in this case, this is a comment bot, but let's just imagine it's uh someone on the DEV team or perhaps a, an engineering manager and they're going to assign the task to me to go pick it up, maybe uh send me a note with a tag so that I get a notification. Can you pick this one up? And then if we look at the view from my own git lab, I can see, I probably got a to do here and I can see, hey, can you pick this one up? So I'll go ahead and take a look at that and I can say uh at Seabot 2000. Yeah, no prob so I'm uh I'm picking this one up and the first thing I wanna do is from this issue, I wanna create a merger quest. And what that's gonna do is create a new branch for me so that I can start working on this request and it's going to start a merger quest to merge that branch back into master. And it's gonna tie this to the issue so that when this gets merged, uh it's gonna go ahead and close this last thing it's gonna do is gonna mark it as a draft. So people know I'm still working on this and they don't merge it automatically all of this is set up really nice and automatically with that one button. So the next thing is I might check out the ranch and work on it locally, but I'm gonna go ahead and open this up in my web ID E here. I have my uh all of my Gammel and um code set up. I'll walk you through this in a little bit when you can see how it works and then I'll show you what it's doing. But in this case, I'm using this Pulumi uh Python to set the size with infrastructures code rather than a manual click. So for example, let's set this down to a node size of two and I'm gonna say reduced nodes to two and go ahead and commit that this is in the get lab uh get lab web ID E. But you could, like I said, you could do this locally as well. So now I can see that a few things have happened since I've committed that code, it's kicked off a pipeline to go ahead and test that out. So I think this is probably ready. I'm gonna market is ready and I'm gonna go ahead and tag for review at seabot 2000. Uh How does this look to you? And even though I'm using a kind of trivial example here, I'm just changing a few notes I wanted to change to be simple to understand what's important here is this collaboration. This is how as platform engineers, infrastructure and operations engineers, you can collaborate with each other or collaborate with your dev teams so that you have collaboration between developers, the security team, the operations team all in one place. So if we look now back at our comment bots view of the uh of the issue, they see, OK, here is this uh related merger quest and they can now go to the changes and they can see, oh OK, I've put it to two and maybe they might make a comment, uh you know, looks good. Um Or maybe if there's a question, it could provide a in line suggestion, you know, maybe to, to make it three instead of two, not 23. But in this case, we think that two looks good, we're gonna add that comment and others can add those kind of in line comments. And what that does is creates an unresolved thread here. So this is really nice because when we go through, we can look at the merger quest and see all of our feedback from our peers. So for example, in this case, we see there's an unresolved thread, we're gonna jump to that thread. In this case, we're just being told this looks good, but maybe it might be something to address and when we address that problem, uh then we can resolve the thread. So we can see we'll go ahead and resolve the thread and that'll make the change ready to merge. We can also see that our pipeline passed and it all looks good. What I can do now is go ahead and merge the code because it's been reviewed. And what's really nice about this is in my GK get commit history. I have a history of what exact changes were made. I have a history of who participated in this. I have the discussion that took place I was able to collaborate. So even with this small trivial change, I've been able to have a lot of collaboration and even have some compliance capabilities. For example, let's say you might want a lot of people to be able to suggest changes to your infrastructure. Anybody could make a merge request to suggest a change, but you could lock down the permission so that maybe only a few people have that ability to merge or approve. And so this allows you to stay compliant as well with your internal compliance policies or if you have regulatory compliance and it's a lot faster and a lot more automated than uh you know, having that change management meeting. So this is a, a much more modern way to do it. What I can see here is as I've merged, it's, it's gone and kicked off a pipeline to go ahead and uh do my master pipeline where I have a build and an infrastructure update. And the last thing that I wanna show that's really neat is here is the uh Pulumi integration. So even though this comment was left by the comment bot, you can see, I didn't leave it. This was done via the integration. And what it's done is sent the Pulumi plan output directly as a comment. So one way I could review this is I could go to the pipeline and look at the actual job and I can see the job that's run. I can uh even go to the Perma link, which is really nice. I can open this up inside of Pulumi console. I get a lot of nice changes here. Uh I can see what was updated, but instead of uh having to make all of those clicks and all of those steps with that one web hook that uh uh we've set up, we get a comment here to show us uh what the update and what the change was made from Pulumi. So as it runs the master pipeline, it's gonna go ahead and uh make those changes, update those in my cluster. We'll take a look at those in just a moment. Let me walk you through some of the code. So as I mentioned, I started with uh the basic Aws Python Eks example that I just downloaded off the repository and I just made a few changes. One of the changes was I added the GIT lab C I CD configuration and this added three scripts here, a setup script which basically just logs in a Pulumi So when this setup script runs, it's gonna log me in, there is a preview script and there is a run script and you can see these are exactly the same. The only difference is this one runs Pulumi preview. So it's gonna show me the changes but not actually enact them. And this one actually runs Pulumi up and go ahead, go ahead and make the changes. And this is my GIT lab CIML file. So this is the file that is configuring these pipelines that are running. You can see, I've got two stages here. A build and an infrastructure update. The build phase is just a stub. But this could be where you set up your U I, your service and the infrastructure updates, the one we care about. So what we're doing here is on the master branch, we are running the run Pulumi or the Pulumi Up script to enact the changes. And on the merger quest, we're running the preview. So uh when we have a merger quest, this is the test. I just want to see the preview. I don't, you know, every time I make a change in a merger request, I don't want it to actually go and enact those changes. I just want to preview them. But when it all looks good and I actually merged a master, then I'm actually gonna run uh the Pulumi up and enact those changes on AWS. And the last thing I'll point out a really nice feature is that in order to make this really easy is I've just pulled the Pulumi Python image of a Docker hub so that it already has Pulumi installed when it goes to run my C CD, it just uh pulls in this image and it can just start executing these commands. That's uh that's the basic setup. This is the uh main Python. We can see that it's uh got the old um uh info there. But if I do a a get pull, it'll uh it'll pull my changes and I can see there we go. Now it's updated and let's go take a look at that master branch. It looks like it has finished running, it's completed successfully. And in theory, if this all goes well, and we look at our AWS cluster, we can see we now have two nodes, it's the same change. But in this case, we've done it in a way that's collaboration. We've done it through compliance. We call this git ops operations by git request. Thanks a lot for watching. Please do uh reach out to me on Twitter and have an excellent day. Cheers.

---
