---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Resource Graphs | Modern Infrastructure"
title: "Resource Graphs | Modern Infrastructure"
meta_desc: |
    In this video on resource graphs, David introduces us to the Pulumi resource graph. We learn how to manipulate it with explicit and implicit depend...
url_slug: resource-graphs-modern-infrastructure
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Resource Graphs | Modern Infrastructure"
  description: |
    In this video on resource graphs, David introduces us to the Pulumi resource graph. We learn how to manipulate it with explicit and implicit dependencies, as well as visualize it with your web browser.  Want to propose something for us to talk about? Drop a request in the comments or head to this GitHub repo to add a topic request or vote for your favorite with emojis: https://pulumip.us/pulumitv-github  Watch the whole Modern Infrastructure series at https://pulumip.us/modern-infra  Learn more about Pulumi at https://pulumip.us/home
  sortable_date: 2022-03-31T22:00:04Z
  youtube_url: https://www.youtube.com/embed/C7l5ajiMhsk
transcript: |
    Hello and welcome to modern infrastructure here at Pulumi TV. My name is David Flanagan though you may know me from across the internet as rock code today. I want to follow up from my awesome colleague, Laura who just published an amazing quick bit on graphs. Graphs are such an important part of working with Pulumi that I thought we should take a look in a bit more detail I could. Before we get into the code, I want to show you how to debug or understand your plumy resource graph. Pulumi shipped with a stack graph command. This command writes a graph or at least graph notation to a fail. This notation is called graph or dot This can be viewed as an image with a variety of tools from websites, desktop viewers or even just in VS code. It's a pretty well supported format for graph images. So let's take a look at a simple graph of some resources when we have no dependencies within our stack. So let's start by creating a couple of resources. The first thing I'm gonna do is import the lime random from Pulumi random. I will just allow us to create a few resources such as a random string, which can equal to random random string. We'll just call this first. We'll open up the options and we'll see that we need what we need that. Oh Yeah, cool. And we can set the length. So now we have our first resource. Now, let's create our second resource and we'll make this one a random integer. We can do a new random random integer. We call it second which takes some options. So we'll say man two max 64 and it takes a seat which can be just a little. And we have a prelim program with two resources and no dependencies. Now, we can go to our terminal and run a li me up and it says we're going to create a stack and two resources I mentioned at the start that there is a plume stat graph command which will allow us to output dot notation to generate the graph to be able to inspect it or visualize it. So we can just output that I can run cat to PB copy which copies it to my buffer. And there are a whole bunch of ways to visualize this. But I'm just going to use sketches. And what sketch says allows us to do is to see that we have a graph here. And the two resources that we're creating are actually depending on the stack existing. So we have our ply stack random integer and our random string. And there's nothing particularly special about dot notation, either we can open this file inside the VS code. And we'll see that we have straight digraph. This is a directed graph resource is a random integer. We can specify that it requires a resource one, resource. One is just our stack. We then have resource two, which is our random string, which also has a dependency on our stack. And then the last thing we have here is just a provider which doesn't really have any dependencies. So it's really easy to work with the dot notation syntax. In fact, you can use this for many, many things beyond Pulumi. Cool. So let's start to manipulate this graph. The first way to do this, we Pulumi is via explicit dependencies. And by that, I mean, using the depends on resource option, we can take complete control over the graph and the order in which resources are provisioned by ensuring that we explicitly set the dependencies via depends on on our resources. So let's check that out. So let's add our first explicit dependency. Now let's just quickly recap on how resource creation works we call new on some thing, right, random string and random integer. The first thing we pass to this function is the name of the resource followed by a dictionary or object, which is the resource arguments, the information that we need to be able to successfully construct the resource. But all resources have a third option, which is the resource options can actually configure the way that this resource interacts with the broader PLU program. We can add aliases. If we need more than one name for a resource, custom timeouts, we can do life sale hooks with delete before replace. We can tell it to ignore changes, we can set a parent. But what's important for today is depends on and this depends on can take an array of resources that are a dependency that must be created before such resource. And just to make our graph look a little bit more interesting, we'll create one more resource. Let's have a random password equals new random random password. We'll call this third and the length can be 32 and we set a dependency on here of a random integer. Now we can come and run a lo me up once more. We have one resource to create and then they'll generate our stack graph again. We can jump back to this web interface, copy all this drop in our new graph. And we can see it's starting to take a bit more shape because we have a provider over here all on its own. There are no dependencies there. We have a graph right at the bottom or stack, right at the bottom. We can see the dependencies follow through we have a random string, a random integer and a random password. And we can see that a random password depends on a random integer and that a random integer depends on a random string. So you can use explicit, depends on key as a resource option on all resources to enforce the order of creation explicit dependencies work just fine. But it can become a little bit for both, especially if we have other ways to infer the dependency graph. Fortunately, there is due to Pulumi input output system. Pulumi can actually work out when an output from one resource is being consumed or used by another. When we ask Pulumi to get the result of an output and pass it to another resource. Pulumi automatically builds up the dependency graph forest. So let's take a look at that. OK. Let's remove all our explicit dependencies. We can remove it from here. We're gonna remove it from here and now we're back to a stack that has more dependencies. No. And plus the dependencies of what pau and fairs to be fantasies. So when we use an output from one resource on another, well, we will detect this. So why don't we use a random string as a seat for a random integer? You can see random strength dot result. And then instead of setting a hard coded length on a random password, we'll use a random integer and see a result. So now we can no longer create the random password without the random integer existing and we can no longer create a random integer without the random string existing. And while they're not set and expressed dependent, but it depends on Ha Lumi is gonna work this out for you to the point where if we come back and run the loo me up, it will replace the two resources. It's doing this because the seed changed to a random string and the length is also random. So that also changed. But we can also regenerate our stack graph. You can copy that to your buffer and jump back to sketch first. We can drop this then and nothing has really changed. We still have our provider all on its own. We still have our stack all the way at the bottom. A random string still gets passed into random integer. Random integer becomes dependent on random string and a random integer is passed in to random password meaning a random password is dependent on random integer. This graph is actually no different than what it was last time of those slightly different visualization. And this works at the micro and the macro level. It doesn't matter if your stack has one resource or four resources or 200 resources or 1000 resources. The resource graph is always generated and enforced, meaning that your resources are always created in the right order, minimize and risk conditions and risk the better. Well, that's it. I hope you found this video useful. Let us know by clicking the like button, leave in a comment or hey, maybe even subscribe to our channel because we want to help you be successful with polluting and we hope that you found this video useful too. See you all next time.

---
