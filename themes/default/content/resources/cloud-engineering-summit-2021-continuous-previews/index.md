---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Cloud Engineering Summit 2021: Continuous Previews"
title: "Cloud Engineering Summit 2021: Continuous Previews"
meta_desc: |
    Continuous Integration and Continous Deployments have been part of our application lifecycle for some time now but what about Continuous Previews? ...
url_slug: cloud-engineering-summit-2021-continuous-previews
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Cloud Engineering Summit 2021: Continuous Previews"
  description: |
    Continuous Integration and Continous Deployments have been part of our application lifecycle for some time now but what about Continuous Previews? The ability to easily share new features and changes to a wide audience within your organization is a game changer for accelerating the delivery of features your users need. In this talk we will walk you through everything you need to know to deploy a Continuous Previews pipeline. Starting with containerizing your application, deploying to a cluster and connecting the results back to a GitHub Pull Request. Attendees will leave this session ready to take control of their development process in ways they may not have known were possible.  Talk by: Peter McKee and Josh Thurman
  sortable_date: 2021-10-20T23:01:46Z
  youtube_url: https://www.youtube.com/embed/n2T_6RqCxMQ
transcript: |
    Hello, everybody. My name is Peter mckee. I'm the head of developer relations at Docker and today Josh and I are gonna talk about how continuous previews is. Cha is a game changer for accelerating and delivering new features and development to your end users. So I'm gonna hand it over to Josh. He's gonna walk through some concepts of continuous uh previews and then we'll quickly jump back and I'll go through a quick demo and uh then we'll wrap things up. All right, Josh over to you. Yeah. Thanks Peter. Um I'm Josh Thurman, head of developer relations for you Fei. I'm gonna jump right into explaining the why, what and how of the continuous previews methodology. Share my screen here. OK. So let's start with why. So why CP So what um so teams that follow AC P method um will be able to begin testing earlier in the development process. So with CP, you move, you're effectively removing any gaps between the developer writing the code and the approver who's testing the feature that they're working on. Um Second uh teams that use this will accelerate their iterative feedback loops, which means they will be able to speed up how quickly an issue can be reviewed, feedback provided and adjustments made. And third uh teams that adopt the CP method will simplify their overall testing process with CP features are can easily be tested independently and feature testing can be separated from integration testing. So I want to frame this a little bit um in the overall software production process. So every team that develops software has four hurdles, they've got to overcome one, the development of new code to the integration of that new code with existing code, three, acceptance testing and four delivery to end users. So I would venture to say that everyone tuning in can easily think of numerous tools and processes that support development, integration and delivery. But what about tools and processes that improve how software is accepted and tested? Um We're all kind of probably scratching our heads on that. So this is where CP comes in. Uh CP is a method that fundamentally improves how your team collaboratively tests new software. So let's talk about the foundation of the continuous preview process. There's eight principles behind it. One continuous collaboration, two empower DEVS with production like test environments, three tight integration between your ticketing repositories in infrastructure. No additional burdens on placed on the dev team limit contact switching. We all know that's costly uh confirming functionality prior to integration, reliance on automation and support for full stack. So front end back end microservices API S anything else you can think of. So how does CP fit within agile? So if agile is the overall umbrella that drives uh how we build software CP is a method or a best practice that is nested within agile. So the big loop here uh represents a typical agile workflow. New requirement is designed and ticketed developer picks that up and begins their work. Uh When they're finished, that branch is merged, it goes through an integration step and then uh your acceptance testing begins. So the problem with uh this model is there's too much of a gap between the individual developer writing new code and the person approving that feature. So CP is an add-on method to the overall agile workflow and enables feedback loops to begin earlier and happen faster. So you see the little continuous preview piece that happens in the development uh section there. So it's a tighter loop and it's a loop between again the developer writing the code and the person approving it. So next, I'll talk about, you know, a little compare and contrast. What does a non CP process look like versus AC P process? I'm just gonna be descriptive here. So in a non CP, uh testing does not begin until uh post integration, you have a delayed feedback loop between the person writing the code and the approver feature and integration testing are done in batches. So they're, they're all coupled together. You have persistent uh Q A slash test environments, there is more context switching and you're at a higher risk of breaking or breaking uh your Q A environments. So in uh AC P workflow testing begins pre integration, you have a continuous feedback loop between the person writing the code and the approver feature and integration testing are decoupled. So you have a separation of uh concerns and you have instead of persistent environments, you have on demand test environments uh and that are have a purpose driven life cycle and you have as many as you need, you also have limited context switching and you've got a lower risk of breaking or breaking uh your Q A, let's talk about CP and branching. So I'm showing a github flow here. And so in this case, uh a developer has uh checked out a topic branch. And when you're following the CP method, it can easily be deployed to an on demand environment that has a purpose driven life cycle. This again enables the developer and approver to quickly iterate through feedback loops until the feature is approved. So in this case, the developer um has checked out the topic branch, begun work and because it's being continuously previewed, an improver is reviewing the work in progress and providing feedback. So in this scenario, uh we see two thumbs downs, there was two feedback iterations that did not pass on the third iteration they accepted the feature and it was approved. So now the feature can be merged so merged. So we've been able to test and accept the feature in isolation and later if and when we are tracing root cause issues in a post mege review, we can have confidence that any issues are most likely related to integration or not functionality issues. So that reduces um our time spent debugging. So let's look at the CP loop and I previously mentioned one of the principles which is tight integration between ticketing repository and infrastructure and that is uh displayed here. So this issue starts as a ticket and then developer begins working on it uh again in a git uh workflow. So CP is the automation step that occurs. So from um a GIT workflow, you should be able to kick off a preview deployment without breaking context. That deployment is then gonna go uh to your infrastructure and then to close the loop. Uh once you have a preview URL that shows back up in your ticketing system and so that signals to the uh whoever's Q A or approving this feature that it is ready to be uh reviewed. And of course, the process continues uh through as many loops uh as required until the new feature is approved. So in summary, on the process, um continuous previews make it easy to collaborative review and test in progress feature development for full stack applications. So our acceptance testing can happen earlier in the development process. Uh We can accelerate our iterative feedback loops and overall testing process has been simplified. We can feature test in isolation, we can also separate feature testing from integration testing. And so all this results in improvements against our key performance indicators. Uh Some common ones are lead time cycle, time, team, velocity and code stability. And of course, that all leads to happy end users. So uh enough about concept, let's get going with um seeing a technical implementation of this. So I'm gonna pass it back to Peter. Uh who's gonna uh share what he's got? All right, thanks Josh. So let me go ahead and share my screen and let's take a look at um little demo application that I have. So first, I have a, a small little continuous preview uh server that I wrote and it's running on a remote machine. Um And now I have a little app application I have running locally. You could see it here on port 3000. It's a um just a small Crud app and I'm gonna go ahead and make a change. We got a ticket that came into um into our queue. I'm a developer on a team. So they want to get rid of this continuous previews in the title. So, um we're just gonna call it widgets application. Let me save that. Then I'm gonna come over to my command line. I'm gonna stop this. I'm running inside of containers and then I'm gonna restart it. So I'm doing Docker Compose up and I'm giving it a dash dash build. So it'll rebuild my containers and this should run relatively quickly. Um And then start everything up with the changes. Give this a second to run. I'm running this in uh local on my machine and I wanted to run it in, in compose so I can do my dependent services and my application at once. Ok. So now it's up and running. Let's jump over here to the web, give it a quick f five refresh. And there we go, we have the title has been updated. Looks good to me. Let's uh let's go back in our command line and I'm gonna do a get commit and I'm gonna say uh update the title and then I'm gonna do a get push. So that's gonna run. And typically you have, you would have your continuous uh preview server connected into your get hub or bit bucket or whatever that is. And whenever you cut APR or do a push that can send a web hook into your server. So I'm gonna simulate a web hook here. I just have a little bas script that makes a call out to the web into the uh continuous preview server. And here it is running here, we get back. Everything's been built, everything's fine and it's done working. So that is updated. So now we're gonna come over here and you can see I'm running on my CP server. Um Let's give that a refresh. And now I have widget application, I can give this URL out to anybody on my team and the business peers, um business analysts, um and you know, product owners, they can come take a look at the application. Go. Yep, that looks great. Or they might say, you know what, no change that back. Uh We don't care. So let's pretend that that happened. So let me run in back into my application just gonna do a um an undo put the title back. I'm gonna say that and then I'm gonna do another um commit and I'm gonna say revert title and I'm gonna do a commit and a push that's been pushed and I'm gonna update, send uh a message into my um continuous preview server. There we go. Everything's been updated. If I come back into my continuous preview server and hit refresh. There we go. It's been updated. Now this URL again can be passed around to all your teammates. They could take a look at it and then you conti can continue on with the process once it gets signed off. All right, Josh, let me kick it back over to you. Yeah. Great Peter. Thank you for sharing that. So, share my screen again and I'm gonna show uh a continuous preview um with E Fei. So first, let's look at the app that I'm going to deploy. So this is a six container microservices application and I'm gonna work on uh a couple of these components. So I've got three off the shelf uh do official images here, engine X red and of course, a post container. And then I've got three custom uh elements that I'm working on. So I've got the voting app, uh the Results App component and the worker component. And so I'm gonna work on a couple of those and let me go following the CP loop. Let's start with ticketing on a new feature that has been designed. So uh here's my ticket. I'm gonna need to change the voting fact function. I'm gonna double the dog. So every time every vote for a dog gets doubled. So I've been working on that and let me show you, I already have this branch. I've already committed to it. And what I'm gonna do now that this is ready for uh to be reviewed or previewed by the approver. I'm gonna open my pull request, create and create. OK? So that pull request has been opened. Now, bear with me. I'm gonna do one more pull request and then we'll see uh why I'm doing that. So this was for the example vo voting worker component, let's say also that I was working on the uh results component and uh I was working on a change color branch. OK? So again, uh to save time for the demo, I've already committed my changes. I'm gonna open up a request here eight and create. OK. The importance of the pull request is I'm the developer working in my get workflow. And without doing anything uh extra, I actually kicked off a preview deployment for each of those branches that I've been working on and so I can go uh to ei here and watch. Uh When I did that pull request both of these deployments uh kicked off. So again, uh this first one is gonna preview the double dogs change that I made. And the 2nd, 2nd 1 is gonna preview the color change that I made. So once those go live, uh I will have a preview URL and to finish the CP loop and I already had this one running just to save uh time uh on the build process here. But I'm gonna finish the loop by going back into uh my ticketing system. In this case, I've got Jira and so this was the ticket I started with and uh EI went in here and placed this preview URL right here. So, uh whoever is approving this knows that it's available there, they can go take a look at it. Um If, if they need to uh make any comments, they can say uh no, not quite right. Of course, that's gonna go to the developer working on it and um they're gonna go back through the loop and try to make the changes until uh the prover uh has indicated that it does, does meet the requirements. And so and let me show you uh this in a little bit more detail. So what we've done on the backside is deployed six containers all to uh kubernetes. And uh this works with any, any cluster. This happens to be an EKS cluster. Um But you can run it on, on Azure on GK. You can also do it on prem um But I have all these containers running if I need to. If I have any issues, I can go in and actually I can look at the logs and these are filterable. So I can see uh you know, my build process was done and I can see the containers up because I can see the logs are, are running here. And so uh now this one's up and then it'll take maybe another 30 seconds or so and I'll be able to review uh those changes here. So, um so that's it. Uh That is a continuous preview in action uh leveraging efe automation and um Peter, I don't know if you have any final comments, but I appreciate everyone tuning in. And um yeah, please come uh check out uh continue previews. I wanted to reference uh a lot of my talk was from the CP Manifesto. Uh You can go view that at CP manifesto dot org to learn more about uh this process. It's open source. So uh you can also check out the repo and then go and uh we'd love to have uh feedback there um and more collaboration. So uh please check it out. Yeah, great. Thanks, Josh. Yeah. The only thing I would say is make sure you get out the manifest. So I think it's really important. Uh Yeah, like you said, give some feedback and we love to hear people's thoughts about it. Thanks everybody, really appreciate it.
---
