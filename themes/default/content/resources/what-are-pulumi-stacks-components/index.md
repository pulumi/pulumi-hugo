---
preview_image:
hero:
  image: /icons/containers.svg
  title: "What are Pulumi Stacks and Components?"
title: "What are Pulumi Stacks and Components?"
meta_desc: |
    In this tutorial, we'll show you how to structure, organize, and share your Infrastructure as Code using Pulumi and language constructs.
url_slug: what-are-pulumi-stacks-components
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "What are Pulumi Stacks and Components?"
  description: |
    In this tutorial, we'll show you how to structure, organize, and share your Infrastructure as Code using Pulumi and language constructs.  The examples are in TypeScript but Pulumi makes it easy to stand up infrastructure in your favorite languages including Python, JavaScript, Go, and .NET - saving time over legacy tools like CloudFormation and Terraform. https://www.pulumi.com/docs/get-started  â–º Join the Pulumi Community Slack: https://slack.pulumi.com/
  sortable_date: 2020-04-09T21:57:08Z
  youtube_url: https://www.youtube.com/embed/629luaYjwMQ
transcript: |
    Hello and welcome to Pulumi TV. My name is Mike Mare. In this installment, we'll review how to use Pulumi stacks and components to better organize your infrastructures code. Pulumi is a modern Infra infrastructure code tool that helps you declarative, describe your cloud infrastructure using real programming languages. Pulumi enables developers and operators to work seamlessly together and to help drive adoption to the cloud much faster. Let's get started in this episode. We'll review a couple of core concepts. You'll need to organize structure and share your code. We'll cover what a polling program is and how that relates to a pluming project. Then we'll visit stacks as a way to instantiate our plu programs and then we'll cover resources as far as what's built in and what you can use to customize your own attractions. Let's begin at the basis of any sort of Halloumi project is a Pulumi program. A Pulumi program is a collection of files written in the language of your choice. We support text script, javascript, Python go and dot net. These are the files, they're going to ultimately describe what infrastructure you want to instantiate for it to be run by the Pulumi cli, we have to take the Pulumi program and place it in what's known as the Pulumi project. And what this means is that we just have additional metadata and the ability to install dependencies that relates to the code. In question, you can either construct the Pulumi project using the Pulumi cli in our templating system or you can manually construct it. If you want to create the individual files yourself. Let's see how to use the cli to get started. We'll create a new directory first and CD into it. In this case, we're going to create an S3 bucket on Amazon. We use Pulumi new, which will give us the ability to choose a template. We're going to choose Aws using Python. It'll ask us for a project name. Let's say my super cool S3 bucket. We'll get her a description. We'll go with the default, the stack name. We're going to go with the default of death. But this could be anything that makes sense to us. We'll choose the region. I'm gonna choose us West too. And now we just have to run a couple of the set up instructions to actually run the update in Python. So we'll set up a virtual environment and activate it. We'll run some more commands to get our install set up. And then lastly, we'll all the dependencies needed by this program with that in place. We have everything we need constructed to run the Pulumi project before we run the update. Let's look at the code as you can see this is written in Python. I'm importing the Pulumi project using the S3 capabilities of our STK and they creating a bucket and exporting the name of that bucket. Let's run a topic. We first see a preview of the changes that will be presented to us. In this case, create a new bucket. We can see the details of that if we still choose to and if you wanna perform the update, we'll click. Yes, great. If I do bloomy stack output, I'll see that. Since I exported the bucket name of my bucket, we can use this to pass on to other cooling programs to share it with folks or to simply collect artifacts based on the programs that we ran. You can explore what stack we're in by running the Pulumi stack command. Again, a stack is an instantiation of a flu program. Let's dive deeper into what a stack is in Pulumi. A stack is an instantiation of that Pulumi project stack names could be anything you'd like them to be. They closely mirror your git branching strategy and the names often match. So for example, if my blooming project had a dev staging and prod branch, I most likely have a dev staging and prod stack. This allows you to use the same code but template it parameterize it or manage it as you see fit on a per environment basis stacks can also be tagged with metadata that allows you to sort filter or even adapt the stacks to be better searched and used within the Pulumi ecosystem. As we saw earlier, the Pulumi stack man gives us a dump of all the information that this current stack is in. We can see multiple stacks if they exist. Currently, we only have one the depth stack and we can create them by easily saying stack in it new stick. We can also erase that stack. We'll confirm the deletion and it's gone. Let's go back onto the dep stack by selecting it. Great. Now that we've seen how to get started with Pulumi using a Python project, for example. And what stacks are, let's shift gears a bit and show you what using stacks looks like with a real concrete example in my second tab as denoted by the bottom, I have two separate projects, an info project and an app project. Let's dive deeper into what each of these are. In this example, I created two Pulumi projects, one for my infrastructure. In this case, a cluster that I'll be deploying on GKE. And I created a second pluming project for my application that will be deployed into the cluster from the former stack. Infra I will export some key properties such as the cup and fig file and the name space to be working in from the stack and stacks can actually reference other stacks to pull data and key values that make sense to them. If we're looking here at our app project, I can leverage the Pulumi configured subsystem to reference a stack by using its essential reference name that is of the structure user project and dev or stack name for that matter. To retrieve that stack, we can go back to the infrastructure and say and my second reference is my user name, the project and the stack name in this application stack. As we can see in this helper script, I automatically set not only the zone and project to use in GCP, but I also allow myself the ability to reference a stack that the infrastructure was built in. So in this infrastructure, I stood up a basic community cluster because updates and Pulumi are item put in if I run it again and there are no changes, nothing will change. I can see its output by running stack output. And there I can see the coupon fick file which is a secret and the name space that I'm going to be deploying in from my application per project. If I switch gears to the application stack and I look at this code, it's going to pull the CIC and name space that I need. And its index is actually just going to wrap both of those properties in a provider that's leveraged for us by in Pulumi any provider in for example, is just as simple as specifying the cupid file. And optionally a name space to operate within, we're going to then leverage that provider by creating a new demo app. And as you can see, I have now attempted to create a new class called a demo app which leads us to our next construct resources. Resources. In Pulumi, ultimately, stem from the resource class. We have custom resources and component resources which we'll see next. A custom resource is any given infrastructure object that's usually uh and typically created by a provider that's specific to the provider you're using or the servers you're intending to use. So if I'm not a clever writer and I want to instantiate V MS objects, storage block storage clusters, virtual networks, those will ultimately be given to me by the provider for the pro for the user that I'm actually housing in. So for example, if I'm running on Aws or if I'm running on GKE, I will be using the GKE provider to then create resources that are known in the GCP ecosystems such as V MS block storage, GKE clusters, virtual networks, et cetera. Custom resources are the resources that we innately will be constructing in a given environment. These are fixed and these are known. However, if I want to create my own set of resources, I would leverage a component resource to co locate any resources that belong together and should be managed together. So for example, if a custom resource is the various resources that a provider makes available to instantiate over API S such as V MS object storage and block storage. A component resource can be a collection of infrastructure resources that make sense to you as far as living together. So an example would be a container for your app, some config data and maybe an object storage to store any output when I want to actually enable the reuse of this subtraction. That's when I reach for a component resource. So let's look at what a component resource looks like in action. I'll first create a new demo app class that extends the Pulumi component resource in here, I can prescribe a constructor for it some built in properties that it'll have. But ultimately, what I'm going to be doing here is deploying a workload into KTIS. The resources need not matter, right? In this case, I'm creating a container image, pushing it off the registry, attaching some volumes, some config data, some secrets and then I'm applying it into cabernet. But the idea is this is a representation of what I as the application developer want my application to look like in cati. Again, the details may not matter. But the idea is that I created an abstraction that made sense to me. Here. Is there a set of resources that belong together and they should be deployed together. And so we can create an extraction using the component resource class to achieve such a purpose. This also allows us to invoke an instantiation of the demo up in as little as three lines. I can just reuse the class and pass a writer to deploy into the appropriate GKE cluster component. Resources are very powerful. They allow you to customize how your infrastructure should be managed. Some additional references. If you want to learn more are available here, we highly encourage you to check out our polling architecture and concepts which dive into our programming model, gives you more information to go off with, with regards to how to organize your stacks and your resources. If you'd like to see what using stacks at scale looks like we have put together a crosswalk for cnet's set of playbooks, which is a reference architecture for how to manage cnet's induction using best practices. We make great use of stacks and stack references in those playbooks and we encourage you to check it out if you want to dive deeper. Lastly, the code for this program is available at Pulumi T v's github Repo. Please check it out. Open an issue. Leave us a comment or share it with friends. That's all the time I have for today. Thank you and have a great day.

---
