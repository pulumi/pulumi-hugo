---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Ep: 011 - Pulumi and Kubernetes"
title: "Ep: 011 - Pulumi and Kubernetes"
meta_desc: |
    "Discover how Pulumi simplifies cloud programming with Kubernetes and other cloud platforms like Azure, GCP, and more. Unlock the power of real cod...
url_slug: ep-011-pulumi-kubernetes
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Ep: 011 - Pulumi and Kubernetes"
  description: |
    Luke takes a look at our new Kubernetes support.
  sortable_date: 2018-09-26T18:45:53Z
  youtube_url: https://www.youtube.com/embed/bBAhJdoC8FM
transcript: |
    How you can use Pulumi with Ktis. Uh and how that docks in with some of the other support that we already have for uh A to BS Azure, GCP and uh and all the rest of the cloud platforms. Uh So let me get started. Um You'll notice that we've uh swapped over now to uh in the Pulumi dot com page. We now have uh KTIS tab here. And so we have a lot of details about kind of how you can use kubernetes along with uh with Pulumi. And really, when you think about Pulumi all up, what we're trying to do is bring the ability to program the cloud and so to write software which lets you interact with the cloud platforms. And so that can be software which deploys and manages resources in the cloud. It can be the application code that you deploy into those resources in the cloud. And as we talk to users, you know, users today, are you using the cloud in a variety of different forms? But in many of those places, they're also using CNES as part of that solution. And so whether it's on prem moving into a cumbers deployment where that's a stepping stone towards more cloud native application development in their on premise environment or whether that's inside a cloud platform like aws or Azure or GCP, uh where they're using cities as a nice high level container orchestrator um within the environment of uh of one of those cloud providers uh along with other managed services. And so when we think about that sort of holistic story of programming, the cloud and using cloud native infrastructure as code Kubernetes is a really important part of that. And something that a lot of a lot of users have been asking us to really focus on. And with the recent release that we did, Kate is now a really first class part of what you can you can use with Pulumi. So we did, we did some exciting kind of blog posts. I covered a bunch of the core capabilities of this and for those who haven't checked it out yet, definitely encourage you to look at the blog post. We did programming Kiss with 11 Pulumi pearls. This really goes into depth on a bunch of the different scenarios that folks can, can use with, with C. And today, I'm going to just kind of go through a couple of these and show off uh how some of the really interesting parts of how Pulumi can really make it easier and more effective to work with uh cores and work with cores in an environment where using other cloud resources as well. And so there's three kind of high level points that uh that I think we, we think are really interesting for, for Pulumi for Cotis users. The first one is that you can write your cloud, your configuration, your infrastructure as real code as software. And so this is a really kind of different way of thinking about it. Typically people kind of are coming to cores and they're, they're writing things using YAML or writing Jason or something like that. And maybe they're going as far as using something like helm or sort of go templates or something over their YAML. Um But they're not really writing it as software, they're not using the tools that they, that they think of when they think of software engineering, they're not using the ability to create reusable components, they're not having four loops and conditionals, they're not using, you know, having the ability to cleanly document the interfaces that they have to different pieces of their substructure. Um And so really with Pulumi, we're trying to bring all of the benefits that you get from kind of core software engineering and real, real code to the authoring experience for your human applications. And this, this brings, brings many different benefits and I'll kind of show some of these once we jump into code in a second, the second one is sort of multi cloud infrastructure and this is this point that, you know, for a lot of teams, you know, they're working in an environment where they're using, but they're also using some other cloud, whether that's, they're using AWS to use S3 and uh and R DS and, and a variety of other managed services or they're using Azure and they're using Cosmos DB uh or they're using GCP and they're using a variety of other services for machine learning there. Even in the on prem scenario, oftentimes folks will be working with both Kubernetes and managing some VM ware resources or or other underlying infrastructure within their environment. And so one of the key things that Pulumi does is bring a unified kind of control plane to all of those different cloud providers. And so within the same application with the same Pulumi application can manage both that cloud infrastructure and the infrastructure. And this is a really powerful thing and I'll show you some examples of that in a second as well. And then the last piece is really thinking about the way that you do deployments as, as code and as software. Um And this is something where you know what we've seen with kind of uh um the way that sort of the cloud providers have, have exposed uh you know, configuration language, those cloud formation or arm or any of these different technologies that it's really important to be able to describe kind of the dependencies between pieces of an application to describe expressive workflows of how that software that those updates get deployed into the cloud environment. So you can really understand the dependencies between components and how those, how those gate the delivery of different parts of the deployment. And with Cooper's, one of the things we noticed, talking to a lot of folks is, you know, when they're using coop control, uh you know, they just kind of take a bunch of YAML and say, hey go and put this in the cluster and that works a lot of the time but not all of the time. And so oftentimes they need to then go and intertwine other interesting pieces of logic into their deployment flow. Whether it's uh you know, testing that some part of a deployment flow got to a significant health state before they go on to another step of the deployment flow, whether it's just there's a core dependency between two components and they have to make sure that one updates correctly before they try to start the the second one in almost every medium to large size kubernetes deployment. We've seen folks end up writing a ton of bash scripts and other things to kind of stick in the middle of that flow. And it gets very complicated to kind of manage what it means to correctly deploy those the kubernetes resources. And so Pulumi again, can kind of help with this part in terms of writing out his software and really understanding all those dependencies. So with that kind of as backdrop. Let me jump in and to show kind of some code and what it really means to think about, uh, you know, kubernetes in terms of kind of programming the Cloud with Pulumi. So before I jump into that, let me just kind of show what that, what it looks like to kind of work with, uh with Kubernetes today with just raw, uh with this raw coup cuddle and Ktis Ya files just as a as a background before we jump into the Pulumi specific pieces. So here I have the, the guestbook tutorial on the Kubernetes IO page. Great tutorial. Many folks who have worked with Kubernetes have probably gone through these tutorials, part of kind of learning how to get started uh with Kineti. And if you look at this, you know, you see it has a variety of these blocks of YAML files that I can deploy and I can run coup cut apply to sort of push these up into my cluster. And these describe the different components of my infrastructure. So, you know, the deployment describes that I want one instance of this image with these resources and exposing this container. And the service says I want to then put a visible end point on that inside the club. And so you see there's quite a few steps to kind of like uh take all these M files, stand them up. And ultimately, this goes and runs a simple php app. Uh inside a cluster. So I'll show you quickly what that kind of looks like when we come and move over into the uh the Pulumi world. And so here I am inside visual studio code. Since we're kind of authoring this as software, we're really going to get to take advantage of some of the features of real programming languages. And in this case, we're working with javascript and actually in particular, here we're using typescript so that we get both the benefits of javascript, but also of kind of some of the rich typing that we get from typescript. And you see a few things. The first is that this largely looks kind of similar. Um you know, we have this apps V one deployment and then we're passing all the same things we're saying we want to run one instance of the same image with the same resources and the same ports. And in fact, the this API that we have exposed over the Kubernetes API um in this package is an exact mapping of what's available inside the Kubernetes API. So we actually go and take the API specifications that are open API specs that are published by Kums Working groups and turn those into an API that, that users can actually go and, and, and interact with um here, of course, because we have that uh and because we kind of have this in code, we can easily go and explore that as well. So I can come in here and say, you know, uh K dot extensions dot V one beta one, I can see all the different API S in their V one beta one form that were published as part of that API uh If I go in and say apps, you know, I can get all the different apps, uh all the different apps API S and so I can actually go and explore and do the same kind of things I would do in my normal application development using a kind of an ID E like visual studio code. Um And I can get all those experiences just for offering my plain old Kubernetes deployments. But what that means also is if I find documentation on anything that I can do with Kubernetes, exact 1 to 1 mapping into what I need to specify here to use that from Pulumi. There's no indirection at all in that API and you can do everything you can do with Etti from Pulumi. That's the, the second thing that to kind of note here is uh is just a couple of minor things like we, we took in this example, this fairly little, you know, we took that deployment and that service that we saw in the in the previous example and just kind of mapped it out directly here. But even here, we did a couple of interesting things like just use a little variable, right? So here I, you know, I declare this match labels once and then use it in these two places here. And so just the ability to have variables to have a little bit of reuse is actually already a significant kind of thing that takes you beyond the kind of copy paste of writing cosmo files. The other thing of course, because we're using typescript is we're getting sort of strong typing and that means we get many benefits. Like if I have a Typo in this thing, I get that error feedback right away. I'm told this is not a valid spec for that deployment. And I get that feedback as I'm typing in my code as I'm authoring my application. And if I was doing that with Coop Cuttle, I may have gone, you know, for, for 30 minutes typing up code and then I don't find out until I'm, you know, doing my coop cuddle apply and I have to kind of iterate at that point on that. So that immediate feedback in the authoring experience is another nice benefit. We get there. Other than that though, in this example, you'll see we're kind of just doing all the exact same uh things to stand up those resources and stand up that phpf. The last thing you'll kind of see if I switch back for a second to this example. Um You'll notice that uh kind of at the end of the, um at the end of the tutorial they have here, they really talk a lot about kind of viewing the front end service via node port via load balancer. They kind of have to go through some manual steps that you have to do. They are different depending on whether you're going to deploy this into an environment where you can expose load balancers like in one of the managed cloud environments or whether you need to use node ports or cluster IP or something like that in a, in in a A MNI or a similar kind of environment. And in this case, we want the code to be written once and be able to actually operate in all those worlds. So we don't have to have those kind of manual intervention steps. So we don't need the user to kind of overly specify that stuff. And so we're able to do a few simple things here like we have some configuration that we set whether this is mini cube. And if so we pick cost IP uh if not we pick load bouncer, and then we actually also check that to decide what front end IP to expose. So showing here just some of the simple code that you can write to this. And let's just kind of see what that then looks like inside my console here. So I have a Pulumi stack here and Pulumi stacks are an isolated deployment of a piece of code. And so that code I had, there was a description of an application I want to deploy and I can deploy many of many instances of this into various different Cubana environments. And so today, I'm actually going to be using a GKE environment. I have as a test environment and you'll see here. I have this demo 0926, which has a star next to it, which is my currently active stack and that was last updated 24 minutes ago. It has zero resources in it. So now that I have that stack created, I can come over here and say Pulumi update. And this will actually go and, and try and make the code that I have. It'll try to apply that to my target environment in this case, that GKE cluster that I set up. And so you'll see here, it tells me first a preview of what's going to happen. So in this case, it's going to deploy those three deployments and deploy those three services for the red master replica and front end. And if I want, I can even come in and see the details and see all of the specific values that it thinks it's going to need to apply when it deploys this. So I can go ahead and click. Yes. And this will actually kick off those deployments. We'll see we actually do some of this work in parallel and we provide you some feedback along the way about what's actually happening. So as those deployments rolled out and the pods were stood up inside the cluster, we gave you that feedback on the fly and then we ultimately gave you the checkmark saying the deployment initialization is complete. So this is actually really nice if you're used to using coop control or something like that, where you just kind of throw it at the cluster and you don't really get much feedback. It says, yes, I I register that I know about this thing come back later and figure out if the thing is really running here. This is kind of nice that we're actually, while that thing is being deployed, we're waiting and, and verifying that it's deployed correctly before we confirm that it actually finished creating this is sort of a key kind of difference to the model that Pulumi gives for usage and is really valuable for really making sure that you can sequence deployments of things reliably because you know, when something has successfully deployed into the cluster, you'll see in this particular case that the uh front end uh is the only one which was exposing that uh that um load balancer IP. And so it took a little bit longer because it was actually waiting for uh Google cloud to allocate a load balancer for it to expose that end point. Um But that ultimately did complete set it created. And now we have exposed this front end IP. So these outputs are actually a really nice feature of Pulumi as well that I can export some values from my module in javascript here. And so I can export the front end IP. And that will actually be the IP address that I need to use to connect to this thing. So that's really the key piece of externally visible information. For this particular example, if I open that up, uh you'll see, I have my guestbook app running here. Uh So really simple, spun that application up in GK. If I come over here, I can probably come over to uh to GKE and see that I have those uh those three deployments uh running inside uh inside my GKE. And so if I come over to my front end, actually, let me come over to services uh got loop cluster and let's do the search uh grab that front end. Um We see here in Gke um that this has the load bouncer associated with it. Um And here's the information about the load bouncer and I can see all that data also inside my, my GKE console. Um So I really did just deploy this thing to GKE. Um So then we can also see I'll just do a quick Pulumi destroy if I want to tear this thing down. Uh Go ahead and say yes, this says it's going to delete all these resources. This will actually unwind those and the unwinding will actually also uh adhere to that same ordering that was described. In this case, we tear down all those services and then we start tearing down uh the deployments as well. So this will just take a second to clear this out. So while it's going, let me just show, you know, this example, we saw some of the simple benefits that we get from using code and being able to describe this stuff using javascript instead of yaml. But really, this was really highlighting that this can be kind of 1 to 1 where things get more interesting is where you really deeply take advantage of using code. And so in this example, you'll see that I'm actually using, I'm writing the same application. So I have that same red as master red as replica on front end. And I'm exposing that same front end IP the only difference in this case is that instead of me writing out the services and deployments in this very repetitive kind of pattern that you saw in the previous example. And frankly, you see pretty often in applications, we introduced a simple abstraction, a simple reusable component uh called uh service deployment here. Uh that, that encapsulates deploying both a deployment and a service in a pretty consistent pattern. And this is something that, you know, probably for the 70 to 80% case of services, this is probably rich enough to describe them. And then for the other 20% case, you may need to sort of tweak things beyond what this can describe. The nice thing of course is that you can use, you know, something like this one that we've provided. And if I go to definition on this, uh we can, we can show what this is doing internally, but you can also create your own. So within your organization, you have some common patterns that you apply. Like if you want to inject side cars into all of your, all of your services or all of your deployments, uh You can do that uh just by having a base client that you use, that describes how that component should be structured and then using that across all the different places where you use this code. So the cool thing is here this, you know now turns that into like a 24 line thing. I can look at this, I can immediately understand exactly what's going on here, which which images are being deployed, what ports they're exposing how many replicas all the key pieces of information about what this application looks like. And then all the kind of boiler plate is hidden away behind this component. This component gets to use some of the features that Pulumi offers generally for, for users to kind of other resources. So in this case, it constructs the container, the deployment, the service, the various other pieces that it needs. Uh The one key thing that they do that we do inside a component is we say parent call in this. Um So we pass the component as the parent of that child resource. And this allows us to sort of display this information in a nice tree structure as well. Um And so that's, that's a really kind of nice capability as well of uh components. But the really key thing here is, and the way the thing you can sort of think about applying to many use cases is that that core software engineering benefit of being able to do software reuse abstraction building components. That's something we can now bring to kind of the infrastructure space. And in particular, in these examples, we can bring into Kubernetes. Um This is a very simple example of that, we expect to kind of build some more high level libraries like the service deployment. But what I'm personally really excited about is kind of about what other folks can do in terms of building these sorts of components within their organizations and that fit with the patterns that they're doing uh inside their coup. So those are some of the benefits of just using uh kind of software itself for this. Um But I really also want to talk about kind of how you can use Pulumi to kind of do deployment orchestration in more interesting ways. And so for that, I want to turn over to kind of a little bit more involved example uh of working with Kubernetes. And that, that example is this uh config map rollout example. Uh And so here again, I have another, uh, application, uh, using Kubernetes written in javascript. And the key thing that this is gonna do, uh, is gonna take a few steps first, it's gonna deploy a config map. Uh And so that config map will hold an engine configuration. So we'll, we'll have a default compel actually, uh, show this. Um, uh, this is the, the engine configuration that we're going to deploy as part of that config map. Uh And then it's going to create a deployment which uses which mounts that config map. So here we see we have a volume mount for that config map and we put it in the uh the uh engine uh folder. And then of course, you can put a front end in front of that and expose it just like we did before. Now, this is fine and this works just normally, whether we were using, you know, coop control style approach or Pulumi what becomes interesting is when we want to update that uh that um config map and make sure that as part of that update to that config map, we actually then turn over the deployment and update that. And this is actually something that's surprisingly difficult to do uh just with uh coop control. And folks have to kind of work out some complicated things of uh you know, forcing the deployment to update because they can fig map updates in sort of out of band ways using bash or something like that what we really want to do is just be able to write code just like this, that just has that config map. And then by seeing that there's a dependency on the config map name, which itself depends on the config map. We know that if there's a replacement of this config map that's going to require us to update the deployment. And so let's kind of see what that looks like by default when we do this in Pulumi. So I'm gonna go over that folder. Uh OK. And so over here, uh I'll just do plume stack, LS again, see what stacks I have uh uh deployed for this. And we see I have this config map loop GK with no resources in it. So what I'm gonna do is just uh do an initial deployment of this uh with the code as is actually let me just make sure oops. OK. I will deploy this with uh google dot com. Uh Let's do a Pulumi update. And so just like before, we'll kind of see what resources we're gonna deploy. So that config map that deployment in that service, we're gonna create all of those. And so I'll just say yes, uh this should deploy reasonably quickly. We expect this to take just a second as it finds, as it uh um uh find creates the end points and the uh load bouncer. Um Just give it one more second. I will say the nice thing here is, uh, you know, obviously, you know, take a second. I don't know what's exactly going on. The, the key thing for me that I always find really interesting here is the fact that this is sort of hanging here is telling me that there's something wrong. Uh And that's something if I was using, you know, coop control directly, you know, I would have, this would have told me it succeeded. Uh And I would have no idea that something had gone wrong until I looked at some monitoring metrics or something like that to understand that my deployment had actually failed. Um And so here, the fact that we're waiting that we're giving you that status feedback is really a key thing for understanding is this thing succeeding. Is it failing? Where is it in that process? That's information you could get by sort of manually pulling various things inside your Coates cluster. Um But with Pulumi deployments, you kind of get that all kind of free as part of the deployment. OK. So it did actually finally complete there. Uh I can hit that. Um Let me actually take that uh UR there to uh to Google dot com. So, OK. So we successfully deployed an engine engine next instance using this uh this config um And let me just now change that to maybe I'll change it to bing dot com. So I'm gonna change that in my default comp. And what actually notice I'm not going to change anything else. I'm just gonna change that file in default comp and I'm gonna come over here and type Pulumi update again and we'll see what happens when I do that. So what happens here is that I actually get told that I'm going to see some changes to my um, uh infrastructure as part of this. And so there's actually a couple of things that are gonna happen first off, the config map is gonna get replaced. And it's saying that the um the data is actually going to change, which is because that's being loaded off of the disk. And I'll just show you that just to make clear why this is happening, that data is actually being populated by reading that file off of disc. And so as part of me running this program and deciding what desired state I want to be in, it's reading that file, seeing that it's different. And, and, and so Pulu Pulumi knows to make both of these changes and to coordinate the way both of these changes are applied. And I can even go in here and see the details and see exactly what's going to change the exact details of what's going to change in my default. Config uh the exact the fact that my deployment config map is going to change from this old config map to this new one. And the order I'm going to see that that new config map is going to get created. Then I'm going to update the deployment and then I'm ultimately going to delete the old config map. And so I'm going to clean up the place. Now. We're updating the, uh let's make sure I close this out, open up a new one. There we go. We're on bing dot com. So we rolled out that update into our cornets cluster to that engine configuration and really the key thing there is we didn't sort of have to think about it. We were able to just make the change we expected to make just to that default configure and everything. Pulumi kind of figured out the dependencies and deployed everything and updated everything as you would expect. And so that's really the key thing we want to do here is make it so that your uh your deployments are really reliable that if you make changes, uh Pulumi will understand where that requires uh what, you know, what uh dependencies those have and how those need to get deployed to correctly uh get to the state you want. OK. So that's just one simple example. There's many, many, many other examples of that if you look at that um that programming Pulumi Pearls Post, um there's, there's many more examples of this sort of thing. Uh The this, this was the sort of cascading rollouts. There's also like staged and gated rollouts with prometheus checks. If you want to check some, you know, you deploy some part of your application and then check some Prometheus metrics and then continue deploying. You can do that because it's just code, you can inject other things like checking Prometheus in amongst that. But generally you have access to a ton of different tools um to use that software uh to describe the way you want to deliver your um applications. OK. So the last part of this is really multi cloud infrastructure and and how you can use coupons alongside other things. Um And so there's a bunch of cool examples we have of this if you go over to um you know, Pulumi uh uh examples. Uh this is the examples repo that I've been showing in the uh in VS code as well. But I have a ton of examples here. You can jump into both for and for a bunch of other platforms. Um So encourage folks to take a look at some of these. If there's any particular topics end up A KS, we have examples of that. Um And if you want to stand up eks, we have examples of that as well. Um And so if you know, for instance, if I come over to this Eks example, you know, simple as saying new Eks cluster and providing some some configuration about the details. Uh And that just uses our Pulumi Eseks package which we've published. Um So really, really easy to stand up an Eks cluster. And in this case, actually also stand up a VPC to run that really, really easy, much easier than it is to kind of do this manually. Uh Do you know stand up eks or A KS to stand up the cluster? But then as part of standing that up, we really want to also deploy some resources into that cluster to get it initialized in the state that we want for our application environment. And so I want to be able to describe that entire process in one in one code base. Let me show you one example of that, that kind of has a few different pieces going on. But II I kind of love this example just because of how many different things it shows. So this example um is using Azure. And so we're using the Pulumi Azure package, it's also using that Pulumi Kuti package. Uh and then uh you know, it's doing a couple of things first off, it has this full file that sort of stands up a Kuma cluster using the AK service in Azure. And so here we go and create the active directory accounts, application and service principles. We create the knas cluster with all the appropriate information. And then we actually construct a kubernetes provider so that we can create resources inside that knas cluster, which we just stood up. And so in this case, we say new Coonan dot provider uh and pass the KB config that we got out of that a KS cluster with that. Now in the other file, we can come over and do things using that Cober cluster. And so in this case, uh let me go back to the other file. So in this case, now we have that kinase cluster and we have the provider we can use. Now we can do things like create a Cosmos DB account, we can create a Cobert Secret that has the information about how to connect to that cosmos DB account that we inject into our cos cluster. And now we can actually install a helm chart. This is the Vietnam node 4.0 0.1 chart. We can specify some values to that chart and we can say run that inside this K provider that we just stood up inside Azure and make sure we don't deploy this chart until that Mongo connection is available. And so that means that we've actually stood up that whole Cosmos DB account and have that connection string available so that we can use it to run this application. So there's a lot going on here if you think about it, not much code really, but a lot of different pieces, we're actually going to stand up a whole kinase cluster. We're going to stand up a whole cosmosdb. We're going to describe the dependencies those things have on each other. And we're going to inject information into the kinase cluster about how to connect to that cosmos to B mongered end point and then how to use that from a Benami application. And finally similar to a lot of other examples, we'll export a few key pieces of information, we'll export that cob config so that we can externally deploy additional things inside this environment and we'll export the front end uh address of that node application that's running. And so there's tons of use cases of this sort of thing. You know, we sort of think about this as sort of a working kind of application in a box. If I'm a start up on building up a new application or service, I can kind of use something like these 50 lines of code to kind of be my whole environment with my database, my coupons cluster, my my managed services, my S3 buckets, whatever it is I need stand that all up, inject all the right stuff into my cobras. So it's working. And now I've got an environment that I can actually deploy my coupons based applications into um that has everything it needs set up. And now I conversion all of that together using uh using Pulumi and just making whatever changes I need to this application. So we have a variety of examples of this sort of thing where we combine the best of uh of with the best of the cloud platforms. And I think that's really where I've seen, you know, a ton of ton of users we've talked to recently trying to kind of use those two together trying to maximize the benefits they get from both of those and really Pulumi kind of uniquely helps with that combination. I think it's a really exciting thing that you can do there. I kind of quickly talked about this, but it's another super important part of the support that we added recently is actually the ability to use Helm charts. So anyone who's, who's using coupons today is familiar with the, the broad array of Helm charts that are now available, great public repositories and also an increasing use of Helmm charts as a way of packaging up dependencies and components inside an organization. Uh And so, uh you know, we, we really wanted to make it easy to go and take those existing home charts, but use them from within uh Pulumi and get the ability to kind of coordinate deployments of those home charts from uh from Pulumi as well. And so we have this ability, this uh dot helm dot V two dot chart, uh which lets you to specify um a uh home chart and then specify some of the values that you can provide uh to parameterize that home chart. So a really easy way to get started. If you already have existing Helm charts, if you already have existing communities, you can just bring those in, use them directly from Pulumi. Don't have to change anything. You can just write the sort of outer outer shell in Pulumi. And then if you find value in using Pulumi for more pieces of that, you can move those pieces over as well and describe the details of the dependencies between them to get some more benefits. All right. So that was kind of a tour of uh of some of the things as I mentioned, uh definitely check out the blog post we wrote on this topic, tons of great stuff in there uh to get even deeper in these. Uh The examples are, are a great place to go and look if there's any topic you're kind of interested in, whether it's about communities and some of the things we're doing there or whether it's about server this or about AWS infrastructure or anything else. Uh We've likely got an example that highlights something like that um Over in our examples. We, if you haven't yet gotten started with Pulumi, you should check out Pulumi dot IO. Uh go through the getting started, download the tool. Uh and, and let us know what you think you can join us on our Slack channel. Lots of discussion there with folks getting started with and using Pulumi in their applications. Um And if you have any questions at all jump in there and, and give us a um drop us a note. Um We'll be, uh we'll be back again uh soon to talk about more of what's new with, with Pulumi. Uh Thanks for joining us this week and we'll see you again soon. Thanks everyone.

---
