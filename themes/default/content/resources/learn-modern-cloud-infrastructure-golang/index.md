---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Learn Modern Cloud Infrastructure in Golang"
title: "Learn Modern Cloud Infrastructure in Golang"
meta_desc: |
    Learn the easy way to define, test, and provision resources on any cloud using Golang and Pulumi.
url_slug: learn-modern-cloud-infrastructure-golang
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Learn Modern Cloud Infrastructure in Golang"
  description: |
    Learn the easy way to define, test, and provision resources on any cloud using Golang and Pulumi.  Get started: https://pulumi.com/start?utm_campaign=PulumiTV&utm_source=youtube.com&utm_medium=video  This video shows you how to use Golang to setup AWS resources but the concepts also work on Azure, GCP, DigitalOcean, Alicloud, and more. With Pulumi you can setup any cloud using  - JavaScript - TypeScript - Python - Golang - C# (or any .NET language)
  sortable_date: 2020-05-11T18:49:17Z
  youtube_url: https://www.youtube.com/embed/UMsPGqHdd0g
transcript: |
    I'm Evan. I'm uh here to talk about modern cloud infrastructure and go with Pulumi. Uh Thanks so much for having me tonight. Um Pacific Northwest. We're really excited to be here. So, uh I'm doing something a little different. I have some live polls that were set up ahead of time. So if you go to pull EV dot com slash Evan Boyle 164, you can vote in real time on these polls. So, uh looks like a couple of people may have, uh gotten a hold of my slides and beat me to the punch. So, uh, let's go for it. I wanna hear. What's your background engineer, devops? Are you, you know, a student? You just learning, um, leave this here for a moment. All right, we have a developer, heavy audience tonight. Looks like we have some, uh devops folks in the room tonight as well. Hi, good to see you. Awesome. OK. Well, uh, if you all keep this, uh, keep this tab open, we're gonna have a, a few more poles throughout the night. Um But I'm gonna go ahead and move on for now. So what we're going to cover today, first provisioning, treating your infrastructure as cattle, not pets. Second architecture, you know, these are things that we typically use in and go and other programming languages, you know, using uh abstraction and ECA encapsulation where appropriate to share our best practices, you know, not repeating ourselves uh needlessly but sharing those best practices across teams. The third thing we're gonna do is test. So look at unit and integration testing for our infrastructure, which is something that you would be surprised to hear is not, not entirely common. So, uh, if you want to get started, uh, there are two things to do. So I pasted that link in the chat. Uh If you want to follow along, uh Pulumi getting started for, um, Aws and then also cloning this repo uh Pulumi examples into your GOP path. Uh If you, if you do that, um, you should be good to go. I'll just leave this here for just a second, uh, gonna have these steps up in a, in another moment here. So, so another tool I wanna hear, uh, where are all of you in your cloud journey? You know, are you, uh, total, uh cloud beginners? Are you just getting started? Uh, maybe you're actually managing services and production, um, excellent healthy mix, but it looks like we have a lot of veterans here as well. Very cool. Well, hey, you know, if you wanna drop a note in the chat, I'm curious, uh, for those of you managing services in, in production. I'd like to hear, you know, how are you provisioning your infrastructure today? Ok. So you want to go to the cloud, you know, get it. I got more where that came from. How do you get there? You know, multifaceted, you know, many, many different paths you can take. It's, it's, you know, super confusing. You can create a VM and seven EV seven easy steps using the uh A W US console or perhaps the CLI maybe the SDK or you could uh write a class formation template or terraform or chef or puppet or answerable. Wow, the choice is overwhelming. Yeah, seriously. So let's just take a step back for a moment, right? What do we want out of our cloud development process? We want maintainable and correct system, first and foremost, you know, a familiar tool chain that we can use with the whole team because software isn't built in isolation. After all, we gotta work with other people and whatnot, right? Uh Confidence making changes, you know, and then the ability to iterate in an isolated development environment, right? And I say, you know, are these goals really different from traditional, you know, desktop development? So yeah, why not rely on the same tool chain that we're used to using everywhere else? Good old goer. So now I'd like to start with a simple little demo. So what we're going to do here is create ac purity group with a public address on port 80. Look up the latest Linux A I. We're going to create an E two instance using those two properties that we define. And then we're going to specify a very simple launch script that just starts with the server on port 80 export that public DNS. So it's accessible from outside of the deployment by other programs. I'm gonna post instructions for how to get started, but I'm gonna walk through this in my terminal real quick. OK. So uh can I get a thumbs up? Thumbs down, can if, if, if this isn't readable, can someone uh who has audio access just chime in here? Um So what I'm gonna do right now is clone the examples repo. This is Pulumi examples. Hey, Evan, would you mind doing like one tick bigger than what you got? How's that? Cool. I think that should be good. OK. Perfect. So we've cloned into the Pulumi Examples repo here. And so now I'm gonna C CD into examples. Aws go web server. OK. And the first thing that we're gonna need to do is initialize a new stack. This is kind of like a container for all of our resources, like a ephemeral developer environment if you will. So uh PNW go is what I'm gonna call mine. All right. And then I'm gonna set a little bit of configuration. I'm here on the west coast in Seattle. Um So I'm gonna set some config uh for the Aws region and I want to deploy in us West two. What? Pulumi config set Aws region? Perfect. Ok. And then I'm gonna run flume up dash dash. Yes. And while this uh gets going, I'm gonna go ahead and pull up these uh instructions real quick and don't worry, we're gonna look at the code uh here shortly. Ok. So, uh this is the time to grab your computer And here are the instructions for any of you who'd like to follow along at home. So go ahead and make sure you create that uh github dot com slash Pulumi path uh CD into it. And then you're gonna clone that examples, repo uh CD into the AWS go web server directory, run Pulumi stack in it to create that ephemeral environment. And then we're going to set a config value for which region we'd like to deploy our resources into us. East one U two, whatever, whatever you want to do and then run this command plu me up. So I'll leave this here for just a second for those of you following along. And you can see here that uh we have created a stack which is that container that holds all of our resources. We've created a security group and an EC2 instance. And down here we have some output. So we have a public host name and a public IP. So let's go ahead and try and curl this. Uh see what we get. Oh, great. We get a hello world. So let's go ahead and look at this code real quick. All right. So we have this Pulumi dot run mostly looks like any other main file that uh you would see. But we have this Pulumi dot fun uh run which injects a context that we can use. It has some helpful uh utility functions, some Pulumi helpers, things like that. And first thing we're gonna do is define this security group, that security group just has uh an ingress um that defines uh TCP traffic from port 80 to port 80. Uh and defines a Cider block from there. We define our AMI and we use this wild card expression to look up what is the most uh what is the latest Amazon Linux? Uh Ami last thing we do call a uh EC2 dot new instance to create uh our instance specifying the security group I DS that we found before. Uh And the AMI that we looked up before. And then here are very sophisticated web server. It's just a batch script that uh echoes how world into an index HML file and then runs a simple Python server. And you can see at the end here this is where we exported those values that you saw on the output, the public IP address and the public host name, both that are uh outputs available on this um on this server that we created. So another really cool thing about this is uh these Pulumi has a uh has uh output command stack outputs that uh allow you to compose into other tools. So uh instead of just copying and pasting that value, we can do stack output. Uh And the value of that was um public uh host name. Oh a little bit of a typo there. But if I get that right. Beautiful hello world. Awesome. So let's break it down again. Uh This is the uh the set of uh go bindings for the Pulumi uh core Pulumi Pulumi project and just this context function uh that gives us a container for which we can create cloud resources inside us. Here. We import the AWS findings and create our security group redirecting traffic 80 80 create a cier block. Then we look up our AMI use those two values, pass them into the EC2 instance, specify that user data, export those values. So they're able to be accessed programmatically by other programs or by, you know, just us as operators using the cli. And then finally, we can manipulate those outputs and see the response from our web server. OK. I'm gonna stop here real quick for any questions. I'm gonna switch over to the uh the chat. Let's see. You can't skate bash ever. Ah Yeah, that's, that's a great point. And actually you can kind of uh kind of escape it. Kind of we'll, we'll get to that a little bit later. Uh, can you talk on how to maintain a remote state? Um, let's, let's hold off on, on that one for ok. Questions tat, let's see, since Pulumi is all code using standard languages, is there a way to do TDD? Unit tests? So glad you asked. Uh, we're gonna get to that later in the talk. But yes, there is absolutely a way to do test driven development and unit tests. Um I'm gonna defer the question on remote state by, by remote state. Do you mean um how do you, well, you know, that's, that's a little bit of a segway into good segway into the next question. So I'm gonna, I'm gonna defer that one for now. OK. So this is perfect time for a pop quiz. Hope everyone's ready. Did you bring your pencils? All right. So if you can open up the chat again, oh, it looks like someone already came in here and voted. But is Pulumi imperative or is it a declarative desired state configuration? Like hear what everyone thinks there? All right, a little bit of a mix but, you know, it seems, seems like uh uh OK. Well, I don't know. What's the, what's the answer gonna be? Trick question? Why not? Both, right. So let's go ahead and look at this if we run Pulumi stack, export and dash dash files, stack dot Jason. So, and then let's go ahead and look at this output dot Chase on file. And let's look here. So what do we have we have right here. This is our go web server, EC2 instance. OK. And inside it here you can see we have input. So what are some of the inputs that we passed in here is that AMI ID that we looked up dynamically? Uh Here's the instant size, there's all sorts of other properties uh such as the user data. Here's our sophisticated web server. And you can see on the other side, uh we have all of these files that were eventually uh resolved. So what zone it's in um information about public pipe, uh private IP addresses, et cetera. So going back to the question at hand here, you write imperative code. Pulumi executes it produces a declarative state file that we already looked at right and drives to that desired state. So the answer to the to the pop quiz is Pulumi is both, it's, it's both an interface for writing imperative code code that's executed to produce desired state. And then the back end uh engine which drives that uh desired state to completion. So I'm gonna go ahead and uh switch back to the chat real quick and see. Do we have any questions here? Uh I, I do agree. It's imperative uh that you eat more fruit to stay healthy. Yes. Thank you very much. All right. Uh If there aren't any other questions, please feel free to drop them in the chat if you have them. Um I'm gonna go ahead and move on. All right. So uh Pulumi allows you to create reproducible isolated instances of your project. We call these stacks. So each developer can spin up and tear down uh environments as well. If your environment gets forked, you can just, you know, take it out behind the shed and, and put it to rest and spin up a new one. So that life cycle here looks like Pulumi stacking it to create a new environment. Pulumi up to populate it with cloud resources according to the state that you've designed. Pulumi destroyed, which cleans up all of your resources because we don't want to pay for that, right? And then plume stack RM to delete that container and delete the history associated with it. So we're gonna go uh through just a very small amount of Pulumi 101 here real quick. Uh You may notice that we redefined some types here. We had that strange Pulumi dot in and Pulumi dot String for, you know, for port 80 for TCP like why, why would we do this? Why? Well deploying to the cloud is fundamentally asynchronous, right? Some values we know at run time like we're building a web server, we always want to expose port 80 but others only resolve at run time. Like what is that public IP address of our EC2 instance? If you know that ahead of time, uh you know, I may have a business proposition for you. But so Pulumi has what's called inputs and outputs. So it talk very lightly about types here. So if we just consider T to be some type, so T could be a string, T could be an in it could be an array, it could be a, you know, complex structure. Uh an output is an asynchronous object that promises to resolve with the value of type T. So if you've ever used javascript before, this is very similar to promises. So we create that EC2 instance and every member of the results. So you might may remember we looked at that state file. So everything here in the outputs uh this A I this A RN all of these are asynchronous values that promise to eventually resolve but are not immediately available when that code runs. So an input uh an input of T is either an output of T. So it's either that eventual value or a promptly available concrete instance of that type. So this could be, you know, an AYC value that security group uh id that doesn't exist yet or it could be that port that we've already defined port 80. So when creating cloud resources, all these uh input arguments must be input of key to accommodate both prompt and a sync values. So everything feeding into a resource when you create an mi is an input and everything that comes out is an output And so you know why all these custom types, everything comes back full circle, right? This goes back to our uh lovely generic questions that we um that we talked about at the beginning of, of the meet up tonight. So Plume uses union types in other languages to represent this. So an input is either A T or an output of T and you know, go doesn't have generics for now, at least. So we must define our own custom types and those custom types use a combination of, you know, strong typing interface and then reflection under the hood for runtime checking to allow us to represent this union type, this generic union type while still offering that strongly typed API So it's a little strange um something to wrap your head around but you know, uh is what it is. Let's see if uh there's any questions on that. Oh yeah, static IP. All right. That's your, that's your business proposition for me. I may be, I may be out of a sum sum of money. I should spoke too soon. Alright. Any other questions? OK. It looks like a few have popped up in the meantime, how is your feature parity with the likes of terraform and cloud formation? Uh How long does it take between uh new services launched and plume can support it? So, uh Pulumi actually uses some of the uh terraform providers under the hood. So we use the uh uh we use, um, the Terraform Aws provider for instance. Um So those are up to date just as fast as the Aws providers are where the Terraform providers are. Uh, we don't actually, just to be clear, we don't actually, you know, produce Terraform or anything like that. We just use the, uh, we are compatible with some of the underlying provider mechanisms. Um And for others, like we have some native providers that we've written ourselves. Like we have a fully modeled the use um API specs. So we, we co generate a bunch of SDKS based off of the uh the open API specs. So when 0.18 came out two weeks ago, we actually had our support launched before the PR was merged for Cooper's 0.18. So very, very fast because a lot of this stuff is fully automated. Um Let's see, try to stack RM but forget to destroy. Would you be able to delete the stuff you created? Uh You can't, unless you do a forced deletion, you can't delete a stack that still has resources inside of it. So you will be warned. Uh OK. So where is history for stack store? This is another good one. So by default, state is managed in the, which is free for like open source and individuals. Um There are like obviously paid plans for like enterprises and whatnot, but there's a um S3 uh state back ends, there's GCP, there's local file back end. So you can manage that state yourself in a, in a variety of cloud providers or you can manage it in the Pulumi Sa and see that full history. Uh You do not need to use Pulumi dot com to be able to use Pulumi. Um ok, let's see uh in case of collaboration with multi dive, how to maintain remote states. So yeah, this is where something like uh we have a, we have a a or we have like an on prem hosted um state management solution uh that you can use. And if you're talking about like collaboration with multiple developers, you're talking about locking and concurrent updates and things like that. It, it handles all that stuff. Very cool. OK? I'm gonna go ahead and continue on manipulating outputs. OK? So, you know, we write these programs, we have these uh values that can either be promptly available or asynchronous. Like you can't just add two promises together, concatenate two promises like it, it, it just doesn't work like that anyone who's done this AYC programming knows. So we have to have some way to be able to manipulate these values. You know, normally we just use sprint F, we just add this thing together, we just, you know, set that value the structure. It's, it's not that straightforward when you're dealing with the, the cloud, it's fundamentally asynchronous programming. So we have what's called apply, which allows us to specify a callback function that manipulates the underlying of value when it becomes eventually available and that's going to return a new output and that new output can be propagated into uh other cloud resources that you may want to create. Uh for instance, you can, you know, take a bunch of RL components and when they're all available, maybe the server, the protocol, the port that gets assigned, maybe some network information that's determined at run time, you can um apply all of these values together and then return a that can be used as an input into um uh another cloud resource that you're creating. So this looks like this. So we have our VPC and we want to take that output property that DNS name. We know it's not available right now, but we know it'll be eventually available so we can attach this, apply string, callback on there that waits for that value to be eventually available and then uh splats on an HPS at the beginning. And then now we have this L value which is now a new output, a new eventually available value. So what if we want to do that coordination that I talked about earlier? Like, you know, waiting for maybe a database and a sequel server or something like that and then creating a connection string. So we can use Pulumi dot All very similar to promise dot All. If you, if you're familiar with javascript, promises to await these two values, the SQL server and the database wait for those two main values to be available. And then we call, apply over an array of those of those values. Uh do a little bit of string manipulation and then return them back. And once again, connection string is a new asynchronous value. It is an output and that output can be used to pass into other cloud resources. All right. And we have uh you know, since this is go, we try to, you know, when we're building this SDK, we try to be idiomatic and you know, try to do what we can to smooth over some of these idiosyncrasies. So we do have a plume dot sprint F which uh basically under the hood, combines uh apply and all uh in order to use something like you would be useful with uh used to with normal sprint F. But URL once again is an asynchronous value. So something to be aware of any questions here. Let's go ahead and take a look at the chat. Yeah, Pulumi tools are open source that is uh not something that I mentioned. But yeah, something to definitely be aware of Pulumi uh open source uh completely. Uh you can go and look at um the Pulumi providers, all the, all of our cloud providers and SDKS, uh all the work that I do is open source, which is amazing. Um Let's go ahead and look and see if there are any new questions. Pulumi do auto deploys if you push to master will uh automatically do a deploy for you. So, yeah, we have, we are not ac I CD uh operator like there's lots of C I CD providers in the space and we integrate with uh most, most all of them. So uh we have like Orbs for circle C I that are prebuilt that you can just grab and go if you want. Uh Let's see. Are you able to talk about how folks are currently using Pulumi? Oh Man, that is a, that is a super long conversation, everything from, you know, people, buildings, people migrating, uh you know, 50,000 line terraform legacy deployments that they have into something that's uh more component size, more manageable. Um We have people who are doing uh lots of lots of serverless workloads. Um We, we have, we, we call ourselves modern infrastructure is good because we have put a great deal of emphasis on support for things like land building Docker images as a part of your deployment, pushing those up to registries, we have a Docker package that will actually build your app for you. You can specify like build parameters so you can build your Docker image and then deploy it to S a lot of kubernetes stuff. A lot of people who are doing both the deployment of their uh underlying like infrastructure like defining VPC S uh deploying EKS clusters or GKE clusters. And then also in the same program defining their kubernetes resources, which is really, really cool. All right. So architecture is code, you know, we want to compose our infrastructure into useful units, you know, extract these into functions, publish libraries, share these with the team. And we acknowledge that like, you know, when doing something like a you know VPC configuration, not all of us are are Sean with ex extensive uh extensive experience doing uh RT C and extensive extensive uh network understanding. Like maybe you want to abstract some of that stuff away from your team for security purposes, you have best practices you wanna follow. So let's take a look at our example that we wrote previously. So we've pulled this all into a create infrastructure function that returns this infrastructure struck that just has the raw group and the server exposed, right? But all of the logic is now hidden and nothing's configurable anymore. Uh One thing to note down here is that in that uh in that uh Ami we're now using a hard coded custom A I. So we have this uh ami value for the new EC2 instance and we're not specifying user data anymore. So our uh our hello world web server is is no longer using that user data. It's no longer configurable. It's the uh stamped and approved image produced by our company, right? Um So uh the main code here looks very similar. It's just a lot shorter. We run that create infrastructure function and then we export the public IP and the host name just like before, right? But it's a simpler interface for maybe those who want to run a web server but don't wanna be exposed to all the details of network configuration in which a am I to pick yada ya. And so these improvements are shared, right? Like I said, we don't have to worry about the network configuration. We can encapsulate and expose the appropriate level of detail, we can enforce policy like, you know, make sure that everyone has the appropriate tags on all of our deployments that allows us to build like operational tool, you know, further automation. Stop real quickly for questions here just in case. See, I agree that it is super cool that you can define Kate stuff right next to other stuff. Yeah. And we see a lot of people who uh who do things like, you know, uh Kates for their compute and, and stateless workloads. But they take advantage of um they take advantage of like data uh data solutions in Aws and Azure. So maybe they have sequel and Aurora or they want to do some log analytics in VCP, uh some machine learning in GCP. It makes it really easy to do that. Um How do you handle the version of the Pulumi API? So we release uh minor versions um every week or so. Um And we try try very hard to maintain a, you know, a semantic versioning basically that's, that's what we try to follow. Um So we are actually about to next week go from 1.0 to 2.0 which is uh really, really exciting. So there are a few minor breaking changes. Nothing for go. That's um that's gonna be a break because go is actually going into preview or going out of preview and into G A. So it's, it's uh you, you'll get a full contract, which is really exciting. Um All right. So testing, yeah, finally getting to the stuff that everyone's excited about, right? I love writing tests. So, you know, since we're in the ecosystem, can we use, go test? Can we use, you know, our favorite mocking tools go cover like all the tools that already exist. We don't need to reinvent the wheel, right? Can we do this? Hopefully, maybe. Yes, yes, of course, we can do this, right? The whole one of the big benefits of using a real program programming language is that you can take advantage of everything that exists in that ecosystem. Uh So let's go ahead and write a unit test against our create infrastructure function, right? So we want to verify that uh that service has that tag. So we can build that operational tooling, right? That uh no one is specifying that user data. We we, you know, pretty sure that they can't because we wrote that function signature that takes no parameters. But we want to just be extra, super careful. Uh And then we want to check that SS H is disabled because it'd be really bad for someone to be able to log on to a server and, uh, you know, take our user data. So there's another good time to go ahead and grab your computer. I'm gonna switch over to the terminal and I will post instructions in just a second. All right. Uh I'm gonna go ahead and do a Pulumi stack. Destroy dash dash. Yes. Uh or sorry, not Pulumi. Pulumi destroy dash dash. Yes. All right. Uh And while that runs in the background, this is just to clean up my old Aws go web server resources. I don't want to pay those, pay for those. So gonna open up a new tab and I'm gonna CD back into testing unit. Go OK. And I can go ahead and open this up and uh look at our main, this is our create infrastructure function that we had, right? And then look at our main test. We have some mocks that are not super exciting. And then we're gonna step through uh this testing code here. It's runs inside of a standard Pulumi run this variant returns an error so that we can uh check and make sure. And essentially we're going to use Pulumi dot all and apply to await for these asynchronous values that we've knocked out. And then inside of those apply callbacks, we're going to do some assertions and use weight groups to coordinate everything. So we have a weight group of three and then we're running three assertions and we, you know, looks very much so like a, like a standard unit test test infrastructure takes in a star testing key and then we can run that test from here. But I'm just gonna go ahead and go back to my console and uh just run go test. And so while that gets started, I'm going to put those instructions up for anyone who let's see this. So yeah, Pulumi examples testing Unico and then all you gotta do go test and you can deploy this example if you like may require you setting some additional configuration. But yeah, it's there. You can check it out and try it if you want. OK? Cool. And you can see, hey, half a second and ah our unit test is executed. So let's dive in a little bit and see we got a passing unit test. It's awesome. Let's check out what does this thing actually do? That's why we're here, right? All right. So, like I said, we have this uh Pulumi dot run error. Uh This one's a little different because we specify some uh mocks as a, as an additional parameter. So Pulumi dot with mocks and pass in those mocks that we defined above and we're using a weight group to coordinate these three sort of asynchronous tests that we're gonna run. And so our first test, we want to test if this service has tags, right? So we're passing in that server urn that unique, uh that unique address that we can use to identify it, then we're passing in the tags from that server just passing in the urn here so that we can, uh you know, add a little bit of both log if perhaps something fails and we have a bunch of resources in our stack. So wait for those available values to become available, call this apply call back and then make sure that that tag, that name tag exists inside of the tax collection that gets passed in. And you do see here that um because of the nature of like generics and go when we do this all uh that, that gets called into this, apply T we do have to deal with uh interface. Um This is a result of providing something that is, you know, uh works with these union of input types, um this T and then output of T um in a language like go that does not support generics and it sounds like many of you hope it will never support generics. So, and then we have uh you know, this other test that just tests to make sure that user data is empty basically. So wanna make sure that that user data value is new, that no one's clattering that ami that we worked so hard to prebuilt uh with, with our uh blessed web server image on it. Right? And then this one's a little bit more involved, but similarly passing in that urn and that ingress and awaiting those values, then once they become available, we're going to loop through everything in the ingress that we have and just have a little flag value to see if something's open in the internet. And if we're on that uh open Cider block, we're going to break out and fail. But you know, this, this shouldn't look too uh too foreign. This is very, other than the all and the apply, this is probably very similar to the unit test that you're used to writing inside a go. So, you know, these are unit tests, we aren't verifying, you know, the functionality of a particular cloud service or the behavior of your infrastructure. You can't make, you know, H TB queries to cloud resources that don't exist, they're mocked out. You know, these, these tests are only as good as the mocks that you write. Um uh But you know, you can verify quite easily uh things like control flow logic, propagation of expected values and configuration, this behavior of your code in isolation of the crowd. So, you know, if I, if I call this, um if I call this method, you know how many, how many lambda functions are going to be created or you know how many uh like how many E two instances are going to be created. And as you said, half a second, this is blazing fast. Doesn't require that CL cl I binary to be on your machine. And it gives you that sort of tight dev uh feedback loop that, you know, a lot of people really love. I love it. Any questions here? Let's go ahead and stop for a second. All right. Is there a way to make your tests actually try to create, destroy my infrastructure? Oh, wow. It's so great when people throw you a softball that you're set up to answer in the next slide, how do you handle the version of me? OK. We got that. Thanks Aaron. Yeah, he says he'll take his payment via Venmo. All right. Uh I'm gonna go ahead and move on since you know, uh Aaron needs to get paid. Obviously, integration testing. Yep, you are right. So we do have ways to do full end to end verification of our deployments, spin them up, uh spin up our cloud resources in an ephemeral environment, execute some code afterwards that has access to those stack outputs that has access to those cloud resources and then tear everything down. Make sure we don't leak those resources in C I or in your local development environment because we don't want to continue paying for that right? Cloud is expensive enough as it is. So uh this is, you know how we can verify like the integration of cloud resources like when I change that I am role like did I suddenly lose access somewhere? Did I tighten things down in the proper way? Uh Verify that ede request can flow through the system and then, yeah, so let's go ahead and I'm I'm not actually going to do a code demo for this one because as we said, deploying cloud resources, spinning them up, executing, you know, waiting doing retries and then tearing down the resources doesn't demo quite as well. Um But this, this is inside there, I will just go ahead and show you where this code is. So uh testing dash integration and if you look inside of here, one of the things that's kind of cool. Uh If we do LS program, we're actually using our Go test harness to deploy a typescript program here. Uh I, I hope that I get invited back after uh showing typescript during the go meet up. But uh we're actually not going to talk about the, the typescript program at all. Just think it's kind of cool that our test harness does support uh executing languages uh in, in a variety of other uh or executing programs in a, in a variety of other languages. Through go we at Pulumi or go engineers the whole Pulumi uh engine cli all the providers, everything is written in go. Um It is like our favorite language and you know, something I'm excited to work in every day. But yeah, uh long story short, if you wanna follow along and try this out later, you can go to the testing integration. Cool. So here we have some basic configuration that's defined once again, just looks like a regular go test, right? Takes in the testing object. And so we have this program test options that specifies where is that uh where do those files that you want me to do to plu me up over where does that program live on disk? Um some other configuration values. And then you remember how we had to specify what region we wanted to deploy our resources to. So you can specify that same config map programmatically through this test harness. And then this extra runtime validation function is what gets executed after your update has completed successfully. So in this case, we're going to look for our stack outputs uh for our website URL that, that public host name that's exposed and we're gonna execute that request with a little wrapper that does some retries. And just once we get that uh result body, we're gonna assert that it has hello plume, which is what we had baked into our web server. Awesome. So you know integration testing, this is how we validate the end end flow of our cloud resources like in the wild. This is a much slower process than unit tests. You know, it does provision that full replica of your infrastructure, but it really brings confidence and enables like CCD for infrastructure and like moving really quickly, you can't always test every edge case and every, you know, new developers aren't every, aren't always aware of like all the nuances when starting to poke at infrastructure. So this is, this is what helps you hit that green button, merge your pr and you know, let it get deployed through your C IC system and not have to look back. But yeah, what do we test here? We test, you know, we can do really interesting things like check test health checks and alarm configurations um mentioned before I am bugs and things like that. My favorite is the ability to actually simulate deployments, right? So if you have uh if you have like a secondary environment, uh you want to do a simulation of updating the stack from one state to the next, you can actually specify multiple steps. So you could specify like different git paes of the same Plumy Throat program. So you could deploy the old program first and then apply an extra step and edit that now doesn't update. And so you can do things like simulate that pro deployment and measure up time, like see if you gonna cause a database outage. It's kind of cool. And then finally, you know, this is the ecosystem. So today, Pulumi uh all of us go first here, we're not really interested in this. But if you did happen to be uh you know, we do support typescript no Js Python and then all of the dot net languages um integrations with all the source code providers. You can use whatever tools you're using today. So you know, NPM for javascript, you can use vs code all the go plug ins that are available there. We have C ID integrations and then available on all the cloud providers. So Aws Azure GP, like I talked about, we have full modeling of all the Cobert use resources. We actually have this really cool capability. It's not uh not quite finished yet and go but in other languages, you can use our uh you can use our API S to generate the animal. So if you have some sort of bespoke kubernetes deployment process and you hate writing animal, you can write um in your language of choice and produce that KTIS Yaml using strongly typed uh API S and this declarative sort of desired state model. Um Yeah. So just in review, we talked about, you know, provisioning. So how we, how do we automate our, you know, team set up? How do we automate our application development environments, um treat everything as cattle, not pets, make sure that we're not incurring too much cost, automatically, clean things up. And then how do we apply architectural best practices, right? You know, things that we're typically used to and go, right, uh applying that right level of encapsulation for the consumer that we're offering for. And then last, how do we apply testing, best best practices, both, you know, fast inter dev loop unit tests and uh full confidence integration tests. Uh that let you move quickly. Uh Kind of, yeah, and uh you know, really appreciate everyone taking the time tonight, really enjoyed being here and talking to you and all of the, the witty comments. So you all are quite a funny group. Um Lots of ways here for your you to learn more about Pulumi. You can hit me up directly on Twitter. Um Feel free to drop into the Pulumi Slack. I'm Edin on the Pulumi Slack. Um Would love to hear more from you if anyone wants to uh get started on some feature requests. We have a, a list of issues that are good getting started in Pulumi Pulumi. So always looking for new contributors and uh and help from the community.

---
