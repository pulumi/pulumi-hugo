---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Building Native Providers in GoLang | ContribEx"
title: "Building Native Providers in GoLang | ContribEx"
meta_desc: |
    In this session, guided by Ian, we'll build a native Pulumi provider in Go using pulumi-go-provider.
url_slug: building-native-providers-golang-contribex
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Building Native Providers in GoLang | ContribEx"
  description: |
    In this session, guided by Ian, we'll build a native Pulumi provider in Go using pulumi-go-provider.  What is Pulumi? Pulumi is a free, open source infrastructure as code (IaC) tool, and works best with the Pulumi Service to make managing infrastructure secure, reliable, and hassle-free. Pulumi helps developers and infrastructure teams collaborate and tame cloud complexity â€“ something we call Cloud Engineering.
  sortable_date: 2022-09-13T22:06:26Z
  youtube_url: https://www.youtube.com/embed/ONbo1ru8tUA
transcript: |
    Hello and welcome back to Pulumi TV. Today we are live streaming and taking a look at the Pulumi Go provider, a framework or package to help you build native Pulumi freighters and go. My name is David Flanagan and I'm your host today, but I am joined by my colleague Ian, who is a software engineer at Pulumi, who is going to guide us through everything that we need to know to build a native provider. Hey, Ian, how's things? Things are pretty good? Awesome. Can you please just take a little bit of time to tell us a little bit about you and what you're working on? Sure. So as David said, I'm a software engineer at Pulumi and recently I have been working on making writing providers a little bit cleaner and require quite a bit less boiler plate. Awesome. Thank you. No, feel free to share more. No, on you go. Um So this started out of a hackathon project where we realized that we wanted to write some providers and it was quite difficult and there were a lot of pieces that had to fit together perfectly, but so they were strongly synced but also updated independently. Um And we thought that there could be a better way to do this because we're all software engineers and we write software for other developers and it seemed much better that we write software to handle a lot of what we've been doing than do it ourselves manually in a very error prone way. Awesome. What I mean, what were some of the biggest challenges previously before this framework of writing the provider? Is it, is it just all the the boilerplate that's required? Um Is there other specifics that we could share? Um So we've had a couple of major problems. One is that there is a lot of boil plate, but because it's currently implemented as boiler plate, it gets out of date because it's not part of a library. Um The specific issues within that are you have to write a schema um which is a big Json or YAML file, the schema has to exactly match your go code. Um And there are some subtle interactions there where if small errors like an extra pointer or not can have unfortunate um consequences during runtime. Um So getting that right and up to date was quite of a thing. Um De serialization and serialization is a little bit finicky. It has to match the scheme exactly. Um You call different sets of methods. Um There are different requirements for what constitutes proper de civilization, whether you're doing preview, whether you're running a preview or running an actual Pulumi up because sometimes values are there and sometimes they're not um handling optional values correctly, et cetera. Um And then the other thing is there's just a lot of methods that you have to implement correctly and a lot of them you don't care about, except when you do. So handling all of that was a lot of complexity and having quite a lot of experience with the Pulumi schema uh working on it professionally and quite a lot of experience with the Plume engine. It took me a long time to figure out the correct set of things to do and it shouldn't. So we're trying to fix it. Nice. So this work on the Pulumi Co provider is like an opinionated, er, py way of trying to make this a lot easier for people to write their providers in a native fashion. So we're actually going to attempt to kind of get started today and see how far we can get on writing a native provider. Is that correct? Uh Yep, you confident? Ok. I think we'll get something awesome. Well, I'm excited to kind of work through this today and see what we can put together. So the link I will put into the comments for people, er, but it's just available at gaub dot com slash Pulumi slash Pulumi dash go dash provider. And I, if you can share your screen, we'll move over and we'll start talking about this as we make some progress as well. Ok. So yeah. Is this good and visible? Uh Yeah, let's just pop over here. Ok. Your screen is now live. We can see your capital. Ok. So we're gonna start by making a new provider. Um I think the plan was to work on the short IO provider, right? Yeah, sure. I was uh a URL shortener that has a pretty nice API it's something that we use on the team at Pulumi. Um and I like to do everything as infrastructure as code. So I thought it would be an interesting uh concept to see if we could build a provider around that. The way we start is this is a go package. So we're going to create a directory. We're gonna go um in it and we're gonna do go it. Um And I don't remember. So we're also gonna do get in it because version control is good. I'm gonna switch over to that project. Maybe not. Um I can explain um then to start on building the actual provider, it's a normal go um project. I think traditionally we do something like provider. Um and then we'll do provider dot go and this works well. It's a structure but it doesn't really matter. The great thing about this library is that you're just building some go code so you can do it however you want. We can do short go if we want. Um Well, your bed set up is pretty nice. This is actually emac emacs. Wow. Emacs running Doom. Um, which, uh, ended up which itself is then running a package called Evil, which does emulation. Nice. Yeah, I saw this Get a sweatshirt and there and, and command was, I just assumed it was them, I had no idea. It was emacs. Oh, it does stay at the top of the bar. So I should have been paying more attention. But nice. They're all complete and stuff like that. You've been typing is, is pretty sweet. Yeah, that is also available in, it's, it's all LSP servers which is also a plug for PM will now has an LSP server. Um Go check it out, just started to do a release. Uh I'm just gonna tackle one of the questions of the chat while you do a little bit of tap or we can pause for a second. Um but is asking as the session recorded. The session is live on um linkedin and youtube and Twitter, but it is also available on youtube channel at Pulumi at youtube dot com slash Pulumi TV. So yes, it is available. How are you? No problem. Um So I'm just going through and setting up basics we have and try to do so memory it's not gonna work. Um Gets this. Um We're gonna return this import shows up a lot. I like to shorten it. Um But of course, it's just go, we're gonna return a provider and the specific way we're going to do this is the provider library is intended to scale all the way from you. Or in this case, us would like to build a relatively small provider to you would like to build a massive programmatically driven provider. So there are different layers. Um The way the layer we want to use is the infer layer which handles OK. You have some go code, please turn it in an opinionated and intelligent way into a Pulumi provider. Um So this handles things like deriving the schema from the types. Um And it handles a lot of seeing defaults. OK? So I just wanna make sure I understand that. So if we use this in fair layer from the provider, um this just means that we can define tape structures for the objects that we're working with. And I'm assuming some crud methods and it kind of generates all the rest for us. Uh Yep. Yes. Um We, we define type trucks, we define crud methods on those trucks. So you don't see Pulumi property maps or R PC um struck blobs, you see your input, your arguments and inputs and outputs type. Um And it will handle serialization. If the sterilization is wrong, it will error saying I'm sorry, this field isn't correct, it doesn't match et cetera. Um So this is the point where I'm less confident we are now at the point where we should start defining actual resources. Um Because there's not like this, this will handle driving most of the boiler plate um for actually defining the provider. Ok. Do you have any opinions on which resource we should actually implement? Uh Yeah, I mean that the only the most important resource from the IO provider would be the, the chart URL. Uh So they call it a link on their API so we should call it a link. Ok. Um So you would do type link um as an empty structure. There's still a little bit of place. We do link AGS, you can call it whatever you want. But AGS make sense. And then there's a type link, I call it state. Generally speaking fun. And because in Pulumi, it is common to have the state of a resource also include its inputs. Um I think it's a relatively use Lidum. We can also just do, we can embed link A and link state. Um then to create to add this provider, um This would be infer uh what is it um resource um link think AGS. Thanks. Thank you. Which is uh using um the go generics feature is strongly used and required. Ah Cool. I keep meaning to play with. I haven't quite got around to it yet. But um ok, so this and fair provider, we press it in three strips. We've got the length of the link Rx and the link state. So the AX is the input that people use to create a new link link state is for any company computed values or something we get from the API that isn't necessarily an input. So I guess output would be, I don't know if that's the right terminology here, but maybe uh and then the link is, I'm actually not sure what just the vanilla link struck. Then link is essentially a place to hang link is a name space is a really good way to think about it. It is just a, it's a place to hang methods. So when this is there are a lot of methods that you can implement for a resource, not all of them are required specifically only we create is using that as a receiver methods. And the method is that Yeah. OK. Awesome. Um You said one other thing, sorry, I didn't mean to talk over you there. Yeah, you said something that I think was quite interesting. You said like a good plume idiom is to actually include the input parameters as part of the state. Um Is there anything more we can share there? Why is that a good idiom? What does that enable? Um I find it helpful mostly because when you are then working with this resource, you can assemble the arguments depending on your language immediately as you hand to the resource. And then if you want to figure out what did you hand in et cetera, you can then um just um like do like your normal dot operator on the output. The other bit that is helpful is that a lot of resources work by having a set of required or a set of optional and required inputs and then have all the outputs required. In other words, you can give it know like an Aws bucket, you can give it a bucket name. But if you don't, it will still have a bucket name and it's a required output that you can see. Um And this makes the code I think relatively easy to use just as a consumer of the generator. SD. A nice Yeah, that makes sense. There's nothing in the engine that requires it. Got it. Ok. Um Try to compile. We see an error that says link does not implement create because there is one method that every everything, every custom resource has to actually implement. Yeah, this is the same with dynamic providers as well, right? Like the only required method that you need is the the create method. Uh Yeah. And this kind of makes sense, right you came up with or at least I could come up with a reasonable default for delete which is do nothing and for update, which is error out because you can't update and for read, which is passive names. But the reasonable up the reasonable behavior for create is you gotta do something, right. Yeah. Um And the way I for go is um I I don't remember the method signature. I run the, the compiler because the compiler is fast. I wait for it to error and it will tell me what I'm missing. Clever. Um Depending on how exactly did. Yeah. Um So this is name spring. Then I need to face the house. Oh yeah, we don't really need these types of names. Um So the basic create method works by um it takes a context which is both your timing and your logging. It takes the name of the resource and its inputs and if it's currently in a preview, OK. Cool. And then it outputs the id, the state which is a structured link state as given. And then if there's an error, we do the standard go idiom or the errors at the end and you can choose and if you have an error, everything else is ignored and the error will be displayed to the user, right? Um So if I'm looking at the API reference for link list or for link queer, am I looking for link queries or link editing? I guess? Great Earl probably. Yeah. Yes, there's a an API M point for I'm creating, I've got it here. Mhm. Um I see a link, sorry. Yeah. Uh link it, link editing and then create URL which gives us uh they actually have generated goal code that we can use so I can send that or I can send you the the link. Awesome. I'm on that page. All right. OK. Uh Yeah. So if you're on link editing, create URL and then the three drop down, uh I'll just share my screen so the audience can see what we're looking at to. So I'll pop over here for just a second. Um So this is a short UR API reference which is not doing. There we go. Uh And if you click the three drop down here, you can actually select both of languages, go as an option. And we can actually see the, the code that we would require um to use goes built in a P library to send a request to create a, a link or resource. I'm not back sharing your screen. Awesome. So I have copied that and I'm gonna paste it into the create body and then of course, fix it. Um I copy I code. Um So we have OK. Yeah, great. Um So we have earl we have a payload, we have a request which is gonna return an error which we should probably check um add some stuff to the request, perform the request, you read the body. OK? Great. Um And then we return the result and the body. Um Great. So now I'm looking essentially into where we're gonna have inputs here. Um So if we type in a domain gram. Yeah. Yeah. So I think the inputs would be the, the main, the short URL and the long URL. Great. Um These are all gonna be strings, let's call them main short and long. Um This is subject to change, but right now you have to explicitly tell the package that what you have is a Pulumi um field and not just a public field that you happen to be using. Um So we're gonna do that here the way you do that is with the struck annotation. Now have main a short and the long field that are all required arguments to the inputs and man should be the like, you know, the domain we're using to chart. Yeah. OK. And it probably for a second. Great. Um And then we're gonna put these, I believe in this body. So what um I mean, sorry, they call short original URL, capital URL. I wasn't paying attention, but we can call it short. I think it's a better P I answer. Um And then the last thing is called they call it path. Thank you. I guess that brings up like a design decision that maybe others have. I know that I'm now starting to question all my life choices. Um But does it make sense to kind of map your provider api to exactly their API or do you know, do you think it's suitable to say? Well, actually, I think, you know, it's OK to change it if it provides something that's a bit more uh fluid or understanding like, or is it better to just say no, that's let's use it? I don't know. That is definitely an interesting question. And I'm gonna, I think I will personally defer and I don't have a great answer. I think it probably depends on how much, you know about the API and how bad it is. True, I guess. Yeah, your makes sense to you if you're an expert on how this works and it's also terrible as is, I think it's probably, you know, go right ahead on making it better if I was doing this for real. Um And trying to write production code for the short lio provider, I would probably stick to what they have because I don't have a, I don't know it well, such that I can have a better idea. Ok. Uh It's my personal opinion on this. Um you as an influenza, I think this is your first to bear, which is to choose. Do you want to copy it? Exactly or not? Um And then we have input dot domain into that short and input dot Long and autocomplete because it's just a ghost truck that's sitting up here and short and long of the wrong way around your parameters. The original URL is the long one and then short on that and they call that the path on the domain. Yeah. Ok. Um And then do we have any information about the response body just so we can respond with something? Uh Yes, we do. Um The response we get back adjacent object and it's gonna return either a 200 or 201. Those are both success and we get back uh where the, the ID string, capital S which is probably the only thing that it is important at the moment sounds good. Um So we're gonna say as the link state, we take the inputs and also we're gonna do an ID string. Um And then to get this to just be a Jason dot um martial of where is that party? Yes, not that work but OK. Um Let's see, I'm gonna try this, remember how to turn it. I guess we'd have to do that's already body. Um The media is we are going to and marshall are returned this adjacent blood um check the error and then we should be able to return. We're gonna say name is the ID, which means you can only have one of these in your state. If we were being good Pulumi citizens, we would um probably post fix that by a random er but the nature of the or by a random um essentially set of numbers, but the nature of that random set of numbers tends to be very provider specific. So you are left implemented here in the future. There will probably be tools where you say return. Um He died. Perfect, same um then provide some characterizations but that does not exist yet. He returned a link state. Um The link cards just input and where, what, what did I call it ID state um gonna be oh a drink um cast a string and the last thing is we return milk because not encountered any er OK. Well, I think there's one thing that we need to handle for this. This looks really good. I think this is gonna work but um we do need to pass through an authentication header. OK. So how do we have access to the Pulumi config or should we just hard code it? For example, today, uh we can access it. Um So you can infer a resource. I'm the essentially the concern I'm working against is I wanna make enough time so I can kind of run this, but it should be quick. We can um add a resource I believe it's with might have to look at the docks. Um where you essentially tell um you define another structure. Yeah, just like resources. Uh-huh, I believe it is we actually I know an argument. So for what authentication need to pass through is it just user name and password? Uh No, it's just uh api token. I like to a to api to, to have a conti and, and then you true. Great. And if you jump down to lane, I think plus 20 or something from there. Oh no. Yeah, there we go explained. Have a Gig method um which should return an instance of Ark and fake. And then we just call it very cool. This is a really nice api to work with. Um like there's not everything we've written is, is purely a provider logic. You know, there's no, there's no scaffolding or boiler plate or anything like that. So it is very cool. That is the goal if you want to um probably not for this session. If you want to, you can always, you can essentially, this provides a lot of hidden scaffolding. You can drop down layers if you want to see more and customize more. But the idea is if you just want something simple, this should provide basic building blocks to do it for you. Yeah. So it's what we've done now, a working provider with a single resource. Uh Yep should be enough. Um If you want to inspect bits. Um Let's see, there are bits of boil plate that is helpful to see. Um And this, the plan is that this all goes into a cli somewhere. Um For example, this is currently a library, right? So we need to actually generate the provider itself. We're gonna call that ploy resource short. Are you need to actually generate a main function? Because this is this is very much all pure go code. So needs to be a main to drive it. Uh For this, I will endlessly copy from a previous thing because it is uninteresting. Um So for the resource code we just have, that's um yeah. No, I've apparently lost what we've been working on, but it is definitely still there. Um We have a set of imports because um here we have believe we don't have a, here we're not gonna do a version. Um Then we just do, this is what actually runs it. This is the driver. Um And we want to do air checking because we are good, I think. Mhm Something bad happened to print it and exit. Um The other we do go build, we get a binary out. So thank you. So we've got a provider, a resource. We've got a main for the provider binary. Um I guess we'd need to generate some sort of SDK next. Uh Yes. So let's call it. Let me for this binary will do it seemed to build. Oh, ok. You free part of this is real. I highly recommend make files are pretty great. Um Do this once uh we have a binary. The other thing we wanna do is get SDKS. This is another bit of boiler plate that will probably go away. But right now it is the as we decide on the best way to embed it in some cli so that it is never touched again. Um It is still man um traditionally called Klu Jen. And this, I will also copy it is somewhat longer but is very straightforward. And also you are anyone is free to copy it from here. Um All this does is bring in all of our various generators. Um So this will call SDK Cogen, I think I have to update the lane on minus eight on the left. Pulumi string is the example provider, right. Yep. Um, the string is actually gonna be turned into a real provider. Um, the, the solution, um, as hard as um, the solution to a lot of the plu, we want a bunch of functions but we don't want to thread them through, um, the language itself because then they're mutable and you can't replace them is we're building providers, handle common functions including one for stringing negation, which is why next spring is actually, I think. Mhm. Originally and I turned to awesome. Um, this is all just generate the SDK in the most boring way. The way you actually get the SDK, there's a G schema function and it will return a parched schema, um, that you can call it a writer. Um, now if we do this and we have no bugs and we say, um, we can get a scheme up. There we go. So we have a provider which takes as a property, um, a token, the token is required. Um, we have some resources with these properties. They're all required and some import properties. Um, just to before we actually run anything, um, I wanna show off a couple other bits, um, because this is a very plain and uninteresting schema, you can also do things like find an annotate function. Um, let's take an an and we can do, ah, cool and it's relatively normal. Um I have a default value but we will have an environmental variable, which is right. Um Now, if we rebuild, we should see essentially this show up in the schema and this annotate function works on the config and also on link and also on LINK AGS and LINK state. And also if you just have objects that you use, it works on those two. Um Hey, look at that, this all shows on you um down and I hope this cli to Cobra you can use whatever you want um language and I know go is set up. So I will go with go and makes an error. Um 00, just missing there. I have a reasonable idea of what happened. Um I suspect that because go is go, it is gonna need import paths. Um So here are unfortunately, there is still some platy things. Um So one thing to do is map short index because we want it to the top level. Um And I think to do this, what you have to do is with um language map and then set the import path which will set it on the schemo, which will set it for Cogen might be easier to do, get that and do um Js because it is quite a bit easier to generate. Um So in theory, we see all the normal stuff, we have a fun time. We have a provider which to define our token somewhere. Yep. We have the environment, all this done correctly. Um Let's see, have a link file, all the stuff we kind of expected to have. Um, and then if we go to SDK. Yes. Um Yep. Ok. Um Let us start a new project very quickly. Uh We can, we can just start here um, of a consumer. Mhm. Um Script. And you should be um one downside with working on Pulumi full time is that you have a lot of stacks that are, that a lot of them are called some variation on test. Oh, yeah, I've got a few of those to our project. Um You can do yarn link, it's thanks or install. Um Yes. Do you need to make that provider binary available on your path? Yes. Yes, I do. Um My plan is to, to avoid corrupting. So actually, let's see. Here is a, this is what you should not, probably not do, but there is a new feature that was just developed for essentially, um to make it easier to develop providers that allows you to specify where the binary is for a provider. Ah, um Yeah. So let's make sure we have an up to date version. We're gonna rebuild our binary um go into consumer fibers. Uh Actually looking at time, I'm not gonna do that just because I do not trust myself to do it quickly enough, right? You can't have a good index. This will be sure uh Let's see if we can do blood um as equals uh um act one and you can with that. Um For those not super familiar with shell, all I'm doing is trying to hijack my path for this command. So yes, in theory will work or it will reject the version that we created because by default things create with virgin equal to a version variable. Um Yeah, it links does not six. Mhm This is not top level. There's an underlying. Yeah. Was it not just IO dash link? Is that not what I was looking for there? Um Same, I think there might have been an a an additional nest. No, maybe not. Uh Yes, we have, we have a real, a real thing now. Oh And now we are doing the typical thing of we have a resource. This is I don't entirely remember what. Oh, actually I have a decent sense. Um But we have resource. It's called link. It takes some arguments and it's a demand, a shorten a lung need to be arbitrary. Well, if we want it to work, use rock code to dot link and shark can just be this year and long could be Google dot com or something and rock with A K and I sent you an API token on a private chat if you can see that. Um Let's see. I I can send it to you on Slack if I see, sir. Yeah, I see the token. Um I'm gonna, you can stop sharing my screen for, you can just flash it. I'll delete it right after the session. Yeah, that's OK. OK. Um Or you can just pull in a con a secret which means when you paste it, it shouldn't be visible. Or are you going to hard code it in a code? I was gonna say that to me, said a secret, a secret secret and I'm sure um and then this would be and it just hit return. Uh If you hit return, you could have hidden it because it will prompt for a secret uh red line. Oh, but it's like I said, I'm going to read that this is not a real token. It's an ephemeral token for today. So it's all good. Um So if we look at our stack, config yeah, there we go. Have a secret. Great. Um That is good to know but not something that I remember. Um Now the question is, will we be able to get it up or not? Thank Pulumi or do you have to import that in the index all these into our yarn install in the generated SDK? Yeah. Um For sure. Um Yeah, it should. Ok. Um As you can see, we are still getting this experience perfect. Um And yeah, it's saying it tried to install, it didn't work because we have not published this provider because we're building this provider but patients we can get the functioning out. No, I'm not entirely sure what's going on. Yeah, I'm not sure why that's complaining about that. Either. Should we try moving this from tier dependencies to go or um, to actual dependencies and then you install here? Oh, we probably need to include, if it's in peer dependencies, we probably need to include it in um, the Dommer package. Um, but this is, and then we'll see if we can get compiling. Is this because we compiled it with a blank version. Uh I believe so. Yes. OK. I don't think we, we don't, I mean, I don't want to keep you past the time and I think we're showing all the cool bits anyway, like um we don't need to actually show it working. But, you know, we are pretty close. I think it gives people a really good understanding of how they can start to experiment with the provider code base. And I think what we've seen today is I'll put on, I'll switch it back to there we go. Yeah, I think what we've seen to do today is is really awesome. You know, the ability to, to build a native provider with just defining a couple of trucks and a single create method. I think the use of all the generics to tie that together is really, really cool. And like you said, this is, this is early, this is something that has started as a hackathon project and has been developed. Uh presently and it's going to continue to improve. There is a little bit of boilerplate required and the generation of the SDK and the main do go for the provider. Other than that, like people's offering experience for providers is going to be drastically improved in the coming days, weeks and months. And I think that's really exciting to see, so, you know, great work and this all looks fantastic and I'm really excited to see where this goes in due course. Can you maybe give like a quick 32nd to a minute overview on what's coming next or when do you think people will be able to start using this new framework? So the basic idea at the moment is done. Um We are refining bits of API we are working on that. We're working very hard right now on the rest of the experience. So once you have this part, we have the SDK generation boiler plate, we have the actual publishing of the plug-in via github, we have getting into the registry that is all gonna become drastically easier in the near future. Um Right now, the current project is to get the entire experience from. I have an idea, it would be cool if there was a short provider to it's published in the registry and available. Um I think the priorities are uh simple, painless and quick. So we're working on all of that. Awesome. But I mean, we've managed to write a provider with a single resource and like under an hour. And that is, you know, you have to explain things to me as we go along. So I hope people see the value in this free market that benefits the dot net. Like it's a huge quality of life improvement for people that want to build a limit providers. Yeah. Um, I'm glad, I certainly hope so. Uh Also just for my own uh edification, I will post a working version of this example. Getting at the last little issues in, I think the path and getting garden to work and providing a real version. I will post that to github with a link to be determined. Uh All right. Well, just let me know when that's available. I'll add it to the, the show notes and make sure it's available for people that are watching us after the fact as well. All right, we've had one minute over, but, you know, it's been an absolute pleasure Ian sitting here and working through this together. So I want to say thank you for spending some time with me and I'm really excited about this new framework and can't see what, can't wait to see what happens. Yeah. Can't wait to see what comes next. So thank you again. Have a wonderful day and I'll speak to you soon. Ok. Uh Have fun. Thank you very much, but

---
