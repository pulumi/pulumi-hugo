---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Serverless GraphQL API | Modern Infrastructure Wednesday 2020-05-20"
title: "Serverless GraphQL API | Modern Infrastructure Wednesday..."
meta_desc: |
    In today's episode, we are building a serverless GraphQL API using Apollo GraphQL, Google Cloud Functions, and Pulumi. Code for this episode availa...
url_slug: serverless-graphql-api-modern-infrastructure-wednesday-20200520
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Serverless GraphQL API | Modern Infrastructure Wednesday 2020-05-20"
  description: |
    In today's episode, we are building a serverless GraphQL API using Apollo GraphQL, Google Cloud Functions, and Pulumi. Code for this episode available here:  https://github.com/pulumi/pulumitv/tree/master/modern-infrastructure-wednesday/2020-05-20  The examples are in TypeScript but Pulumi makes it easy to stand up infrastructure in your favorite languages including Python, JavaScript, Go, and .NET - saving time over legacy tools like CloudFormation and Hashicorp Terraform.  https://www.pulumi.com/docs/get-started/?utm_campaign=PulumiTV&utm_source=youtube.com&utm_medium=video
  sortable_date: 2020-05-20T04:24:04Z
  youtube_url: https://www.youtube.com/embed/mU5_aclyQR8
transcript: |
    Hello and welcome to another episode of Modern Infrastructure Wednesday. I'm your host, Lee Zen. And today we're gonna be talking about serverless graph QL API. It's kind of a lot to unpack. What we're talking about is really how to build a graph Q API uh using a function in GCP. And you can see I've been wearing my new Super Pulumi Pu T shirt. Uh So let's get started. Um In this episode, we'll be covering basically a way to modify an existing example. It's a, it's an Apollo server example. So Apollo is one of the graph QL uh API implementations and then we'll learn about callbacks and callback factories. And really, so seeing how we can actually modify the example to, to work with callbacks in Pulumi, uh you can follow along on github dot com slash Pulumi slash Pulumi TV. Uh All the example code will be there uh as well as well as all the previous episodes, example code. And of course, if you enjoy this episode, please like and subscribe to the, the the channel for future videos. Uh We're publishing one every week and yeah, please comment if you have any feedback So let's take a look at what this looks like. Um I already have a uh uh you know, skeleton project set up uh for GCP. Um and uh Pulumi uh on typescript. And if I go uh look at the example I was talking about this is in the Polygraph QL um Repo uh I've already installed uh the two dependencies they talk about. So now we're just going to uh copy and paste the code they have around uh implementing uh the API handler uh as a Google function. So um this is really what the function should be in, in the Google function itself. Uh But for now we're gonna drop it into our employing program and then, and then kind of add some things here to uh get us to deploy. So here this uh this handler is really what we want to deploy. Um And so we can, we can make an API uh we'll actually, we'll call it a function. So we'll call this API function. And um this is this is a uh DC P uh cloud functions, uh callback function. And so we'll call this API function. And this could really just be the uh server dot create handler here. Um And the reason is you can see we, it takes a callback, which is exactly what this creates. Um And that's pretty much all we would technically need. Um In addition to that, we will want to actually create a uh invoke, so that we can actually uh invoke a role rather remember, so that we can actually invoke this from anywhere. So let's go ahead and do that. We'll call this the uh EP I invoke and this is a uh cloud functions uh number, we call this a Guy Boger. And we can see here this takes a function. And so this will be the function above and there's an underlying function and there's the um uh Ivy and then also requires a member and this will be all users. So we'll let anyone uh invoke this. So even even just random internet users, and we'll give it a role which is uh you know, the cloud functions uh invoca role. And then finally, we'll export the, the URL uh of the function that we're creating. Cool. So let's try running a plume up and see what happens. This should actually fail. Um And the reason for that is because uh and you'll see quickly when we try to serialize the function, uh it doesn't really work because we try to capture this uh Apollo server class uh that we instantiate up here this object. And, you know, we really don't like kind of the this and stuff like that. And, and um part of that is because we're kind of crossing this boundary between, you know, instantiating this here and then trying to use it um as a full fledged thing uh in our function. So we could uh, fix this up and let's do that, uh, by wrapping this. So we'll call this a callback and we'll make a call back up here. And I actually said, let's clean this up and make this, uh, look more typescript here. So we'll call it, we'll do import, um, from, let's do that. And, uh, we'll, we'll have this thing, we'll have this, uh, function call back and, uh, call back. Actually, let's, let's look at the, the type signature for this. Um actually looks like this. So it's an express request response to avoid. So let's just copy this here and we'll use that signature uh in our call back and we'll just indent all this and early we had server dot uh create handler of and this is our callback function, right? And so we can just, just invoke this with the uh request response. And so we, we basically, uh we need to import express, of course. So let's try this. So what we've done is we've wrapped all that code we had previously into the callback itself. Um And we're just calling the call back uh as if you know, uh that's what we're doing. So let's say yes. And so instead of just uh passing off the, the function itself, like we were, instead of just passing this, we're also doing all this other work uh that we were doing before in our, in our uh in our Pulumi program and now doing it as part of the callback itself. So let me fix the indentation here while that's running and while this is running, actually, let's also take a quick look at the, the example here. Um You can see what this is really doing is it's very simple. We're just uh you know, creating a simple uh schema where we have a single query type with a parameter. Hello. Um And uh these queries just return hello world. So we're not doing anything complicated. Obviously, if you want to get into this, you can go uh learn more about graph QL or if you're already a graph QL uh user or know knowledgeable graph QL, you, you can pretty easily modify the example we're doing to uh to work with your needs. So this is still deploying, you can see the function created the IM number created. So everything worked. I mean, let's try to execute it. So uh we can curl uh Pulumi oops, let's wait to curl post. And so we'll take the stack output of the URL. And uh we probably need to give it a content type uh application Jason and we'll give it some data and it'll be, you know, query and uh we'll give it the query of um hello. So let's try that. And so now this is actually executing the function and we get back the result we expect. So life is good. You can see it's kind of a little bit slow and that's some of the startup time, but also some of that's because, you know, every time we invoke the function, actually, it's gonna run all this code. So this is all part of our call back. Um It's going to instantiate a new Apollo server and do all this stuff and then finally invoke the callback. So how can we avoid all this startup overhead? Well, that's where uh callback factories coming in. So let's take a quick look at uh the cloud functions documentation. Um For Pulumi, you can see we have this concept of a callback factory. It's a signature that actually produces an entry point, but it allows us to initialize expensive state. So the whole point is that this factory lets us create a callback. So let's do that. Um So how do we do that? So let's modify our uh example here. And so instead of just giving it the call back, we can actually give it a Callback factory. So we'll give this a factory which we haven't declared yet. Let's go back up here and let's change this to be a factory. And as we close the signal for a factory is actually fairly simple. It's just, it's a, it's a, it's a, it's a function that takes no parameters and it returns a call back. So we can actually, instead of doing this, we can just return this. And uh so now we're not wrapping the whole thing. So now what's gonna happen is all of this code. All of this is gonna act as initialization code. And then this callback is actually the the handler that will be called on each function invocation. But the the remaining stuff uh up here is only called uh one time when the function is first created. So let's update this and we should see this still work. So we can see it's going to replace the function with the bucket object is the, is the source code and then also replace the, since we've changed some of the other stuff here. So let's do this. You can see the URL, we don't know what it's gonna be. Now, since we're gonna have a new uh a new uh invoke invocation URL. So let's run this. It's like a couple of minutes uh for us to update. So just a quick recap of what we changed uh Before we were just invoking the whole thing as its own callback. And now this factory function is basically just is just returning the call back instead. Uh And all this stuff becomes initialization code. Actually, if, if you were to go into the console and look at how it's, it's set up, you, you would actually see that that happening. Uh There, there's the initialization followed by uh using the, the handler as, as just this um as opposed to the entire handler being all of this code. Um So that would be the difference. OK? Great. So our update is done and you can see we, we update and replace the object and now let's go back to run our pro command and we should see that this will return the same thing. But uh without having to do all of that uh startup cost. So that's, that's it. Actually just those are the two things I want to, to run through today. Um Hope you had a good uh time following along. Uh As always, please like and subscribe. Please leave any comments uh in the video below and we'll see you next week.

---
