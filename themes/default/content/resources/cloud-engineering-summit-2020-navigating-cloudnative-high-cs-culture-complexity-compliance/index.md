---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Cloud Engineering Summit 2020: Navigating the Cloud-Native High Cs: Culture, Complexity, Compliance"
title: "Cloud Engineering Summit 2020: Navigating the..."
meta_desc: |
    Cloud-native architectures fundamentally change the way applications are built and delivered and introduce a sea of new challenges that need to be ...
url_slug: cloud-engineering-summit-2020-navigating-cloudnative-high-cs-culture-complexity-compliance
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Cloud Engineering Summit 2020: Navigating the Cloud-Native High Cs: Culture, Complexity, Compliance"
  description: |
    Cloud-native architectures fundamentally change the way applications are built and delivered and introduce a sea of new challenges that need to be overcome including:  Culture: Defining new roles and responsibilities for Dev, Ops and Security team members. Complexity: Jumping into a new technology while trying to modernize and maintain legacy systems. Compliance: Dealing with cascading dependency updates, minimizing attack surfaces, avoiding container misconfigurations, and building a hardened pipeline that becomes the single source of truth.  Join this talk and learn how Chef helps Dev, Sec and Ops teams overcome better work together via a codified approach to application delivery. During the demonstration you’ll see:  How to eliminate container “bloat” and reduce complexity associated with dependency updates with application definition How to apply a shift-left approach to system hardening that applies both to the container and the host the container in running on How Chef fits into pipelines, integrates with tools like Pulumi and helps secure the pipeline
  sortable_date: 2020-11-11T00:28:48Z
  youtube_url: https://www.youtube.com/embed/xkhotnCPNKA
transcript: |
    Hello. Uh Hello everyone. My name is Heather Payton. I am a product marketing director at chef uh responsible for the application delivery side of the house. And along with me today, I have uh Neve Cahill ne you wanna go ahead and introduce yourself? Yeah, thank you, Heather. Hey, my name is Ni Kale. I'm the solutions architect manager for the West Coast for chef. I'm very happy to be here today and I love working in devops with all of our customers. Great. And uh as advertised today, we're gonna be talking about uh some of the challenges organizations face, especially from the operational side of the house as they adopt um cloud native architectures and how chef helps them um overcome those. So if you look at studies across the industry, um commonly you see these, these top challenges um highlighted culture, complexity and compliance and there's a great quote over here from Gartner. Um talking about the, you know, the move to cloud native is not simple, there's cultural changes, um More things shift left, more things are done in the development side of the house. There's complex city which mostly comes from all those legacy apps that have to be untangled and then there's compliance. And when you look at this picture, we see compliance many times as its own thing. And to be successful and cloud native, we really want to start thinking about compliance um across uh the whole process need. Did you want to throw anything in on that? Yeah, absolutely. I think really what's key here when you're trying to overcome the complexity and the learning curve is cooperation between the teams and you really want to find a framework and a tool set that enables that cooperation. So that's where uh solutions like polluting that support multi cloud and different kinds of tech analogies as well as chef and chef habitat and inspect and really enable all of these different circles to come together. And honestly compliance shouldn't be over here on its own, right? It should be layered in across everything that you do uh along with security. Exactly. So moving along when we think about complexity, right, we, we think about something that looks like this. I like to call this uh the mess in the middle and that's what DeVos is addressing, you know, all the tendency, all the dependencies, all the tools, um all the things that have to be done to take an application from DEV um to release. And as we start to untangle that and move to cloud native um architectures, we're really trying to break um application components, um instructions for delivering into smaller and small pieces that can be more easily managed. And so as we move from coding applications to assembling applications, more and more tasks become codified and automated. And there's a great quote from Gartner here that addresses that and this is really chef's approach to helping clients from their existing architectures into cloud native architectures. What we do is we provide a common approach for defining applications and breaking them into those smaller and small pieces that not only works for cloud native architected applications but existing applications. So if you have applications that are critical to your business, but you're not gonna rewrite for five years and you want to be more efficient. Um This process of application definition can help you um gain a lot of those economies of scale and manageability um that you see the cloud native architectures without having to rewrite them. So application definition, this is really the process of defining everything that application needs to be built, run and managed uh then packaged into a single artifact. Um that's uh infrastructure independent and can be run anywhere and deployed on demand as part of a pipeline. But then we have a new challenge to consider as we mature this, we don't want to build black boxes boxes that, you know, we don't know where the dependencies are coming from or what are the transited dependencies or you know what, what version is actually running and who owns that version and updating it. What was the base os and security policies? And me, I know this is an area you talk to clients a lot about. Did you have any more insight here? Yeah, I think that, you know, really making it, making the process really clear about what your transitive dependencies are, where you're supposed to get your packages from. Uh what packages are approved for use within your environment and really a whole, you know, implementing a strategy around package management is very important. Uh So at the end of the day, whether you're creating and building a container or you're just deploying a regular application that might be more legacy. Uh these questions and the the whole um challenge of managing those packages, versioning deployment, et cetera remains the same. So it becomes very important as you're deploying to multiple different environments with legacy apps that might include certain layers that are more up to date and cloud native. Uh It's a lot to get your arms around. And what I hear a lot is really, you know, how do we approach that from a strategy perspective? Um How do you really incorporate um uh a a framework that enables and allows your developers to focus their time on development rather than you know, the actual build and deploy process? Yeah, great. And I mean, and that's exactly where um this kind of next generation of thinking around packaging strategy management comes into play where after we define the application and we've um created these atomic small pieces and we have single artifacts. We also um implement a strategy for tracking and managing those packages um so that we can um see what's in them, them and manage them better across the organization. And along that plane is the integration plane, right? You want also those packages to be consumable um across your DEV OPS tool chain um and other solutions. And by doing that, then we end up with a transparent package um that's easy to audit, um easy to manage and easy to update. And with that, then uh will turn it over to you who are gonna like take us through the demo show more of this. Yeah. So basically if we take this from left to right, generally, what you want to do is you want to be building an application package that is as skinny and minimal as you need it as it can be. You don't want to be including transitive dependencies. You won't be able to run that package in numerous different environments, potentially run that under a container format. And then once you produce your container, you want to make sure that the container is functional, that it's compliant and then that you can easily deploy it and understand that it's securely deployed and that there's no um security gaps exposed. And with that, I'm going to pivot over to the demo really quickly. So if we take a look at how chefs and the chef solution stack along with solutions like Pulumi enable this process. Uh Chef habitat really uh brings uh a mature uh capability to the package management layer. So what we're looking at here is an application. It's a tomcat application. Um It's a three tier application but really looking at the front end here and what we're uh defining here within habitat is the ability to say, OK, these are the uh layers that are required to build this application. So included in that would be um the build dependencies of obviously maven and corretto. And then in order to run this application, we need these layers, we need to, we need corretto and we need Mongo tools in order to connect into our Mongo DB back end. And so as you're going through and building the package with habitat, um it is only including the uh run time line libraries that it needs in the resulting package. So even though it's using all of these transitive dependent packages uh in order to build your TOCA application, it is not including those in the resulting package. What that means is you have a very uh small deployment application package um that has everything that it requires to run that application within any environment and within any platform, including container format. And you know, even though we only said, hey, we're using um Maven in order to build this application, you'll see that all of Maven in turn depends on all of these other packages and you have very clear visibility into what version of those packages is being used within this particular application. And then if you want to go through an update uh specific packages, you can, what this enables you to do is to build a very small skinny container. And a lot of um the container build approaches, you'll see that, you know, you'll typically start to install an application on an OS container like alpine or you know the base bunch container of the day. But what we're doing with the habitat is that a habitat application plan allows you to build an application container from scratch, which only contains these application libraries that are needed as well as the scratch OS. Uh It also allows you to specify an application service user. So, you know, from a compliance perspective, you did not want to run your application as root within the container. Uh You can specify that within your application uh habitat plan here. So you could change that package service user to root. And that is the uh users that we will use within the container itself. And uh bear in mind that this application um build process as well as the uh container build process can be leveraged as part of a of a pipeline. And then once that container itself is built, it's available to run within your environment. And typically what we recommend doing is if you're deploying to something like kubernetes, you can update your kubernetes manifest or your home chart. With this specific tag version, we will automatically export with this tag, but you can control the tag formatting. So what does this look like when you're running the actual application within your environment? Well, what this looks like is essentially if we pivot over to chef automate what habitat does is it also gives you visibility into what the deployment and run time status of your application is. And you know, one of the best practices is to always have a health check and status check within your application, which habitat can help you enforce. So not only now do you have a container that's running a very thin version of your application and the application libraries, but you also have operational visibility into whether or not that application was visible in its deployment. So you'll see here, I have um my application package that was deployed. This is my stable release at 7.0 0.8. And you'll see here on the right hand side, I deployed this to five different instances and they are all up and running correctly. Um If they were not deployed correctly, we would have a critical warning in here and you could easily fall back to the last known good package version or container. Um If we talk about on the security and compliance side, what chef brings to the table in this layer is really the ability to ensure that as you're deploying, that you're deploying in a compliant and a secure manner. And there are two aspects to this. One is essentially uh making sure that your containers are compliant to your security standards. So it's much more than just vulnerability scanning. It's really making sure that your runtime configurations for your containers as well as Cotti are secure and properly configured. And it doesn't matter if you're running any managed service in the cloud or if you're running um Docker hosts yourself or KTIS environments yourself. If you scroll down here, you'll see that a lot of the settings that we can automatically check for, they align to cis recommended best practices, but they're also really pragmatic. So if you think about, you know, where we defined a non root user as part of our habitat package and we have that ability, here's where we can enforce that using uh inspect. So as part of your pipeline, what you would do is you would run an inspect, check against your, your built container and you would ensure that that container does not have the setting to run the application as root, which is simply, you know, that's just best secure practices. There's other obvious ones like do not store secrets and darker files, but also install verified packages only. And if we link that back to habitat as well is how do you ensure that a package is verified? Well, with habitat you have your best packages that are part of your habitat origin and essentially you have visibility into which packages are used within which applications and how those map back into your images and you have portability there as well. So essentially you have visibility into all of these layers and it's reported into your compliance overview. Um There's you do not install unnecessary packages in the container. And if you look at this, a lot of these right here are just, you know, um within inspect itself, it's, you know, it could be a manual check. But if you build this into part of your pipeline, essentially, you make sure that you're secure and compliant across all of the different layers. Um Another item would be adding a health check instruction to the container image. So part of what we do with habitat is we automatically have that health check included as part of your application build. That's what gives do visibility into the applications tab here in our chef automate layer. So we bring all of these capabilities over to the CNET side as well. So as you're running your KTIS environments, we can similarly check uh that your pods and your name spaces are running in a secure manner that they are not open to the world that you have a correct traffic uh configuration um configured on your KTIS clusters. So it's really very pragmatic from left to right, really end to end security and compliance for not only darker containers or containers in general but also just running application packages. And I also want to mention one last thing before we finish the demo, which is this capability is amazing. You can also bring this capability to off the shelf and legacy applications. I want to highlight that. So you know, as you go through your uh habitat application definition, your plan definition, you can actually simply without even building the application, copy your binary into um the habitat package and leverage the same deploy and in several mechanisms as well as all of the compliance and security that comes with that uh for those off the shelf, as well as legacy applications. So that's it for the demo Heather back to you and we can wrap up. Uh Thank you. Well, we hope uh you enjoyed our lightning session on how chef helps uh navigate the high seas. Uh with that, we hope uh to see you uh virtually during the rest of the event and please feel free to uh reach out with us to us with any additional questions. Thanks Heather. Thank you very much. Bye.

---
