---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Cloud Engineering Summit 2021: How AWS architects APIs for hyper scale"
title: "Cloud Engineering Summit 2021: How AWS architects APIs..."
meta_desc: |
    With AWS Cloud Control API, AWS introduced standardized APIs with the goal of solving support for the latest AWS innovation through a resource-orie...
url_slug: cloud-engineering-summit-2021-how-aws-architects-apis-hyper-scale
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Cloud Engineering Summit 2021: How AWS architects APIs for hyper scale"
  description: |
    With AWS Cloud Control API, AWS introduced standardized APIs with the goal of solving support for the latest AWS innovation through a resource-oriented model, typically available on the day of launch. In this session, we will introduce how we took Cloud Control API from concept to launch, the culture and technical changes instituted internally to launch Cloud Control API, and the importance of engaging with partners and customers early in defining the product, user experience, and development.  Talk by: Rahul Sharma
  sortable_date: 2021-10-20T23:01:17Z
  youtube_url: https://www.youtube.com/embed/esbXQIOqifI
transcript: |
    Good morning. Good afternoon everyone. I'm Rahul Sharma and I'm a senior product manager at Aws. I'm really excited to be here with everyone at the Pulumi Cloud Engineering Summit and I'm excited to present to you all a new Aws service that we recently announced AWS Cloud Control API. As we outlined in the abstract, I'll introduce AWS cloud control API. In today's presentation, talk about how we conceptualized the product architected it for scale and launched in collaboration with partners like Pulumi. So without much of you, let's get straight into it. I'll start off the talk with a background on cloud control API S Genesis. Then introduce to you all what is cloud control API and how it benefits users then walk you through the journey of building cloud control API from concept to roll out at scale. Then present a demo on using cloud control API and conclude the presentation with resources to get you started. So let's dive straight into it before I begin the background story of cloud control API. I want to take note of the sequence behind our product development at AWS. We work backwards from our customers. Hear their feedback, identify a solution and then build our products, cloud control API followed the same sequence. It was no way different. In case of cloud control API, there are in fact two types of customers for whom we were building this first builders or developers who are the end users that build application infrastructure, manage and monitor them. And the second set of customers were AWS partner network or the A PN partners such as Pulumi who build on AWS, expose their solutions be it infrastructure as code in case of Pulumi configuration management, cloud security portion management, among others to end users, we identified three opportunities to help these customer personas. So what were these opportunities? The first one corresponded to builders who use partner solutions. We heard from these builders and who are AWS customers that use partner solutions to specifically build and manage the cloud infrastructure that they want to accelerate their pace of innovation and time to market for their applications. For example, there are situations where there's a lag between supporting a new Aws release in A PN partner solutions. For instance, if say an Amazon memory DB resource is unsupported in a partner solution, then customers using that partner tool will need to wait for it, support for it to support before they can start using those in memory database services. The open question for us was can we help these customers adopt new AWS features and services in the form of cloud resources closer to their launch. That was the first opportunity that we had. The second corresponded to Aws partners. As you are aware, Aws continues to innovate on behalf of its customers to help them unlock new capabilities on cloud. For example, we today support over 200 plus fully featured services. And in 2020 alone, we launched over 2700 significant new features. Aws partners want to stay in sync with our pace of innovation and we learned that it can often take a few weeks to integrate with and expose each new Aws capability nationally. Our question was, can we automate supporting new capabilities on behalf of partners through a one time integration? Can we have some sort of a unified interface that allows partners to integrate once and benefit from getting support for the latest Aws innovation? So that was the second opportunity. The third opportunity, which is finally what we recognize is that we have an opportunity to standardize the API S that interact with all these features and services or latest Aws innovation we are talking about and you may wonder why as applications become increasingly sophisticated, developers and builders tend to work across several Aws and in some cases, third party services as well by using distinct service specific API S. While these API S are descriptive and intuitive, some developers prefer a consistent set of API S to manage cloud resources across various services. For example, to define an Amazon K stream as you can see in this example for a data streaming application, I would use a variety of API such as a create stream API to define stream name char count to add um attach to stream API to add, attached to the stream or even like using the increased stream retention period to define the retention period at a later time. For getting details of the stream resources I would use describe stream similarly to create a Lambda function. I would I would use a create function and get function to API S to get the details. One of the most common use cases further that we have heard is around identifying and deleting legacy resources that were created by customers for the purpose of testing outside and these resources were created outside the management of infrastructure code solutions. What we heard from our from from these customers is that they want a programmatic way to identify these resources that were created outside the management of infrastructure code solutions, cross reference them against existing resources which are managed through these solutions and then delete them in order to like simplify the way they manage their costs from maintaining these resources. This was possible this could be possible in a programmatic way through a consistent set of APIS right, such consistent API S will help these users avoid authoring and maintaining custom code to discover and delete each type of resource. So we we national question that came to us was can we uh expose a consistent API method to interact with hundreds of Aws services and beyond. So that's what led to the birth of cloud control API. But to summarize the three opportunities that lay in front of us, were, can we support new AWS features and services in the form of resources closer to launch? Second, can we help a PN partners automate their integration with the latest AWS capabilities? And finally, can we standardize API S to interact with hundreds of Aws services? And in fact, third party services as well, these opportunities led led to the foundation for building cloud control API. So what is cloud control API, cloud control API is essentially a set of common API S that is designed to make it easy for builders and developers to manage their cloud infrastructure consistently and leverage the latest AWS capabilities faster. Typically on the day of launch, it introduces consistent API S to manage the end to end life cycle of Aws resources and third party resources as well. Uh which, which ranges from creating a resource updating, updating it, reading the state of the resource deleting and listing right now with these create read update, delete and list resource. And in this case, we actually call our read resources, get resource API, you can use the same set of API S to perform the end to end life cycle management for beer. And Amazon can use a stream, a lambda function, a cloud watch log group, an ECs cluster or even third party resources such as data dog monitor Mogo Atlas clusters among among others. All right. And you may wonder while these consistent API S helps address the opportunity. Number three, which we highlighted on consistency. How does it really address the first two opportunity areas that we identified? Right, which is accessing the latest AWS innovation faster and providing a unified interface to integrate ones and benefit from all latest innovation. I'll get straight to it right away. So first and foremost is how does cloud control API enable faster access, cloud control API uses the cloud formation registry to expose resources built by AWS service teams and third parties to integrating partners and their customers, right? For new AWS services and features, these are available typically closer to the day of launch. So any builder or developer using a partner tool that's integrated with cloud control API can now benefit from faster access to the latest Aws innovation and they these builders can also be using these API S directly next unified interface with with these U consistent API works that are exposed. Partners can now build a unique API code base using these unified API words, common input parameters to integrate once and expose the latest AWS features as resources you can imagine to control API as an adapter layer on top of all the underlying services that are supported and all partners now need to do is integrate with cloud control API and get the latest AWS resources as and when they are supported by cloud control API, typically closer to the day of launch partners. Now don't have to integrate with each new Aws service or feature themselves, right? So that's one of the other benefits of cloud control API. One time integration is needed to keep up with AWS S pace of innovation. And then finally, the thing we start to touch upon is consistent crowd plus list interface that is designed to make it easy to manage cloud cloud infrastructure consistently. Whether it be it an ECs cluster can stream LAMBDA function or hundreds of other AWS resources or over a dozen third party resources, you can use the same card API S to manage them end to end. So now while you are aware of what cloud control API is and how it addresses the opportunity areas we identified, you may naturally wonder how was this built from concept to rollout at scale in the next few minutes. And in my present presentation, I'll walk you through the steps we undertook for the end to end rollout. So let's get straight into it. As you're aware, each product launch begins with ideation. And so was ours, the customer and partner feedback was something we heard ourselves uh as AWS cloud formation from, from our direct users to address the feedback of faster coverage. We at cloud formation undertook a journey starting in 2018 where we switched our internal coverage model from an older and more tightly coupled implementation to a self service mechanism. What do I mean by that? It essentially means that we allowed or enabled individual service teams at AWS to build coverage in a decoupled way to ensure resource support is available faster. We further externalized it reinvent in 2019 with the launch of cloud formation registry and the cli with the registry being a place to discover and consume resource types and cli being an open source client that lets developers and internal teams build these extensions. This was the ideation, right? Like the idea started with the coverage uh the the coverage opportunity that needed to be solved, right? Like how can we help our customers get faster, faster resource support or faster access to the latest Aws innovation? Now, while we lay the foundation through registry, we realized we can, it's it cloud formation is not the only uh is it cloud formation can be the can be one step forward in terms of helping the rest of the partners in Aws partner community or other AWS partner network to to to to help solve coverage in a scalable manner, right? So we realized we can solve this resource coverage problem for customers who are not just using cloud formation but also using partner tools such as infrastructures code, cloud configuration management and cloud security portion management among others. But the question was how do we do that right cloud formation can be thought of as essentially three pillars, right, like three layers rather the resource provider layer for AWS or the deployment and orchestration engine that offers various managed experiences on top which is layer number two. The third being the syntax for specifying desired state of a resource by cloud formation templates. Our concept here was to externalize the resource provider layer for hundreds of AWS resources across several services. And in doing so, we also wanted to address the opportunity of standardizing control plane api interactions for all these hundreds of Aws resources. So that's where the concept began, right? Let's just externalize the resource provider layer and get the partners and builders start building and accessing the latest Aws innovation faster. While we had the concept ready, we wanted to like have early validation to test our concept. Early enough, we gathered feedback from Pulumi among other Aws partners, internal Aws teams and our customers early feedback on the concept lay the roots for designing the product for scale these discussions, informed API design and the concept. So once we had these early discussions and meetings uh for the validation phase, we moved on to designing this product for scale. How did we do this? We did this by beginning not in the start like forecasting demand, right? Like estimating adoption at scale and usage for customer at scale. Once we forecasted demand, it was it was critical for us to architect systems to support such demand forecasts. For example, designing the components that can support traffic from all the regions we intend to support based on our demand, right? And then finally, while we were designing these systems, it was, it was critical for us to keep certain tenets in mind like safety and security along with scale and standardization were some of the some of the core tenets we had in mind while designing cloud control API and the system right now. Once the design was ready, uh what followed next was the product development piece. Uh And to test the product development in its early days, we released the private data uh for cloud control API and gathered deeper feedback from Pulumi and other partners and even customers on areas such as coverage the API interface. Uh And if there was a need for a console or not, right, our acceptance criteria was to satisfy or rather address the feedback, the critical feedback ahead of rolling this out at scale and making the product generally available. When we rolled out, we, we rolled out uh the product after prioritizing the feedback that we heard from all our external stakeholders including Pulumi. And uh there are three areas as I mentioned for feedback, resource coverage API design as well as console, whether this was needed or not. For as far as coverage is concerned, we actually prioritize the support of resources to move from the older and tightly coupled uh mechanism. Which I talked to you about to a self service mechanism on cloud formation registry into a registry based model. And we we ported some of the resources over to have those supported on cloud control API S such as LAMBDA function, A AWS lambda function, AWS API gateway stage among others. Right. Similarly, we we also made few, few, few uh feed, we incorporate feedback on the API interface as well. We designed for, we updated our, our update resources API by incorporating feedback on implementing standard RFC 6902 JSON patch operations for update resource API, which I'm going to show in your in the demo as well the way the patch operations work and of course testing this out for scale, right? And and then finally, as part of our launch announcement, we throughout the journey, we continue to invest towards increasing Aws resource type support, right? Like uh and we launched this product on uh September 30th. And we continue to invest towards increasing support for AWS resources on cloud control A P. And we'll have many more resource types in the coming months, including those from Amazon EC2 and Amazon S3 services among others, Pulumi collaborated with AWS on integrating with cloud control API via the Pulumi Aws native provider. And you can now access the latest AWS features and services on the same day as it is supported on cloud control API. This includes hundreds of AWS resources and even third party resources and by building on the by building on Aws cloud control API the AWS native provider built by Pulumi. And currently in preview, as most of you would know, exposes the unified resource model for AWS built by service teams by leveraging the Aws cloud control API. The AWS need a provider for Pulumi builds on the work done by service teams at AWS to define the resource model for their services. So I'm sure by now you must be excited to see what these API S really are. What does consistency mean? Right. So I'm gonna switch over my screen to the terminal to demo uh cloud control API and its consistency. I will do that by showcasing the create update lead and list operations across three supported resources, uh stream, Cloudwatch Law group and ECs cluster. And I'm going to also showcase the case of identifying other discovering resources that were managed outside or other created outside of cloud control API and how you can actually manage them using these APIS altogether. So before I start my demo, I am going to first showcase the desired state files associated with the 3D sources. I talked to you about AWS cloud watch law group, Amazon K stream as well as uh a Amazon E ECs cluster, right? These desired state file consists of the resource configuration or all the properties that I have associated with my resource in a JSON file. So in this case, I'm gonna first showcase to you what are the kind of properties that I'm defining for each of these resources, right? And then go through the terminal to showcase the consistency of create read update, delete and list calls across these three resources. So let's get straight into it. So as you see in the screen, uh you're seeing a desired state file for a Cloudwatch log group. As you're aware, uh cloud, an AWS cloudwatch log group is a group of log streams that share the same retention monitoring and access control setting. And a log stream is a sequence of log events that share the same source, right? In this specific configuration file, I have specified the log group name as my demo logs and also specified the retention days which is the number of days. In this case, 90 for which I have, I want the log even to be retained in this specific log group. Similarly, let's go to the desired state file associated with the Amazon Kiri stream. And as you are aware, an Amazon Kiri stream captures and transports data records that are continuously emitted from different data sources or producers short count as well as the retention period, which is the length of time. Data records are accessible after they're added to the stream. In this case, if you look at my configuration, I have specified the name of the KS stream specify the retention period hours. In which case it's 1 68 or 71 68 hours or seven days. And the char count, which is three in our case. And then finally, I have also specified the configuration associated with an Amazon ECs cluster. I have specified the name of the cluster, the cluster settings which specify container insights which collects metrics at the cluster task and service levels on both Linux and windows server instances and the tabs associated with the S cluster. So these are all the desired state files. And now I'm going to configure these resources using cloud control API read the state of those resources, list them update by either replacing a certain property or adding new properties in and deleting them. So let's get straight into the demo part of it. So I'm going to switch over to my terminal. Uh This is just an active directory of mine where I've listed all these files that exist. All these are desired state JSON files. I'm gonna clear this and let me get started with creating the cloud Watch Law group. So to create the cloud was Law group, I am going to specify the cloud controls, create resource command. In this case, I'm going to specify the resource type name, cloud watch log group and pass in the desired state file in this case because the state file exists in my active directory. I can use the path as mentioned here, but I can also specify the same using a JSON blob which consists of the desired state. So once I hit enter, you would see that progress event is returned which showcases that this operation is in progress and also returns a request token. I can quickly identify the progress of this specific operation. So I'm going to use an auxiliary API of cloud control called get resource request status, copy the request token here and see whether this was operational successful or not. And as you see this operation was successful, that means that the Cloud Watch law group is successfully created. How do I check for that? I can list all the resources or identify them in my account and region. So I'm gonna use the list resources called to list all the cloud host log groups in my accounts in this region. I just specify the resource type name and I'm going to get an output consisting of the identifier. In this case, my demo logs as I had created properties, which is the retention days that are specified as 90 log group name as well as the Amazon resource name or the R that gets output as part of this call. Now, if I want to update any property for this resource type, for example, if I want to change the 90 retention days to 1 80 all I now need to do is use the update resource API call, specify the type name and the identifier and pass in the new or rather the patch document, right? Like what is the operation change. Once I specify the identifier, all I need to do is pass in the patch because it's an asynchronous code, this will return a progress event. And you see that I've updated the retention base from 90 to 180. And I can show you how the patch operation is on my text editor. So in this case, you see my Cloudwatch law groups patch document which consists of the operation as replaced. And the path basically points to the property that needs to be updated in this case, retention days and the value to be 180 right. So going back to the terminal, uh let's see what is the status of this request. Uh In fact, before assuming this is successfully created, I can just read the state of the resource so I can use the read call or the get resources, call for cloud control, specify the type name and the identifier which I've pitched from the list call and read the state of the resource type. And you see the property has been updated right from retention days of 90 it's moved to 180. You see all the other details which were configured and the Amazon resource name associated with this resource. You can also delete this by calling the cloud watch law group type name, specify the identifier and the resource and the API call associated with delete resource enter next and you see again a progress event is passed. So as you are seeing here for create update and delete operations, these are asynchronous calls and for read and list. Those are synchronous. You get those responses immediately. Here, I can either use the get resource request status or the, the which is auxiliary A P or I can do a simple list call to see whether this resource exists anymore or not. And we should expect a value which is rightfully so because the resource is deleted. So there are no more resources available right now. This is the flow from create update, read, delete and list, right? Just for cloud law group to showcase the consistency. I'm going to use the same set of API S same sort of input parameters to create and instantiate an Amazon can stream resource. So let's get straight into it. So to do that, I am going to use the cloud control API S create resource call and pass in the resource type name and the desired state file. So I'm going to use this API call as you saw it very similar to the Cloudwatch log group, create resource, same API word, same type name, uh sorry type name is different. It's K history, but desired state file is what we saw in the configuration state, same input parameters. And in asynchronous call, you see that the operation is in progress. To see whether this was successfully created or not, you can uh easily check by calling the get resource request status or the auxiliary API. And let's do that as we speak. We have the request token here returned from this call. Let's pass that in. And let's see the, and you see. Well, yes, the operation was successful. So bingo, our Kinsa stream is now ready and created. And now you can list this kneer stream in my resource by calling the list resources API just specify the stream type name and you will get the result, you'll get the identifier. In this case, the identifier is my demo stream. Now, one thing that you would notice is that the properties are different. In this case, you only get the identifier. Whereas for cloud group, you got the properties as well. And that's simply because um in case of Cloudwatch Law group, uh there isn't a list API call. So the permissions for list goes to the prescribed streams call, which returns all the response parameters, right? So you see this here and now if I want to update, suppose I want to update my kinesis stream and add tags to them, right? I'm going to use the same update resource call, same input parameters type name uh and pass in the patch document. I will show you quickly what the patch document is in our case. But in the interim, I am going to invoke the call and let the progress events pass in and I'm going to showcase to you what the patch document is in this case, it's not replacing any existing property, but it's actually adding uh the property associated with tags for K stream. I have specified the property value as tags, operation as addition and the value, key value pairs associated with the tag specified the key as environment and value as development. And let's see the operation status on where we stand, we see the operation status is in progress and that you're adding these tags. Let's use the get resources or the read call to read the state of this stream resource. You have the, you have the identifier past and now you see that the properties returned are the Amazon resource name, the retention period hours that are specified as 1 68 the tags as well as the short count, right? And now you can also delete this KSA stream using the delete resource API call, same consistent input parameters, passing the type name identifier. You get an asynchronous call to check. You can use either the auxiliary uh API which is the get resource request status. So you can also use the list call in this for the purpose of this demo. I'm going to use the list resources to see whether this exists, this resource exists or not and rightfully so this resource is deleted. So now you don't see any identifier associated. So that's where Keynes is, right? As you noticed the create read of data, delete and list A PS remain the same, the input parameters remain the same. And that showcases the consistency of cloud control A P. I'm going to just showcase one other resource type. In this case, I'm going to use the Amazon ECs cluster and I'm going to use the create resource call, specify the type name and the desired state file. You see that it returns the familiar progress event that we talked about and I can see whether this request was successful or create request was successful or not by passing in the request status. And you see that the operation is successful. That means this ECs cluster has been spun up and to list this ECs cluster, I again call the list resources or API specify the type name and get the result. In this case, the identifier as well as all the properties associated with it, right? Like you see these properties are null because they did not specify that in my desired state file. I just specify the cluster name, the Amazon resource name the tags as well as the container insight cluster settings, right? I can also read the state of the ECs cluster resource type by calling the read resource or the get resource. Uh You specify the type name, same process, you get the details out. And also you can delete your resource by passing in the AWS lead resource scout control, delete resource api and the identifier associated with this ECs cluster. Familiar progress event and you can quickly check either using the get resource request status or list resources for this time. I'm going to actually use the get resource request status and, and, and show you the, the show you that experience as well. So I'm gonna take the request token, pass it here and we see that the operation was successful. That means this delete is successful. So when I call the list resources, I should get a null value, which is rightfully. So as you see resource description is null. So with this, what I'm trying to showcase here is that these create read update, delete and list calls remain consistent for all the supported aws and third party resources, which are over hundreds of aws resources that are supported today on cloud control API as well as over a dozen third party resources. All of them, their entire life cycle end to end can be managed using cloud control API S consistent set of API S that we have exposed is right. So with this, I'm gonna conclude the demo and I am going to uh showcase to you how you can get started. I'm really excited for everyone here who is listening in to get started building on cloud control API as well as start using the Pulumi Aws native provider, which is built on top of cloud control API. So with this, I'm going to switch over to my presentation and share some of the resources to get you started building. So let's do that to learn more about the product, how it works. And the FA Q SI would point you to the product page of cloud control API, aws do Amazon dot com slash cloud control API. And at the same time for you to get started using the plume aws native provider, which is built on top of the cloud control API to leverage the latest aws innovation. I would point you to the great blog written on how to get yourself started using the Pulumi Aws native provider. By following this link, we can't wait to get you started on the cloud control API journey. Thank you all so much for your time and giving us the opportunity to present this product. Talk to you about how we took this from concept to roll out at scale and also the Pulumi Aws new provider, which is built on top of cloud control API. Thank you everyone.
---
