---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Ep 013: Building Reusable Infrastructure Components"
title: "Ep 013: Building Reusable Infrastructure Components"
meta_desc: |
    In this episode Luke walks through building components with Pulumi that can be shared and reused to create cloud native infrastructure as code
url_slug: ep-013-building-reusable-infrastructure-components
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Ep 013: Building Reusable Infrastructure Components"
  description: |
    In this episode Luke walks through building components with Pulumi that can be shared and reused to create cloud native infrastructure as code
  sortable_date: 2018-10-10T22:03:31Z
  youtube_url: https://www.youtube.com/embed/SgiP9d1oLs4
transcript: |
    All right, welcome back everyone to this week's episode of Pulumi TV. My name is Lou Coin, uh CTO at Pulumi. And today I'm gonna be talking about uh building components uh with Pulumi for infrastructure. So we've talked uh you know, in previous weeks, we've talked a lot about how we can uh you know, program the cloud with Pulumi, how we can use some of the core capabilities of program languages uh to work with containers, servers, infrastructure, and KTIS. And this really helps us to uh take a higher level view um of how we can build uh put together applications built out of these building blocks now because Pulumi takes the approach of using program languages instead of just mark up like Yaml or, or Jason or something like that. Um We have the ability to use many of the tools and get many of the benefits that application developers get when they uh work with program languages to build application code. And we're able to bring those to the infrastructure space as well. And there's many benefits that you get from this. So you get things like uh the ability to have type checking for instance, the ability to have rich tools and, and, and, and ID E. Um and most importantly though, is the ability to sort of create new kinds of abstractions when you think about what programming languages are really, you know, best used for and where, where they bring the most uh impact, really a lot of it comes down to the ability to sort of create reusable abstractions. Um And so if you think about kind of the days before programming languages when people were, you know, typing in assembly or something like that in their computers, uh And you'd be working at a very low level of abstraction, you had all the tools that you needed to program a computer. Um What you were missing was the ability to easily create reusable functions, reusable components uh that could express some subset of logic and then let you reuse that in other contexts and this sounds like a really simple thing. Um But it really leads to once you have this ability to really simply and easily create re usable abstractions and components, it lets people build libraries in higher level uh abstract these kind of richer uh more abstracted components on top of the raw building blocks. And so really what Pulumi is sort of uh at its core is doing is bringing all those tools to create those kinds of new abstractions to developers. And we see that being used for two purposes, one to sort of build some of these standard libraries on top of the core underlying building blocks of the infrastructure providers from the cloud providers and Kubernetes. And second is to enable you inside kind of an organization to define your own kind of components that describe things that fit to your um production environment and that express the sort of uh pattern that you want to use and stamp out throughout your organization. And so today, I kind of want to go and do a little bit of a deep dive into how you build these reusable kind of components with Pulumi. Uh and what it's like to uh kind of uh build those and use those and some of the benefits that you get from having access to these sorts of components. All right. So let me dive in and I'll just gonna go straight into the code actually, before I go into code, I wanted to show uh one quick thing. And if you've visited Pulumi dot com, uh recently, we actually yesterday um uh push some updates which to update some of the UI here. And one of the things we have is a new creative project button. So a lot of more status about what's going on. Um But we have this new creative project button which is a really easy way to get started. Um If you're new to Pulumi and want to jump in and want to start using it to, to work with Aws or with Azure or GCP or whatever it is you want to interact with, you can jump right in here, um Click on these buttons and create a new project. So I actually already uh did this, created a simple project. And so I'm just gonna jump over into that project that I have open inside my editor right here. OK. So, uh let's do a quick kind of tour of, of some simple uh uh Pulumi building blocks and then how we get from there into kind of building our own uh components using those building blocks. So I can start off just sort of doing the kind of normal thing I might do. So let's say I want to just create a S3 bucket. Uh So I'm gonna say new Aws dot s3 dot bucket, you see here, the nice ability to sort of get intelligent and completion list that I get from using a real language. Um But let me just call this my bucket and we see this is a normal resource. So as well as me passing a name, I can also kind of pass in some arguments here. So for example, maybe I want to say I want to in version it on, I say they is true. Yeah. Uh So I can pass some arguments to my bucket uh just like I might hear as well. Um And this I can do for any of the resources exposed by Pulumi. So Pulumi has access to sort of every one of the resources that are available at Aws and Azure and GCP and uh and a variety of other cloud platforms. And in Cotti and I can access them all um using these sorts of constructors like Aws 0.3 dot bucket. And if I go to definition on one of these, we'll actually see if I scroll kind of all the way back up that this is a class bucket which extends Pulumi dot custom resource. So one of the kinds of resources that we have in Pulumi are these custom resources which are resources defined by an implementation out in some other provider somewhere. So in this case, in Aws, but there's another kind of resource that I have as well that you'll probably often see if you're working with Pulumi and that's a component. And so components are ways to sort of create what looks like the same kind of resource, but as sort of a virtual resource that is actually made up of lots of other pieces. And so for example, with AWS, uh you know, there's a concept of a VPC but uh a VPC is actually made up of many more granular building blocks. And so when I want to actually stand up a full VPC that has all the subnets and configuration that I want, I actually need to stand up of a dozen or so different aws resources. And so I might want to do that instead by just creating um a component. And so in this case, I'll call it my network. Um And I can similarly pass some options to this. So I'll say a number of availability zones too and use private subnets uh to stay true. Um OK. So this is uh similar, it looks the same as a S S3 bucket, it's just a S info dot network. Um But in this case, this is actually uh going to be a component resource. Uh So instead of a custom resource, this is a component research and we'll get into the difference that that makes in just a second. Um But the key is that to the user, these things they can use almost entirely the same. Um But this a Infra network is actually made up of a few building blocks. So let me come in here and I'll just do a simple Pulumi preview uh to see what this looks like to scroll up for a second. OK. So you see when I preview this uh a couple of things. So one that a S S3 bucket we see there uh just like I'd expect is a normal resource that I'm going to create. But this network has this interesting ability to actually be a new node by itself. So this a Infra network is a node in my tree. And then all of the things that are part of it are nested inside there. And so this gives me an easy way to understand that these are all related to this network. They aren't just a bunch of resources that I'm gonna use. They're all implementation details of the A Infra network. And that means I don't have to always worry about all these, I can trust that the person who designed his network implemented it correctly um that they implemented it to satisfy the sort of contract that was provided here and that I can then go and use this like I would any other resource and let that component author take care of the implementation details and I can take this further and do things like uh you know, cluster equals new Eks dot cluster. I just my list here. And this uh Eks cluster is actually a library that we built uh Pulumi Eks which makes it really easy to stand up an Eks cluster uh um uh an elastic cluster inside AWS. And so this thing has a bunch of parameters on it. So I can say sort of VPC ID is my network dot VPC ID and my submits on my network. So I bet that is. And now I could come down here and again, do a Pulumi preview. And this time, we'll actually see a lot more stuff. Um because the CKs cluster actually turns out to stand up an EKS cluster in uh in AWS requires a lot of different resources. Um And so here we see the Eks cluster has inside it other components. So the service role components which themselves have some Children. It has a Kubernetes Yao config group, which is a package of YAML uh of kubernetes YAML configuration to deploy a dashboard, uh the kubernetes dashboard and then a variety of other resources that it needs to correctly stand this up, both AWS resources and uh kubernetes resources. And so this gives you a sense that you know, you can, these components can actually be nested. So like the service role is nested within the cluster and they can be fairly complex components which have very simple API S. And that's really the key, you know, benefit that users get from these is they don't have to think about all those details. They can think about this API in terms of this higher level notion of just these handful of properties that are available to configure this component. OK. So, so that's a, a sense of kind of what we can do with some of these sorts of uh components inside um Pulumi, but let's go back to something simpler and see what it looks like to actually create uh one of these components ourselves. And so I'm gonna start by creating a really simple example here. Uh And what I'll do is let's just keep it really simple and we'll just pass uh let's create a new bucket and then as well as creating a bucket, I'm gonna do a little bit of extra work here. I'm gonna um I'm gonna do a four loop over a folder on my local disk. And I'm gonna create objects in this bucket in S3 for every one of those uh files. So I can say like let files equals, let me star as from, I'm just gonna import a couple of libraries and that I would want to use. And so I'll say FS dot um readers sync and I'll grab the doc slash files directory and I'll say for that file of files and inside here will uh or create an object. OK? So a bucket object is just gonna store an object inside a bucket. And so I'll call this bucket object file and then I'll pass the bucket is gonna be the bucket I created above. So we're gonna put it in, in that bucket and then the content will be FS dot Read file, sync, path dot join back slash files, file. And then we'll just two string this. OK? So there we go uh really simple uh program here. That's gonna create a bucket and then for every file in my files folder and I'll just open that up here. Uh I have this files folder here with a, with two files in it, index at html and data dot txt. Uh And so I'm gonna, for every one of those files, I'll just create a bucket object. And this lets me kind of keep a folder on my local disc. That's part of my project in sync with the S3 bucket handy way to just make sure that I've got some files in S3 every time I run a deployment uh from this uh folder. And so let, let me come back here and do that Pulumi preview again and we'll see what it looks like when I just run this as uh some flat out some straight up uh regular Pulumi coat. So we see kind of as we expect this is going to create an S3 bucket, it's going to create a bucket and two bucket objects, index HTL and data dot TXT. OK. So this is just a normal uh Pulumi program. So what I might want to do is sort of make this into a reusable thing. Uh I might want to use this for a handful of different folders, so I may want to use it across several projects that I have. And so I can kind of walk through kind of how we can bring typescript and in the javascript and, and the programming language to bear on that kind of problem. Uh So the first thing we can do is just create a function. So um create three folder, uh maybe I'll say folder string and we'll have this guy return the aws S through Buck. OK. So we're going to create a simple function here and we'll just take that code we wrote before, put it in there and then instead of files, we'll just pass folder and then finally, uh we'll return that bucket. OK? So now we can do create S3 folder and we can pass that slash files here. OK? So this is more or less the same code as before. But now we've just taken this and put it in a function. This means we can sort of do something simple like you know, describes three buck. OK. So simple, uh simple kind of thing, we can document this, we can sort of do what we would is with normal sort of code. Uh And with this component now, the key thing is here that we're, we're creating these functions and sort of uh the ability to have reusable uh abstractions and API S here like this function, but we're doing it to create infrastructure. And so if I run this again, we'll see sort of Pulumi preview and we'll see that this now stamps out uh this uh this sort of thing. OK? I, and so I could use this sort of multiple times I could do, you know, do whatever I want to kind of reuse this and, and keep this as a function. But there's a couple of things that are sort of maybe not uh entirely ideal about this. So one is we don't get one of these nodes of resources at top level. And the other thing is that I don't sort of get a nice API to this. I'm sort of, it's very ad hoc and that's gonna be beneficial. I can sort of write any kind of code I want with a function like this. Um But I don't get a nice consistent API that feels the same as it feels like to use other resources. And so we can do to address that is actually to create our own uh component resource now to create our own component which Pulumi actually natively understands. And so let's take this function and actually move it over to be a true component. So what I can do is I can say I'm going to make this the S3 folder class. What I'm gonna do is say it extends Pulumi dot component resource. It's a Pulumi dot component resource. You can see you can go to definition and read kind of about uh what this thing does. Um But it's just a kind of resource. So as I mentioned earlier, there's really two kinds of resources, custom resources and component resources. When I have one of these, what I wanna do is create its constructor. So what is it going to mean to create one of these things? Uh And it's, I'm gonna need to pass a few pieces of information. So I'm gonna need to know what name to give to this component. So that's gonna be the name that appears in this column here. And then I'm gonna need to know the arts. And so I'm gonna skip that for now and we'll, we'll fill in, in detail, what that should be in a second. And then lastly, I'm gonna take some options. Um And this is the options. Let me configure how the resource is going to be created. And these are things that Pulumi kind of deeply understands and I'll, I'll talk in more detail about uh about these in a second. But you see we actually have an interface called Pulumi component resource options. And so you can take that as an optional uh last parameter. Now, we have to call uh the super class constructor and this requires most of the same stuff. But one key additional piece of information is the type. And so again, that's this is gonna be what she displays down here. Um And so in this case, we're gonna call this just as three folder, we'll pass the name and we'll pass the art and we'll pass the arts. OK? So there's the simplest possible component that we can create just uh creates a folder. And in fact, if we come down here now and say uh we just do this and now we do Pulumi preview, we should see that we'll actually get a um a folder resource in the graph. Um It just won't have any Children yet. Uh So we see we get this S3 folder um which is just a virtual resource for this component. Um But it doesn't yet have any Children inside it. OK? So let's go ahead and move that code we used before and we'll put that inside uh inside here and actually just get rid of this code for that. OK? So we're gonna take that same code and we're gonna use it to construct the resources within here. Um But there's a couple of things. So one this folder that we passed in before now, what we might want to do now is actually just pass that as the arguments. And so I'll just create a simple interface here called S3 folder A and it's gonna have a folder as a string on top of it. So now we'll just type a dot folder dot folder and here now we'll pass. OK. There we go. So now we've defined sort of a nice interface to our um arts. Now I have to find a nice interface to our uh um to our API and because we're using a type language, for example, now we, if we mistype this, we get that same error reporting, all the same nice benefits we had before the past 12. Here I get an error um that sort of thing. But uh but now I can have room for expanding this to accept additional arguments and additional uh um uh inputs here. Um And so I can take, you know, not just the folder, but I could specify that I want to turn on versioning for the bucket or any other parameters I want to expose to users of, of this component. OK. Uh But other than that, this code was exactly the same. And so now I can run my Pulumi preview one more time. We'll see this time, uh that although we removed the other line and are now just using the S3 folder to create this, we do still see the bucket and bucket objects getting created. So they're now getting created by this component, but we don't see the sort of thing we expected, which is that the folder is not the parent of these resources. Um And so we don't have this sort of nesting and an ability to understand that these are associated with that S3 folder. And the reason for that is that to actually indicate that a resource that gets created is, is is owned by a particular component. We need to pass one additional thing uh which is we need to pass terent colon. Um So what this says is that uh when this resource is created, its parent will be the resource, the component here that is being used to construct this and we can actually set the parents to any other resource and that will create this the bucket objects of child. Now, if I come over here and do Pulumi preview, we should see that those actually are nested underneath. OK. So now we've successfully got those resources nested underneath and they have their parents set to uh set through this component. OK. So that helps for the nesting um but we also may want to expose some of the details of this to our users. And so in this case, we know we're creating a couple of things, the bucket and all the objects. So let's uh make sure that we have a property on this, um which is the bucket and the property which is the um which is the objects. So we'll have an array of those and we'll have a bucket. And so these are just gonna be properties I can set, push, OK? And just to make sure I'm gonna say this dot objects equals an empty rate. OK? So now we actually can see that uh the, the component that we have as a programmer when we're writing our Pulumi code now actually gets access to that bucket and that object since that means we could come down here and say three folder dot bucket and we could do other things with this bucket, like we could put additional objects in here or we could uh use it as the logging source for logging destination for some other bucket, whatever we want to do. And we have access to the underlying building box. And this is really important because it means that I can now compose this with other parts of my infrastructure. I don't, my abstraction is not entirely a black box. I can actually see the individual pieces inside and use those uh as part of my application. OK? So, so that was building a simple component uh using um and exposing some of the resources. And so one of the nice things about this is I can now come in and I won't go ahead and type all these, but I can now go ahead and document each of these, you know, um properties on the resource. I can document the class itself and the component um and I can document, you know each of these inputs. So I have this sort of rich ability to use all the sort of techniques I might for structuring and documenting and, and typing and getting that rich typing for components and, and classes inside a programming language for application development. It can bring those into this realm of, of building components as well. OK. So we built, we built a very simple uh component there. Now there's a couple of other things that are sort of really interesting. I mentioned this resource options. Um And there's a handful of properties that I can uh provide there. Uh And so one of the nice, one of the reasons why components are are here handy is they let me as a as a component author, not have to think about all those details and just get them sort of for free. So, you know, an author here can do something like say I want to protect this resource. Um So if I say protect coal and true, what that means is I wanna uh protect it from being deleted. So if a user comes up and tries to Pulumi destroy, that's gonna fail unless they first do a deployment that removes the protect coal and true. This is a really nice way to ensure that you can't accidentally delete these resources via Pulumi. So if I come over here and now that I've set protect Colin True and I'll say Pulumi preview, actually, I think I'm gonna have to do Pulumi preview. Dash dash dis, let me just do dash dash. This will show me the details of what's actually going to be created. And so now we'll see this is a lock icons next to each of these resources. And so not just that folder, that S3 folder um component I created, but every single one of these resources that I created inside, it is also marked as not being delete. Uh And so this is a nice thing. The component author didn't have to worry about that. They didn't have to actually, you know, pass the protect bit through or do anything or think about protection. That's something the Pulumi took care of because this component says it wants to be protected. Every one of the resources that are parented by it is going to also uh be protected. Um And so that's a nice benefit to using components as you sort of get this ability to be, to sort of um to, to connect in with the rest of the Pulumi model for free. One other similar thing is the ability to sort of use um providers. And so, um if I come over here and say, you know, uh let me config uh we'll see that I have some configuration set up. And so I have my Aws region set as US West two. but I may wanna have another A S region and so we actually now support the ability to say I want to uh Great Eu West wanna create the E West provider for Aws. So as well as me Ambient using the one that's connected to uh to us West two, maybe I wanna use region U West one. Ok. So now this is another A DS provider I have access to and I can use this as well in a similar way instead of me saying technical and I'm gonna say providers and I'll say instead of for, for the Aws provider, let me use add Aws. And so what this lets me do is say, I don't want to use this, the built in uh Aws provider that's connected up to this default region. Uh the Oregon region. I want to actually override that and use this other Aws region, but I want to use it for everything you need to create inside this S3 folder. And so again, I'm gonna type in preview dash dash dip. And in here we'll see all the details of what it's going to create. So we're gonna create this new provider. Um So you see Pulumi Provider, Aws and it's called E West one. But then every one of these other resources will see without me having to change anything as the component author. Every one of these says it's gonna get created by that uh E US one provider. And so all the same resource is gonna get created, but they're gonna get CRE passing parol in this, all of this gets picked up automatically uh for you. Um And we'll continue to add more of these kind of resource options. And all of the time that we create, we add these options and the ability to specify additional parameter. Uh those things will flow uh really nicely through uh all the components that you have in your code. OK. So uh I think that's a pretty good uh tour of building that component. So the one thing, the last thing that I can do when I have something like this is, you know, I can export this out of my um out of my index OTs so that now I have this as a library that people can use. Um And I'll just get rid of this. So now I've created a package that actually, you know, I'll export this one as well so that people can use my interface. If they're using just like in this case, javascript, I can actually go and package that up and put it in existing package managers and so just like all of the libraries that Pulumi provides itself are provided via NPM. So things like Pulumi, Pulumi and Pulumi A s in, I could go and publish this package myself. So I could just go and type M PM publish and that will actually publish this out to N PM as a as a package that I can access on N PM. Um just using whatever I specify in my package, Jason. Uh So here I could say this is Cobin component data. Uh and this will now be a package that anyone else can come up and use and, and incorporate into their own applications. And this has a bunch of benefits. Uh You know, just the fact that we're getting the piggyback on top of an existing package manager means you get all the various features of package of these package managers, you get the existing public N PM repository, uh which is easy to go and use just from any uh desktop environment. It has um lots of tooling built up around it, you have the ability to pin the specific versions. And so if I come over here and go to MD mgs dot org, and I come over to someone like at Pulumi slash aws in front, this is a package that we, we were just using that we, that we publish and this, we actually published too as part of every build of this library. And so you see, I can go back to any version that was ever published of this thing and I can go and choose to use that version and I can lock my application to that version. So you get very rich ability with these components in packaging to specify the exact version of the component to specify loose senders. If you want to always pick up patch releases or to even have tags like DEV, which is going to always be attached to the very latest um uh release, even if it hasn't yet been officially released. So the last official release was 0 15 1 about a month ago. Um but we're doing active work on this library still. Uh And so if you want to use some of those new capabilities, you can do that using the DEV tag. And so all of this is sort of all this ability to control the package manager is, is things you get kind of for free with uh with Pulumi. Um because we're sitting on top of uh things like N PM, if you're building things with Python or you're building things with go, um you can take advantage of the package managers and ecosystems uh built up around those as well to do a similar thing and package uh uh publish out uh these kinds of packages. OK? Uh So that, that ability to use both components and then to package those up and make them available inside package managers like N PM. Really means you can create a sort of rich uh set of libraries and reusable components that you can use across your application. Uh So both uh things that are gonna be useful for you uh like this S3 folder uh and things which is gonna be useful for lots of books like the EKS um example that we saw. Now, one last thing I want to show you, I've been focused here, kind of really on kind of some of the low level infrastructure pieces, these aws S3 buckets. But it's important to recognize that everything we've talked about here applies to any of the different cloud platforms that are supported as well as Kubernetes. And just to give you another example of, of one of these that I think is kind of interesting. Uh We have this um Karnes guestbook example. And so K's guestbook is sort of one of these very standard examples that you'll often see uh for KTIS. And this is a simple example of that application just ported over from the Cuban Museum. You see there's a lot of text in here to create this, but it's really just creating three components, uh redis master red replicas and uh uh uh engine uh front end uh to serve the website. And so uh these three components are very simple and very formulaic. And if you were to actually read through this code, you'd see a lot of it feels very boilerplate. I'm doing really the same kind of things for every one of these, I'm creating a service. I'm creating a deployment for every one of these things. I'm using the same uh labels to make sure I use them for the selectors for the metadata and then also for the metadata of the service that's going to attach to that deployment. And so a lot of boilerplate here and whenever we see this kind of boiler plate and this kind of repetition, that's a place where we sort of think, you know, in general, when from a program language standpoint, hey, can't I name that pattern something, can't I create a reusable component uh that represents all of that. And now uh tell people to use that reasonable component so that they get to work at a slightly higher level. And this is really what we did in this version called in the components folder. And this is all in our examples repository at Pulumi examples. So you can go and check this out yourself is we took that whole uh that whole example and which was, you know, 100 and 100 or so lines uh and see how long that actually was 120 lines of code and sort of a lot of border plate as we're saying, which boiled it down to what it really is. It's really these three things red as master reddest replica and a front end. Uh and each one of those is very similar uh they are a darker image and some ports that are going to be exposed and then some optional things like how many replicas do we want, whether we want to allocate an IP address, et cetera. And so we did this by creating this new thing called service deploy address where it can be reached is inside the cluster. And then internally it, you know, creates a new component, this KASJS service service deployment uh and creates three things, creates a container uh image out of some of the parameters, it creates a deployment and it creates a service. So just that boiler plate that we saw in the previous example, we've just moved into a reusable component. And now it has a nice simple API on it, this interface service deployment ARG which just has a smaller set of parameter, the parameterizes that sort of templated pattern. And this is a really handy way to sort of up level the way we think about something like tunes. So instead of thinking about each one of these primitives is the only thing we get to work with. Once we understand those primitives, we can move up and say, hey, now we want to build things in terms of a service deployment or some other directions in the program model on top, just like when you know when we build the C standard library, that's just a whole bunch of code written in assembly. Uh um But it's something that I can think about and use at a higher level to make me a lot more productive as an application developer. Ok. So components really handy way to uh let people work at a higher level of extraction as they're working with infrastructure, whether it's in cloud providers or in Kubernetes. Ok. So that was a quick uh demo of um some of those features. Uh As always, you can kind of get started with uh with Pulumi at uh at www dot Pulumi dot com. Uh get started working with containers, services, infrastructure, uh and Cooper, you can reach us on Slack. Uh And uh with any questions, uh we're, we're lots of great conversations going on there most of the time. Uh And you can always check out our blog for a bunch of uh interesting other topics. Uh We just published a blog post earlier today on Lambda, LAMBDA, which is a really fun uh topic, really great blog post. Definitely encourage folks to check that out. All right, that's it for today. Uh Join us again uh next week uh and have fun uh with Pulumi. Thanks a lot. Bye.

---
