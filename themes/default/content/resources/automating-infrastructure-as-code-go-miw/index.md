---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Automating Infrastructure as Code in Go | MIW"
title: "Automating Infrastructure as Code in Go | MIW"
meta_desc: |
    In today's episode, we'll take a look at Pulumi's Automation API and how to automate infrastructure as code.
url_slug: automating-infrastructure-as-code-go-miw
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Automating Infrastructure as Code in Go | MIW"
  description: |
    In today's episode, we'll take a look at Pulumi's Automation API and how to automate infrastructure as code.  Code for this episode available here:  https://github.com/EvanBoyle/automation-api-examples  Today's example is in Go, but Pulumi makes it easy to stand up infrastructure in your favorite languages including TypeScript, JavaScript, Python, and C# - saving time over legacy tools like CloudFormation and Hashicorp Terraform.  https://www.pulumi.com/docs/get-started/?utm_campaign=PulumiTV&utm_source=youtube.com&utm_medium=video
  sortable_date: 2020-09-02T19:30:05Z
  youtube_url: https://www.youtube.com/embed/m92HpG-JlUs
transcript: |
    Hello and welcome to another episode of Modern Infrastructure Wednesday. I'm your host, Lee Zen. And today we'll be exploring automating infrastructure as code. You may think, hey, infrastructure as code is already automated, but that's actually not quite what I'm talking about here today. I'm talking about how you can take infrastructure as code and run programmatically uh such that it's not really invoked by a cli but run in just part of your regular uh applications. So, yeah, we're gonna be taking a quick demo of the Pulumi automation API and then we'll be uh automating some of that infrastructure code. So let's kind of see how that works in practice. And uh yeah, let's, let's go. Uh So I have a uh a program already pulled up here. This is um from the uh uh automation API examples repository. Uh And that you'll find a link to that below uh in the, in the description of this video. But you know, this is, this is basically, you know how, how it's structured will bring it. It's, it's in go that's kind of what the preview is right now. And uh you can see at the very beginning one of the cool things I guess that you talk about here is like the way that this works is, you know, we don't invoke the Pulumi cli at all here. We're just going to run this as a normal go program and have all the Pulumi things take place and have our infrastructure provisioned. Uh So you still get all the same desired state, uh type things that you get with Pulumi, but without having to invoke the cli. So here we define our project just like we would in, in a normal Pulumi program and then we create a deploy function. Uh And here this is what you would typically think of as a Pulumi program. This is in lined into the code. Uh And so, you know, very simple, we create an S3 bucket, create an object and a policy and then that gets deployed. Uh And then we have an output. So, um but you can see the actual deployment actions uh and the coordination of everything happens fully within this program. So uh and we install the plugins, we, you know, we, we uh define the stack, all that happening here uh within the program itself instead of it outside of it on the cl I. So if I go to the my command line and I and I run um see I'm actually running go here instead of running Pulumi. Um This will actually go ahead and uh create the stack and also uh deploy the program. So you can see it, installs the plug in and creates the stack and then it actually starts the update and creates my, creates my bucket along with the the object inside the bucket. So that should finish in just a second. And we can actually take this uh URL and we can uh see if that uh that works. So let me bring up Chrome and sure enough, uh we have our website. So that's kind of, you know, what you expect and, and uh not really showing that much of the automation aspects of this yet. So let's let's try to do that. So you can see if we go back to here, like one of the cool things if you think about this is that we're just running this from a regular Go program. And so really all this can be refactored uh as of the regular Go program and, and anything can, you know, you can really do anything here uh as you would expect in a normal program. So, um you know, with, with a AAA plumbing program, typically you would run Pulumi up and that's going to invoke the, the GO code. Um And so it's kind of harder to kind of think about like running that code in the context of something uh else like something outside of, of that program. But here, uh we could totally imagine like taking this uh here, this, this code of highlighted where we're creating these, these objects. Uh And you could totally imagine like driving that off of something else um in your program. So let's, you know, as kind of like a uh a, a brief example of that. Um If I were to take this and you, I'll take, I'll extract this into its own function. So we'll call this like, you know, uh create con create content and this will be a new function which takes also Pulumi context. Oops and uh the, the bucket ID, which needs to be a uh let me uh and he uh um and so uh here, we can, we can basically take this and copy and paste it into that uh that function. And if I took too much did not mean to do that, just need that to here. So take this, put that in here and oh we take this bucket ID, put this here. Uh And then we'll, you know, we'll finish our refactoring like this, right? And uh we can say if OK, so we factored it basically, it's gonna run exactly the same way if I run it right now. But what's interesting now if you think about like the fact that we've extracted this uh function is like this function could actually be driven, you know, off of some other scoped thing um in this, in this program, right? Like I could have, for example, a map uh of data uh that gets fed into here. So for example, like we could, we could change, um we could change this to be, you know, program driven off of what's going on in the program uh as opposed to, you know, this thing that uh is kind of static quote unquote to how I've already written my ping program. So this could be driven off like the inputs to this program can be driven off of this outer program that I'm, I'm writing. So that I think it's a very cool way to think about just how you can actually automate your infrastructures code. Like all this is just normal go code that we can uh then manipulate um in the context of in the context of our program. So yeah, I just want to show kind of uh this is a new preview feature we have in Pulumi this automation api uh hope you guys can take it for a spin and yeah, and, and, and uh give us your feedback. Uh Please make sure to like and subscribe to Pulumi TV. And we'll see you next week on modern infrastructure Wednesday.

---
