---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Getting Started with Azure and Infrastructure as Code"
title: "Getting Started with Azure and Infrastructure as Code"
meta_desc: |
    Microsoft Azure’s product offering is continuously evolving, and infrastructure tools often can’t keep up with the speed of innovation. Pulumi’s Az...
url_slug: getting-started-azure-infrastructure-as-code
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Getting Started with Azure and Infrastructure as Code"
  description: |
    Microsoft Azure’s product offering is continuously evolving, and infrastructure tools often can’t keep up with the speed of innovation. Pulumi’s Azure Native provider is built directly from the Azure API, bringing power of familiar programming languages to Azure without sacrificing on latest features.  In this workshop, you’ll use the Azure native provider to build infrastructure using Pulumi’s TypeScript SDK and examine some of the features not previously possible.
  sortable_date: 2021-10-22T04:53:08Z
  youtube_url: https://www.youtube.com/embed/8kEpE9fi8lM
transcript: |
    And you'll notice it's installing a bunch of packages. It's sort of laying some stuff down and it says cool, you are ready to go. So if we were to take a look, let's do a little guided tour of our new project that just got created. So really what happened is it created all the files that we need, which we're gonna see initialized a new stack in our Pulumi account called DEV and it installed all the package dependencies we needed from N PM. If we had done a Python, it would have pulled them from pipe pie. If it was get packages, it would or sorry, get go packages, it would, it would do all the go packages it needs. It's all that stuff that normally happens. So cool. So now if we kind of take a look, the first file we wanna look at is the index dot ts. This is the entry point to our program. This is where we're gonna write all of our code. You'll see we've got a package dot JSON and our package lock just normal N PM node kind of stuff tells all the packages. This is all the stuff Pulumi did for us, the Pulumi dot Yaml is the metadata. Um And right now really all that's in there is just its name, what run time is it using? And then we have our node modules which we don't even have to look at. But that's all of our installed N PM dependencies, just like any other kind of fun node project that we might be doing. So um if we were to take a look at index Ts, so this is our, our uh big, big bad Pulumi program. So far, all we're doing there is we're just uh it's just importing the Pulumi package and saying get ready to go. She's not doing anything yet. So uh the only file that we're gonna be working with by hand in this workshop is this index dot TS. This is where we're writing our code. So if um we want to interact with Azure because this is the Azure workshop, so we have to install the Azure native provider and I want to take one second to talk about what we mean by a native provider. So there's different kinds of providers in Pulumi and a provider is a basic, particularly a package. It's a way to use your programming language of choice to interact with resources, whether they're things like clouds like Kubernetes or if it's platforms like Coop Ktis, maybe it's Digital Ocean, maybe it's Azure, maybe it's something like pager duty or cloud flare or anything like that. Um A native provider is one that is built using the API spec directly of that provider. So what's cool with the Azure native provider is an example that provider gets built nightly based upon the API spec, which means as soon as there is a resource made available in Azure, that's new. It is in Pulumi almost immediately like within 24 hours, very, very powerful stuff and, but we wanna, we wanna use this thing. So let's go ahead and install it. So we're gonna do an N PM install. We're gonna install Pulumi uh slash Azure native. This is just gonna go ahead and say cool N PM install, pull down that uh pull down that package, shove that in our node modules added to our package dot json means we get to use it now. Very cool. Um It's gonna take a take a hot second because um you know internet now while this is happening, one of the things that we do with Pulumi is there's configuration right? There's things that might be different. Again, we talked about them being different from stack to stack. But like one of the things that we can set, in fact, one of the things we have to set for the Azure providers, we have to say uh what location do we want to provision our stuff in? What, what Azure location is? Where is this stuff supposed to go? Um It really shouldn't be taking this long to install a uh N PM package. Uh get pod, come on, get with the get with the program here. The um so as soon as I get my console back from trying to install uh N PM packages through the wonders of code, we will, we're gonna go ahead and we're gonna set where that is. Ok? Cool. So it just took a second but it's there. Cool. So now and again, if we were to look back at our package dot Json, see we do it. Did you know we have that in there? It's available to us? Awesome. Let's go ahead. We wanna set our location. And so we're gonna run this command here at the terminal, which is we're gonna say Pulumi config set and it's Azure native. So we're saying this is a configuration for that provider, set it to a location in West US, use whatever Azure location is appropriate for you. Now, here's the thing that happened. You may have noticed eagle eyes that there is now a file called plume dot dev dot Yaml. So this is the configuration um overrides if you will, that are for this particular stack. So if we look in there, you can see it's set as your native location to West US. So let's again, let's say I had a stack called P prod. And let's say I put that in not a different location, it could be set differently. That's what go ahead and now we've, we've got ourselves basically set up to go. So in this next part, we're gonna deploy some static HTML files to Azure using Azure storage. Maybe not a thing you do in your day to day, but it's a relatively quick thing to be able to do. Um Mostly because just from a cloud resource perspective, doesn't take that long to spin up these resources. Versus if we're going to create like an A KS cluster that might take, you know, 20 minutes uh for, for Azure to do that. So first thing we need to do, this is gonna be constant for most. Anything we're doing in Azure here should come as not a big surprise is we need to create uh a resource group, which is what we're gonna use for all the resources we're gonna provision. So we're saying, OK, all this stuff we're gonna create, that's gonna go into a resource group. So in order to do that, uh but we kind of need to have a resource group. So the first thing we need to do with that is we um need to tell our typescript program how to use uh Azure. So we're gonna say we're gonna import as resources. This is for a resource group and it's from Pulumi Azure native resources. We're not importing the entire Azure native pack. We're just saying just the thing that we need, we just need resources. Um That's plume Azure native resources. Now we're gonna create our resource group. So we're in typescript and so we're gonna call it resource group because we are creative and it's gonna be a new resources and it's a resource now. And look at this. This is interesting. You're like, oh this is cool, Manny. I didn't realize that we installed the awesome Pulumi plug into visual studio code to give us all this type of head stuff. No, we didn't because this is just in the package. This is the beauty of using a programming language like typescript or go or um dot net or Python in this is that because we imported that package. We get it just like any other package, any other class, any other thing that we get. So we get all of our type ahead, which is amazing. So we get our resources and we're gonna do a restart resource group and we're gonna call it app because that's the world we live in. So this, if we were to run this Plumy program, it would create a new resource group called app. Cool. Um Very exciting. Not a whole lot of work yet, but we gotta start somewhere. Now, we have a resource group and we want to add an Azure storage account. We're gonna shove all of this amazing html content for our static website. So we need to be able to get now, remember we did resources for the resource group stuff, but now we need storage. So we're gonna import Azure native storage, which lets us now use that and we're gonna create a storage account. So we're gonna call it storage accounts and it is a new storage, um storage account. And we're gonna also call this one app and we're gonna set a couple of parameters around it. So we're gonna say enable HCTPS traffic only, of course, because this is 2021. Um We are gonna set the kind and it is a storage find storage B two and the resource group name. So we have to set a resource group name. Now we remember we called it app, but maybe it'd be cool to access this programmatically. So if we go and remember we created that uh concept called resource group and then if we take name from it, that will go ahead and put that in there and then we need the SKU which is gonna be name is storage school name and it's just gonna be a standard LRS. Go ahead and close that out. Do do, do, do, do OK? So couple of things I wanna show you what we did here. Now, remember you, you might say, well, Mandy, that's cool that you got the resource group name, but you could have just copied app, you knew it was called app, but here's what's gonna happen. Pulumi auto generates unique names for things. Um So you don't have a name, space collision, right? So we'll see the resource group when we create it, if you were to look, you wouldn't, it wouldn't actually be called app, it'd be called app dash, some type of identifier. Now, you can override that if you need to. Um We don't generally recommend it because you don't want to have. This is a way of making sure you don't end up with a name space collision across something as generic as resource group in your entire thing. So being able to access that programmatically here um is, is really powerful. So now we've got our storage account, but we wanna add another resource which is gonna be a storage, static, a a storage account, static website. Um It's very similar and we're just gonna go ahead and create our new one, which is gonna be, we're gonna call this one static website, which is gonna be a new storage storage account, static website, which we're gonna call my first app. They're so clever and creative. And so the account name is gonna be, remember we just created storage account up there. Let's go ahead and grab it. Cool. We can get that account name for that and it needs a resource group, right? Which is, can anybody guess how we're gonna do that? Yes, we're just gonna go ahead and grab resource group uh name just like we did above. Uh it needs an index document and we're gonna say good old index dot html. Uh No throwback to old school Microsoft default dot A sp um shout out and 404 document is 404 dot html and that ends us up there. So that gets us. Um We've created our static website, which is a thing. Now, the final step is to upload some files. So we created that storage account, static website, the static website thing, we want to loop through all the files in our sample app and upload them. So if you notice we have um the um files in that uh content directory, which is what we're gonna end up using and that gives us or not, sorry, not in our content directory. Sorry. There's the www root directory has our 404 has our index dot html. We're gonna go ahead and be using those in a second. So um remember we are now in a real programming language, javascript. Um your opinions on whether or not that's a real programming language is for a different discussion. Uh But because we can do that, we can map over, we can iterate, we can do loops, we can do conditionals. And in this case, we're gonna do a map of our two files that we want to use. And because we're gonna use some very similar things rather than having to do this one at a time. So it's gonna look a little like this. We're gonna say we know we have an index type dot html. We have 44 dot html. Are two files we're gonna use and we're gonna do a dot map so that we can map and we can um take across all of these. So we're gonna say for each one is where it's gonna be name. And for each of these, we're gonna create a new storage or create a new storage blob, right? So it's a new blog. It's a new blob which is name and it the resource group name, guess resource group dot name. Then we need to say what is the account name, which is static storage account dame. Then the container name for that is going to be the container name of our static website. So that's static website, uh container name. And then the source, where is this coming from? So we're gonna do a new Pulumi asset which is basically just saying use something at the, at the file system level and it's a file asset and its location is dot dot WW dub root slash. And then we're gonna expand out the string interpolation of getting the value of name that we were just using. We got that we've got that and the content type is text html. Got it, got it good. OK. So begin. So like we're able to say do this for because we're it's a map, right? So we can say do the same thing twice, but just interpolate in the name of the file that we're using. So this, this gives us that ability rather than having to create two different individual resources. Now, it might sound pretty straightforward. I mean, I hope it does. Um But really, this is, this is, this is powerful. So um at this point, we've got our, our whole Pulumi program. Uh We've go ahead, we're using the Pulumi package where we've got our thing for our resource group. We're using some storage. We created our resource group, we created our storage account, our storage account was static website and now we have our files on that. So at this point, if we were to say we've defined our infrastructure, so we want to use the Pulumi command line to actually create these resources. So if we um run Pulumi up, remember, make sure you're in your app directory here in your program directory and then we say Pulumi up and you're gonna see something, it's gonna run a little bit like this. So first of all that view live, if you were to click on that, everything we're seeing in the console is available in the Pulumi um web interface. So if you wanted to show that to somebody else, I wanna see what was up with that. We're cool just looking in the console here. So it's gonna say this is doing what um when you run Pulumi up the first time like this, it's gonna run basically a preview. It's gonna say cool. If I run this program addie, here's what's gonna happen. I've got six resources that I want to create. I need to create a stack because we don't have that stack yet. I need to create a resource group, a storage account, uh the static website and then two blobs for the two files. So I can, if I were to go in here even and say, do I want to see the details? We can see in depth everything that it's gonna do, what the RN are gonna be. All that good stuff. So we're gonna say, yes, go ahead and perform this update. And which means it's gonna fire out there into my Azure sub. It's gonna create that resource group, create that storage account, do all of uh the things that we've asked it to do because computers are nice and they do what we tell them whether we want, whether what we told them is what we meant in the first place or not. So cool stuff happening there. Um OK. It's chugging away now what we're gonna do next while this is thinking, OK, cool. So we've, we've got our infrastructure but I don't, I don't know where it is. I mean, I know it's an Azure and I could go on the console. I could poke around but that sure does not seem very infra Cody to me. So we can export values from our Pulumi stack so we can see them as an output and we can either throw those out just to hit in the command line, we can actually pass them around from Pulumi program to Pulumi program, which we aren't gonna do right there. But we're gonna go ahead and say, let's go ahead and get the end points from that website we created. So we're gonna export uh a constant called URL and that's gonna take the primary end points from that storage account. So if we were to go ahead and run Pulumi up again, you're gonna see that. It's gonna now say, OK, so the cool thing is uh what do you think Pulumi is gonna have anything that needs to do? Spoiler alert? It shouldn't because we didn't change anything. Our infrastructure is in the state. We want it to be. But it did say if you run this, there's a new output, which is that URL. So we're gonna go ahead and run that. Granted. Yes, I could just copy paste that. But I want to show you how we can use this stack output. So I didn't really have to do much of anything. So now if I were to say, let's curl the Pulumi stack output URL because remember we had a very uh constant called URL. So if we take, if we take the value of Pulumi stack output of URL, pass that to curl. Also helpful if you don't try to use braces, Maddie, because you are not writing javascript, you are doing bash and today we actually have a website. So now we can all go put web developer on our linkedin and get paid the big bucks. All right, we're gonna do one more cool thing here. So that was fun. But let's do some Docker because you can't dev ops without Docker. Uh So in that what we did, we deployed our static HTML files. And this next part, we're gonna deploy that exact same html to an Azure app service using Docker. We're gonna build the Docker image using Pulumi and upload it to the Azure container registry. So lots of fun stuff going on here. Now, we need an app service plan in our resource group. But if we want to do that, we need to bring in um the web package because that's what's gonna let us do that stuff. So we're gonna add uh as your native slash web as web so we can use that and then we need a plan. Um So our plan, we could just do this at the end. We're gonna go ahead and keep our other deployment happening. Our static website can still exist in, in, in uh in blob storage. Um This is a yes and situation. So we're gonna create our plan and this is gonna be a new web app service plan, which is gonna be called plan because I am so creative and the resource group name is gonna be resource group dot name. The uh kind for this plan is gonna be going to do this on Linux, New Reserves is true. And then the SKU here is gonna be the name, oops is B one and the tier is basic, should be more than sufficient for our little static website. Oops and do and do. Ok. Cool. So we got ourselves an app service plan man with plan now, Panama. Uh All right, cool. So we've, we've created our plan. That's the end of that. No big deal. Everything's cool. Uh We want to build our Docker container and we already have so that www root directory, there's a Docker file. So we're gonna use that Docker file. Um But before we do that, we wanted to find a container registry where we're gonna put that Docker image. So we need to uh add container registry to our imports up at the top. So we'll go ahead and import container registry because that's what we're gonna be making. And for this one, we're just gonna go ahead and some of these, I'm gonna do a little copy pasting because you don't need to sit and watch me type all day. But this one's pretty, this is nothing terribly new that we did here. We're still using the same resource group variable uh or value that we had before and we're just creating a registry called registry. Now, this is where things might get kind of interesting. Uh Actually, hopefully it's been interesting all along but, but we're gonna do something else. Kind of cool. Now we need to get our credentials from this register, created a registry. But if I wanna push my Docker image up to it, I need creds, right? And we wanna only grab the creds once the registry has been created. If we Pulumi does not necessarily like boom, boom, boom, boom, boom, it tries to run things in parallel as much as possible but trying to access and use those credentials when we don't even have the registry yet. You can guess. Would that go so well? So Pulumi has a mechanism for this called apply an apply call and you can chain multiple apply calls with using all. So what we're gonna do here is we want to grab those registry credentials that we just created. So we're gonna call that credentials and now here instead of doing a new, we're gonna do uh it's gonna be Pulumi dot all and we're gonna grab that off of the resource group name registry aim and then if we stick our apply on this and then do bear with me here for a second. And we're gonna wanna do resource group name, registry name, course registry is, then we're gonna pull the list, list, registry credentials and then the resource group name of that is going to be resource group name and the registry name is going to be registry name. Cool. And then we should end up with a, let me just see. What did we, what did we get wrong here. Uh there should be there and that's one too many plans. Ok. So because we did this apply and apply all, it's going to wait for all those other things to be working. So, and then we wanna actually we've got those values. That's cool. Let's do something with them. So we're gonna say that admin user name, user name his credentials. But again, we, we're doing this supply which is what's uh making, making uh sure that it's not going to try to uh set that value until the credentials, user name. Bang. Ok. And then we're just take the password the same way it's gonna look kind of like this. Ok? So that gets us our credentials. So now we can actually do something with this registry. So finally, what we wanna do is we want to, our registry is ready to store our Docker image. So maybe we should make one and push it up there. Um So we need to add a new provider. So we're gonna, you know, we've been using Azure stuff so far, we need a new provider which is Docker. So we'll do N PM install Pulumi Docker, right? So that's gonna get us um installed while that's going, of course, we need to add that to our imports so that we can actually use it. And we just do that with import dash dash or import uh stars, Docker. Cool. Now we want to define our Docker resource right. So we're gonna say constant image, there's a new darker image called app. We're gonna set our parameters for this. So the image name is um so we're gonna use this Pulumi dot interpolate, which is letting us take some info that we have here so we can take from that registry that we created. We'll get its login server cool. And then we're gonna take app and we want the tag of latest on that because of course we do. Let's see. Do we get that? Yep. I think that's right. And then for the build, the context that we're passing that is gonna be WWW root. So it knows where to find our Docker file and the registry that we're gonna push it to should come as no big surprise that the server is the registry login server. The user name is admin, user name and the password for that is admin password. OK? And right. All right man. Uh bill. That's why there we go. So calling it the image, what we want to call the image where to get the Docker file from and what registry to push it to. So now we want to actually deploy that Docker container and we're gonna use Azure's web app service for that. So we're using the web resource again, which we already have imported because we used it um earlier. So we don't have to do a new import for this just to use it. And we're going to define our web app. And for this one, this is a lot of typing and I wanna move along. So I'm just gonna walk through what we're doing here. Um uh-huh, OK. User name, admin user name. Why doesn't it like that? Oh, that should be admin user name. There you go. OK. So what we did here for this app is we said, OK, it has a resource group, our usual resource group um use our plan that we created for the server farm. And then what are some of the app settings? So what's it's uh for the site? Config it's Docker registry server URL. We already have that. We, we know where to get the admin user. We have those credentials and then our custom image is exposing port 80. But if we're doing something different, we want it set to always on and it's gonna be set to HPS only. So this is really doing a lot of the stuff that we did in the static websites on storage earlier. And so now what we've accomplished is we've got uh this web app to find using that plan. We've got the Docker image it's gonna create. So the only thing left to do now is our friend Pulumi up, which is gonna go ahead. And the first thing it's gonna do is be like, cool. I've got, you know, all your uh fun stuff that you've already done. So we should see a bunch of resources, it doesn't have to change um from our static website we created before and it's saying six unchanged, which is telling us the four things would have to create, it has to create the Docker image, the registry, the plan and the web app. So let's go ahead and let this go. This is gonna take um a bit of a minute. You notice again that existing infrastructure or static site in our bucket has remained unchanged. And uh one thing that we didn't do uh that we did before that might be helpful. Oh, someone has a hand raised. What's that mean? I don't, I don't know. Um I think someone just clicked the button. Cool. Um We never grabbed uh the URL like, so how can we do that? So while this is running, let's go ahead and add that to our code. So we're gonna export another constant, which is gonna be uh the web app, URL, Oops, web app, URL. And then we for this, we're gonna do a Pulumi at Interpol eight, our friend Interpol eight and we're gonna grab hdps forward slash hash. Then apps default host name is gonna come out of that. No, you go away. OK. So that's gonna now give us that new uh thing so you can see everything went back up. Everything is cool. Um But let's go ahead and run Pulumi up again and this way we'll go ahead and get ourselves our web app URL in just one second and see what's going on with that. Um If you have any questions, please fire them off into the chat. Um, we'll do our, do our best to answer them. Um, as we kind of wrap up in our last little bit. So we went ahead. We've got our web app, URL should be applied as an output. And once we've done that cool, we'll just clear this. If we were to do, if we were to curl that, we're gonna see, we've pulled that up again. So that gets us. That's what we did. Now, of course, we want to clean up after ourselves because we've just provisioned. I've just provisioned a bunch of resources in my Azure account. Maybe I don't want them to be there anymore because I'm gonna forget about them until next month when my bill comes. So if I do, if I were to type in Pulumi destroy, what Pulumi Destroy is gonna do is it's gonna take all the resources created in this stack and delete them. And so it's gonna show it's gonna say, yep. Are you sure you want to do this? I am so sure. Um No one's accessing that website. It hasn't made itself uh available on the Twitters yet. So it's gonna go ahead and delete all those pieces. And then finally, what I'll be able to do is I can actually remove the entire stack because you would see that if uh even um even though we deleted those resources, the I'll go ahead and show you um while this is chugging away. Hang on a second here. Yes. So those resources are being deleted. But if we go ahead and switch to look out, oh, I don't know what I just did there. Uh Share screen, switch screen chrome tab. All right, if we go back to my Pulumi, you know, so we had this uh my, my first uh which one did they even decide to do? Um Here it is my first Azure app. Hello. So this was the program we were just working in and we can kind of see in this DEV stack. Uh It just did it destroy, we can see the activity, we can see all the things that we've done and even in the resources, you'll see there's actually no resources now um because we've deleted them all and now I'm like, all right, I want to get rid of this. I don't care about this anymore. It's time to move on with my life. So if we go back into um our console here, if I were to do Pulumi stack, RM DEV and says, are you sure like, yes, I want that stack to go away. Workshop is done. Um And then that way I don't have it poking around and hanging around inside my Pulumi account anymore. So, uh how can you transfer the state file from app dot Pulumi locally? To your project. Well, you can do uh you can do a Pulumi export, which will export the current state. And then if you had a different back end set up somewhere for your state, uh you could then do a Pulumi import. So, um again, we have uh a bunch more, we actually have a bunch of more workshops today. Uh a little bit later, I will be doing a workshop on building a self service cloud with Python. So we'll be creating using uh Plume's automation api uh to build some deployments in Kubernetes. Um And then also my colleague, Kat Cosgrove is going to be um doing a workshop on uh uh GCP instead of Azure. And then we've got something fun we're doing with our friends uh NX as well later on today. Um You want to continue your journey here to get started if you go to the plume dot com slash do slash get started uh for any cloud, anything you're doing. We have a ton of code examples on github. Also go to Pulumi dot com slash registry as, as we just launched the registry this week which is full of um all the different providers, all the different resources, all the things. It's one stop shop for all the pieces and packages and parts. So thank you for uh joining us today and hopefully we'll see you at a future workshop. We'll see you on the internet and keep building awesome things

---
