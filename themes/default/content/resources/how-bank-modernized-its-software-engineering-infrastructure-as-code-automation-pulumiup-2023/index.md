---
preview_image:
hero:
  image: /icons/containers.svg
  title: "How a Bank Modernized its Software Engineering with Infrastructure as Code Automation |PulumiUP 2023"
title: "How a Bank Modernized its Software Engineering with..."
meta_desc: |
    At financial institutions, data privacy and security aren’t just best practices - they’re Federal requirements. Dennis Sauvé, DevOps Engineer at Wa...
url_slug: how-bank-modernized-its-software-engineering-infrastructure-as-code-automation-pulumiup-2023
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "How a Bank Modernized its Software Engineering with Infrastructure as Code Automation |PulumiUP 2023"
  description: |
    At financial institutions, data privacy and security aren’t just best practices - they’re Federal requirements. Dennis Sauvé, DevOps Engineer at Washington Trust Bank, shares how they modernized its software development and infrastructure practices since migrating to Azure and adopting infrastructure as code. He will cover how his team enables developers with infrastructure components, prevents developers from deploying forbidden resources with CrossGuard policies, and uses automation to save time and effort.  
  sortable_date: 2023-07-09T16:32:30Z
  youtube_url: https://www.youtube.com/embed/Q63ZaX340M4
transcript: |
    Hello, it's my privilege to be presenting here at the 2023 Pulumi Up conference. My name is Dennis Sovey and I'm the Devops engineer at Washington Trust Bank. We have a software development team of about a dozen engineers all supporting numerous projects within the bank. I'm a part of our infrastructure team working with our Azure engineers and developers to automate resource deployments to the cloud devops at Washington Trust Bank is a relatively recent development. I was hired in as the first development operations engineer at the bank in the March of 22. It was a lot of work getting up to speed on all the moving parts of the bank and prioritizing which systems could benefit from automation the most. I'm a member of our it infrastructure team and I serve as a liaison between our infrastructure department and our development department. I work with our developers to understand their cloud infrastructure needs and coordinate how to best deploy those resources with my team and information security. Working with our development team can be challenging at times. Our development team schedules around a scrum framework whereas infrastructure works off of more of a Kan triage framework or it after all, this means that sometimes I have a lot of bandwidth to assist with development objectives. And other times, my duties on infrastructure have to take priority. An overarching goal of adopting infrastructures code has been to remove infrastructure availability as a bottleneck and put a lot of development environment. Scaffolding in the hands of the developers in the form of premade infrastructures, code resources and components, automating deployments has alleviated an enormous burden of manual deployments from the infrastructure team as well as creates repeatable and reusable components for use in future projects. I'll share some background information about Washington Trust before we decided to adopt infrastructures code into our deployment pipeline. The FDIC has strong regulations surrounding the protection of clients, personal data and for good reason, data breaches have a horrible impact on an organization's clients and all data entrusted to us must be treated as confidential. It's because it's the right thing to do and because the FDIC mandates it, given that client data must be protected using infrastructure as code to build out our cloud resources, gives us a blueprint that can be reviewed and improved on by our information security team and our infrastructure team. Cross guard. Pulumi resource policy tool gives us the ability to prevent undesired and insecure resources from being deployed to any environment. Reducing the number of places we need to implement Azure policies. Cross guard also allows us to block the deployment of certain resource skews that may incur unnecessary expense. I will note that we also implement Azure policies in all of our environments for auditing purposes and out of an abundance of caution, less regulated organizations could rely solely on Pulumi cross guard for control of resource deployment. Pulumi approach to cloud deployments allows us to follow and maintain best practices for secure cloud architecture. The reusable components prevent any security configuration from being missed in a traditional gooey setup of the same resources and saves us time from having to manually deploy resources. You can plume up most resources from code in the time that it takes to open the browser and sign into the Azure portal with M fa and find your way to the resource creation view. Let's say that marketing wants to make a change to the organization's website. The developer responsible for the website makes the changes, zips up a copy, sends it to the server via S FTP and unzips it there to deploy. Does this sound familiar to anyone that was a workflow for us for quite a while? Anything can happen in between to cause a break, you can zip up the wrong directory, sending your development directory to the production environment. You could send it to the wrong server replacing a client portal with your website. Maybe the changes that worked on your machine aren't quite working as expected in production. As Washington Trust Bank grew over the past few years, it was realized that we needed to bring our deployment pipelines up to date. This meant picking a new source control provider, a new deployment system, a new cloud environment. It was settled that we would continue to use uh Microsoft products by consuming Azure cloud resources and using github as our source control github actions were a natural extension of choosing github, which left us with one question, how do we deploy multiple Azure tenants from personal machines and github actions? We had a few choices before us basic Terraform which allowed us to template Azure resources for deployments but not much beyond that. Azure Bicep was in its alpha release stage at the time. Then we came across Pulumi. Pulumi was not only supported Azure natively but also supported a whole host of other clouds like aws and GCP. The fact that we were empowered to choose which language we wanted to write Pulumi and gave us the confidence that we could take Pulumi with us if we ever decided to change our core language or cloud provider. The Swiss Army knife versatility was exactly what we were looking for. And we've only uncovered more of what we love about Pulumi as our relationship has evolved. Integrating Pulumi with our github organization and users was incredibly easy deploying to our developer machines was painless and using it in conjunction with Azure cli was seamless. It just worked. We've used github actions extensively for our software development projects. Our C I CD pipeline is guarded by environment guards requiring reviews from info sec and infrastructure before uh making deployed changes to live or stage environments. This prevents accidental deployments of unapproved changes to our production tenant. Part of our github actions workflow is running a Pulumi refresh and preview showing us a detailed delta differential of the changes that will be made to the environment. This gives reviewers the ability to easily review changes and compare against approved change requests using Pulumi to destroy and Pulumi up to completely redeploy resources is helpful when iterating quickly and there are fundamental changes to resource properties that cannot be modified but must be completely recreated. Wrapping our brains around Pulumi output convention was a bit of a learning curve but we got it with the help of A L during our Pulumi training sessions for our development team, changes to infrastructure was now code first with the ability to import resources that were stood up quickly by other teams into projects. So we can track everything with code, monitor drift and remedy differences quickly. The true value is knowing we have an exact blueprint of our cloud infrastructure that can be used to stand us right back up again. In the case of a disaster, we knew going into Pulumi that we need to create a standard package that would contain the core of our Pulumi library in the form of both common functions to build out a spoke in a hub and spoke architecture, as well as customized component resources that were built around strict information security standards. The solution is an internal M PM package for our team called Frasier, an amalgamation of infrastructure and Azure. I wrote and maintained the initial versions of this package and I'm immensely happy to have members of our development team jump in and contribute with our hub and spoke architecture. And Azure, we have strict guidelines as to how resource groups and their virtual networks can be created. These include subnet IP spaces, peering to and from the hub virtual network user to find routes. And more this method allows developers to easily scaffold the spoke from their new application in Azure without having to worry about the basics that we've set up for them behind the scenes after creating the spoke and building out other resources, some of which are common components that can be called from Frasier as well. Developers submit APR and from there, their changes can be deployed into test environments. After being thoroughly tested, changes can then be merged into our main branch and queued up for approval and deployment into stage and live environments. With github actions, approval requests are automated and deployment is started after appropriate approvals have been given, it removes deployment responsibilities from both teams and allows for a clean history of the deployment processes as well. We have been building out component resources as well allowing us to customize groups of resources that are commonly used together with specific configurations that are ideal for our organization. Components are stood up just like regular resources, but they all show as grouped underneath the parent component resource which makes for an easy to use stack output, complementing our Azure policies cross guard is an amazing feature of Pulumi that allows you to control what resources are deployed during the preview and deployment stage. Thus preventing developers from even reaching Azure to stand resources up. Creating custom error messaging allows us to give context to developers as to why the deployments are not allowed with policy packs. We're able to group together policies based on focus which allows us to deploy many policies at once and keep them organized in a project. This prevents deployment of forbidden resources at the Pulumi layer before the resources even have a chance to reach Azure. An example of one of our first policies was that by default, we wanted all SQL databases to use TLS 1.2 by default. This can easily be accomplished by checking all the SQL resources with a cross guard policy for TLS 1.2 compliance in the same vein that we also wanted to ensure that our storage accounts would have public access disabled by default. Another easy check with cross guard policies as Washington Trust Bank continues to expand into Azure, we will continue to leverage Pulumi as an infrastructure as code deployment partner. We've had success in using Pulumi to automate deployments of our web services for our development team, data management tools for our business insight team, as well as orchestrating our entire hub and spoke cloud architecture model. We have complete confidence in being able to replicate our cloud environment if needed. All thanks to Pulumi allowing us to keep our infrastructure as code. I hope this presentation has illuminated how Pulumi can be used in a highly regulated environment to not just automate manual deployments but to make them more secure as well. Thank you for your time. I hope you enjoy the rest of Pulumi.

---
