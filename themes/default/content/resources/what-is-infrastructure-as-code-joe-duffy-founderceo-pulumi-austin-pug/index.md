---
preview_image:
hero:
  image: /icons/containers.svg
  title: "What is Infrastructure as Code?  with Joe Duffy, Founder/CEO of Pulumi | Austin PUG"
title: "What is Infrastructure as Code?  with Joe Duffy,..."
meta_desc: |
    Joe Duffy, Founder/CEO of Pulumi, discusses "What is Infrastructure as Code?" and "What is Pulumi?"
url_slug: what-is-infrastructure-as-code-joe-duffy-founderceo-pulumi-austin-pug
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "What is Infrastructure as Code?  with Joe Duffy, Founder/CEO of Pulumi | Austin PUG"
  description: |
    Joe Duffy, Founder/CEO of Pulumi, discusses "What is Infrastructure as Code?" and "What is Pulumi?"  There have been several generations of infrastructure-as-code tools. Joe walks you through the evolution of infrastructure as code (IaC), how the open-source Pulumi framework allows engineers to write IaC using general-purpose programming languages such as JavaScript and #GoLang, and the future of multi-cloud environments.  This was live streaming in Austin, TX, during the in-person Pulumi User Group (PUG) meetup.   
  sortable_date: 2023-07-13T11:00:51Z
  youtube_url: https://www.youtube.com/embed/ieSjz3-EOec
transcript: |
    All right, let's get started. Um So thank you for coming. This is actually, I think unless I missed one, our third user group that we're officially kicking off. I mean, Erin mentioned we had a happy hour previously, but uh we started these user groups, uh maybe, I don't know, three months ago and as soon as we created them, we had hundreds of people kind of in all these different regions across many countries, kind of sign up organically with very little promotion. So really excited, I think that's a testament to, you know, the growth of the Pulumi community. Um And honestly, we're very international. I think a third of our customers are in Europe actually. So is the audio not right? Is it, let's see if I can pull this down if that seems better if that we can use to make money. Thank you guys for bearing with us. Appreciate it. Just start the 1900. We, we're still officially sorry, I can't say, you know, eventually we'll get, we'll get to the point where we're up on the state official, you know, audio tech. Um But, but yeah, so we're just getting started really happy to have you here, you know, uh we're gonna keep doing these, I think one of the user groups are gonna try to do maybe something once, you know, every other month just to keep them vibrant, keep, you know, things going on. I think a lot of them, you know, I'm trying to kick all them off if I, if I can, you know, traveling around. Um, I was at the London one, we just at the Seattle one recently, coincident with some product launches. But importantly, you know, we're always gonna have, you know, a customer, uh hopefully to give a presentation or somebody in the community to talk about how they're using Pulumi. Um So we've got Chris today, which is awesome. I can't wait to hear his talk um about sort of adopting Pulumi in, in, in an actual organization and some of the challenges they're uh faced, but I'm gonna kick it off with maybe more sort of conceptual thing. Uh I think it would be a little bit of fun to talk about, you know, our view on infrastructures code and why our approach to infrastructures code uh with Pulumi is a little bit different uh than I think what most folks have encountered. And so I'll just get started. I wanna make it interactive. So if you have any questions along the way, let me know, I'm gonna try to keep the 30 minutes so we can move on to Chris who undoubtedly will have much better content uh than I do. Um um So with that, I, you know, I'll get started, you know, I think we found Pulumi over six years ago. Uh My background is in developer tools. I was running the developer tools strategy at Microsoft, including all the languages teams. And what I saw was, you know, obviously Asher at Microsoft but did a lot with Aws and Docker with containers and server. And it was kind of a mess when I, when I sort of got my hands dirty and started trying to build cloud applications. And to me, it was really exciting because we're finally entering into the era of distributed computing, right, infinitely elastic computes elastic data managed services. Um you know, for 50 years, like I worked on uh parallel computing and multi core in the two thousands when we, you know, everybody is freaking out because, you know Moore's law is over. And now like we have to learn to become parallel programmers and what's gonna happen to the Windows and intel sort of relationship turned out to be vastly overblown. But um back then a lot of the research was into distributed computing. Uh and we took a lot of that and packaged it for, you know, programming multicore but distributing computing has, has been coming forever in computer science. And to me, the modern cloud is finally, you know, it's here and yet I look at how most people were you know, interacting with cloud infrastructure. It's like manual provisioning SS into servers and doing manual things, uh pointing and clicking in the cloud consoles and unrepeatable things um to create effectively cloud architectures. But by very manual processes, it's almost as though you built in, you know, imagine you're building a desktop application by going and clicking a bunch of buttons in the windows, you know, mmm MC snapping or something. Uh To me, it was, it was really far from the amazing developer experience that I had envisioned and of course, you want to create an ETS cluster or go to the Amazon documentation and good luck. Great. Um So of course, we, that is a feeling I had when I, I basically took a sabbatical at Microsoft and was like, I'm gonna spend a summer pretending I'm actually building cloud applications. I was managing teams of hundreds of people and I just want to get my hands dirty. That's how I felt. And it's, you know, why, why did they feel that way? Well, first of all, it just wasn't fun but you know, it's not repeatable, doesn't scale very easy to make a mistake. Uh And I make a mistake, I mean, you know, take up production leak a secret or worse. And that led me to discover I kind of knew about the concept but coming more from application developer background, I'd never really gotten, you know, used infrastructures code in anger, but that was sort of a solution to a lot of those problems, right, to automate manual processes and code them as repeatable steps and sort of treat infrastructures like software. Although we'll get to more of that as I go and um really eliminate the toil uh and do more with less. And I think to me, if I were to just summarize, you know, I think a lot of folks, I actually, I'm curious how many folks here use an infrastructures code tool today, whether that's terraform or cloud formation or Polu and then how many people use Pulumi? OK. Almost over, almost perfect over left there. Um which is great. I love it. Um And I think, you know, if I were to just summarize, you know, the two primary benefits of infrastructures code and, and by the way, we didn't start out Pulumi thinking we're gonna build an infrastructures code tool. We started with a new programming language, we started with, you know, frameworks and then all roads led back to infrastructures code. I'll talk about why that is, but without infrastructures code, there's really no consistent programmable compos interface into the cloud. And the way that we've approached Pulumi is it's really all of that compos programmable interface into the cloud where cloud services are really building blocks that you can use to build bigger things out of smaller things. But really it comes down to two things, one code and two declarative where you can encode you know the cloud architecture, the configuration of resources using a repeatable asset ie code that you can check in, in version and review with your colleagues. And then the magic is the declarative part. I think with Pulumi, we often get to this, you know, heated debate in the community. Often somebody will lob a hand grenade and you know, say, well, Pulumi is not declarative. Well, it turns out it's subtle, right? Because if you're using, let's say Python, you're expressing yourself in an imperative language, even if the infrastructures code engine itself is declarative. And so to me, the infrastructures code is not really infrastructures code unless you have that Declarative card. And what that gives you is the ability to really have a resource graph, right? So a program executes for the sole purpose of creating a resource graph which represents the configuration, the desired state of your infrastructure. It allows you to preview changes, get the full life cycle, not just spinning up infrastructure, but evolving it, versioning it, destroying it. It's easier to recover from failure because you're declaring your end state. So if you fail somewhere along the way, it's not like you're writing a ad hoc script where if it fails, you have to consider every possible point where it can fail in the script. Um As a result, it's easier to automate, we'll see some really advanced cool automation use cases that Pulumi enables, then you've always got history of changes and you can enforce policies and all, all those good things. And for folks that are infrastructures, code users every day, I'm sure this is kind of bread and butter. Um But it's really important to just ground things in, in these sort of simple facts. So let's focus on the code part for a second. To me. I was, you know, led to believe that code is, is uh you know, expressive, it, it captures your intent and, and uh you know, there's various forms of code like Yaml, the L and YAML is language. So arguably it is code, but I would say, you know, you look at domain specific languages like terraform, you know, it's almost like deceptively simple for the easy things and then, you know, painfully difficult for the complicated things. Um And then you look at things like, hey to configure an Amazon BBC and cloud formation and you're talking about thousands of lines of Yaml or JSON. So is it code? Sure is it the kind of code that scales to modern cloud architectures and allows you to um you know, productively capture the sorts of patterns that modern cloud architectures need arguably that. Um So it feels like pushing the boulder up hill sometimes. So there's another twist on sort of the Pulumi perspective. It's interesting being on Microsoft when we started uh Azure, we called it a cloud operating system. In fact, it was called red dot And it was cloud Os was the original framing of, of Azure. And when I heard that I was like, wow, that's amazing. It's like a distributed operating system, right? And that's how they actually started. That's why there's so many path oriented things with like service fabric and, and things like that. But over time, especially going up against Amazon as you was forced to sort of move rapidly away from that towards infrastructure as a service, you know, easy to compete basically. And as a result, like I think that original vision of the Cloud is the new operating system, like we've moved beyond single node operating systems as being an interesting debate in a, in a sense. And at some point, we lost sight of that as an as an industry. But certainly, you know, as you did. And if you, if you frame your thinking in terms of like, what was it, what does that actually mean if the Cloud is the new operating system? Well, there are some analogies I would, I would draw to build up to that outcome one programming languages. I mean, I would say programming in YAML and Jason looks like programming an assembly language, super low level, every little detail matters how even the in indentation of your Yaml matters. But you know, you're programming at a super low level. And then of course, at some point, you know, sticking with the analogy C comes along, you've got a higher level language that's much more productive and eventually you have no jas and others. Um And so that was the first insight with Pulumi was, let's not just create a new DS L uh let's not, you know, go create even a new language. Let's let's use language as people know and love. So Pulumi at its core, it's a declarative infrastructures code engine, but it has an extensible language model. So the engine itself is written and go, it's open source and it can host any language as a separate from time. It uses GR PC. It's if you tomorrow wanted to implement Rus support, probably take you a couple hours to do minimal Rust support uh because it is extensible and easy to, to do that. But the the challenge Russ at Pulumi bringing up a new language is actually all the documentation making sure all the examples are available in every single language. Anytime we bring a language to market that doesn't have complete parity with other languages. Obviously, people are disappointed because you know, if I come to Pulumi and I love Rust, but Rust is not on equal footing with all the other languages, I'm I'm obviously gonna be disappointed. So these are the current supported languages. Any no Jess language, any dot net language, Python. No, we do have AJ VM uh implementation. So any, you know scholar closure group, um we support op A for the policies code engine. Obviously, that's not for the infrastructures code, but for policies and then sort of mind bendingly, we brought up YAML support uh last year, which honestly, our philosophy is simple things, simple, hard things possible. And sometimes, especially if you're doing machine generation of your infrastructure is code. Yaml is actually an easier target for machine generation than like having to generate Python or something like that. Um And so we have, we do have YAML and of course, Q because Q compiles down L and um it works as well. Plus, don't forget the L and the M Os language. So come on, come on soon. There will be common Lisp and has and lots of others, actually somebody did do a FORTRAN implementation. So if you ever want to do is go to fort how about it. Um but you know, it's not just the language, right? It's everything around the language, you get ID E support, refactoring support. This is an example of our EPS package, which is incredibly popular largely because you saw the screenshots from the AWS documentation was how to use EKS this, this package just comes with a properly configured EKS cluster out of the box um with all the right, you know, off settings and uh can export your coop config. So, um and by the way, a lot of our customers build their own components as well and the trick of building a component is what is that interface? You want the, you know, the defaults to be same but you want to have all these sensibilities so people can control the different elements that they need. So, you know, like right here, mid size max size two pretty straightforward. But what if I wanted like a GP U node pool or something like that? We do have the extensibility for you to go and do those powerful things. Um But with lots of those sort of components, but you can see we're sort of trying to move up the extraction um the layers of distraction so that you can extract encapsulation and re use. So that um effectively, that's been the secret to everything we've done. And computer science and software engineering, we've been able to build bigger things out of smaller things, right? You know, we have libraries that encapsulate lots and lots of things. So we don't have to go recreate the wheel every time. But Pulumi you can kind of do that for infrastructure as well. So the second part of the analogy is run times, right? You know, so uh interestingly, here's uh some win 32 code which is like, you know, Charles Petzel style, you know, create window. Um It's kind of the code that I grew up writing. Um But we've since moved to higher level abstractions, right? So, you know, no J SI can just create a file, not have to be a file system or a Win Fs file system expert. I can just productively write that high higher level code and that's sort of the direction that we see, uh going with. You know, now that we have abstractions, now you can write higher level code instead of having to worry about every single little detail of every cloud service that you're trying to use. And by any cloud, I don't just mean, you know, a DS A or Google cloud, there's a lot of different cloud providers out there in the world today. You know, it's cloud native with KTIS Helm. Uh, you know, if you're doing something with snowflake, you know, configuring the, the data lakes, I mean, that is cloud infrastructure, cloud flare mango D the Atlas, the world is very complicated now. And the thing that I often observe when customers pick up Pulumi is they're coming from a world of like bash crying dozens of tools that were never meant to work together and it's not fun. It's error prone and it's sort of insecure like what if you have a secret that comes out of one? Like you provision a Mongo DB at database and like now you have a, a token for access in the database and now you have to stick that in your ecs instance, writing in aws. Well, how do you do that securely? Well, hopefully, you know how to use, you know, the secret store and, and all that, it's, I mean, it's really complicated. So having the ability to do it with one consistent workflow is really powerful. The one thing that Pulumi does not do though is we're not trying to abstract away what makes all the clouds great. We're not trying to be sort of, you know, lowest common denominator across all these, these things. And so we say the programming model is consistent, the deployment workflow is consistent. Uh the way you do secrets management is consistent. But if you know, you're doing like, you know, redshift database and they just ship the feature and reinvent and you want to use it today, we're gonna give it to you. So that's a a subtle distinction. I would say the the analogy, the third part of the analogy is, you know, operating systems, right? I I think arguably you say Cooper Netti is, is basically just a thread scheduler for the cloud, right? It's, it's like the the cloud's version of a thread pool that schedules containers and, and things like that. Um Again, I keep coming back to the analogy because it, it goes to show you how many things are missing from our current tool kit. There's no consistent application model for how you install configure applications into the cloud, right? We have some things like Helm is arguably trying to be that. But uh you know, the more we push the boundaries in this direction, the more kind of obvious opportunities to improve the state of the world uh emerge. And I think, you know, infrastructure, we think of them as building blocks, they're sort of the building blocks of the cloud. The great thing about Pulumi is you can stitch these things together and program them, configure them and basically build anything. You can dream of infinite combinations of these things. In fact, I'll show later this new Pulumi A I tool that we released. It's really great for how do I stitch together random building block A with random building block B like, I don't know how many people here have ever had to figure out, you know, OK. A just released this new thing. I'm already using, you know, kiss and EC and LAMBDA, but I want to integrate it with this new secret store thing. Like how do I even do that? It's really difficult because the permutations are endless and yet in that is also the power of treating the cloud like, you know, a set of building blocks. So let's get back to this infrastructure software concept that I had mentioned at the outset. Um you know, we talk about infrastructures code but with Pulumi, the really exciting thing is once you use general purpose languages, you have access to everything around those languages like software engineering practices. Um So we can move beyond code to software. Um We think about how we organize our projects and use sort of software component best practices. We can do continuous verification with, you know, unit testing and integration testing, um continuous deployment like we do our applications now. We can just apply that to our infrastructure pipelines. And honestly increasingly the the boundary between applications and infrastructure, especially in a modern cloud, you know, let's say serverless world, it's kind of blurry, right is a container registry application or infrastructure. Well, it's kind of right at the boundary is a serverless function itself, application or infrastructure. Well, it's kind of infrastructure that hosts the application code, but a lot of times they have to version very closely to each other. So bringing how we deploy our applications and infrastructure closer together. A lot of folks we're working with are trying to to do that. Now, otherwise you you know deploy a new container image, take the shot. Hash go over here, deploy your new application image like and make sure it works. Oh It didn't work, go back, fix the thing like it's not having the unification is is quite painful. So Pulumi tries to bring those things closer together and I already talked about sharing and reuse. But one of the subtleties around sharing and reuse is it's not just about OK, I don't have to copy and paste anymore. I have actual components. You actually actually have versioning too. So like let's say you find out you have a security vulnerability in the way you configure your web application firewall. Well, a lot of times you have to go track down, where did you copy and paste that bad cloud formation, right? And go track it down. Well, if you actually have a, a component, you go fix the component, roll out version 3.0 and then find all versions out there in the wild that are less than 3.0 and patch them and upgrade them. The same way we do CV ES and other pieces of software, we actually released a bunch of blog articles on everything in this category recently that you may want to check out. Um And then once we have that we can start to take it to the next level. So I'll talk through just a few features that are kind of interesting that are more advanced in use case, some of them are newer. But a lot of people when I talk to them, they don't know they really exist. But the automation api now that we have in infrastructures code in any language, now we can do some cool things with it. One, what if infrastructure code was not just a cli what if it was actually a library that you can embed into a larger piece of software? That's what automation API is. So examples of things that allows you to do one, you can build self serve portals where somebody comes and clicks a button on the back end, you're actually going and spinning up cober clusters or you know, landing zone environments or you know anything really. Um In fact, we have customers like cockroach labs as a customer of ours, you go log into their product, you know, cockroach labs dot com. You say, give me a cockroach database on the back end, it's a fast product. It's spinning up, you know, using Pulumi, spinning up clusters and Gke and Eks and then deploying their software into it and then scaling it going multi to region. Um Of course, you could do that with a tool like terraform, but, you know, you'd be shelling out to a cli you have to parse the output. It's, it's very clunky and, and the failure modes would be tough to deal with. Certainly doable with Pulumi is kind of a first class um scenario and then custom tools and frameworks. Um There are actually companies out there like Firefly who um and and Nitric and others that are actually, you know, building their product using Pulumi sort of at the core. Um Plumbic deployments is a recent feature we launched. It's actually a server side execution of workflows. And the most concrete example of that is you can point us out a GRE anytime you merge code, we're gonna go actually do the auto deployment similar to how our CS CD integrations work, but just easy to use out of the box. What's not obvious though, is it effectively the server side equivalent of automation API So if you want to kick off long lived workflows that run on our servers to do things like drip protection and remediation, multi stack orchestration, like for example, say you're God forbid, you have to replace like your entire VPC or, or an entire EKS cluster and then you have to orchestrate the deployments across all the downstream dependencies. You can, that's something you can express and execute using this sort of technology. And similarly like the blue green deployments, uh multi region deployments, maybe you want to deploy to us West, you know, wait a little bit until you have some of the health metrics that are green and then graduate that to the next set of regions and maybe have concentric, you know, deployments. It's the sort of thing you can do. Uh there's a breast api and a client side interface for programming this. So again, this is this is new. So a lot, a lot of folks might not know about it and then insights actually we launched um feels like forever ago, but I think it was only three months, three months ago um which is search analytics and A I for infrastructure. So um honestly, it sounds kind of boring and yet it's such a killer feature, you know, you know, you have a log group associated with your, your data warehouse somewhere. But where like what region you know, a console is never easy to search here. You can just come here type data warehouse filter by log group, find it uh and search any cloud. So even if it's an Azure or I mean, just really easy to find things. It's also easy to slice and dice and get diagnosis or not diagnosis, but analytics. Um Like where are most of my resources? And we've had customers look at this and go into the dashboard and say, my God, I had no idea where it's so much crap just sitting over there that nobody's using. And you can see like you can actually query and say, find me all the stuff that nobody's touched in over a year and many people have been able to clean up a lot of cruft um with this very quickly and again, it supports all the cloud providers. Um The search also has this nice A I sort of natural language interface. So you can say like how many three buckets do I have or any of them un tagged? Um Things like we actually just released a property search. So you can actually query on the properties. So do I have any R DS databases running my sequel versions that are End of life like 5.6. Um And we'll come back and tell you very, you know, within milliseconds, you'll be able to find that. Yes. Question about this. How are you able to search through the states because Pulumi doesn't store a local state like that? Yes. So it's a good question uh is how do we search the states? Um Given that Pulumi doesn't store a state locally? Like terrible does and actually Pulumi does store the state on the surf, it doesn't require you to manage the state on your own. That's it. Folks may not know this. You can't, there is a mode you can run Pulumi where you can manage your own state in an S3 bucket or anywhere if you really want to. But it's so much easier to use the cloud. But because of that, the cloud actually has just the metadata. Um and we have an import feature. So you can actually, even if Pulumi didn't uh provision the resources initially, you can point to say your cloud account, we'll slurp up the metadata and now you can search over it and we're gonna make that a lot easier kind of going forward, we'll make it so you can do policies code the same way against existing resources, not just what Pulumi has deployed, but it all comes down to that metadata model which Pulumi does actually uh store on the server. Yeah. Um Yeah. Any other questions, I will save time at the end for Q and A. I'm almost done. In fact, I feel like Aaron is giving me the stare down. So I will uh wrap up. I I would say the other part of Pulumi insights that's really nice is, you know, analytics and being able to just slice and dice the infrastructure usage. If you wanna say like how fast are my cober clusters growing and how much are they costing me? And you know, you can do a lot of that sort of analysis and then the really fun feature, which honestly, this has been one of the uh fastest growing features that we've ever launched in terms of usage. I will say there's like a I in the air these days. So it's probably no surprise, but this is actually genuinely useful. Um You know, I, I can actually show you very quickly. Oh my God, this is like, I don't know if you can tell how tiny this is. I will do my best. Yeah, it's probably not gonna look very good, but yes, a good idea. There we go. Ok. So there's a new A I assistant that we launched, um again three months ago and you can basically pick, you know, any language. Uh And then you can ask it to, to do something. So I could say give me an Eks Cluster, um that uses with a Helm engine X chart installed into it fronted by a cloud flare CD M. Sounds fun, right? And I'm just confident it's gonna give me something and it often is very good. The reason it's good. Um The sea here, some of these things are deep links. So, um, we've actually taken GP T uh four. You can actually select which model you're using down here. We've taken GP T four, we've actually extended it with custom bettings, custom embeddings, um and, and hooks so that we can use, basically send its trading model based on the Pulumi registry. So we actually feed it all the schema scheme information, feed the information from the Pulumi documentation, all of our examples. And as a result, it will um make things, you know, a lot more reasonably. Uh well, it says it and the thing is it will refuse to create things, it doesn't know how to create as well. So, you know, that the end result is, is gonna be reasonably complete. Um And then, because we're absolutely nuts, we create a command line version of Pulumi A I that not just C does not just generate the code, but it will actually go out and create the infrastructure as you're typing. So in this case, I said, hey, give me an S3 bucket. It said chugged away and said, OK, here's your S3 bucket, here's his name. Now we said, hey, look at an index file that says hello world in three languages. It's gonna go create the E S3 object that contains, you know, the, the content and went deployed it. And now we asked for the URL back. So it's, it's hosting a, a static website and the S3 bucket gave us the URL. And the interesting thing is if it makes a mistake, you can actually fix its own mistakes as well. Um So in this case, it gave us an undefined for some reason, but now we have this, this nice website that it just created. Uh And we said Hey, it's kind of boring. Can you add some color, please? I said, all right, no problem. We'll add some color and then uh we the index, we refreshed, got some color and then we can get the code. So we say that uh Bang program and it gives us the actually the full infrastructures code that we just generated. Um obviously not something you're probably gonna do like in production, you know, unless you, you enjoy YOLO in production. But, but in terms of just rapidly, it like you have an idea, you want to create a service that does a thing, it's really productive to, to start that way. So anyway, I uh that, that's it for, for me today, I think like fun, powerful, productive. We love making things more fun and I think being able to use great languages and great ID ES is definitely fun. But as you've seen, there are some really advanced scenarios where you can build bigger things out, smaller things, um do more with less and then A I just kind of takes it to the next level. So, oh, well, of course, from Buried in Crummy, DS L and Yaml to Lovable cloud program. So uh thanks, I'll happy to take a couple of questions soon. I do hope I, I get bonus points for adding cowboy hats and yes, I have question. So in the past, uh for instance, we have a similar who can precipitate here by Aws they use inside and outside, they have a back up for multiple languages. So one makes different from the other. Yeah, it's a great question. So the question was, um, you know, there's CD K from Aws and then there's the CD K wrapper on top of Terraform as well. Um, yeah, I, I will say, you know, we're flattered. I, I think, you know, we, we had come out confused before CD KTF, but I think the real answer is CD KTF is sort of a, a bolt on afterthought. And I think if you sit down and actually use it, you will feel that there's an impedance mismatch between the way that the engine works, which is in terms of HCL and the way the sort of transpire works, which is the CD K interface. You know, I think you, you frequently find that you're debugging issues at the level of HCL when in fact, you wrote code and maybe Python. Um and it's just a lot of things about the experience that are not first class, a lot of the examples are just not there. Like you look at terraform. All the examples are H cli think Corp is sort of invested in HCL as being their brand, which makes sense. Um And that may change over time, but it has not yet. And I think even the CD K home page when you go there, it sort of says like not supported for production use, which I think is a testament to it's still early days for that technology that said honestly, it's great to see others viewing the the future of infrastructures code similarly to how we do, right? So it's not that we're anti CD K or anything. We just find that if people enjoy that way of doing infrastructures code almost universally, they prefer, you know, the the experience of using tool anymore. Yeah, the uh the experience of the story, the story with respect to like multi tenant for customers. And as an example, um our product deployed uh we call it on but the customer and they give us to modify their infrastructure. Um What would that look like if we wanted to do that with careful right now, how integrated with that the cloud accounts or that's a great question. Actually, we have a lot of customers who do that sort of pattern. So, you know, like Pat Panther labs is a good example where they're actually managing cloud resources on behalf of the customer. Um often in their cloud account, I think the Pulumi model of projects and stacks is very flexible. The idea is you set up a project project is the code come and set up blueprints. And then a stack is one instance of that project and you can have config the config is basically elements of that stack or that project that are gonna vary per stack. And so oftentimes what people do is have like a stack per customer. And each stack can have its own, let's say eight of credentials or eight of his profile or uh and then within that, you know, let's say one customer has 10 instances and one, but the other has five instances, you can easily say Pulumi, you can fake set instance, count 10. Pulumi can fix that instance, count five. And then you would see those all in Pulumi cloud. You go to your dashboard, you can easily see your customers, right? So a lot of people will name the stats based on the customer they represent. Um And then the nice thing is it's really easy to switch between stacks and then iterate and diff them to see like what's different between these two stacks, especially in the config we actually have a a panel that will like show you the the config drift to make sure you're not unintentionally drifting between customer stacks. So it's very, I think you would find that it's very natural with. Yeah. Yes. Yeah. So build the infrastructure and when you want some part of infrastructure, you have infrastructure. So there is a uh uh to make uh infrastructure, we need to not only have infrastructure but we have to uh a tool to build the images to contain the image and real images, how support imaging and, and water maintenance. Yeah. So the the question um just to repeat for. So it was on the audio is um you know, infrastructure is code is one element but building publishing container images and I presume VM images as well is another key part for we we integrate with a lot of different tools. So for example, um we do integrate with we have a Docker package where you can build and publish a Docker container image within your Pulumi program. So you can say here's a container image build and publish this, do any doctor container. Uh and it works great with like provision an ECR registry or something build and publish a container image, publish the er registry. The next time if you change the doctor file, you just run, pull me up again, it's gonna diff the detect the diff in the Docker file or build the container image, get the new shot hash push that to the new container registry. So that's the latest. So that workflow is pretty um nice out of the box. Uh for for VM images, there's a variety of ways to go about it, but like Packer is one that I know a lot of people use. Um We do support things like answerable integration. So if you're gonna, you know, if you're gonna use a config a tool like answerable, there's a way to say provision an EC2 instance and then run some answerable playbooks, you know, after provisioning it, for example. So we have a lot of options depending on the specific details. But that's definitely I agree. It's a key part of the, the story. Yeah, good. All right. Thank you, everyone and keep.

---
