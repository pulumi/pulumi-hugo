---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Policy as Code with Cameron Stokes | Modern Infrastructure Wednesday 2020-03-25 (MIW 2)"
title: "Policy as Code with Cameron Stokes | Modern..."
meta_desc: |
    In today's episode, Lee Zen chats with Cameron Stokes about using Policy as Code to ensure that deployments meet organization expectations.
url_slug: policy-as-code-cameron-stokes-modern-infrastructure-wednesday-20200325-miw-2
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Policy as Code with Cameron Stokes | Modern Infrastructure Wednesday 2020-03-25 (MIW 2)"
  description: |
    In today's episode, Lee Zen chats with Cameron Stokes about using Policy as Code to ensure that deployments meet organization expectations.  Code for this episode available at: https://github.com/pulumi/pulumitv/tree/master/modern-infrastructure-wednesday/2020-03-25/aws-ts-webserver  The examples are in TypeScript but Pulumi makes it easy to stand up infrastructure in your favorite languages including Python, JavaScript, Go, and .NET - saving time over legacy tools like CloudFormation and Terraform. https://www.pulumi.com/docs/get-started/?utm_campaign=PulumiTV&utm_source=youtube.com&utm_medium=video
  sortable_date: 2020-03-25T17:49:06Z
  youtube_url: https://www.youtube.com/embed/DToFeIfO-PQ
transcript: |
    Welcome to another episode of Modern Infrastructure as code. I'm your host, Lie Zen, and today I'm joined with Cameron Stokes. Hey, Cameron, how's it going? Hey Lee doing well. How about yourself? Great, thanks. I'm really excited to have you join me today. I think we're gonna be talking through a lot of fun stuff related to policy as code. Um And we're just gonna start by looking at a uh project right here. And uh in this project, we're gonna be talking about some very basic configurations. Um You know, we're gonna start with using some aws. Uh We're using typescript today uh with Pulumi and we're going to create a very simple stack. We're going to first create a VPC with just one availability zone and a public subnet. And then we'll create a security group uh for that, for that VPC with the ingress uh for port 80. And then uh we'll create some web servers to, you know, be able to talk on that, on those ports. Uh And you know, pretty simple configuration here. Um We'll have a certain number of instances based on some config we import uh from a different file uh but you know, let's, let's just see how this runs and while this is running. So right now we're previewing an update if, as if we were to uh deploy this. Uh So while this is happening, Cameron, and I guess, you know, the question I have is how do we make sure that, you know what we're gonna deploy is actually gonna do the right thing in terms of not violating any policies we might have as, as an organization. Yeah, so we can uh do some pretty basic things like I've, we've already done in this code which is like setting a, a common set of tags as in base tags on line 10 there that we then reuse across our VPC and security group. Um That's one way to kind of get consistency across resources, but it's really easy to, to just omit that or to omit the, the stack uh tag as a part of that and um violate those policies that you talked about. So really what we want to do is use plume's policy code feature to enforce that uh certain properties of our resources are are there and there's such certain values and basically just uh kind of put some compliance and governance in place uh using policies code. Awesome. So if we look at this preview, you know, it looks like it would have created, you know, these three instances along with the security group and the VPC, along with all the related uh routing that we talked about earlier. Um So why don't we try to get some policies in place? Um It looks like we have a handy file open here already. Cameron. And uh do you want to walk us through this? Yeah. So this is uh one of our uh policy packs that is actually configurable. So, within this, we're gonna check for a few or rather two different um uh kind of checks or policies within the stack and uh the configurable, meaning that we can have different config values set for different stacks. So in this case, we're gonna check for um the particular instance type or the class of instance types that are used for our EC2 instances. And we're making the allowed instance classes value configurable. So down on line 20 you'll see where our, our policy check or our function actually begins to, to do that check. So on line 21 it's gonna pull in that allowed instance classes config value uh the, the value of this is gonna be like T three or T two or C five and so on, it's gonna be a, an array of those and then on line 22 and, and the next year after that, it's basically gonna check that our instance type uh is of one of those instance classes. So uh for instance type is at the T two T two medium check that it's of instance class T two based on the config value. Uh And if it is not report a violation and say that our instance type is not of allowed instance classes, the next policy down is going to check for the maximum number of instances in this stack. So again, we have a configurable value value that actually has a default in this case of five. And then uh online 40 is where we're actually gonna do our, our policy validation or policy check. Uh And this case is actually acting on the entire stack. So not just a, a single instance or single resource type as in the previous one. So it's basically going to do a count or do a filter for a type of A S EC2 instance, define the total number of instances and then just compare that to that maximum instance count. Got it. And so, you know, in one case, I'm validating stack. In the other case, you know, I'm validating resource as we saw earlier uh for the EC2 instance types. Um You know, what are some scenarios where I would want to validate the stack versus just validate the resource? Yeah, the, the main difference is uh so online 20 where you're validating uh an individual resource or you're, you're specifying the resource type that you want to check so that validate resource of type A BS EC2 instance. And then when Pulumi policies code implementation runs, it'll basically it over every uh resource in your stack. And if it is of type A B EC2 instance, pass it into this function to do that check, validate stack. On the other hand, gives you the entire uh list of resources in your stack so that you can do like aggregate checks. So in this case, we're counting the number of instances to be able to compare to our maximum instance count um config value. Uh Another use case for validate stack is um doing cost estimation. So in a similar manner, we could basically filter out all the A S EC2 instances and then do a cost estimate based on running them for an entire month and then add that up over uh the course of a month effectively and get that estimate and then compare that to a budget is another another use case for doing a value stack call. Got it makes sense. And what if you know, in both these cases, we actually have some configuration values either defaulted in or um you know, we're passing them in uh to the policy. What if I don't need, you know, any kind of configuration whatsoever? Yeah. So there, there's a um uh call it a regular policy that you can write that actually doesn't have any configured values and that can just kind of do more static or hard coded checks. So uh in the file that you're about to open when you do that uh across a number of different policies to check for um uh certain properties on the resources themselves. So like in the first one, where uh the name of this policy has discouraged EC2 public IP address. Uh again, we're doing a validate resource checks or just acting on a single resource type in this case of uh a of EC2 instance. And then we're checking that the associate public IP address property that has been set in our code uh in our actual plumbing project um is not set to false uh or rather is set to false. Um And based on that, we're going to report a violate violation, that associate public IP address should be false. And in this particular uh policy, this one is set to advisory. Whereas in other policies down below, you can see that this enforcement level is set to mandatory. The distinction there is that if a uh violation is reported on a, on an advisory policy, it'll print a warning, but it'll actually let you proceed with that deployment and proceed with that with that up uh for a mandatory violation that is found it, it will actually halt and print you that warning, but then not let you actually proceed uh with continuing with that deployment. Got it cool. Um Looks like there's a couple other uh policies here. Let's try running this uh with the policy pack so we can oops I can't type. Yeah. So, um what you're doing now is, is just running that preview with the, the kind of more like static uh policies as, as we described. So the ones that are are currently on your screen, um They're also going to check for like ingress rules on uh security group. So in our case, a security group is set to uh allow from a private network space. So we actually won't see a violation for this one because it's checking for public internet access. Um uh but we, you can see for the violations that were printed here. We do have associate public IP address set to false and it's reporting a violation for each instance that was found to have violated that in our stack. Cool. So let's try, I guess turning that off and we can see what happens. Yes. Is that the F and we should see that uh that violation go away. And so while this is running, you know, you talked about advisory versus mandatory, you know, what are some use cases where you would want to have the, the mandatory check? I really get. It's like, hey, let's just not do this. Where does the advisory check come into play in your mind? Yeah. So um uh kind of along the lines of like the instance class uh policy that we talked about before. So let's say you um uh you know, might want to allow larger instance classes for specific projects, but you still want to warn against them, right? You know, some of the the instance classes or instance types at Amazon and Google and, and a and so on can be quite, quite expensive, quite costly. Um But again, there might be case for them. So you could check for that. Another uh kind of use case for advisory is if you're actually rolling out new policies to your team, uh you want to give your team time to adapt and kind of incorporate those uh those new policies into their um into their code. So let's say you want to put in a new policy for, you know, three months from now. Uh you can set that policy to advisory in the message on the policy itself. You can say, you know, this will be set to mandatory as of uh July 1st and now you're, you're giving feedback to your team, you know, every time they do deployment that they need to go ahead and incorporate that into their uh into their project and then come July 1st switch that over to mandatory and now it's required and it is enforced uh across all your stacks, right? That makes sense. Yeah, that makes sense. I mean, you wanna give people time to respond, right? You can't be so heavy handed. Cool. Um Should we try moving some of these base tags like, you know, to see what happens then? So we talked about how um uh those tags are required. So we actually, I, I should mention so the earlier one, we can see was clean. Uh because we, we actually uh turn that, turn that flag from two to false. Oops. Oh, I think is it because uh so the policy is actually only checking for tags on, on instances in this case? Yeah. Yeah. So if you, yep, go down there and move it. So this one's a bit more complex because if I remember right, it's checking for a, a name tag, a project tag and a stack tag. Um And so we should see three violations for each instance. And in this case, we're, we're provisioning three instances. We'll see uh uh several uh violations reported here. Right. Right. And we're not just checking that exist. Uh in this case, we're checking the value as well. So we want our project tag to be set to our project name and want our stack tag to be set to our stack name in this case DEV, right. So we can actually have some pretty complex rules in here. Um as we saw earlier where it's, you know, you're actually doing, you know, using real code to check uh these kind of conditions. Yeah, exactly. Right. And, and based on the stack name, the, the uh check is, is different, right? It's checking for uh stack is at the DEV or if you're on your stack or we would check that stack was at the OK. So I put, I put that, I put this, these, these tags back in. So we won't get that policy violation anymore. Um Should we talk about a little bit about how, how, how to run the, uh, the configuration based uh policy packs? Yep. So I earlier I was doing, you know, this, but now we wanna also, we wanna run the config based one. How do I do? I, I, if I recall correctly, it's like this, right? Um And, yep. And now you're gonna pass a JSON a path to a JSON file that has the config configured values in this case. Yeah. Uh Let me see what stack I was on. I'm on DEV, so do this and let's take a quick look at this while that runs. So yeah, yeah, earlier we define these, right? Yeah. So uh this is based on the, the policy name. So like allowed dash instance classes is the policy name and then allowed instance classes and camel case is the actual uh config uh variable name essentially that we're gonna set. And in this case, it's an array whereas the maximum instance count is just uh in integer, right? So if we go back to this code, uh here we have this integer like you just talked about and this is this is that name, uh or sorry, this is that name. And then uh up here we had the allowed instance classes where it was an array. OK? That's pretty, pretty uh pretty self explanatory, I guess. Um And it looks like we violated that. So, if I look at my config here, I guess I have three instances configured and, uh, I guess that's not allowed. Cool. Um, so we can actually just switch stacks, I guess. And so I can, I can do the same thing and just really just change, change the, the configuration I'm running against. Is that kind of how you would imagine this working in practice? Yeah, that's exactly right. Is, uh, you can um based on the stack that you're working with in this case, prod use a prod a set of configured values for the, the policies in this case. Cool. And so in this case, uh if I look at my config I have still three, but now I have a different instance type. And uh in the prag case, you know, these are allowed and I'm, I'm within, I'm well within the maximum instance count. Yeah. So just, just to kind of see, see the, the full picture, if you were to change your instance type from C five large to T two medium, uh which is what our DEV value was and rerun it, you'll see uh a violation of, of that particular policy. No, uh it just type. Yep. So in, in this case, the the kind of real world uh usage of this would be to enforce um that you're using kind of, you know, less expensive uh instance classes and in your DEV environment or in your non production environment. Uh But for your production environment where you have, you likely have higher usage, you have more users, you have higher load, you need to use kind of more optimized um uh instance types. Uh You can set uh you know, a policy that allows those higher classes or higher instance types uh in production as an example. Awesome. And so you know, we ran this, we ran this set of configuration based policies. Uh We also had the non configuration based policies earlier. Can I mix and match those two kinds of policies together? Yeah, you, you absolutely can. So uh when you're specifying the policy pack flag, as well as the policy pack big flag, they just take uh essentially an array or a list of uh of packs and then of config um so yeah, just do comma policy pack or policy code, right? And since that one doesn't have a config value or configure path. Yeah, you can just do a comma there. Yep. And so I think if I recall correctly, we, we had all passing on the second set of the second pack. Um and we should fail the first pack and then if we fix uh if we fix our configuration, that's I don't know what type of A BS better. So this should, now, I should be, I should have, you know the correct configuration now for going into production. Yeah, exactly. Right. And, and uh in this case, you're in plum preview. So it just, you know, ends and, and exits and shows that you have a clean preview. Uh, if you run a plum me up or Pulumi update, it would actually allow you to then proceed, uh, with, with that deployment. Whereas if you still had violations that were set to mandatory, it would exit and tell you, you had to essentially had to fix those before you could continue. Awesome. And one thing we guess we haven't talked about is how do I share? You know, I, I have this, I have this policy on my, on my, on my developer box. How do I share this policy with the rest of my, my team? Yeah. So like you said, what, what you've seen so far is running it from, from your local machine and, and referencing that local policy pack um through the Pulumi console. So through our, our A S platform, effectively, you're able to publish these policy packs and also set the config values into the Pulumi console. And from there, you can actually set organization wide uh policy and, and pick and choose uh this policy pack to apply to dev with this particular config uh set in it as well as we showed here. Uh But then also have the same policy pack, but with the production or the pro config sets to apply to your prod stack. So through the consoles where you're able to get that organization wide uh um application and enforcement of policy. Awesome. And then when I run it next time on my desktop, I'll get those, I'll get those configurations. Yeah, that, that's exactly right. So, uh if, if um you publish those to the console set the configure value and then enable it for your specific stacks, the next time you run a pluming preview without all those policy pack, flags and arguments, uh It basically handshake with the console effectively and then download that policy pack and run it uh in the same way as you saw before. But now without you having to remember to, to pass those flags and, and get it strong enforcement of that. Awesome. Well, I feel a lot, you know, more safe uh knowing that uh we're doing the right thing here and that we have our, our stacket figure correctly. So thanks for walking me through this camera. This was, this was super helpful. Yeah, you're welcome. I enjoyed it. Awesome. Well, hopefully, uh we'll see you guys next time on modern infrastructure as code. We hope you enjoyed this episode about policy as code. And yeah, we'll see you next week.
---
