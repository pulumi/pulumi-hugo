---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Cloud Engineering Summit 2021: Developer-First Infrastructure"
title: "Cloud Engineering Summit 2021: Developer-First..."
meta_desc: |
    Listen as Joe Duffy leads a talk about Cloud Engineering with special guests Ken Exner and Luke Hoban. Joe discusses how he thinks of the cloud as ...
url_slug: cloud-engineering-summit-2021-developerfirst-infrastructure
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Cloud Engineering Summit 2021: Developer-First Infrastructure"
  description: |
    Listen as Joe Duffy leads a talk about Cloud Engineering with special guests Ken Exner and Luke Hoban. Joe discusses how he thinks of the cloud as the a giant super-computer and dives into each component of the cloud operating system. Then Luke will talk about how Pulumi makes authoring cloud components easy and gives a few examples of Pulumi's Multi-Language components. Finally, Joe and Ken discuss how customers are currently using the cloud and how they both envision the future.  Talk by: Joe Duffy, Ken Exner, and Luke Hoban
  sortable_date: 2021-10-20T22:59:30Z
  youtube_url: https://www.youtube.com/embed/SQRM0r5U1js
transcript: |
    Hi, everyone. My name is Joe Duffy, founder and Ceo of Pulumi. I'm here today to talk to you about something we're really excited about uh that we're calling developer first infrastructure. And to get started to set a little context, I want to start by talking about the modern cloud. Uh It's no surprise to anyone here that the modern cloud is very complicated. Um But with that complexity comes a lot of exciting benefits. Um But, you know, we're shipping code faster than ever before today. We got more moving pieces than ever before. We're really talking about distributed architectures. And that's actually one of the themes of the talk today that I'm really excited about and why bringing the cloud closer to developers is so exciting. But the fact is between Aws Azure uh Google cloud, you know, there's hundreds of building block services in each one of those that can be stitched together in infinite ways to build powerful software. There's vendors like Cloudflare and Snowflake, um many, many others that are introducing their own cloud services that are exciting as well. And then we've got the whole cloud native ecosystem with, you know, a new project seemingly launched every week. Uh It used to be that there is a new javascript framework every week and now we have a, a new cloud native tool every week to stay on top of. It's a lot of moving pieces. A lot of, you know, complexity in how we're, we're building a shipping software these days. And, you know, if you're a developer, your background is being a software developer like mine uh is then infrastructure might seem boring and tedious. In fact, there is sort of a meme that infrastructure should be boring. Should it really, is it actually tedious? Does it have to be I think a different perspective is that cloud infrastructure is really the essential building block of our modern application architectures. Um That sure maybe setting up a network or a Kubernetes cluster that should be quote boring and left to the experts who are the infrastructure experts who are gonna go make sure that's secure and reliable and, and cost effective. But what about, you know, a ac function is that in the infrastructure domain or is that in the application domain? I'm going to argue today that it's a little bit of both uh and that developers really should care about some of these things, you know, pub subtopic A Q um A lot of these are essential building blocks of building distributed applications and that's really exciting and that's, that's something has changed over the last 10 years. I would say 10 years ago, the conversation is more about, hey, let's provision through virtual machines in a database and sure infrastructure was relatively boring back then. Uh But the world of modern cloud has really changed all of that the way I think about it. And you know, the context for today's talk is, you know what if we reimagine the cloud as effectively a giant supercomputer that's planet scale infinitely scalable uh that's compute and storage available to us on demand as our application architecture evolves and as our application becomes wildly successful, and we've got, we go from, you know, tens of users to thousands to millions of users, you think of, you know what it takes to run lift. For example, uh a lot of these modern companies that were fortunate enough to be born in the cloud are actually using the cloud, using this giant supercomputer to fuel their business and really fuel the innovation. Um And as a developer, the same way, you know, I'm writing software that runs on, you know, an Intel PC, you know, back 15 years ago now I'm writing code that runs on this huge computer. Um And arguably the cloud has become a bit of, you know, the operating system because there's a software component sitting on top of the supercomputer. And as a developer, this is really exciting, you know, this this goes from infrastructure being this boring thing that's an afterthought to really being part of an applications architecture, I think of for many decades, we was talking about the age of distributed computing. Uh in fact, in the fifties and sixties, there were tons of papers and interesting research done around, you know, communicating sequential processes, which by the way is the foundation for go concurrency model. You know, a lot of these pieces have come together. Finally. Um I think a lot of folks predicted it would happen sooner um when we went through the whole multicore transition, which led to concurrency and AYC programming. But now what we're seeing is thanks to the cloud, the age of distributed computing has actually arrived. And that's a very exciting thing. The challenge is how do we tap into all that capability? It's not always easy, you know, the cloud is complicated. Uh We're waving in tons of yam and um you know, there's sort of a missing programming model. And so to, to take us into the, you know, solution to that problem. Let's, I'd like to demonstrate an analogy in three parts. First of all, you know, me, several decades ago, we went from writing assembly language to higher level programming languages like C FORTRAN, Cobalt, et cetera. Um Obviously, we've come a long way since then, but this is a huge revolutionary change in enabling people to focus on building better software, being more productive. It almost sounds funny in hindsight now, you know, many decades later, but actually writing in cu is way more productive than writing an assembly language, you know, fewer bugs. Um, you just get more done. Um, you know, 10, 10 X the productivity, right? Um And that was a huge change in our ability to build this software ecosystem. You know, arguably Microsoft wouldn't exist. Amazon wouldn't exist, none of, none of the current industry leaders would exist if it weren't for that innovation. And then we didn't stop there. Right? We kept going. So we went from writing C which is a relatively low level language. You know, C's goal was to expose the underlying capabilities of the hardware directly to the programmer. And for good reason, C was used to write operating systems and the runtime themselves. I'm about to talk about. Um but that wasn't good enough to fuel sort of the next several decades of innovation, we had to increase the level of abstraction even further. And so we came up with things like Java um and javascript uh with, with no Js eventually, you know, coming on the scene and, and, and Python go dot net, you know, there's a lot of a lot of things I could have put in this category. But here are some of the, you know, things that come to mind when you think about higher level programming languages, some higher level than others, some dynamically uh uh type checked, some uh statically type checked. But the key here is we kept increasing the level of abstraction. So that developers could focus on business logic, could focus on what matters for the problem they're trying to solve and not swizzling bits and bytes. Like in, in C, for example, of course, plenty of people to write code and C envoy is written in C++ because you know, the developers there really wanted tight control over performance and, and the, the key here is we've got a lot of different tools in the tool belt that we can choose from. One key part of this that I think I wanna highlight that. I, I hope folks keep in mind as we go through the rest of this talk is some of these are multi operating system technologies, java. Although yes, it works on Windows, it's not window specific. You can run Java on the server. In fact, that's one of the reasons it became very popular in the early days was you write serve letts in Java and you could run it on the server. This is around when the web was emerging, right? Um And you know, Python, you can run Python anywhere. And so that leads to the next analogy in the final part in this three part series is the cloud really has become the new operating system. And there's a software fabric that sits on top of the hardware that we're now targeting with our software so that we don't have to be always experts in the underlying bits and bytes of the cloud. And you know, this architecture diagram on the left is Windows NT on the right, we've got Kubernetes, which arguably has become the standard scheduler for workloads in the cloud. Um Obviously, it doesn't cover everything that you do in the cloud. And so the, the analogy is a loose one, we don't really have that one diagram that, that works anywhere. But, you know, we've got lots of different operating systems too. We've got Windows, Mac Os X, uh Linux, etcetera. Um And so I think the, the reason for highlighting this is just a mindset shift. It's a shift in thinking about the cloud is just a container of compute that runs my code to an entire ecosystem of building blocks that I can use to build powerful software. And that mindset is, is why we found a Pulumi frankly, but it is really exciting and uh that's, that's the, the pre prelude for the rest of the talk. Um Infrastructure's code is, you know, what we ended up building with Pulumi. Um But unfortunately, infrastructure is code today is, is uh largely yaml domain specific languages. It, the analogy here is, you know, I think back to the assembly language to see um transition that I highlighted earlier. Um a lot of the configuration management uh techniques that we use today treats the infrastructure as though it's an afterthought. It doesn't embrace sort of this new world view that we just covered. Um So, even though it's called infrastructure as code. It's typically not, it's missing a lot of the capabilities that we think of when we use the term code, it's text so we can version it, we can check it in it's repeatable so we can effectively execute it, which leads to sort of a code analogy, but it's definitely a loose analogy. Um to say that it's code, what we're seeing now is this transition to infrastructure software, which is think of all these cloud services that we're configuring using infrastructure as code as compos building blocks. Um You know, really take the that three part analogy that I was just covering and take that to the next level. I think, you know, I mentioned we at Pulumi built in infrastructures code technology. We'll be honest, we didn't know that's what we were gonna build at the outset. We had that vision of, hey, the cloud is the next operating system and is really this powerful capability. Infrastructure's code is what gives you this, this programmable abstraction and a consistent resource model on top of the cloud service model so that you can then compose all these things and use programming languages that we know and love to, to build cloud software in a more native way and bring the cloud infrastructure closer to the application architecture. And so when I say infrastructure as software, what do I mean? Well, software engineering, you know, if you're, if you're a developer means a lot of different things. It means typically you've got facilities for abstraction. Um We've got higher level languages that, that give us, you know, great productivity and expressiveness. We've got type checking to find errors much sooner in that. In that process, you get great ID es you know, editors that have syntax highlighting colorization, red squiggles, if I make a Typo, right click to ref factor all these things just built in so that, you know, the code is just there and I can get into the flow and, and really, really get my job done. Um There's unit testing and integration testing various ways to make sure the code is correct before we go deploy it or execute it uh in production um debugging. So I can interactively find errors. C I CD, all all these things that we know and love about software engineering historically, have not applied to infrastructures code. And we think that's a real shame and that's why we're excited to, you know, talk about Pulumi today. There are other folks who are doing great work here as well. I wanna call out the AWS CD K team, for example, for also seeing this, this exciting future. Um And um and but really, really excited about this next level of innovation and really up leveling our entire game when it comes to infrastructure and to show that in action, I'm gonna invite uh Luke Homan, our CTO Pulumi to program the cloud. Hi, my name is Lou Cobin, I'm the CTO of Pulumi and I'm gonna do today to talk about uh how we can take some of the developer first infrastructure principles that Joe talked about and apply them uh using a tool like Pulumi. So today I'm gonna focus on using Pulumi, but really most of what I'm talking about here will apply for any modern infrastructures code tool that's taking a developer first approach to how we think about managing and working with our infrastructure. I'm gonna start where you kind of expect for a developer first experience, which is inside my ID. And so I'm here inside visual studio code. I've got some typescript up on my ID and I'm just gonna start writing and, and programming some infrastructure. I'm programming the cloud from scratch. I'm gonna start with a really simple use case. And as we go through this demo, we'll bring in more complex uh building blocks to show you how this looks as you get to larger and more realistic applications. But to go, let's just start with something really simple. Let's create an AWS S3 bucket. Now, the first thing we see as we start typing is that we're getting that same developer experience that we're used to for an application developer. The rich intelligent the completion lists the squiggles, all those sorts of uh very quick feedback, the ability to discover and understand what's available. For example, when I type aws dot I can see all of the different name spaces that are available for all the various features that are available inside aws. There are many, many hundreds of different API S available from the A Os platform. And all of them are available here within Pulumi. I can then go ahead and say I want to create a bucket, just give it a name and now just so I have something to work with. I'm gonna export out the name of the bucket. So I'll export um bucket name, it's equal to bucket dot id. OK? So I've written my first program, let's go and deploy this and create some infrastructure. Gonna come down here. I'm just gonna type Pulumi up to update the cloud with this infrastructure. Now, one of the really important things with these modern infrastructures code tools like Pulumi is that even though they're using a programming language like typescript, in this example, they really are still desired state configuration. So when I say Pulumi up, the first thing it does, it shows me a preview and that preview tells me what changes are going to be made when I try and deploy this program to the cloud. And in this case, because I have nothing deployed so far, it knows it's just gonna need to create that bucket that I specified. I can see the details, understand exactly what's going to get created and go ahead and say yes to actually deploy that into the cloud, ok? I've created my bucket now, I might want to create additional objects. So one thing I could do is create an object, I'll call it this time instead of a bucket, I'll grab a bucket object, I'll call it orange again. And this time I need to specify some properties to indicate the details of what this thing should be. And so for example, I'm gonna say I want this object to live inside that bucket. I'm gonna say I want uh the content to be hello world. OK. So I've specified an additional property and now when I type uh pulling me up additional resource, now when I type pulling me up, we see that there's two unchanged. So that bucket that I already deployed doesn't need to be modified, but this bucket object does need to be created. So I'll go ahead and say yes to create that. Here we go. I created my addition, my second piece of infrastructure. Now, I can do say something like A S S3 LS and I can grab the name of this Pulumi stack, output bucket name and we can see that we have a single object named OB 13 bytes for hello world inside my bucket. OK. So we've got some infrastructure, we're building up something inside this bucket. Now, so far, we've just done things that you kind of expect from any infrastructures code to whether it's cloud formation or Azure resource manager or uh anything like that. So what we want to do with because we have software is really take advantage of some of the unique benefits that sort of a programming environment, a software engineering environment can enable for us. So one of the really simple ones is just, hey, I can write a for loop, so maybe I can say constant file name of. And now I use some built in libraries. So I'll read a directory off of disk to find all the different files that are available inside this folder. And for each one of those files, I'll go ahead and uh create an object. So in this case, it's gonna um be named file name and the content inside that folder is gonna be FS dot read file, sync, an impact, do join, do slash files with my family. OK? So there we go, I've, I've written some code. This is using a for loop. It's using some libraries that are available for me like readers, sync and red files, sync to interact with my environment and use the libraries inside my no GS environment. I'm taking advantage of this being a programming language and having that flexibility and infrastructure to, to work with. I can also see one additional thing which is that I get an error here. Um So I get a squiggle telling me, give me the feedback right away that I have a problem with my code. And if I look at this, it's saying that buffer is not assignable to type screen. That's because I have a slight issue here where I actually need to specify what content encoding that file uses. So I'll go ahead and fix that. Now type Pulumi up to deploy this. We see that I actually have this file called index dot H you know, inside files. And so it's going to deploy that file uh instead of the original object with hello world in it. So now we see we're gonna create this resource and delete this resource. I'll go ahead and say yes. Now one thing I'm just gonna do here instead of continually running Pulumi up and checking the preview and doing the updates that's really useful when I want to make sure I know exactly what change I'm making to the cloud. But while I'm in this rapid development mode, like I'm showing you right now, it's really important that I be able to quickly make changes, see them and react to them uh as I do. So one of the things we can do to, to enable that is type Pulumi watch and this is just gonna watch every time I save, we're gonna see uh an update deployed to uh cloud. So let's see what happens. Now, there's a couple of additional things I want to do to this. I want to modify my bucket to make it be able to host a website. In this case, I have an index document which I just uploaded called index dot HTO So I'll just save that. I go ahead and click save on my file and that starts an update down here and that'll take just a couple of seconds to deploy up to the cloud. But there's one additional change I need to make, which is I need to make the apple public read. So this can be read from the internet and I need to indicate that the content type this text html. So it will be rendered correctly by the browser. OK? So I hit save again. That's gonna deploy that I can come over here. Oh And there's actually one last thing I need to do. Export con URL, get the website endpoint. OK? So there we go. We've uh we've written some code which does a little static website hosting. We're updating that right now in just a second, this should be available. Yeah, there we go. There we go. So now we've got our hello cloud Engineering Summit. And now of course, if we want to modify this, I'll just remove some of those uh excitement from this hit, save that's gonna deploy. And there we go. Now, when we hit that uh curl end point, the object in that bucket has changed to be this one. So we would have that, you know, all those uh developer productivity benefits of being inside an ID E quick feedback loops, error messages, completion lists the ability to discover API S and the ability to quickly iterate on my infrastructure. One of the things I I wanna do because I have a programming language is not have to rewrite this code every time somebody else has probably had to sort of invent this idea of creating this for loop and reading files from a disk and creating objects from them. So maybe I want to give that thing a name, turn it into a reusable piece of infrastructure and instead of copy pasting it around, actually share it in some useful way. So the first step there could be something like I wanna say and I wanna take a bucket and I wanna take a dir. OK? So now we've made this a function and we just need to generalize it a little bit by not hard coding this folder. And now we just need to call it. So we say sync to pass the bucket in and pass dot slash files. So in our particular case, we're gonna call this function, but in general, we're gonna use this thing here. So I hit save on that. And one of the things we'll note is it's gonna start doing an update, but there's actually not gonna be any changes need to make because I just did a refactoring of my code here. This is another important thing I can refactor my code, I can be confident that those changes are not gonna make any changes to my cloud environment because I can do that preview. And now I can uh have it um be a separate piece of functionality. There we go, I've abstracted out that logic, given it a name, given it an API uh all that sort of thing and I can go further, I can move this into its own file. Uh So for example, I actually have a file here uh called sync, which has a sync folder, uh API. So I'm gonna just rename this to sync folder. That's now a reusable piece of infrastructure that I factored out into its own file. It's documented. If I come back over here, I can hover over this and see what the description of that API is. And so I've created a reusable uh piece of code and this is really what program languages and software engineering are so good at is the ability to create abstractions and reuse them. There we go. Now, I've gone in a very simple form, uh static website hosting with just creating a bucket and then syncing a folder of files to that bucket. OK? So we've started with some very simple bottoms up examples here that start from just the raw building blocks of AWS. But one of the things we've learned is about this ability to create abstractions and we really want to make that something that's available to as many users as possible. And so earlier this week, we actually launched something called the Pulumi registry. And the Pulumi registry is a place where you can go see all the various things that are available for you from within Pulumi. And so your PLU programs have access to all of these different packages and there's 78 of them right now. But quickly growing over the next few weeks and months, this package is for all the things you expect like Aws, Azure, GCP and KTIS. We looked at Aws in the last example, but for example, I can come over into Azure, I can see an overview of the package and how I use it information about how to install and configure. And then most importantly, as a developer, I can go and access the API docs so I can find things I might be interested in. Like maybe I want to know how I work with virtual machines in Azure compute, I can click on this come into the API docs and see that there are dozens of examples that I can work with in a whole bunch of different languages like typescript, Python go and C# but I can use a starting point to start working with uh these raw building blocks of the cloud, but there's not just these core cloud building blocks. There's also two additional things. One is, there's dozens and dozens of long tail cloud and SAS providers I can work with. If I want to work with A or Alibaba or, or A zero, I can work with those inside and I can get the documentation from the Pulumi registry, but then just like the sync folder API that we looked at, we also have a bunch of components and these aren't things published by cloud providers themselves. These are packages of, of functionality that's built on top of what the cloud providers offer to make it easier to work with certain parts of the cloud. There's things like EKS and API gateway, things like VPC and an Azure, quick start for container registry ge replicated. And finally, there's things like the ability to deploy some very common and useful uh helm charts like DNS, the one I want to dive into is Amazon Eks. So with the EKS package, it takes all of the complexity of standing up a Eks cluster in uh aws and turns it into with smart defaults, best practices built in a single line of code that does all the right things by default, but then offers a bunch of configuration that we can go look at in the API for all of the additional things you might want to do on top of that. So if you want to create a new ID I DC provider, if you want to um set the desired capacity, all of these options are available, but there's smart defaults and best practices defaults built into the API. Let's take a look at what it looks like to use a component like this Amazon Eks component from within Pulumi. So in this case, we looked at um typescript. In the previous example, let's show that we can do this with Python as well. And so here we just took that little piece of example code uh that was in the registry. We brought it over into our program here. And this is just a normal Pulumi uh Python program. When I do Pulumi up in this context, we'll see that something's quite different, even though I only wrote one line of code here to create an EPS cluster. We'll see that Pulumi is when I try to deploy, this is going to deploy quite a few resources. So it's gonna deploy 28 resources into the cloud and that's the component I specified. But then we see all these different Children of that component and that includes the uh EPS cluster itself inside A S but it also includes some networking uh capabilities, some IM capabilities and even some resources inside the Kubena cluster itself. So these are resources not within AWS, but actually within that knas cluster, they wanna create a config mat. And so this shows how we can mix and match those cloud providers to do that. This is really the power of abstractions is all of this logic to, to build up and connect all these different building block pieces to create that best practices. Uh ECs cluster, all of those are built into this component which was built once shared on this uh shared in the registry. And now anyone can come and use it and automatically benefit from all this without having to just copy paste that over and take ownership of it. Now, I want to actually also show in the registry, there's a link to the source code so we can come over here, see that source code in github, but actually have that downloaded locally as well. And there's two things I want to highlight uh related to the source code for that package. The first is that uh the the ECs package is actually written in typescript. And so here's an implementation of that cluster class that we just used to create the EKS cluster and all the outputs that are specified in the documentation for that. Now you might wonder we used that component from Python in the in the last demo. But here we're actually showing that it's implemented in typescript. And this is because Pulumi has made available the ability to create components in one language and use them from other Pulumi languages. That means that this ecosystem of components can be shared across the various different language ecosystems that are working with modern infrastructures code. The second thing to note is that once we define a component and give it a nice interface and API and documentation of what its contracts are for the behavior of the various different interfaces that it exposes, we can then write tests that test the behavior of that interface and of that component. And so for example, here are some of the tests that we have for that EPS component. Some basic tests that when I stand up a cluster, the cube config that's generated is what I expect. And some more complex tests that uh configure the service IP range and verify that the output is the expected values from the actual cluster provision by a these sort of tests allow us to really enforce and, and make sure we've uh we've been, we've created the right contracts for our components and that those are robustly tested on every uh commit that's merged into these components. That means that as a consumer, I can be confident that this piece of logic behaves as it's uh designed. And that means I don't have to worry about all those details of the internals of that. I know that when I use this component, it's tested and validated to make sure it behaves as expected. OK. So I've looked at two examples so far of storage infrastructure and of compute infrastructure. But there's one last one I want to touch on just very briefly and that's application infrastructure. So one of the other components that we have available inside the registry is the API gateway. So API gateway is obviously a service inside AD BS that lets me build serverless rest API S. And so with Pulumi and the AAA API gateway component, we make it really, really easy to create one of these API gateway components. Uh directly from within uh your code. And so here's the documentation for that uh API gateway. We'll just go ahead and take uh this particular example. We'll actually come over into our original uh code base here and we'll just replace this with that code. So I'm gonna go ahead and hit save uh to deploy this. We'll actually see that because I removed the existing code. We're going to delete a number of uh things that were uh provisioned already. Oh, I have some things that I didn't mean to have here. OK. There we go. Let me go ahead and set, hit save. I got that feedback. I got that error really quickly. That's good. I didn't have to wait for this to deploy. Um But now it's deploying, we actually see this is going to destroy some of the existing infrastructure and stand up the new infrastructure. So it's gonna stand up a variety of things to support this rest API as well as a number of things to support this callback function. But the interface that I specify here is really simple. I say I want to rest API and I say I want the routes to be just a single route and for that route to be the root path, the method get. And then when that, when that's called, it's gonna invoke this function F this function F is just some code I've written in line here that's using a callback function which lets me actually specify the implementation of this callback right in line. So I specify that I want to the call and then I want to return a 200 with that says hello. So I've exported this as URL again. So I can just come over here, curl that URL and point. And now instead of pointing out the S3 bucket which has now been removed, it's pointing to uh this function that I've specified in API gateway. So a really simple way to build up sort of servers applications by using these higher level building blocks that are available inside the ploy registry to do things like Sulo an API gateway rest API. OK. So I've seen several examples of how we can kind of use something like pluming. But really these come back to all these examples, lean on the ability to use programming language capabilities, use software engineering capabilities to get developer productivity within the ID, to create abstractions within functions or libraries or packages or versioning. And ultimately to work with the entire breadth of the cloud from a Azure DC P and to a wide variety of components built on top of them. That's it for me. Thank you back to Joe. Well, thank you, Luke. That was super exciting. I think it, you know, it's one thing to talk about it and it's another thing to see it in action. I think that was a really great demonstration of a lot of the concepts of really going from infrastructures code to infrastructure software and giving us a way to go from being buried in Gammel to programmable building blocks and reasonable architectures. So the technology is one thing but really this idea of getting developers more in the driver's seat, really empowering infrastructure teams to go to the next level goes well beyond just the technology. Uh I think, you know, the infrastructure of software approach is is necessary prerequisite but not sufficient on its own to do what we're calling cloud engineering, which is bring the cloud closer to developers, bring great software engineering practices to infrastructure teams break down the walls between two the two sides of the house and let people really collaborate at an at an entire rapid new uh pace of productivity and to talk a little bit more about that. I'm thrilled today to have Ken Exner the GM of developer tools from Amazon web services here to chat with me a little bit about the role of developers in the modern cloud era. Thanks for being here, Ken, of course, good to be here. Thank you for having me. Yeah, I um love to hear just a little bit about kind of what what your role at AWS is and then we'll jump into some fun topics to, to chat through together. Sure. Um So I manage uh developer tools for AWS uh sort. We have a portfolio of products um that uh are targeting developers and making uh their lives easier and developing on Aws. So it's everything from infrastructure as code tools like cloud formation and CD K uh to the sdks and CLI that developers use to um services like amplify uh appsync, uh the code services cloud nine. So a big portfolio of tools and services for helping developers be productive on Aws. Awesome. Yeah, it's always fun to chat with a, a fellow developer, productivity and developer tools. Uh Nerd, it's frankly what gets me up out of bed every morning? So great to have you here. Um Yeah, maybe to kick it, kick it off. I I think, you know, we're seeing much more of a transformation in terms of the way that developers and infrastructure teams are working together. And I'm, you know, I think one of the catalysts for that is sort of the modern cloud architectures, you know, this move from monolithic simple applications to more distributed architectures uh which is frankly really exciting for for developers. Um Talk me a little bit through why does the modern cloud change the way that we should approach how we build software? Uh Sure. Uh So I think um a lot of the traditional architectures are based around this monolithic uh uh application architecture where you you have a server. And your goal as a developer is to get software onto that server. Uh You know, one of the things that has happened with, with modern architectures is um while we made it a lot easier to operate these things. We've also introduced a lot of complexity and sort of the distributed nature of these things. So if you look at a typical modern architecture, um you no longer have to manage these servers, you know, have to, you know, we create this server, this environment, we created a lot of these uh capabilities that make it easier for developers and operators to, to use these pieces, either for managed services or you know, using container environments. But there's a lot of moving parts. Uh So you know, a typical application, modern application will be sort of a uh a dance of, of micro services and managed services. And maybe you're using um some server services from AWS, maybe you have some distributed um you know, some distributed uh uh micro services are part of your architecture, you have different data stores. So it's become sort of this, this uh network of all these distributed pieces that uh a developer has to think about. And um well, I think one of the things that I wanna see us do better as an industry is is get better at making people productive in this, in this distributed architecture. It's a lot easier to operate. You're able to, you know, get a lot of uh benefits from uh from being able to use all these managed services. But how do you make it easy for developers to develop against that? I think is, is the challenge, I think Pulumi and Aws C is sort of the next thing in productivity we need to make that easier. Yeah, absolutely. I, I still remember, you know, frankly this is sort of the era that I think Aws was born out of. But, you know, back in the early to mid two thousands, I was working at Microsoft and we had all these XML web services and, you know, uh distributed architectures. But, but really the the the world today has come so far beyond that where um you know, the systems are much more loosely connected. Uh we're shipping different pieces at different rates. Um Why is this, do you think exciting for developers and, and how do you see their role in creating developing, maintaining these more distributed architectures? Well, I think this is sort of the entire story of devops, right? It's the developer is now part of the story uh in defining infrastructure, the line between infrastructure operations and development has become much blurrier. Uh Developer typically has to, you know, manage infrastructure as well. Think about infrastructure, sometimes it's as little as you know, they they may be responsible for, you know, creating their own containers is that infrastructure is that operations, it's a little bit of both. Um At the same time, you're seeing it and sort of traditional um uh operations folks have to pick up development responsibilities. So, you know, typical uh cloud center of Excellence or it shop is is starting to pick up development responsibilities as well. And so the line between uh developer and operator has really, really, really become blurry and something that most professionals who work in this space typically have to wear both hats, at least some, some part of the, some part of their time, they have to be an operator and and a developer and, and think like both personas and what, what is the ideal interface between the, you know, the, let's say operations and developers is it, is it code, is it point and click? Is it ticketing? Is it Kubernetes? What, what are you seeing in your customers? Um Well, I hope it's not ticketing. Um I, I think, I, I think um I think the space that we both uh play in sort of infrastructure is code, application code. Uh I don't want to get into a debate about declarative versus imperative languages but uh having, having an artifact that is sort of the the contract between infrastructure and uh application code. I think that's the right answer. Uh You know, the infrastructure is code uh space, whether it gets realized as declarative or imperative uh languages is, is, is sort of the, the way to, to think about your infrastructure. Uh It's the way to sort of reason about your infrastructure, it gives you something uh you know, that can be version control, that can be uh that can be code reviewed. Um That can be used to sort of describe your infrastructure at any point in time. You can recreate your infrastructure from that definition. Uh I think these are, these are important um improvements in how we think about uh how we think about manage uh our applications and, and and our infrastructures being able to put it into code that that can, that can then be um you know, all the benefits of code. You can, you can reason about it like code, you can do a dip, you can do a code review, you can version control it. All these things that are super important, important that have made developers productive. You've taken that to infrastructure and you know, given the power of code uh to your infrastructure management, I think it's a big important uh movement in how we uh how we manage our infrastructure as a as an industry. Absolutely. I mean, once you do infrastructures code, whether it's declarative or imperative, you have a artifact, you can version it, you can bring a lot of the lessons learned that we know about software engineering. You now apply it to to infrastructure. Yeah, and I I think it's it's very, very important not to try to boil the ocean. 11 of the benefits is a lot of these infrastructures code tools do have ways to integrate with existing resources. You know, I I think it's, it's easy to, you know, generate some cloud formation from your existing resources or just pick, you know, specific pieces to modernize one at a time. Um So that's really, really good advice there. Um I think one of the things that, you know, languages and code gives us, let's say, is abstract, abstraction, encapsulation, the ability to build bigger things out of smaller things. One of the thing that always struck me and resonated with me about the AWS platform in particular is you've got hundreds of building block services um And you can stitch them together in infinite numbers of ways to create infinitely, you know, rich and capable um cloud services uh out of these different building blocks. It can be daunting though to, to understand the proper way to configure all these things. But with code, we can now begin to uplevel the, the level of distraction that we're programming against and think about entire systems or entire architectures, not just the building blocks are you, you know, where, where does this all go from here? Are you excited about that uh capability? Um I think what you're sort of describing is sort of uh the history of abstractions and software like software is, is an evolution of abstractions you're trying to build on previous abstractions. EC2 is an abstraction uh of, of a server, you know, lambda and further abstraction. So what you're seeing is, is just abstraction being built on top of abstraction on top of abstraction. And I think you'll, you'll see that continue to happen. Uh One of the things I'm excited for in Aws is making it easier for people to start using, you know, the 200 plus services that we have. How do you, how do you create abstractions that uh allow people uh to be more productive at a higher level than, than the lower level building blocks. It's important that we provide lower level building blocks, but also that we start going higher and higher and making it easier for people to uh develop. Um in particular use cases. Typically, this is, you know, um around a particular uh types of uh use cases like it, maybe someone wants to build um uh a front end or, or mobile application. Uh So we start developing abstractions like amplify an A to B that allows you to uh work at that level of abstraction rather than at, you know, the API gateway lambda levels of abstraction. So I think um we'll continue to see more and more of this, you know, trying to push it up um And make make sure that uh people can be more productive at higher levels of abstraction. Um I think with Pulumi uh as well and in some of the infrastructures code, there's an opportunity for us to do things there as well. Um You can define uh an AD BS resource or you can create higher levels of abstraction. Um Like maybe uh you would create uh an SNS uh resource or an SQS resource. But if you combine them together, you create a higher level component resource, you can do PUBS sub and that new abstraction is, is a, you know, provides sort of an architectural pattern uh for how to use uh these two level building blocks. Uh So I'm excited about doing more uh to go to a plume and others to, you know, create these new um you know, higher level components, uh you know, take, take the building blocks that we have and build higher level uh application um uh building blocks that make it easier to uh you know, develop uh with opinionated patterns uh rather than having to re, you know, stitch everything together at the low level building block. So, uh I think you guys have something called uh a component resource or a resource component. Like, yeah, I wanna take that idea and, and go bigger with that. How do we, how do we create sort of uh the ability for, for developers to start uh creating these higher level patterns and, and sharing them with others? Um I think we can, you know, create an entire uh programming model based on these uh abstractions that we can build on top of uh plume and CD K and other uh infrastructures code uh frameworks. Well, thanks Kent for sharing the perspectives there. I totally agree with, with everything we just discussed and, you know, I think um really excited to go from building blocks to, to these architectures and patterns. I really, I think that's the next level in this cloud evolution is not reinventing the wheel, really uh really putting the builders first and, and really enabling us to, to build bigger things out of smaller things. And I think that's, that's really exciting. Um I think in terms of putting this into practice in your own teams, really putting the builders first and putting them in the driver's seat is kind of the first step. So we'll talk through a little bit about different ways. We're seeing teams organize and, and empower developers. Um The unfortunate news is there's no one right answer, but this is definitely a truism across all of the different models that we're seeing in practice. I think, you know, enabling the folks who are going to innovate to, to do that uh is, is key, it may sound obvious but you look at where we're coming from and many developers just don't have the ability to spin up the infrastructure they need. Um uh It's surprising to me, but we still talk to folks all the time who, you know, developer has to file a ticket uh to get some infrastructure and then wait, you know, uh a long time to get that, you know, up to a month or, or longer. Um And that's, that's no fun. That's not a recipe for moving fast, really operating with code is, is the, the key that we're we're really driving towards here, this whole infrastructure software approach. This is not new uh in, in a sense, you know, we've been on this Dev Ops journey for over 10 years. In fact, I've gotten all this way into the talk and I don't think I've said the word Dev Ops once. Um but I wanna really tip my hat to kind of everything that that's come before. And I think Dev Ops is an essential movement to getting uh where we are today. I think the unfortunate reality is Dev Ops really brought more Dev to the OPS than it did the opposite of empowering the developers to really get their hands on um uh cloud infrastructure, which is, which is great because, you know, cloud engineering is about going both ways, bringing the cloud closer to developers, but also delivering great software engineering practices to infrastructure teams which Dev OPS really played an essential role in doing and has really laid the foundation for the shift to cloud engineering. Um And I think, you know, this, this is really taking a lot of the lessons of Dev OPS and, and taking them to the next the next level in terms of um really software engineering, even in the context of infrastructure. You know, we, we yes, we use infrastructures code and config tools and um we did some amount of testing when it came to DEV OPS, but we, we didn't really get all of the benefits So we talked about, you know, the software engineering desert Dorado slide from earlier, a lot of those things didn't really apply in the realm of devs. And so this really is about, you know, supercharging infrastructure team's ability to get things done. Their demands on infrastructure teams are greater than ever before. And so this is one way to keep up those demands, empowering developers from the perspective of an of an infrastructure engineer is great because that means the infrastructure team isn't always on the hook for getting everything done and getting blamed when you know, schedules slip. Um Of course, there's often got to be guard rails in place. Uh For example, if you're empowering um a developer that developer may not be the expert in all things security um or how much things cost and the infrastructure team really, they are the, you know, the they have to keep control over those things and make sure that there's not a serious security incident and so on. So cloud engineering is about empowering the right people to do the right job at the right time. I think one pattern we often see, especially with early stage startups or midst stage startups. You know, folks that were fortunate enough to be born in the cloud really are adopting models that are much closer to what Amazon web services themselves internally evangelize. Um You know, if you don't need to create a separate devops organization or infrastructure organization at your scale, you know, that's almost always preferable for folks because you can just empower the the builders to build. Um And over time, you have infrastructure experts who emerge. Um you know, configuring a virtual private cloud and Amazon, most developers are gonna, you know, be bored out of their minds trying to figure out how best to do that. Um That's where an expert in infrastructure and a domain expert in networking, for example, really, um can be valuable. But in the early days, if you've got a building block and it's a virtual private cloud that's been written in Pulumi, for example, and there's, there's a module and you could just pick it up off the shelf. Um And you don't have to become an expert in how that thing is configured. That's probably preferable, especially if your goal is to, you know, get something shipped if you're, you know, y Combinator incubator and you, you've got demo day coming up next week. The last thing you wanna do is spend three days configuring a VPC. So use tried and true best practices, get up and running and you know, this whole two pizza thing is size of the team should be no bigger than can consume two pizzas. Um You know, it's kind of rule of thumb for service teams and the nice thing about that is it keeps the boundaries between the teams pretty reasonable and you can get your arms around it. You need to find it with an API so that you're again not dealing with ticketing, you're reducing the amount that humans have to be in the loop. And really, you know, using software as the interface between the teams, this is a very popular model even in larger companies. You know, obviously, Amazon is a quite a large company doing this at incredible scale. Um I won't mention there's often site reliability engineering that that emerges um as a practice within these teams as well. So you often have an SRE expert who's really coaching the team on how to run a highly reliable, you know, scalable service, a common pattern we see also in larger organizations is this concept of a platform team. Um The platform team often is trying to empower the the organization around them that includes the infrastructure and operations team. It also include, includes the developers. These are the folks that are usually setting up a Kubera cluster, usually setting the standard for how infrastructure is done in the organization. Um And you know, this can be exciting for two reasons. One, the platform team can really focus on shipping the best platform and the platform itself is a product for that team. Um Their customer is the developer within their organization or the operator within the organization. Um So it's exciting for the infrastructure team because they can focus on building this this amazing platform and really specialize in that historically, this would have been a pas or you know what have you cnet's thankfully has given us a, a standard foundation to build on. And so whether it's a path or just a opinionated assortment of services often using the building blocks uh to create these reusable architectures. Um That that's typically the approach uh that these platform teams are taking. Um And then we've got developers and developers benefit in this world as well because the developer can spin up infrastructure typically and usually the interface is code using infrastructure software and the platform team can give them these reasonable components and developers can spin them up. You know, one customer we work with actually has an opinionated Cober cluster, they call it a micro service environment. Um So if the developer needs a DEV or test environment, they can just go spin up one, you know, um and be productive and just focus on building their microservices and building their applications. And that's another form of developer first, right? Developer first isn't just about um developers being in the driver seat and oh we don't need DEV ops or infrastructure teams. That's not what developer first is about developer. First is about thinking of the developer and in this model, the platform team really is thinking deeply about how to empower the developer. And I think that's an exciting uh pattern as well. But there are a lot of different ways to organize and and frankly people oscillate between these models as they as they grow and as they scale. And um I think really the the number one takeaway here is, you know, one plus one equals three. We're seeing that thanks to this new approach to thinking about the cloud as an operating system, thinking about infrastructure as something we we use software to deal with. They're breaking down the barriers between infrastructure teams and engineers and, and developers and really enabling teams to build better things together. And that's, that's the best possible outcome um that we can see. And so in summary, just to reiterate kind of some of the things we chat chatted about today. So developer first infrastructure really is about empowering builders to build uh first and foremost and empowering developers and infrastructure experts to build great cloud software infrastructure is software not code is the gateway into that world. You know, it's what gives you programmable building blocks that can be assembled in, in infinite ways to build infinite new uh capabilities into your applications. Um Really that foundation allows us to move beyond just the building blocks to reusable architectures. And I think that's the way we stop reinventing the wheel. That's the way you know, every time I sit down to spin up a network in Amazon, you know, web services, I don't wanna have to go read that 15 page white paper. I just want to use uh an architecture off the shelf that's written in software that I can compose just like I do any of my application uh components as well and we're finally there that we can do that with infrastructure software. And finally, cloud engineering is the practice. I wish it were as easy as just sprinkling some, you know, technology, magic Pixie dust and everything just works. Um But it turns out actually how we work together as a team is the most important thing and often the most difficult to get, right. So I think empowering developers and empowering the builders, we've covered that. But that really is the the first step in terms of getting to cloud engineering. Um and really working together and breaking down that wall between infrastructure teams and developers is what leads to this one plus one equals three. So thank you very much for being here today. It was great to take you through the journey of developer first infrastructure. The cloud is the new operating system infrastructure software and cloud engineering. I hope you learned a thing or two and I hope you enjoy the Cloud Engineering Summit. Thank you.
---
