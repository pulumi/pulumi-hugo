---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Infrastructure as Software Best Practices | Cloud Engineering Days 2022"
title: "Infrastructure as Software Best Practices | Cloud..."
meta_desc: |
    Infrastructure as Code best practices are about applying software engineering practices. In this talk,
url_slug: infrastructure-as-software-best-practices-cloud-engineering-days-2022
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Infrastructure as Software Best Practices | Cloud Engineering Days 2022"
  description: |
    Infrastructure as Code best practices are about applying software engineering practices. In this talk, Luke Hoban and Mitch Gerdisch go through these practices and how to apply them to your cloud infrastructure as an individual developer, a team, or an organization. In the process, they will introduce key concepts such as secrets management, Pulumi components, and more.   00:00 Introduction 01:05 Infrastructure as Software Best Practices 01:54 Developer - Code 02:49 Developer - Secrets 04:01 Demo: IaC in action 10:29 Teams - Components 12:31 Teams - Testing 13:53 Teams - Multi-Stack Architecture 14:39 Teams - Continuous Delivery 15:30 Demo: Components and Testing 21:52 Organizations - Policy 23:36 Organizations - Packages 24:35 Organizations - Refactoring 26:14 Demo: Policy and Packages 30:17 Recap
  sortable_date: 2022-12-21T17:00:37Z
  youtube_url: https://www.youtube.com/embed/wnFBywu7SXM
transcript: |
    Uh I'm Luke Cobin Ceo here at Pulumi and I'm joined by my colleague Vich, a solutions architect on the team. So, one of the things when we think about sort of uh best practices uh for infrastructures code, one of the things that we sort of deeply believe here at Pulumi is that infrastructure is code be best practices are really all about applying the best of software engineering to the problem domain of cloud infrastructure. I'd say over the last four decades, uh we as an industry have kind of learned how to scale up the sophistication, complexity and value of what we can build using software. And those lessons are things that we're now going and applying into. How do we take those and apply them to cloud infrastructure as we need to scale up the complexity, sophistication and value we gain from our cloud platforms. And while the concepts of sort of software engineering are typically the same kinds of concepts that are going to apply in infrastructure as code, the way that those are applied to uh infrastructure tend to be somewhat different and have some unique characteristics specific to that domain. And so in this talk, we'll look at both some of what those software engineering practices are and how we can think about applying them into uh infrastructure as code. So I'm gonna break down the talk around sort of three different uh domains in which we can think about applying our infrastructure software best practices. And those are the scope of the individual developer. And how do we enable the developer to be productive to have the capabilities they need and have the flexibility to develop the solutions they need quickly. The second is gonna be teams and how we can enable the team to work together uh effectively to enable we use best practices and confidence in their ability to deliver uh solutions quickly. And then the last is gonna be the sort of organizational level. How do we maximize the the consistency, the standards, the ability to evolve infrastructure over time and to scale up the use of infrastructure across the entire organization, empower everyone in the team uh to access and use uh rich cloud infrastructure. Let's dive in first on developer side. So probably the most obvious uh best practice is to really take advantage of the fact that infrastructure's code is code. Uh And this really is a fundamental benefit and fundamental shift in mindset from the the sort of traditional way of of working with infrastructure where we'd jump into a portal, we'd point and click, we'd provision some resources and now we don't have repeatability we don't have the ability to sort of evolve that we don't have written down anywhere uh what our infrastructure actually is. And so by using code, we get the benefit of writing down our infrastructure making it repeatable. Uh When we want to stand up a new environment, we already have uh the code that describes how to do this. All we have to do is provide some separate configuration for that new environment. Of course, because it's code we can also bring to bear all the software engineering tools we're used to around our code, we can bring our I DS and the productivity they offer the error checking they offer and all the libraries that are available in our language of choice to leverage as part of our infrastructure as code solution. Now, effectively managing secrets is important for all sorts of software projects. But it's especially important when working with cloud infrastructure because cloud infrastructure typically involves many highly privileged environments credentials that have access to lots of things within our cloud environment. And so when we're working with our infrastructure, we really need to make sure that we're managing our secrets effectively and safely with Pulumi first class support for secrets. You can make sure that any sensitive data that's entering the system is treated as being secret and made sure that throughout the lifetime of how that's handled in the program, uh it's maintained as a secret, even if it's modified along the way. Like we take a secret input and you know, do some concatenation with it or something like that, that value will never leak out as a non secret value. And also that we can then make sure that that's encrypted and stored in a safe way in any place where it's serialized outside of the, the Pulumi project run. And of course, with customer managed keys, uh we can allow you to have end to end encryption of these values so that even the Pulumi service doesn't know about the values of these sensitive uh pieces of data and that nothing that's being stored uh in any serialized format uh has access to these. And so to take a little bit of a look at how developers can benefit from some of these infrastructures code, best practices around code secrets and productivity. Let me hand it over to mitch to do a quick little demo here of uh putting infrastructures code in action pitch. Thank you, Luke. As Luke was saying the, you know, it is software engineering applied to infrastructure's code and one of the fundamental concepts there is really around um dry, right? Don't repeat yourself. Uh And we're gonna talk about sort of varying uh variations on that theme as we go through these uh demos. But the first one is really around, you know, our, our basic con constructs of a project and a stack. So here I'm looking at a pretty straightforward project. It uh stands up a VPC creates an R DS security group, R DS subnet group and then an R DS instance. And this is my code base. This is what I can manage and, and use and write once and then I instantiate that into multiple uh stacks. So for example, I have a DEV stack and my DEV stack. I, you know, I don't want to use multi A Z for my RD si want any changes to be applied immediately. Whereas my prod stack, I'm going to override some of the defaults that I have in my code around instant size. Uh And I do want it to be multi A Z for example. So this fundamental idea of having, you know, one code base that then gets instantiated as different environments is sort of that first level of, of don't repeat yourself uh approach that plume enables. Now also, since I'm using a programming language, I'm also able to apply, you know, very basic approaches around just breaking up my code to be more readable, more maintainable. So for example, I have this config dvts file which is really just some code I put aside. So it's not muddying my main program. And here I'm pulling in config data from that prod dot DEV dot Yaml or I'm sorry, Pulumi dot Dev dot Yaml or Pulumi dot prod dot Yaml. And if it's not set, I can set it to a default. And here again, I'm able to leverage in this case, typescript, you know, in line conditional down here, I set a password. Well, if it's not set, I create one and again, just a very straightforward use of conditional but still using a declarative model. So let's see what the um the that secrets part of the picture looks like a bit, right? So as, as Luke was saying I can set um secret sensitive data. And so I'm gonna set that DB password. I'm gonna actually provide one because in my DEV environment, I don't want it to generate it. I just want to use the one I like to use because, you know, it's still secure but it's um but the idea is, I don't, you know, I can just use one I'm familiar with, right? And here this is not what I typed in. This is the encrypted version. This is the plume service providing that uh key to this, to the engine here to the cli to encrypt it and then during runtime to decrypt it and use it. And that's great, right? So now and I can store this right alongside my code, any public repo without any concerns. Now, the other aspect of the uh as a developer really, what I want is a quick development cycle. I I want, you know, I want to be able to work efficiently, quickly, not have to, you know, go jump around to documentation when I don't need to. And again, since we're using a programming language construct here since Pulumi publishes are, you know, these various SDKS in the given language, the I DS just naturally know how to use them, how to, uh, leverage them. And so, for example, let's say I, I'm thinking, oh, you know, I wanna add a bucket. Um, and it's Aws and it's S 0 S3, right. So I get all this lovely Auto complete. It's a bucket. Great. Um I'm just gonna call it goo and as a and I know I'm done, I know this will work. But then let's say I'm thinking, well, you know, I I know there's a property around deleting or destroying. Oh yeah, force destroy. Excellent. I'll use that and I'll set it to 30, I'm getting an error, right? Because force the story is a boolean value, not a number. So all this just makes me super efficient. I'm able to just rip through and create my code, not the word bullion. Mitch. Yeah, an actual bullion. Um I'm able to be very efficient and really kind of get through this very quickly. Similarly, if I don't want to jump over to our documentation, I can, you know, just as easily in context in my ID. Go to the definition. See, oh, these are all the various inputs I can leverage in that B PC call. And so I'm gonna, I'll get rid of this and let's do a plume up which you've seen a couple of times today in various forms, whether it's on the command line or through our new deploy capability. And essentially uh you know, now it's telling it to go and update the stack and the main update is really because I'm now providing a password. So it's going to destroy that uh resource and uh the that password resource and just update the R DS with my provided password. And again, as part of an engineer, as part of a developer, I want convenience, I want ease of use. And so the the service really provides me a lot of that. So first of all, uh I my, my various important to me stacks start here. I can quickly hop over to it. As we saw, I can see a full history of what's going on including my current update within that update. I'll be able to see the changes that are occurring within a given update. I can see the commit ID, the branch was run from later on. We'll see, you know, we saw uh if you didn't catch it that in the deploy cases, there's a little rocket ship there showing me and with a link to my deployment. In the case of AC I CD pipeline, we'll see later. It'll take me to the C I CD. When I look at the resources, I can easily get a quick link into the uh into the cloud provider's view so that I can see it. Now, this is not a case where we're leveraging your credentials to reach into a aws. This is just Pulumi providing you an easy link to get over there. I'd have to, I'm logged in. So I'm able to see the U I so that basic dr around having a single program instantiating the different environments that quick development cycle that the ID just naturally provides because we're using, you know, programming language based sdks and the convenience of the U I is really the first level of making my uh experience uh all that much better. So I will turn it back over to Luke. Well, thanks Mitch. Uh Let me bring up the slides and we'll keep going from there. So for teams, when we uh when we think about kind of the things that help with team uh productivity and team best practices, one of the first things we really think about is components. And so, you know, when we think about the fundamental benefits of software engineering, one of the really important uh software engineering practices is really creating new abstractions. One of the best things we can do with software is take some code uh that implements some functionality, abstract it out into a function or a component, give it a name, define the interface and document it uh for that component and then allow the rest of the organization and the rest of the world to go build on top of that uh abstraction. And so components are really fundamental to how we think about, you know, what it means to use software. And traditionally, components and abstraction have been underutilized in infrastructures code relative to other forms of software engineering. While in an application development world, we might, you know, grimace at the idea of copying and pasting large chunks of code around within our code base. That's actually more the norm than the exception in most infrastructure's code projects is that we'll just go copy and paste the 1000 lines of, of HCL or Gammel and we'll paste it over here. And now we've got two copies of the. And so with Pulumi, we get sort of the best in class tools for creating components and abstractions uh built using the classes and functions and components that are available inside our languages of choice. And so we can bring those to bear on uh our infrastructure to gain this sort of don't repeat yourself uh build abstractions, build an on the shoulders of of others. One thing that goes hand in hand with that is actually Pulumi ability to have transformations, which means that when you use a component, if it doesn't do exactly what you want, you still have the ability to go modify the ultimate results of that component in any way you want. And this is a really important feature because it means that components don't have to support every single potential uh you know, uh form that they could be used in, they can decide what the high level API is they want to provide and then consumers if they need to pierce through that abstraction can do that uh using transformations. And so a really powerful way to get the best of components with also the best infrastructures code flexibility. Another key software engineering best practice that is traditionally underutilized in the infrastructure's code space is testing. And there are really two types of testing that we think about applying to infrastructures code. There's unit tests uh which are, you know, sort of fast and lightweight. Uh They're written primarily to validate that the code we wrote is correct that wires together the different pieces of infrastructure in the way that we intended to do under all the different parameter organizations that we might support based on configuration or based on the component that we're building. The other is integration testing where we can sort of validate end to end correctness of our cloud infrastructure by actually standing up some cloud infrastructure validating it works validating that all the network access is correct that the database is wired up to the application tier. All these different pieces that are gonna be necessary for a correctly functioning piece of infrastructure and then tears it all down. Integration tests obviously are heavier weight, but they can uh be really easy to do with infrastructure's code because we have everything encoded as, as as software and as code, we can spin up and tear down these stacks really easily to, to have really high confidence in our correctness. And lastly, it's really important with testing, to think about not just testing our projects and our programs, the end result of building out one of these things, but also testing our components. As we build reasonable components, we can test those components in isolation, make sure that they work correctly and then leverage that as we go into uh using those in other parts for application. The next piece here is sort of multi stack architectures. And when we really think about, you know, best practices for software engineering, we often think about sort of micro services and breaking down our applications into units that sort of evolve along common boundaries. So where an independent team owns inversions piece of software separately from all the other pieces, this helps to limit blast radius, helps to give teams more autonomy and helps to ensure that versioning. And the way that versioning relates across different parts of the application is not monolithic but can actually be driven independently for different components that version separately. Now in Pulumi, we actually have the ability to have stack references, which mean you can do this breaking a stack up into multiple different uh smaller stacks but still easily leverage the outputs of one stack as inputs to another stack and make sure that as we evolve these, we can take advantage of that. And then finally, for teams one of the ultimate things we want from our team is to be able to deliver value out to our customers and to our business really quickly because we want to be continuously delivering not just our application software, but continuously delivering changes to our cloud infrastructure as well. And of course, we can use any of our existing C I CD providers. If we've got that set up in our environment, we can go and put Pulumi into that environment and take advantage of the existing infrastructure. We have, we could also do this through things like the knas operator. If we want to use as the control point, we need deployments like we introduced earlier today or the automation api if we want to build our own custom software solutions around this, any of these allow us to sort of automate the infrastructure delivery within our organization and make sure that we can deliver change really quickly and reliably into our production environment and to show off a few of these in particular components and testing. Let me hand it back over to mitch to talk about how teams can apply infrastructures code best practices. When we start talking about teens, one of the first uh aspects that come into play and I'm still a developer, right? All the things I talked about a little bit ago still apply, but now we might enter a realm where there's a bit of, you know, a separation of concerns as Luke was talking about or different teams, different cadences around different stacks and different environments. And that's where the multi stack architectures really come into play. And so here, for example, I have a multi stack architecture that consists of a back end. So the back end stands up a Dynamo DB, a Lambda and an event bus using event bridge. And then I have a front end uh which is standing up an API gateway with a Lambda that drops data into that event bridge uh into the bus. And then on the back end part of the solution pulls it out um and puts it into Dynamo DB pretty simple. But you can see that, you know, the back end team is gonna be working, you know, at their pace, the front end team at their own pace. And so it makes sense to really have them as separate stacks. And so if we look at the code for the back end, we basically see uh creation of a thing called the back end and this bus and we'll dig into that in a minute and it exports as an output of the stack, the bus iron as well as some other data. But this is the important one for the front end team because they need to know how to write into the bus. And so if you go look at the front end stack code, we basically see this bit here where Pulumi provides a stack reference uh method, this capability to go and connect to um that other stack and gret the outputs or output that it needs. And it was in this case, it's that bus iron output and this is enabled very simply by the service. Um And the services are back capabilities also play into this. So for example, I as a front end team member, don't maybe have update permissions to update the backend stack, but I have read permission so I can get the uh the bus arm. Now this all is all enabled um and leveraging component resources, these reusable classes. So earlier, I had that sort of config uh VB file which was just a file, you know, just using sort of a basic uh typescript construct to put data, put um code into another file. But Pulumi also makes available uh what we call the component resource class and I'll use the bus, the bus one as an example. So the component resource is an extension uh on class. And really what it allows me to do is capture my best practices around how I like to do things. It allows me to abstract away the details of how I like to do those things. And so in this case, whenever I want to create a bus, an event bust, I create an event bus, I create a rule and I create a target and that's, you know, nobody else needs to know that really, you know, I write this once and then the front end team or the back end team in this case gets to use it similarly. If there's another project that another application that needs to stand up a bus, they could just reuse this component resource. It's it can be published like any other typescript um module in my artifact and pulled down just like any other typescript module. And so again, and so, you know, and I'm also able to control, if I'm like a central it central platform team, right? I can control what inputs I allow them to use and what outputs I present back. They could, the input could even be like a small medium or large, right? And I just have the logic in here to decide what that means. As um as Luke was saying, there's also this idea of transformations. So um coming back to my components folder here, I have this tagger file which is really just capturing a function. So it's not a component resource in this case. But again, I'm able to leverage, you know, the programming languages uh approaches around putting stuff into other folders, other files so that I don't have to again, muddy my my my code. And more importantly, I can write this once and use it all over the place. And in this case, tag all resources uses our stack transformations capability. Uh Essentially I'm able to pass the stack transformation uh properties which are then applied across all the resources in the stack as I want them to be. So instead of adding this, um so if we come back to my index here, I'm gonna add a new uh tag called project uh name with a value. And I'm gonna use my name base, which is just a sort of naming convention I came up with. And so instead of going through and updating all the actual component resource code, I can layer this on top of any tags they want to set. So at this point, if I do a pull me up, oh maybe not all cats, this will go and and essentially look at again what Pulumi does best, right? Which is understand what the current state is, understand the desired state and apply those changes. Now also as part of this team uh dynamic right, I want to be able to um test my code and kind of even getting back to that sort of quick dev cycle, right. I want to be able to do unit tests. And again, since I'm using a programming language here uh for my infrastructures code, I can leverage, you know, the tooling and the capabilities and the processes that the language enables such as setting mocs and then writing unit tests. I can layer on top of that integration testing as Luke had mentioned around even leveraging our automation API where I can orchestrate a whole, you know, both of these stacks. And then run just using standard, you know packages for the given language uh to hit the API test the API return results. And of course, this all very naturally organically plugs into C I CD pipelines. I can have, you know, I push a branch that creates a branch specific stack. It gets tested when it gets merged into say my staging uh branch that then pushes onto the staging environment and et cetera. So separation of concerns multis stacks, dry part two, these component resources that I get to write the in these classes and then leverage throughout my code uh throughout various projects and other um bits of code and then being able to run testing uh as I need to. So I'll turn it back over to look to talk about works. So let's move on to organizations. So when we think about kind of organizations, one of the first things we really think about is how do we enforce policy across the organization? This allows us to have consistency in what we do across our organization and enforce best practices uh for the um the things that we deploy. And so, you know, this can be in two forms, one can be in the form of warnings where we just let you know uh the the organization forces some policy. But it's a warning just to let you know that this is against our best practices or maybe you don't want to do this. Uh And to provide guidance for developers kind of using, working within the organization. The other is errors. So we actually want to completely prevent you from doing certain classes of uh operations and using certain classes of resources. For example, we may want to completely prevent you from exposing a bucket to the internet unless you tag it with a very explicit tag that indicates you were doing that on purpose. We can use these policies to enforce lots of things where they can be about compliance and security. They can also be about cost and providing just guard rails to encourage people to work within the sort of best practices that the organization has uh made sure are a sort of golden path for what folks do now because this is just software. Uh Our policies can be as rich as they want. They don't just have to be these things that are very, very simple. Uh you know, constraints where, you know, you can't use this property, you know, you can't use this thing. They can actually look up data so they can go and download an allow list or an inventory or a pricing sheet and use that as input to the, the policies. So it can be very, very dynamic, very software based uh and very rich uh for our organization. And of course, with the blooming service, we can go and enforce those across the entire organization and make sure that no one who builds a stack or no one who builds a stack targeting a certain environment is able to uh you know, deploy things that don't match our policies. The second piece of sort of enabling consistency across the organization is leveraging sort of packages. And so just like with any other software ecosystem where we have reusable packages, whether they're in, you know, N PM or pipe pie or um New Get or whatever my package manager might be with Pulumi, we can build reusable packages as well. And those packages take a, a set of components and, and capabilities that are available to Pulumi and make sure that they have a cleanly versioned, uh you know, the delivery of changes to that package. So I can pick up and deploy a specific version and use that and pin that for my infrastructure and then adopt new versions when I'm ready to test and validate the compatibility with those changes. They also allow me to publish into the Plumy registries. So they get rich documentation and support for those libraries. And finally, they allow me to go and uh ultimately publish uh those packages into my favorite package manager, whether that's my own arti factory for internal usage, whether it's into uh some public package manager like the public N PM or PI pi or whoever I want to distribute my packages. And finally for organizations, one of the things, another kind of core software engineering, uh you know, uh benefit is really think about refactoring. Refactoring is so valuable for software engineering because it means that as we evolve and manage a code base over a long period of time, we can evolve that code base to sort of continue to represent what organization intends this code to do as the names of things change, as the boundaries for where abstractions make sense change. And as the capabilities get more and more advanced for infrastructure, we typically want to make changes to the way that that code is laid out the way that roads source is represented and the different pieces of infrastructure that are being managed. And so a factoring is just as important for our cloud infrastructure as it is for our application code. And in Pulumi, we have rich support for refactoring, not just at the level of using all the factoring tools available for your program and language of choice, but also at the infrastructure's code layer. And traditionally, infrastructure's code has presented a little bit of an additional challenge for a factoring because it's not just the code that has to change, it's actually the state. And so because you can have different instances of your stack in different states with different state files, we need to make sure that we can evolve changes across the different versions of how this has been represented in your state in the past. And so Pulumi is aliases feature is actually designed specifically to make sure that it's really easy. And possible to factor cleanly your, your components and your projects uh that you deploy using Pulumi. And this allows you to apply aliases, for example, to components to enable backwards compatible migrations as we make with factoring to how a component works or changes to its behavior, we can easily make sure that those don't break existing applications and don't require them to replace existing resources. So for one last demo, let's take a look at how organizations can take advantage of policy and packages. Uh in Pulumi know now, at the organization level, it gets, you know, sort of dry part three as I like to call it. Um You might even, you know, we, we might even be at a point where the organization is wide enough and large enough that there are different teams handling different pieces of infrastructure, even in different languages. Um Similarly getting to that package concept, I can create things in one language and share them across. So let's let's look at what I have here. So I have a um two again, I'm at a sort of a two stack multis stack architecture where I have my base infrastructure. This is a standing up an EKS with a VPC and what have you. Um It's written in Python because the, the team that manages the, the, the infrastructure like BP CS and the EKS wanted to work in Python, not a problem. And so they, they deploy this, they have this uh deployed in Python. And you know, one of the key aspects that they put, they that comes out of the stack is the coop config for the EK SS cluster. And here I'm actually using an in line secrets uh to be able to make sure it's treated carefully by Pulumi again. Once something is marked as a secret, whether it's an input or output ploy does not leak it into logs or state or anything like that. And then the application team which deploys the guestbook app if you will is writing it in typescript, not a problem and it's going to be used and it is using that same stack reference construct. I talked about a few minutes ago where it's gonna pull the coup config and instantiate the kubernetes provider. And so basically what that, you know, so at this point, I'll, I'll up, I'll push uh deploy the application, the guestbook app. And while that's running, we'll dig a little bit more into what's going on here. One of which is that this service deployment uh construct here, this, this module, this uh resource is actually uh based on a uh multi language component, a multi-language package that is written by us by, by the team. In this case, I'll just, I'll say it's me just to kind of make it simple and understandable. And this, this package, this component is actually written in this case and go and it, but it's just a component resource at the end of the day, just like we saw earlier with the front end and back end with the bus and the the different component resources there that were written in typescript. This one just happens to be written and go and through our multi-language component capability. You'll see it also noted as cross code, I'm able to generate SDKS for all the different languages that we support. And so the APP team is able to use that to deploy these uh red modules uh service and deployment. So in this, you know, I've kind of taken it to the nth degree around dry and reusability and, and being able to work in different languages. But essentially I have them, my base run it in Python. My app written in typescript using a module that was originally written and go but has been able to be just built into the different languages without any extra work to rewrite or anything like that. Now, you'll also see here some policies firing. So there these are advisory so they can be either advisory or mandatory advisory means I get yelled at, but I'm able to proceed. But in this case, so I'm allowed to proceed and this is coming from the service. So the service has the ability to allows me to publish what we call policy packs, they can be put into policy groups. These policy groups are then applied the stacks and if they were set the mandatory in any of them, I'd have been stopped dead in the water. Similarly, at the organization level, I want to be able to manage my teams and my membership through single sign on including Sam L and skim. So I'm able to create teams that have read permissions for stacks, write permissions to other stacks, no permissions whatsoever. And also as an organization, I want to have audit logs to be able to see everything that's going on and just as before able to see, you know, all the activity for any stack at any time, including, you know, events coming out of C I CD. Wonderful. Yeah, I think one of the, one of the most important aspects of Pulumi at the end of the day is sort of the benefits that it can scale across all of these from individual developers uh to teams and then ultimately up to large organizations applying infrastructures code at scale just to recap. I think when we really think about, you know, infrastructure's code best practices, what that means for us at Polu has meant since the sort of beginnings of, of the Pulumi project is really meant applying software engineering, best practices into how we manage cloud infrastructure. And we've seen today how we can do that across many these different areas from, you know, developers and code and how we can leverage productivity at that level to teams and how they can manage quickly delivering software being, having us having reasonable components and testing those and then how organizations can enforce consistency across their best practices. So that's it for Mitch. And I, uh coming up next, we're actually gonna transition into two sessions, one here in the main stage and one on the customer stage. Uh Both of these sessions are gonna be with, uh Pulumi customers who are building really interesting things. Uh On top of Pulumi.

---
