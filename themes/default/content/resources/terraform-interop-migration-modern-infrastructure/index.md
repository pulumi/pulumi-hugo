---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Terraform: Interop & Migration | Modern Infrastructure"
title: "Terraform: Interop & Migration | Modern Infrastructure"
meta_desc: |
    Want to learn how to migrate your existing Terraform projects to Pulumi, or even integrate HashiCorp Terraform providers? Join David as he walks yo...
url_slug: terraform-interop-migration-modern-infrastructure
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Terraform: Interop & Migration | Modern Infrastructure"
  description: |
    Want to learn how to migrate your existing Terraform projects to Pulumi, or even integrate HashiCorp Terraform providers? Join David as he walks you through your options in this latest installment of Modern Infrastructure.  üåê Links: Terraform Migration Guide: https://github.com/pulumiverse/terraform-migration-guide   üí†Terraform HCL Guide: https://github.com/pulumiverse/terraform-migration-guide/tree/main/hcl-guide   üí†tf2pulumi: https://github.com/pulumi/tf2pulumi Pulumi Import: https://www.pulumi.com/docs/guides/adopting/from_terraform/ Building a Bridged Terraform Provider: https://youtu.be/ZjTFaqMrYvY
  sortable_date: 2022-06-30T07:26:42Z
  youtube_url: https://www.youtube.com/embed/IYbOql22eyA
transcript: |
    Hello and welcome back to modern infrastructure here at TV. My name is David Flanagan. Although you may know me from across the internet as coach, I'm a developer advocate at Pulumi. And today I want to spend the next 10 minutes sharing with you ways to migrate existing terra farm projects over to Pulumi using a few different tools and techniques. We're at a lucky time and age as developers where infrastructures code is no longer new people have been practicing infrastructures code for a while and you may just be new to Pulumi. So you may be wondering how do I take all this existing stuff that I have and bring it over to the plume ecosystem and I'm gonna share a few resources with you today. Oh, there is my screen. The first thing I want to talk about is something that I've been working on within the Pulumi Vers Organization on github. The Pulumi VIS organization uh was started by a group of Pulumi community members who wanted a centralized place for non official Pulumi staff to, to live. I'm very fortunate to be able to contribute to this as much as I can and one of the things that I really want to be able to help people with is that migration step that we're talking about today. So we have started over only in the last month, putting together the Terraform migration guide. This guide is going to be out over the next weeks and months for sure. But it's hopefully going to cover some of those hurdles that people often hit. So the first thing in this gaze that we cover is the Terraform HCL gate. We're going to assume with this guide that people have written some terraform before and are are relatively comfortable with the has configuration language. But what you may not understand when you're making that jump from terraform to Poli is well, what do some of those patterns or what does AC L look like and the various Plimer languages? And that's what that gate is there. For. The second part here is the TFGTF Pulumi is a tool that we'll be looking at during this session, which can convert to a which I do not disturb on uh choice of life. Sweet. Um Yeah, you have to plum as a tool that can help you convert Pulumi Terraform into plumbing code. And I'll show you some examples of that as well as some more advanced stuff that you can do with the Pulumi Import command and even some scripting. So this guy doesn't exist yet, but it will be coming soon. Uh We're making some improvements that we have to pollinate again, we will cover that in today's session. If you are not, you do not need to know all this stuff. Now, if you take a look at the AC L guide, you'll see that we have just some examples of common things that people do in HTL that they may not be sure how to bring across the blue ecosystem. Uh So the first one here is we take a look at code re use. What does that mean? Well, in Terra Farm, we have a concept of a module, we can group a bunch of TFS together ship them in a get repository and consume them via this module syntax with inputs and outputs. No, the way that it works in Pulumi is not going to be a surprise to most people is that Pulumi uses real programming languages and not A DS L. So there's no direct equivalent of modules except for if you're using Go well, you would just use Go mode and you would chuck your plum code that way M PM for typescript and javascript pi Pi for Python Maven for Java new get for dot net. Hopefully, nothing too surprising there. Um What we call out in this guide though is that, you know, there's no real need for the concept of a module because within polymer, you can factor all of your code to, to functions and classes to component resources and dynamic resources. So really you just have to consider it like software, right? Like when you build out your applications within your organization, when you see something that is repeated multiple times, we apply the dry concept where we do not repeat ourselves. So we extract and factor things into functions. Once those functions become stable, it may be that we want to provide more uh composition of those functions. We may tweak the inputs and the outputs, we may break them down into multiple functions and have higher order functions. Like all of these things that we do is good software development practices directly applied to our. So there's not the right module, but I think there's much better options. Something that people will be very accustomed to from the HCL landscape is that if they want conditional resources, the trick here is to set account to a tertiary value of one or zero. And then Pulumi, well, we can just use our programming language constructs. So if we were doing this in typescript, we would have an F statement that checked subconditions and then if we wish to, we would create the resource insight. Now, I'm not going to go through all of these. You're more than welcome to come and take a look at all of these blocks. We're going to add more over time and taking a look at the terra farm ecosystem and trying to give people a really good path to understand and migrate their code when they're not doing it automatically. It may be that you're doing partial migrations. It may be that you're setting up your preliminary project and stacks, keeping your existing turf farm and doing things in a slow but intentional way. That's ok. That guide is there to help. So you can find that at github dot com slash Pulumi slash terraform dash migration dash guide. And I hope that's the last time I have to see that out load. OK? The next thing I want to cover is the Pulumi import command. So we have a fantastic page of documentation here at Pulumi dot com. You can find it by going to Docs user guides, adopting Pulumi and importing infrastructure. I will create a short link for this and stick it into the show notes as soon as I'm done. I promise. But there's a few ways to import your existing infrastructure. The first one shown here that we can use the Pulumi import commands. So this is when you're doing that intentional but maybe slow moving migration from one ecosystem. It may not even be to farm. It could be any other infrastructure as co two and bringing it into the Pulumi ecosystem is that we can just run plume import against a single piece of infrastructure. What this does is it will import this into your state file and there is an option to generate the code and you'll end up with code that looks something like this. You can tweak the way that the plume import command works. But all the options are described on the cli you can see that we have a generate code. Where is the argument here does default the truth. So you don't need to worry about it. Um What it does is it will print the code to your terminal and if you do not want it to do that and you want it instead to rate it to a file, you can use dash O or dash dash out. Uh and that will, it will take the same code but a fail. So you don't need to do that badly. And there's a few other options here, especially if you're importing uh database things or stuff that you consider meshing critical, then you know, make sure that you mark these as protected. And if you need to change any properties, there's flags for that. If you want to build a parent or a hierarchy of resources, you can do that too. There's lots of, lots of abilities on the import command. And if you check our release blog from uh in May, there's a whole blog about the improvements and changes that we made to the P import, the link will be in the show notes directly after this live stream. So again, don't worry if we going to find it and make sure you've got stuff to click shortly. Now the import command is great, but it can be a little bit laborious. We're doing things one resource at a time and this is where we have the TF to Pulumi command. Oh, all right. There we go. Uh, is a, that can read T farm programs and give you a poly code in any of our supported sdks. Uh You can install it via Homer on Mac and Linux and you can run it with just there we go to Pulumi and then provide a target language by default, you're going to get no Js. Uh and we're gonna do a quick example of this because I think that it is relatively interesting. So here we have a Terra farm project that it spends up three random resources, password 12 and three, made them all different sizes purely for sure, no real. There's nothing specific about the sizes. You don't need to worry about it. Uh We have a terraform state file and if we run a terra form plan, it will tell us that there's nothing to do. So what we have here is a deployed and working terraform program. Now we can run TF to Pulumi like so and we'll get in index dot ts. This is scanned, our Pulumi project. It knows that we need a Pulumi package and the random provider is then created with three random resources pulling on the side just as we are in the Terra Farm program and brought across our name, password 12 and three. So TF to Pulumi is really cool. Uh We can run that again with target language and this time we will do go and why not do Python? Well at it. Now, if you take a look at Man dot Go, you see the exact same. You just need to go SDK. We have a pluming program, password, one password, two, password three. You'll notice that and TF to plume and the plume Cogen in general that we understand what it means to write Python code, we understand what it means to write goal code and we try to adhere to those ecosystems and the patterns and the rules that they have for naming variables, for naming classes, for naming everything and types, et cetera. And so the names and stuff may change a little bit, at least the I DS within Poli but everything else should be correct and will be correct. So you can see here and go. We have type wrappers, just the lack of generics. So we're doing politer and on all the values lastly, we'll take a look at made up pie. Mhm. Oh Main dot Pie telling me and we have to sim uh we have pass one password two passer three and a random random randoms. Perfect tsum is a wonderful tool and if you can use it, you should use it. However, there are some challenges with TF to Pulumi that are being addressed uh not quite as I speak but within the vicinity of as I am speaking and you'll see that if we go to our pill request here. Um We are adding terraform 0.12 support. This is a precursor to support on other versions of terra farm. There's also a pull request for support in the TF state file V four. So we know that TFP needs some love and needs some attention. We're working on it now. Um It will work for some used cases. It will fail for others. Please feel free to open issues and let us know what isn't working. We are committed to making this work and making this a great experience for developers. So I called this example complex. It's not actually complex. If you take a look at my main dot TF, it's relatively trivial, but I'm calling it complex because what I want to show you is the more manual way of handling a TF state migration when you cannot do it via TF to plumbing. So what we have here is we have the terraform required providers. We've got our AWS provider being configured. We've got uh AWS instance being provisioned. We have an S3 bucket being created and we have an access control list on the S3 bucket. I believe Ron and Timi here will fail. Yeah, we have an error. Uh And that's because the default provider is there. I probably could remove that and that would work, but that's not the point. What do we do in this case with TF to pollute. I think going to migrate our infrastructure. We have some tea yummy. Ok. Uh Just losing my train of thought. I was gonna tell you it's a lap time song but it doesn't really matter. Uh because I'm talking to myself. All right. So what I have done here is that we have a Terra farm program. It also um should be no changes. Good, no changes. Uh And we can't use TF deployment. So what's our next stage? Well, our, our plume import command is super cool. So if we scroll down, we have the bulk and poor operations documentation, what this allows us to do is to create a JSON file like so that has a list of resources with their type, their name and their ID. And if you can produce that file, Polier will import all the state and generate a code for multiple resources. So that is a really cool way to do it. Um But the thing is we need to get that resource list first because we're all developers, we can make that happen. So what I have here is a goal main dot go file that actually loads a subset of the TF state file loops through all the resources, pulls out the name ID and type maps them to plume types and spits out our resources do chase them here. We have the AWS instance, the S3 bucket and our AC L. And what that means is I can run a Pulumi import provide in a research these dot J on and turn out to rate to index alt dot TS. I mean, I've already done this term is already imported. What we're going to do is let me that RM DEV Force and we'll do that again. Oh, let me back. And it, 01 of all my, my Aws credentials have disappeared. Uh, excuse me, while I rep provisioned to reconfigure my S3 credentials. Oh, no, it won't be the credentials, right? Uh, that Ews region West one, this may just be config not my credentials. We're about to find out together. Uh, it's not. Ok. So now it's saying it's not in the region. Ok. What region did I use? Uh, I should know. Let me check because I put a provider. Us Western, us West. Hm. And you? Yeah, bye. All right. Third time. Lucky. Much better. Ok. So it's telling us that we want to confirm, you can think of all the warnings for now. Um, uh, we'll put in the, yes, the magic happens and I've gone way over in my 10 minutes but we're having fun. So, not that fast. Uh, and we want to take a look at index all you'll see here. We have our Aws provider added, we have our instance and one, if you read the article with the import changes, that's going to be in the show notes in just a moment. And one of the improvements we made to the import command was to bring in all of these default fields so that everything was defined as code. And we don't rely on the defaulting too much if we scroll down. Uh, it's also protected by default, which is nice. We've got our bucket. Uh We've got our AC L. That's great. We can do that for any of our target languages and things are great. But you may be wondering, hey, what was in that mean dot Go? Well, let's take a quick look. If we open man dot go, uh you'll see it at a just enough tapes to be able to scan a terraform state file. So we have a type Terraform state which has something called resources. The resource has a name, a type a mode and then instances and inside those instances, we have some attributes and the only attributes that we care about are ID and name. So we just quickly stub all that out. We then have the Pulumi resource file description types. So we want to be able to write a Pulumi resources file with a Pulumi resource. And then we have some code here that reads the state file on marshals it to our Terraform state type that we mocked out. We create Pulumi resources and then we look over everything and say there's the TF state. I'm trying to be smart about generating the ID. So we check the attributes for a name if that exists we use it. If not, we use the ID because there's weird things with the way the state file works and then we spit out the resource and we write it to a file so you could do all this. It's not too much. Now, there is a lot more code in this file and because I did a big copy and paste just to do this quickly, however, all of this code is available and the uh F bridge repository could be used through modules. So everything below here is the mappings that I just copy and pasted. Uh I won't hide it from you. I'll show you it, it's all there. Um But this can be consumed through go mod. I was just lazy. OK? So that allows us to write the resources dot J and pull in a file. Now, the last thing I want to touch on today, I did a live stream a contribute session with Paul stack a few weeks ago where we talked about. Well, what if I want to be able to interact with Pulumi and be able to use Pulumi providers? So the stream went through in much more detail. I'm going to be very quick. The stream link will be in the show. Not in just a minute, I promise, but we have a repository cold, the Pulumi dash TF dash provider, dash boiler plate, you can fork this do a huge search and replace on a default value which is an essentially there's a target for it and the make file, which is all covered on the live stream. The last one, excuse me, which is all covered on the live stream session with Paul stack. It's called make prepare. It will allow you to update the name and the repository and all of the files and then you get a provider that is ready to be built and shipped. However, it's not going to be able to automatically bridge the chair form resources. There's only one thing that you need to do and that is to provide a resource mapping. You do that and say the provider resources dot go. Now this is a large one. Yours will not be as complex. But that's because there's some functions here to make this a little bit easier. But the only thing you need to do is first provide any config uh and inside the contact object. So if you need access keys and they could be set by environment variables, put it in once it's done content, you do resources. All we're doing here is saying that we have a string type from terraform scale. We account SSH key. Here is an example. And on the right, we have to tell it the token was then Pulumi and this is the direct mapping. The bridge does everything else. Now this function is here to make it easier. But if you really wanted to uh you could spec that out manually and we cover that in the live stream that's in the link at the bottom. It's 45 minutes long. Paul stack covers so much good stuff and it definitely worth checking out once we provided the conflict and the resources and there's a lot of them here. You also provide the data. There's too many other the data sources. Terraform has a concept of resources and data resources which allows you to look up just the same. All you need to do is provide a mapping of terraform type string to Pulumi token. And that is all from there. You can build a provider and ship it. So here we go. I said 10 minutes. We're at 24 minutes. However, I wanted to make sure that you leave the session with a bit of an understanding. Well, I'm not used to. It's just I I computers leaving. Hopefully you're leaving a session with an understanding of the ways that we can migrate existing terraform resources using the migration guide by using TF to Pulumi using the import command or even scripting a bulk import as required. You can build bridges to the provider using our provider template. All the length and more information is in the description. I hope you enjoyed this session and I will see you all in a week. Have a wonderful day.

---
