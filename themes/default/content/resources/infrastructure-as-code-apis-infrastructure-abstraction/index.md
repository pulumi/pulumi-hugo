---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Infrastructure as Code APIs - Infrastructure Abstraction"
title: "Infrastructure as Code APIs - Infrastructure Abstraction"
meta_desc: |
    "Creating Layers of Abstraction with Pulumi: Leveraging APIs and Writing Your Own | Paul Stack"
url_slug: infrastructure-as-code-apis-infrastructure-abstraction
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Infrastructure as Code APIs - Infrastructure Abstraction"
  description: |
    Paul Stack, Software Engineer https://twitter.com/stack72  Talk: Application Code Isn't the Only Code that Can Have an API  In this talk, Paul demonstrates why programming languages help to build the best infrastructure code. He shows how simple programming constructs help create APIs that anyone can code against.  Recorded at the July 10, 2019 Pulumi Up Seattle meetup Repo: https://github.com/stack72/pulumi-meetup
  sortable_date: 2019-07-16T20:03:37Z
  youtube_url: https://www.youtube.com/embed/QuOMyZvSt-A
transcript: |
    Um I realized that there's two talks tonight and that's actually stopping you all from having uh more beer and social time. So I'm gonna make one very, very, very, very fast. My talk is called application code isn't the only code that can have API S. My name is Paul Stack. You can find me on the internet at stack 72. It's very strange for me giving a talk at a meet up where my boss is there. My boss's boss is there and my boss's boss's boss is there because usually I drink and I swear. So I will try my best to be as coherent and uh non and as politically correct as I can tonight. If, if I'm not, I apologize in advance and I'm sure we will cut it from a talk. So uh this talk is completely code. This is the only slide I have. The code will be available uh on github and uh you can go and you can download it and you can see different things. So I have two section of code today. Um First thing I'm gonna show that the fact that with Pulumi because it's a real programming language that we can actually create layers of abstraction uh because we can create layers of abrasion, it feels like we can create same API S that people can actually take advantage of. This is not a level 100 talk. I apologize if you're new to Pulumi. But the, the code that I'm showing should be very straightforward because of the fact that we, we use quite sane API S and uh across the different types of cloud, it's gonna be very specific to Aws tonight. And we are going to take advantage of two different things. Firstly, we're going to take advantage of the very um good crosswalk uh Amazon crosswalk API library that has been created and has been lodged publicly within the last uh month and uh people can take advantage of. And secondly, we're going to show that you don't just need to use those API S. If the API S don't exist, you can actually write your own and you can actually start to create some layers of abstraction so that your own users can take advantage of things. So I have a few things going on here right now. Uh Firstly, just to show you, I have deployed this stack because it takes about 10 to 15 minutes and I have like 20 minutes to give this talk. So it's better that you don't look at my screen and watch it, say and pull me creating for the next 10 minutes because then everyone will be falling asleep. So you can see it does a lot of different things. It has a database, it has some VPC sub net, some right tables and some Diam policy attachments. So we'll go back to the code and we'll have a look at what it does. So first thing we have um Amazon X like crosswalk API package on the crosswalk API package, we can pass a name to you, We can pass a Cider block and we can pass a number of subnets. And this is very simple and very easy and it's not the crux of the talk. This is very much publicly available. You can download this and you can use it today and it's a lot of what I'm talking about on on this crosswalk stuff is available on the blog. The second thing is is um R DS. So first thing when we deploy this, it actually brings up um some, it, it will go off and it will find the number of availability zones available for the VPC because it'll go off and make a call to Amazon. And then for each availability zone, it will deploy a number of not gateways or AAA gateway per availability zone and it will deploy a public subnet per availability zone. So if I go back to my pull me up, we can see it's got a public zero, public one, public two, public three, public four, public five and public six so we can actually see it has six subnets that it's deployed. And if we go and inspect them in Amazon, we can see that each of the sub has a slash 20 sider block. So I started thinking about what other ways of abstraction can we actually create um across the top of A O BS. And I'm a very opinionated person and I'm laughing as I say that because the more beer I have, the more opinionated I get. So I've been deploying stuff in Amazon for quite a few years. And um iiii I kind of have my own way of doing a lot of different things. So we declare an R DS and we'll look inside the code of this in a second. OK? We pass in a description, we pass in some tags because I actually want everything to have like a, a base tag. So if you think of uh tags like cost center or department or uh which team or stuff like that, so you can actually set this as a base tag and pass those tags around everywhere. That way all of your resources will be um available to, to have those tags and that'll be useful later when uh when you start looking at things like policy as code and, and different pieces like this, then we, we pass in a number of subnets. Uh The subnets we actually pass in here are the public Subnet I DS that come out of the VPC you'll notice in a production environment, I would not just deploy everything into public subnets, but I'm being crazy lazy and I'm going to just deploy everything right now and have it available across all of my public subnets. We pass in a user name and password which we will pass in secrets for just because good practice. We don't really want to keep that stuff uh available and, and play text anywhere we'll pass in allocated storage, an engine version. This is very much a hard coded um engine to uh post and I should have called it actually a post S DB instance, we'll pass in an instance class. And uh as you can see in Pulumi, we have abstracted uh away the instance types so that people don't actually need to know what the instance type, um identifier is. What you actually do is you just go in instance types and then your intelligence, you can see all the different instance types that are available. So we can actually see what, what they are. In this case. I'm going for an R three large just because I like those types. We have a storage of GP two which is basically an SSD and we pass in a final snapshot identifier because when we destroy our database, we want to take a final snapshot. It's just good practice like this. And I have, we're gonna come back and talk about this San and Han logs the cloud watch because this is a very interesting piece. This is where we can start to really abstract the way different um actions that happen inside our engine. So if we go inside the R DS class, we can see firstly that we extended our component resource. So this is just uh an internal construct in Pulumi where um we can actually start to create our own class across the top of things. We have uh some outputs, we'll come back to the outputs and then we have a constructor. So our constructor takes a name because of how we look at it where we have a name and we take in some arguments, the arguments in this case will be R DS hunters, which will look at the interface in a second and we can start to do different things. So the first thing that we need to do when we create an RD instance is we need to create a subnet group. The subnet group will take the Subnet I DS on any tags that we want. And again, as you can see, because I'm passing the base tags in, we automatically take all of the base tags that we needed as well as any extra tags on top. So in this case, we tag it with sub net group name and so on and so forth and then we append it to our parents. So the next thing we do is we, we create a R DS in instance. Now this has got a lot of different things going on in here. So firstly, I'm gonna look at at the real um uh meat of it. So we pass allocated storage on the subnet group. Now notice that the subnet group is actually this subnet group. That's, that's uh that's actually being created in situ, it's not one that's been created outside. So users don't need to care. They don't actually need to understand about Subnet groups. They don't need to understand what Subnet groups are, what they're needing to do, et cetera. They pass in a number of Subnet I DS and we will create the Subnet groups for them on our behalf. Then we're saying as I said, the engine is hard coded to post um Just because I'm not a my sequel fan, we pass in in uh engine version and instance class and then we can start to take advantage of how our language looks. So if we pass in IOP, we will set s otherwise we said if it's zero and if I ops is zero, then Amazon will ignore that just because of the fact that um it it zero is like uh the default value for the number in the same way as that string is the default value for a string. And Amazon realizes that it's not something that needs to be set. We will set a um backup retention window. And if we don't set that we'll set a default of seven, the same for backup window, the same for maintenance window. And then we'll come back again to this monitor and interval in a second, then we can pass it in the user name, password, any names, et cetera, et cetera. So now we can start to take advantage of um working out the layers of distraction across the top. So I passed in this if a uh send the enhanced logs to cloud watch. Now, if you want to send enhance logs, the cloudwatch and Amazon, it's kind of a pain in the ass because not only do you need to switch it on, but you also need to create uh an im role, you need to attach a policy to that I am role and for people to understand exactly what that's doing uh and create all of those rules would be extremely painful. So because we're in a, a programmer language and I pass in a bull right here where I say send and loves the cloud watch. True. I can actually say if it is true, then what we're going to do is we're going to create a rule. The rule will have the correct assume poli assume role policy which will be monitoring the R DS dot Amazon aws dot com. And it will have the correct tags as well as that, we can attach a specific policy which is a well known and well-defined policy uh which points to the Amazon R DS enhance monitoring role policy. So once that is created because it creates it first, it needs to understand it. Um We can then say further down the monitor enroll A RM. If it is defined above, then pass it in. Otherwise it's an empty string. So we've hidden away 23 levels of um different resources here. Firstly, we've, we've hidden away the, the iron rule, then we've hidden away the Iron policy uh rule policy attachment and then we've hidden away the sub net group. So users don't need to care about that. And it's a very simple API across the top. Now, we can take this a little further. I have created another um parameter called number of red replicas, read replicas. I'm going to, this is where I get a little bit more opinionated read replicas and Amazon are terrible. Uh especially if you're on the non uh aurora based set up because there's only specific parameters that you could pass in. And if you pass in the wrong parameters every time you try and do a refresh, it will actually try and destroy your read replica and it will bring a new replica up in its place. So what I actually tried to do is now this is by no means the best type script. Um And I'm sure that you're, you're sitting in a room with people who are like typescript experts and they will be able to give you much nicer code than this. But it's a very simple way of saying is that if there is a number of read replicas, set it to a number of replicas, otherwise set it to zero. And because again, we in a program language, we can actually loop over and say for every one in the number of replicas, let's create a new R DS instance of an instance, class type, skip the final snapshot. You can't take the final snapshot of a um R DS instance. And then we can actually say that the replicate source DB is our main database that we created and we can pass it in and pass it in the specific tags that go for it. Now, if I go back to my uh Pulumi Street, I can say uh Pulumi 3D and there should be zero changes because everything is deployed as expected. It just gives us a second. It's, it's trying and I promise. So we can see we have 40 unchanged. And if I go back to my code and where I actually um have defined the interface, if I say number of reader replicants, and if I say three and I go, if I go back to pull me up, it should tell me that it's actually going to create three new databases and it will give me the databases red rep with 01 and two, just give it a second again. And there we go, we can see actually see that just by passing in a specific parameter for read replicate that you can start to take advantage of it. So by doing this, you can, if you have like an operations team who uh are, are very tightly controlling like your infrastructure and trying to like define AAA correct way that people can create their, their specific infrastructure across the top of it, then they can actually give you these classes that they can use as like node modules or uh P uh Python modules or, or, or so on. And you can actually write code against these, which means that they can control um the different API S that people do, they can control the different resources that are required for it. And not only that they can actually can start to control the different tags that people actually have on the top. Um by using these types of API S, you can actually start to do different things based um based on the top of it makes sense so far. Is everyone with me or is everyone just eating pizza, by the way, I can see your face? So please at least nod. No one cares really, no one cares. Awesome. So um the reason I started doing this is because um we, we have a fantastic story around um uh VPC S and API Gateway and a lot of globe balancing in the crosswalk and um DB instances are sort of a, a forgotten art within Amazon. Just because a lot more people are starting to use aurora based on the top of them. And I've been deploying DB instances with red replicas for like things like Post Grass and my sequel for about five or six years. And I know the ins and outs of why, why people would require API S across the top. And if we start to, we can actually start to extend this and we can basically pass a new type. So if I turn around and I can say DV, prime, excuse me, DV, option group name. And if I say input, use my type and good string, sorry. And then further die, I can start to take advantage and I can say um auction group name and I can say R dot DB auction group name otherwise uh empty string and then we can actually start to build our own DB action group. So actually, what have I just done here? Oh, it's already there. I apologize. Um So if we pass in, I just gonna take that out a second. Sorry. Um We can actually pass in whether we want to create custom. This is what I want to do, create custom TV auction group and I can make it loveable and put bully in. And then we can actually say further die. Yes. Arts dot create custom TV. Auction group. I can say uh they thought action group, it was near a bar DS auction group and I can say my custom option group and I can really start to like build up a, a proper API across the top. And then anyone can say create custom action group is true and I can say custom option group name is whatever and we can start to like chain different uh pieces of the puzzle together. So by doing this, it allows us to keep away all the layers of distraction and keep away all the different resources that people don't need, need to care about because especially when it comes to things like Im Rules and auction groups and um security group I DS and things like that, it becomes really painful and it becomes quite um arduous in what you. So by taking this a little further, not only will this work for um our R DS instances, but we can then actually start to run and we can say, create a custom DNS record true. And I'm gonna create a new way of doing that right now, create custom that the PNS record. And what I can do here is I can basically say if R dot Create custom has the DNS record and I can start to say DN S dot DNS U aws route 53 dot record and here. So now we've come into something that can be a little painful in Pulumi. So Pulumi has this idea by default of auto naming and a lot of people get caught out by because when you, when you call something by name in Aws uh as a record, it will actually append a suffix on the end and it, it can be a real problem if that's the case. So here we're just gonna overwrite it and say my record and we can then start because we have a full um programming language. We can start to get in intelligence based over what the different pieces are. Um We can start to say types uh A W dot Route 53 dot Record. Oh, excuse me, I apologize. Record types dot C name. And we have like full strong typing of everything that we do and we can actually start to see here is name and type is not assignable. Uh property zone id is missing. So we need zone id and then we can just pretend that we've passed in a zone id and then we actually have a, a AAA DNS record that goes for it and um it'll, it'll work through all the different pieces of it because we can do this. We can, nobody cares about like you can actually say um custom DNS name which will be in the like a string that we pass in. And then they can say, instead of like my record, you can say dot Custom DNS name and you can start to really keep a lot of different things away from, from all the users. So it's, it's like a 20 minute whirlwind of, of the different pieces that you could do in order to make this a little easier um to hide away the fact that this is a programming language. And because it is a programming language, sometimes people are a little put off by it. They're a little scared because especially in the operations world, you know, they have to learn, not just the cloud, not just like um how the cloud works, but also they have to learn a new program language. So by abstracting a lot of that away, it actually makes it a little easier for them. Does anybody have any questions? Whatever you want? It doesn't need to matter like where I live. What I do? I don't mind. I maybe I question. So why do you have a distance? Me but you don't have a type? I'm I'm really sorry. Um Can can somebody who's closer to the mic relay the question just because it's, it's a little far away. So do you have in instance type? So you have an instance type? Yeah, you can into a sense but you, you can't into a sense. The yes you type. OK. So you have an instance type that you can tell a sense but you can't in a sense the Epseps EBS EBS volume type. Any questions about uh the uh that we have available for some place where? Oh OK. Like the magic like like the one that I have highlighted right here, right? Yeah. Yeah. Yeah. So, so, so this is like syntactical sugar that's, that started to be created in the past. I'm, I'm looking around the room maybe the last sort of two months, three months where we started um adding a lot more syn tacular sugar to make things a little more uh usable. Uh Storage type is not one that's being created right now. It's very simple to be created. It's just um time is an issue because we have quite a small development team. But it's, it's certainly, you know, uh things like engine types, things like uh uh storage types, not engine version because they change quite a lot, you know, things that we know that we can control, we, we will certainly over time start to add a lot more synthetic sugar on them to make them a, a little easier because it's, it's very easy to understand like R DS instance types, but it's not very easy to understand R DS storage types. So we, we can definitely add that for you. There's no problem, anything else that all of the providers. But then we, we add more and more. I, we've been at polls, been having a lot of these actually, you guys quite recently. And uh also pr is very welcome. Yeah, I'm just, uh because if I'm a first time user, I need to figure out myself what, what, what to put you to. No, it's super, we have to get that and tell us to get the. So that that's part of why I Paul has been so excited about our coverage of those but, and like part of the reason why I added these as well is because I'm very lazy. Um I don't want to have to remember a lot of the magic strings. So um by, by giving myself the intelligence, I can really start to understand the different things that are available. The only trouble with magic strings like this is um making sure that you keep up to date with Amazon. So, you know, we, we need to find better ways to like uh pull this information from Amazon just because of the fact that um it changes quite a lot, especially when it comes to instance, types, things like storage types and the engine types don't change as much. But when you have um definitely around um instance types, it changes a lot and can differ from region to region which can be a real pain. Uh Maybe maybe a, a blog post on this to show people um how to create uh this, this type of sugar so that if they really need to, they can um simple requests would actually be quite useful here. You love. Mhm. Iii I wasn't volunteering too late. Wrote it down. Yeah, I have a All right. OK. I'm gonna, I'm gonna go to bed. Um It's 5 30 in the morning for me. Enjoy it. Enjoy the rest of your evening, uh, folks. And, uh, I hope to meet you all next time at the meet up. Thanks so much. Thank you.

---
