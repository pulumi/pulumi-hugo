---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Kubernetes Voting App on Azure Kubernetes Services | MIW 2020-08-12"
title: "Kubernetes Voting App on Azure Kubernetes Services | MIW..."
meta_desc: |
    In today's episode, we create an Azure Kubernetes Services (AKS) cluster and deploy a sample voting app. As part of it, we upgrade a YAML manifest ...
url_slug: kubernetes-voting-app-azure-kubernetes-services-miw-20200812
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Kubernetes Voting App on Azure Kubernetes Services | MIW 2020-08-12"
  description: |
    In today's episode, we create an Azure Kubernetes Services (AKS) cluster and deploy a sample voting app. As part of it, we upgrade a YAML manifest to a modern programming language with kube2pulumi to improve future maintainability. In just a couple minutes and a couple lines of code, we're able to start improving upon the code.  Code for this episode available here:  https://github.com/pulumi/pulumitv/tree/master/modern-infrastructure-wednesday/2020-08-12  Today's example is in Python, but Pulumi makes it easy to stand up infrastructure in your favorite languages including TypeScript, JavaScript, C#, and Go - saving time over legacy tools like CloudFormation and Hashicorp Terraform.  https://www.pulumi.com/docs/get-started/?utm_campaign=PulumiTV&utm_source=youtube.com&utm_medium=video
  sortable_date: 2020-08-12T20:31:40Z
  youtube_url: https://www.youtube.com/embed/jKxSm-fnAO0
transcript: |
    Hello and welcome to another episode of Modern Infrastructure Wednesday. I'm your host, Lee Zen. Super excited today to go over building a Cubin voting app on A KS. And especially because we'll be showing off one of the new features that we are announcing today in Pulumi uh which is Cube to Pulumi. So today, we're gonna go through a couple of things. We're gonna create an A KS cluster. We're gonna use Cube to Pulumi to actually convert a YAML uh manifest to a modern programming language uh example. And then we're gonna deploy it and then actually do some quick simple refactoring now that it's in a modern programming language uh all in a few minutes uh here on modern for, for Wednesday. So if you haven't already, please make sure you subscribe to the channel and also uh make sure you uh go ahead and like this video uh after you watch it or go ahead and click the like button right now. Anyways, let's get started. Uh We're gonna start off with basically using this uh this example uh in, in the uh Azure uh quick starts and we're gonna be deploying this, this, this uh example application. And so uh this example application I've already got this open in visual studio. I have this in this uh this file, this L file, this manifest, I've already copied it over. And you can also have a, I have a fairly simple PLU program here set up. Um You know, I just got the, the standard things in my requirements. Uh I'm using Python today and um it's also worth noting I had this cluster set up with this is more or less copied and pasted uh out of this uh in the Pulumi examples, just you know how to set up a AKS cluster uh using Python. This is more or less exactly copy and paste um changed a few names, but otherwise, not a huge lot of differences there. So I've already deployed that. And now the question is like, OK, I could, you know, use something to deploy this em mole, which I don't know if I know if I really want to do that, right? Like this is, this is not that, that great to work with, you know, from a maintaining perspective going forward. So can we actually, you know, I could also rewrite this by hand um into, you know, Python. Uh if I'd like or I can use uh cube to Pulumi. So uh I've already installed this, I'm just gonna show you can, you can brew install uh cube to Plumy super easy. Uh Not a whole lot to do there since it's already installed. And then we're going to run a cube to uh oops going to run a cube to Pulumi. Uh We're gonna ask to convert to Python and we're gonna give it this uh manifest file and boom, just like that, it's all done. And now we actually have the, the exact same uh code. But in Python, which is very nice and uh I can actually just import my cluster and use that cluster to deploy this app. So um from cluster import, uh I think, I believe it's called A KS, OK. And then we can create a provider for that. So um we'll do that, let's do this and we can just give it the um the cup config OK. That's all we have to do. And then for each of these resources, we can just make sure right now it's gonna go against the ambient provider. Uh Instead, all we have to do is just make sure for each of these resources, we give it a uh resource option uh to um to use the uh I'm not sure why that's not showing up uh to, to use that provider. So I'm just gonna copy and paste uh this to each of the resources, all right. And finally, we want to be able to test the app. So in the, in the example, they actually talk about, I think doing something like uh watching and, and then checking using cube cuddle to get the, the service information we're using Pulumi. We can actually just export the information uh out of here and, and have that available for, to us uh at the deployment time. So I'll, I'll take this, I can just do uh a Pulumi export. Oh, you know. Yep, I have that. Ok. We, we export uh and we'll call this, you know, the end point and all we need to do is give it this uh status, that's the output of the uh of that service and we can run Pulumi up. So let's see, make sure we have this preview, see what it says. It's going to do this should uh create the various uh resources that are mentioned here that these various deployments. Oh Did I miss a? I might have missed a oh, here, I forgot the name of the provider. There we go. Uh I believe that's all we need to do. All right. So that now, now we have what we want. So now we, you can see we have the, the various things being created and then we're gonna have this endpoint output. So let's, oops, I'm in the wrong window. Let's go ahead and do that. Yes, you can see actually did, did, did this earlier and uh we're gonna drop that output book. We're gonna do this again uh for real. And so now it's, it's uh this created this provider based on the Q config from the cluster that I created earlier, uh which was, you know, like I said, copying and a paste from the examples. And then now we're deploying the actual services uh that we co generated from the gamble manifest. So this, this code is what Q two Pulumi outputted. And then we're using that code to, to deploy um the example. And so pretty soon at the end, we should have this load balancer IP here and, and sure enough, we do and we should be able to go to this endpoint and test it out, looks like it's still coming up. OK? So let's give that, let's give that a second here. Um While that's going now, you know, the whole point of converting this into code is to actually, you know, not have to uh to be to be able to maintain this more easily. So you can totally see like there's some pretty easy opportunities to uh rape opportunities for um uh refactoring here. So for example, like we can call, you know, we can have this thing called like back end name, right? Like this is used all over the place and we can just replace that um through our, our code, so we can do this right? We can do that. Um And then we can also do this like this should really just be, you know, uh the back end name and you know that that's, that's a pretty simple example of, of some of the factoring we can do, um you know, this is like I said, this is used all over the place here. We have this like red port. Uh we can, we can replace that as well. Right. We don't really expect that to change and so we can go down here, I think I saw uh here we go. Right. And so over time, as you know, we can imagine, like if we wanted to change these constants for whatever reason, like we could do that and that would be part of the way that we are able to uh maintain this application. Here's another one where we can use the uh the back end name, right? And uh one more time, right. So, so really just cutting down a lot of this uh boiler plate that we had from earlier. Um and I'm not gonna do too much of this as I just wanna show a couple of, of these as examples. And then, you know, if we, if we were to run plu me up again, right. We shouldn't expect any changes because we, you know, we've only, we've only, we factored things from a code perspective but, and made it more maintainable going forward, but haven't really actually uh changed anything uh for real here except uh looks like it thinks I made one change. Oh, I, I actually made, I messed up underscore two. This was actually, this is actually not, not a straight up replacement was as your vote, this is, these are underscores. So I, I actually made a mistake. Uh Let's delete that. So we actually wanna say no, ok, let's check this again and now we should see no diff. Ok. So nothing, nothing to deploy, so nothing to do there. But yeah, this time unchanged uh with no silly mistakes on my part. But again, like one of the nice things about plum is you can see, you know, everything is very much desired state driven and we can see, you know, what, what's gonna happen actually before, before it happens and, and know what state we're going towards. So, oh now, OK, I was just waiting for the answer to come up. It's uh it's come up now. And so this is, this is the uh you know, don't need to show too much here, but this is the example app that we had uh earlier. And uh at the very end, we can obviously run polling, destroy and take down our whole stack. Uh And, and, you know, remove all the resources uh from, from the stack. So, yeah, so really just wanted to show this really simple example uh but also really powerful uh of how easy it is to uh build an A KS cluster uh and then deploy to it. Uh not using YAML, but using, you know, modern programming language where we can convert that YAML to a modern programming language using a tool. Uh So you don't have to handwrite everything and then you can start using that language then to do whatever factoring you want. Um pull things in and out. You can see like, actually, like I didn't really, I kind of glossed over this, but I took the code that got generated and then integrated it with existing code that I already had, that was able to reference this cluster. Uh So I didn't have to do anything like, you know, all that orchestration happened in one program basically. Uh And then I was able to, you know, make the deployment check how the state would look and, and uh uh able to make sure that uh things were, were the same after I did my refactoring. So I hope you enjoyed today's episode. Uh Please make sure you follow us on youtube, make sure you hit that subscribe button. Like I said, like the video if you enjoyed watching today, uh leave any comments, happy to always uh talk to people in comments. And yeah, I hope to see you next week on modern Infrastructure Wednesday. Thanks a lot.

---
