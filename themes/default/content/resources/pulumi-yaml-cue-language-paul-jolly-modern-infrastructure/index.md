---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Pulumi YAML & CUE language with Paul Jolly | Modern Infrastructure"
title: "Pulumi YAML & CUE language with Paul Jolly | Modern..."
meta_desc: |
    Join us for this LIVE Modern Infrastructure as David Flanagan (rawkode) and Paul Jolly show you how to use CUElang to describe your cloud infrastru...
url_slug: pulumi-yaml-cue-language-paul-jolly-modern-infrastructure
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Pulumi YAML & CUE language with Paul Jolly | Modern Infrastructure"
  description: |
    Join us for this LIVE Modern Infrastructure as David Flanagan (rawkode) and Paul Jolly show you how to use CUElang to describe your cloud infrastructure for Pulumi.  - What is CUE language - When to use CUE - How can CUE interact with YAML and Pulumi - Build your own abstractions - CUElang example with EKS cluster  Pulumi-YAML: https://github.com/pulumi/pulumi-yaml CUE-EKS example: https://github.com/pulumi/pulumi-yaml/tree/main/examples/cue-eks
  sortable_date: 2022-05-11T22:52:54Z
  youtube_url: https://www.youtube.com/embed/R9NWBp_OjMo
transcript: |
    Hello and welcome to Pulumi TV. This is a slightly different take on modern, modern infrastructure this week as we're going to do it live as always. I'm your host David Flanagan. Although you may know me from across the internet as raw code and today we're going to be taking a look at a plume yael support that was announced at Pulumi up conference just last week. However, we're going to look at it with a twist and look at using Q as a language to provide the All right. Joining me today we have Q team member, Paul Jolly. Hey man, how's it going? Hi, David. Very well. Thanks. How I'm glad to be on today. Thank you for having me on. Ah, always a pleasure. I could sit and talk to you all day. It's always, there's always so much good stuff, even just in our pre segment video, they were sitting and talking about film scores and composers. So, you know, I was tempted to put that video back on for another three minutes and keep that going. But maybe later I'll try and get some uh hand zimmer on feed that in later on as Well, exactly. Yeah, I'm sure they copy it and that won't be too expensive. Pulumi TV scores. Uh, so for anyone who's not familiar with you and your work, could you just give us a bit of a TLDR on who Paul is and what you're up to? Sure. Yeah. Um, as you, as the, the caption showed I work on the Q core team, um, which means that I work closely with Van Louse who created Q. Um Q is an open source project. We'll come on to talk a bit about what Q is in a second um that was developed by Marcel when he was uh at Google. Um Marcel's actually now left Google and we are uh really making a thing of Q itself and Q is really gaining in popularity in various different spaces um sort of known particularly as a configuration language um data and uh API language as well. Also. Um so the main focus for us on a day to day basis is actually trying to understand. OK. Where does Q as an open source project need to go? And how can we make it as interesting and accessible to people in all the various different use cases? Um where Q can, can be found and used. And we're going to talk through one of those today uh in the context of, as you said, of OK, how Q can interact with YAML and in this case, how it can interact with Pulumi. So I look forward to that. Awesome. Thank you for sharing. I guess we should, you know, now talk about Q and, and, and what that means to people. I think I feel like I, all my people that I work with all my colleagues at are probably so fed up with me just going queue all the time. But it's such a powerful tool that I love that. You said that it's really grown in popularity and it's been used in multiple spaces, but there's still a large number of people out there who just haven't come across it yet. And like, I hope that so a session like today, we can show people how powerful it is and how easy it is to get started. But for that, for those people can we just kind of give the what is Q and a kind of rough overview? Yeah, absolutely. Um I think just before we dive into Q there is that uh into what Q is itself, it's actually one of the main challenges for the open source project at the moment is to say, well, Q can be used in lots of different situations and is very powerful. We've, the challenge for us is to make that as accessible to people as possible. So our plan is to say when they land on Q LA dot org, which is the, the website, it should become immediately obvious to them wherever they are coming from as to why Q can be relevant for them? Um So Q is typically known as a configuration language. Um but it extends beyond that to also having capabilities in describing the structure of data and API S as well. So when people think about using Q, they are typically thinking from like a configuration or data or API management perspective. And that's very, very broad though. So if you think about there's one live stream that I did not too long ago where we actually used Q as the basis for describing github actions workflows. And in that scenario there, what we're using is Q as a way of describing the data structure that is our github actions workflow. But we're using the schema part of Q to help ensure that we are writing a valid workflow in the first place. Because if you're just writing YAML, you don't readily have that scheme at a hand. Whereas in Q, you're, you're able to write the data as if it were just Jason but validate that at the same time using the schema that is also defined in Q um to ensure that you're actually writing valid configuration in that situation. So Q combines this nice thing of being able to have data and schema sitting alongside each other. And so really, then you can say to yourself well, OK, fine. In some situations, I actually want to describe something in more of a schema or API style. And that's where the the schema capability of Q really comes in, in other situations you say, well, I just want to write some data and in that situation. So the data side of Q, if I could refer to it about is, is more powerful. And so there's lots of syntactic things within Q, the language that make writing Q much nicer than Yaml for example, or much nice, nicer than Jason. But it's not to say that Q then is a oh we really hate Yaml or we really hate Jason because actually these, we live in a world where all of these different encodings actually need to work together very closely. And so then that's another really key aspect of Q is that it's not looking to replace Jason or to replace Yaml, it's looking to work alongside them. And so we find that where people are using Q a lot and I gave the github actions workflow example earlier on is saying, well github actions consumes Yaml, but I actually choose to write my github actions workflows in queue because it's easier for me to validate that I'm writing a correct workflow. Then all all I need to do is export my cue to YAML and I can continue to interface with that system that already consumes Yaml. So that's been one of the key stories that actually we've been hearing from people who are adopting Q is that they don't actually need to, to go wholesale into Q. They don't need to rewrite systems to consume Q. They can continue to work with systems that consume Jason Yam and actually just introduce Q bit by bit to get small wins within their system. And then step back and say, well, hang on a second. This is actually giving us some real benefits here. Let's work out how we can make our Q support a bit more um integrated in principles. Awesome. Um I don't want to digress too much there, but I'm curious about the actions that we were doing. Um Yeah, because we already get actions, work flow and yama now and some of them are getting quite beefy and we're trying to find ways to make those smaller compos, reusable, etcetera. I'm assuming that you're just using the Q export and committing the dot Get Ya fails to the repository. There's no way if we get up itself to correct. Yeah, that's absolutely right. And we're happy to talk about that in detail. Um Another time because I don't want to distract from what we're gonna talk about today. But you, you just picked up on a really key word there and that's reuse. And so something that's not fully implemented yet but is very high on the list is full package management support. So for those who are familiar with the go ecosystem where there are packages and the concept of remotely depending on, depending on remote code. So a package, you know, hosted by somebody else and owned by somebody else, that same concept will exist within Q as well and that will be a first class citizen um of the, the language itself. Um And so there, the, the concept of as an organization, perhaps building up reusable parts of your C I infrastructure or whatever configuration um might be, you can then re factor that into packages that can then be reused in different parts of the system um in a, in a very simple way. And that's not to say that's impossible with other languages. But with Q, you've got all the benefits of Q plus, you've got a very good package management story to come with it. So that's um something exciting we're working on right now. Yeah, definitely. I hope that comes with a schema dot Q dot org where we can like know like schema dot org that has all these Jason schema repositories. I'd love to see something like that. Yeah, that's it. It's super interesting actually because those um a lot of the my understanding is that github actions, um github themselves don't actually own the Jason schema specification for the workflow specification that sits on schema store dot org. And, and that quite surprised me because it sort of seems like there's a whole load of derivative benefits to them owning that and that being the source of truth anyway, that, that sort of point aside, uh I completely agree with you if, if these schemes do exist in the wild. And there can be a single source of truth that people can reference, they can make, you know, a part of their configuration ensure that it is cons consistent with that schema and that there's a whole load of benefits that come from it. And this whole idea behind being able to compose um large queue configurations and to have them all be consistent because they all uh are consistent with specific schema. It is part of the Q story. So yes, I think we'll um we'll definitely see something like that in the future, right? Last point of digression. And then we'll get back on track here. You should look into get labs C I system which actually does provide a compiler for like to run a command on an object to generate the, the work flow, which is really cool. But I know like in my head, I, I need to go play with that. That's a rabbit hole. I'll happily explore with you. Yes. Um Because to be fair, I have not looked at github, GIT lab. Excuse me, my focus has only been on github because the Q, the project itself uses Q in order to maintain the work flows for the Q projects um that all run on GC I. So yes, we should look at GIT lab as well because that's obviously a very big contender in this space too. I think they, they were one of the first organizations to provide YAML interface. And I think they ran into a lot of these compos reusable really early and they were like, you know, what, just generate your YAML with whatever you want. And here's a flag but you just tell it how to, how to, which is cool. Anyway, feels like a good live stream episode. That one. Yeah, I know. There's too many ideas. Not enough time. That's the problem. But today we're going to take a look at Pulumi Jam support uh and see how we can use Q to kind of build our own abstractions and, and like just like you were doing to get help workloads, but allow people to describe their Pulumi and Cloud resources and build functions, build definitions, all the Q logic magic stuff and make their P programs a little bit nicer because while Gammel is simple and nice if you've worked with before, you know, the schema and stuff like that uh doing abstractions, things like loops like uh I mean, we've all used the gamma anchor at one point and I don't think any of us have ever enjoyed using a Yaml anchor, but the ability to reuse those is really cumbersome. And I think this is where comes in with its superpowers. And just once you learn the syntax and you get comfortable with it, you can do some really powerful stuff and very little code and I'm hoping we can show off some of that today. With apple, no pressure. But that, that's where you come in. Yeah, it was, it was, it was great to see the announcement for Pulumi Yamal support. Um um You'll talk a bit more about that. But I think again, it speaks to that whole world of, well, actually to have first class queue support out of the out of the gate would be, you know, a step too far. But Yael is something that people are very familiar with. And so it meets people where they are right now. Um But this again is what Q is trying to do is say, well, let's meet people where they are in terms of the Yaml space that they're operating in. And as you said, provide them kind of the nice syntactic things within the language that make it easier to use from a language perspective. But also then the the key point is from the Q perspective is tooling. So how can we actually provide really useful tool that helps the person who's writing Q to, to do useful stuff? Um And so language server support will be something that comes down the line as well so that you have within the editor, just that fully rich experience of um completion errors as you're typing, just pulling all that information up front so that you're just making less mistakes or at least catching the mistakes earlier rather than later. Yeah, I always tell people that's one of our missions is to provide a rich editing and composing experience for all and food resources. So yeah, definitely. And to look that back to what you said about Q earlier and that is there to kind of interrupt and work with these other formats like Jason and right, you know, Pulumi means we have yam and can come in and give us constraints and validate and verify all of that for us as well as providing the abstractions on top. So I think we've, we've chatted a bit and, and I'm sure we could chat for the rest of the session, but I would like to share my screen and start running through some of the Q examples that we have and the Pulumi Yael examples repository. So here we go. So if you wanna check out Pulumi ya, you can go to gib dot com slash Pulumi slash Pulumi dash L. Uh All the instructions are here. Um Nice simple example and uh what resonated with what you said there, Paul is coming to developers where they are like some people don't want to fall back to a program and language for simple infrastructure use cases, uh managing github bars and teams or repositories, creating a single bucket with an AC L like you don't often need to write, you know, 60 lines of goal 30 of which are er checking probably and then some typescript, et cetera like a Yale definition is enough for the basic case. And I think this is really cool. Uh But what we want to look at is samples and there are three here that I worked on. We have the using queue to generate a random string or integer, using a plumy random package, deploying an aws do web app. And then my favorite one, the plane I complete Kubernetes Eks cluster on the A AWS book. So I think we should probably start with the easy one first. right? All right. And for do here and this is it, it's not too dissimilar from, right? And that's, that's, that's the selling point of QE. Yeah, I mean Q is a super set of Jason and there's the, then the relationship between Yael and Jason that makes it sort of feel that all three are gonna feel kind of similar. Um But then we sort of get down to some specific differences um between them that makes it uh makes some from a like a writing perspective and maintaining the language perspective a whole lot easier. So I look forward to diving into those. OK. Let's get our project started. So we can see how this works. So in order to use Q with plum, we have to create a new Plumer project. Uh from here, we can say show additional templates. Now, there's no queue. I don't think so. No, I'm gonna expect that we're gonna add Q to our templates library. But for today, we can just say that we want a new Gammel to the things. Uh and we're just like play, we don't need any cloud provider at the moment. We call it modern infrastructure. Then this will be the random stack and this is the smartest Pulumi program I've ever seen a single yama fail with not a whole lot going on. Let's pop that open. Where's code's gonna open? Nobody knows. Yeah, I, I can't see that. Uh I bet it's behind my live stream preview courses. Here we go. Uh Yes, I trust me. OK? And this is it. Uh The Pulumi gamma interface allows you to specify any configuration that is required. We can also have some variables that can be reused throughout our respect. But the most important stuff is here. So obviously, we need to define some sort of resource and then we can expose outputs that can be used with Pulumi stack references or even just the plume stack output command. If you need to be able to consume this and other chilling. Uh What I'm gonna do is just copy this and create a, we can call this. It actually doesn't really matter, but I'll stick with the convention for now, which is N dot uh And if I everyone pulling me up, nothing's going to happen at this moment because we've actually not told it had to do it or something. So I can get a stack, but there's no resources and presumably at this point, it's using the yam file. It doesn't know anything about the Q file that you've put, put in there at this stage. Exactly. Got a keen eye pole at this stage. I mean, we could use uh Q export to actually not have, oh sorry, not have a P dot Gammel and say just a positive, we could just have this as a plume dot Q and that would, that would work. We just have to use the Q tooling uh which would be export, which will spit out Jason. Although we can do that, that show, I can't remember how to do that minus minus out. Thank you very much. And we get something which is very similar to what we're looking for. Now, of course, it's missing the meta data that we need for a P program. But of course, we could add that and we could go down that road and that would be great. I tend to use the different approach. So when we have this run time here, um we can actually provide options to the run team and I wanna make sure I don't mess this up. Yeah. Uh So this comes in like name and then we can have options and then we can have a compiler which should be Q export. And what this tells Pulumi to do is that we are going to run this command before we run any polemic constructs. And that will tell us our configuration or variables, our resources and our outputs which means our Q export that we see here of this will be consumed by the plum program. And hopefully if I run Pulumi preview and we will see that this is now going to create a random password resource fingers crossed. Look at that nice. Right. Very nice. Yeah, but I'm not sure what route I prefer. I think there's actually there's a part of it. It's like, you know what, I just want my plu programs to be a plume dot Q and just have everything in there. Um and use Q export and pipe that to me up the um but being able to specify the run time and the pluming configuration is also quite nice because then it means anyone can really come to this project and just run Pulumi preview and pull me up without having to know what the run time is. Yeah, I I think as a starting point that this is an excellent starting point right from a AD DX developer experience perspective, there might well be once you now that you've got this in place, you can, you'll be able to stand back from it after 10 or 20 iterations of actually doing this. And think actually what we want people to be able to do is X, right? And as I as you were typing the yam there, I thought to myself, well, what you really need there is a schema um against which you can know what is actually valid. And again, just to sort of bring in the QE angle there, right? That is what I imagine. So there is a scheme against which people will be writing a lot of the time. And so if you do have, if, if you are able to get to a situation where Q is, then your first class support, and then we have things like the language server that come come into play as well, You'll just be able to open a QQ file that the context will be clear. And so the scheme against which your writing will be clear at that point. So you will have all the completion, et cetera that you want. So getting back to your point about making that experience a delightful one, that's probably where we want to end up. But how we actually get there, I think is, is sort of the journey you're looking to explore here. I think this is a great start. Well, I don't think we really need to run the pull up on this. You're, you're happy, you can see the preview and it does what we expect. Right? Cool. I mean, I promise you, it works. It definitely works. Uh So let's, we'll spin up one of the more complicated examples that the random ones not that interesting. And what I do want to point out for the preliminary people in the audience is that we didn't register the random provider that was all calculated by the Pulumi run time. That's something that's new or at least an improvement that was made for Yaml support. Because typically what happens is if we have a go project, then our go dot mod tells us all the providers that we need. If we have a typescript or javascript project, we have a package dot G on all of our language is actually describe the dependencies through a file which we don't have with Yaml. Um So the engineers actually built some magic provider detection and plug in installation all into it so that in fact, we could jump over to here. Hope I'm not getting too confident now. But if we go to the queue static went back. Um This uses Azure native resources and we could actually copy this queue into our Q and the plume run time would detect that we're now using Azure, download the binary if I don't have it and we'd have us working Azure project, which I think is, is quite nice as well. Like that plug in auto discovery is a very clever. That's very nice. Yeah, I'm not. So I'm, I'm learning a lot here about Pulumi because I'm um very much a Pulumi Newbie. So um I'll, I'll be asking questions along the way. Hopefully, my questions aren't too, too slow for the, for the audience. Well, let's go to the, the good, the good example, mostly because I don't have an Azure credentials on my machine right now. And I don't want to have to try and do it live because I've never used Azure. Um So we'll just use here. So this was the fun demo that I worked on. I was like, OK, how can we spin up um with so, and I went down a different route. I actually used the queued up mod for this um so that we could provide packages that could be consumed. Um Which I thought was quite cool because in my head and maybe that looks back to what you were talking about with like the package manager support for Q and you know, maybe there being a registry, but there's no reason I couldn't build out an entire repository of libraries of abstractions built on top of GCP, aws, Azure cloud flare, etcetera, and people could just consume and use them, which I think is really powerful. Yeah, absolutely. That's the, that's exactly what the, the first class package management support will enable just as today if you're writing um a go program and you find yourself writing code that actually sits nicely within a package that you want to share with others. Exactly the same would apply from a configuration perspective as well. And so that's that element of reuse coming in as well. And so quite what those packages of reuse look like. Um I guess we'll sort of people will learn along the way. Actually, this is a nice level of reuse here and, or this is the pattern that we should follow when we're trying to encourage reuse. Um So I think a lot of those things will, will become clearer with time, but that's the direction that we're traveling with package management support. Awesome. And that'll be ready next week. Uh I think it's two weeks, actually, it's high on the list. It, it's one of those things where, as you said earlier on there's, um, too many ideas and too little time, but we're, we're, we're fixing that. Uh So definitely, all right, let's say, let's do this one step at a time. So we can see it, feel and then you can kind of walk us through some, maybe some of the key things that are happening. Sure. So we'll leave this as is we'll blow away this. Uh And then we'll kind of run through this. So we have a resources definition which hopefully now we're comfortable with and then we have two resource names, one rock code and then one of my colleagues handle, which is stag 72. Uh So here, what we're seeing is rock code is something called an ECs dot ECs cluster. And do you want to dive into what we're looking at here or do you want me to throw my, my two cents at it? No, please, please, if you want to start. Um Because here I actually had a question and this is, this will be appear sort of like a quite a naive question for those who are more familiar with Pulumi. So this resources block that we're um the resources struck if I can call it that, that we're looking at here, it is presumably just anything can go in there except to say that it's like a map from some string key name to on the right hand side. Then a value that, that describes the instance that it, that we want to create the resource we want created in this situation exactly the the resources as a map and that map as a string id, which is the name of the resource. And then we can have any valid resource product type or description. On the right hand side, you know rock code is my resource name. And then I'm saying that I want an EK cluster and so Eks cluster here is something that you've defined and the, the hash definition there indicates that it's a definition and we can come on to that in a second. But you're, you're essentially saying is this is the EKS cluster something you're imagining that would ultimately be um in a sort of a package more centrally where someone who's, who would be responsible for maintaining that definition. Yeah, this is just one that I provided to show people that using Q, we can have packages, we can build our own definitions which can be reused because what we see in Pulumi land at least um is that when people are building platforms is that the platform engineering team will actually determine what that platform looks like and they expose a small interface of options or configuration that can tweak the way that that works like. It's very rare. The development team would just use the raw eps or JKE API S because the platform team is like, oh no, we've got sensible defaults like we want to deploy monitoring, observably logging, tracing all these other cool things. And that's all I'm doing here is I'm saying like in our organization, well, there's my fire alarm I'll just meet for, we need some Hans Zimmer music at this point. All right, a test every Wednesday, I should remember that. Have a little over Wes. Yeah. So this is just what I'm describing to be an E and we can take a look at this and we can compare that to what I think there is another EK example in a rep that work direct with the definition and we can see how those compare. So I think the one thing that I would point out at this stage is that given that the fire we're looking at here resources effectively a specification of from like the data side. If you like of what resources do we actually want to be created and what you're looking to do with raw code and stack 72. There is saying for these resources, I'm trying to constrain or enforce that they follow some sort of structure here. And that's the schemer part of Q coming in. So the definition side here is that, that's the use of EKS cluster here constrains the raw code field to actually be of a certain structure. And as you're seeing for the, for the use of stack 72 there, you're saying, well, it's an EKS cluster and I'm going to give you some more information about that specific cluster there. But this, the use of definitions in this way is very much like a sort of a validator type approach where you're saying, well, it's gonna help you prevent, right, any typos, it's gonna help ensure that the types of certain fields are correct. So for example, max size, if that was specified as a string, assuming, you know, you've specified your definition as such, it would catch that and flag that to you early as opposed to if this were not validated in any sort of way by a schema, you'd make that mistake. And only when you subsequently came to actually try and apply that configuration, would you find out about it? So this is, this is how the schema part of the queue and data sitting alongside each other work so nicely is that you're seamlessly losing using the two together here in order to um make the writing of your configuration much easier. Yeah, I I had one thing that you missed, but by using the definition, the constraints is really cool of course, but the defaulting as well, the, I actually wanted to provide a whole bunch of defaults for any that can be overridden. But, you know, they're not, they're not a default in the Aws API so we can make them a default in our definition. Excellent point. Yeah. Uh, we actually, we have a question. So let's pop that on the screen. Oh, great. I can't see. I'm probably looking at totally the wrong thing. So uh I don't know where to look for the questions. Uh All right, we got a question from uh whose name is? Uh oh no, it's there. It's just on the right hand side. Uh Sorry, I'm a Pulumi Newbie and have never used a QE. That's all right. We hope this session helps you. Uh But they're curious, does uh kind of be applicable like policy as code mechanism? Cool question. Yeah. So, um I think if I've understood the question correctly and please um tell me if I haven't. Um the, the idea it, it, so my understanding is of the question is as follows. Can Q be used as a means of effectively specifying policy? And the answer to that is absolutely. Uh That is one of the key things with Q. So, whereas let's just imagine David's writing uh this configuration here, but actually another team wants to enforce some constraints over maybe the resources that are being specified here. I'll just sort of wave my hands as to how this is actually implemented within Pulumi. But the idea behind Q is that you can com combine and compose queue from different sources. And then that result to sort of be a consistent validation of all of that QE combined. And so this is the, the compos nature of Q. And so we're like a cross cutting concern like policy where you might have multiple teams, in fact wanting to specify constraints on the resources that you're specifying here. All of that Q would magically get combined together in some way, shape or form and assuming it validates, then all those policies would by definition be satisfied. And David, you'd be able to create your resources using Pulumi up. So yes, Q can be used as a policy specification language and we're looking to make some improvements to the language to, to make that easier. Um And it would sit very nicely and fit side by side by exactly this kind of usage that David has here. And David wouldn't even need to worry about it that that policy is like a, a concern or an aspect that comes in from somewhere else entirely mix. Hopefully, I understood the question correctly. I think you did. That was my understanding as well. So great. OK. So uh yeah, we have a definition now we don't know what that is yet and that's OK. And then we have another definition only this time, we're using the A percent syntax and we're passing in something else, which is it fair to say that as an overlay? Would that be the correct syntax or would you describe it some other way? Yeah. Um overlay is slightly, it sort of gives an idea that the of sort of inheritance where there isn't actually inheritance. So this is actually where the, the strict term for it is unifying where you're combining these two together. And what must, what must be the case is where you're unifying here is that the, the data you've passed in that struck there. So where you've got passed in the properties that struck literal there that must be able to combine with for want of a better phrase, the the description, excuse me, not the description um the definition that is EKS cluster. So it might actually be helpful to um open up that definition here. So we can see how this sort of combining actually happens to ensure that there is then a consistent result. OK? Well, well, let's do this one digit time. Uh If we, if we run Q export YAML, um it's gonna fail because we don't actually have this package yet. So in order to make this work, we have to run a Q mod in it. Is that right? Yeah, uh which creates our Q dot mod directory and then just like we have in this example, we can then create our aws package. Yes, I think what you'll also want to do is that having done the Q mod in it? If you just open the Q dot mod in a second, I'll let you create this for starters. If you open the uh module dot Q, you'll see that it's not given the, the module any path there. And so you will need to actually put in there, the, the path which if you just jump back to the uh the github code that you had. Yes, exactly. You'll need that path in there. And that's a module resolution now, right? Yeah. So there's effectively what, what you're declaring here with the Q dot model is you're saying much like in the GO world, I'm all of my code now lives within a module and you've given that module a path and that means that packages that live within that module. And this maps exactly to the Go concept as well can be addressed by that module path plus any um subdirectory within which that Q code may exist. So here this then allows you to reference as you had within infra dot Q where if you just go to jump to Infra dot Q now that allows that import uh statement to the top there to actually resolve. So the module itself within the main module within which we're working is examples dot Pulumi dot com slash YAML dash EKS. And you just created the AWS subdirectory within that, which then allows us to reference the AWS package within that and what you've then specifically done is within Aws dot Q you've got. Yep. S dot Right. Uh, it doesn't actually matter because the only thing that actually matters within there is the package clause at the top, which I'm assuming is Eks. Yeah. So what you've done there is the reason you're having to specify Eks in the import statement is that, um, the package name you've given in that file does not match the directory within which it's contained. So if you wanted it to be just the import path, would just be examples dot com, examples dot Pulumi dot com slash yaml dash eks slash Aws, you would just need to change the, the package clause within Aws dot Q to be Aws and not Eks. But this because the, the thing here is that what we are supporting Q is that you can have multiple packages in a directory. And so what you're doing is you're specifically referencing the Eks package that exists within the AWS directory for, for normal use cases, you may just be, it may just be easier to, to, to make the package in that situation, Aws. And then you don't need to specify exactly which package within. It depends how many different definitions you're gonna have at that level. And whether it makes sense to have some sort of logical gripping via sub packages indeed. Uh or whether you actually just want sub packages in indeed. So you might actually say you know, having a subdirectory for Eks might be the the best way to structure things. But again, this is, this is what I meant earlier on is in terms of what that level of reuse looks like and how it's best structured. It is going to be a learning exercise for people in the, in the queue space as it is with even go co for example, how to, how to actually structure a good GO API is not a solved problem in an office. And for people that want to be able to reuse these things in lieu of the Q package manager right now, I believe the easiest way for them to do that is just to have a repository that can be cloned to the package directory that has all of their common definitions. Yeah. So that then if you put it precisely so and then that rests allu happens within the PKG directory. It's almost like a go vendor. Uh It, it's, it's like a vendor in your code into the PKG directory. The resolution happens following a directory structure that matches the module and package path at that point. This is just what I, I love a bit like I'm probably going to be the biggest user of Pulumi Yaml and I'm never going to write a line of YAML. Like I think that is really cool. All right, let's uh OK. We've, we've made this resolved now and this should export and it should pull me up. There we go. So we can run plum export if we want and we can also run a plied preview. Let's see what we get doing a bit of thinking. So this is presumably where it's resolving the um doing that um detection as well of what resources it actually requires in this situation. Um As you were saying earlier on what bit of configuration to make that happy uh which just goes to my Pulumi Yaml. Yeah. Uh We can run preview again with Aws. You always need the region and I always forget so OK, this looks much nicer. Wow, cool. And I mean, I could remove the stack one, right? And we could just have the rock EPS cluster but and literally one or two lanes depend on how many overrides or values you need to inject into the definition. We can get complete Cotis Eks clusters with instant rules and the profile, security groups and security group rules. Now that is, that's pretty cool. I'm happy with that. Very nice. Yeah. Uh The definition for this which we looked at very briefly right now. It's not doing anything too fancy. Of course, we could add more and more to this, but we're just making, I'm using this for defaulting and constraints. So I'm saying that if you don't provide a instance type, then we're going to default, which is the start and Q to A T two dot medium. But we also accept the TD dot Medium. So I'm actually applying consents. I'm not giving them carte blanche here. I'm saying we're on this cluster. You could only use T twos or T three mediums and that is all. Yeah. And just relating it back to the question that somebody asked about Q being used as policy. If, if there was like a further constraint that somebody wanted to specify as a policy that the instant types could only be T two dot medium and not T three dot medium that could be specified as policy. And again, waving our hands to sort of imagine how that policy we'd actually be consumed at that point. That would further constrain the valid instant types at that point and prevent you from actually specifying T three dot medium if you wanted to. Yeah, uh then we have some default values for desires capacity, admin and max only here, we do accept any integer values. So of course, you can configure that however you need and we have, well, we I'm not going to run it because Eks clusters can take up above 20 minutes to run. Um But we can see from the preview that we get everything that we required that I'm pretty happy with. That might just be worth pointing out that because you've used the definition there in this situation, you can't add fields that actually are invalid in your infra dot queue. So yeah, break it with a with a raw code field or something like that. I am here lol there. Yeah, Q format. I was just about to say um and then if you'd run your Q export again, that should actually break. So that's, that's the scheme as side of Q being combined with the data side, right? In order to help that experience yet there we go. There, there would be another validation rule but we get conflict and values, you know, we expect a T two medium or TD medium and we sent a four extra large. Yep. So the idea behind the language server will be that instead of having to run Q export. In this scenario, you would see all of this within the editor. So you would have a squiggly red line under T four or extra large, you would get code completion within the properties structure there to know what things you can, could actually specify et cetera, et cetera, imagine sort of a program of language where there is language server support the same will then apply for Q as well because it will know the scheme that you're actually uh trying to write against him. Yeah, I'm looking forward to that. That's gonna be pretty personal stuff very well. All right. Uh Is there anything else you want to cover from this example? No, I think this is a, I think this is a really good starting point for people in terms of understanding how Q can be used um the sort of you saw some of the language syntax uh benefits there of using Q versus Yaml or Jason. If that's something that you prefer, you sort of um we saw some of the use components uh via the importing of packages. We saw some of the schema and validation aspects by the use of definitions. And you showed seamless integration with the new YAML support in Pulumi, which shows how I think you can interact really well with the existing systems that consume um encodings like Yamal and Jason etcetera. So I think that was really good. Yeah, I I'm really excited to start she abstractions for people to kind of make working with this YAML a lot easier and allow them to use and definitions and, and just really have that and improving that experience like the interface is great for people that just want to spend up something fast. But for the more complex use case, we really need to leverage the power of Q. Um just as we've kind of shown here. The EK one is a simple and contrived example for now, but there's going to be lots more cool stuff coming here for sure. So yeah, I think you made a really interesting point about why there is a benefit over um sort of programming languages being used like typescript, etcetera. I think that Pulumi support is that if you allow people to use YAML, you don't make any judgments on how they will actually compose that configuration as part of wider configurations they will have within their organization. And if you just allow them to use YAML, then it's very easy for them to actually have what you can say. Well, this is just part of a much wider configuration we have within our organization. And this piece is then fed into Pulumi here. And that's again where Q can excuse me, where Q can come in, is that trying to con consider, considering that you should view your configuration as one big thing is absolutely something that you can achieve. Um And so it's not clear how something like typescript would necessarily compose within a larger configuration in that situation. So I think the Pulumi sport in this respect is, is like a really strong thing. Awesome. Well, I want to say thank you for joining me and sharing your, your wisdom with us today. It's been fun. Uh I'm hoping we can do more stuff with Pulumi and cut in the future and uh I'll definitely be inviting you back. So just try not to ignore all my emails. That would be very cool. Thank you for having me on and I'm, I'm slightly daunted but excited by all the other rabbit holes that we suggested we might have to explore. So yeah, there's, there's so much stuff we could have fun with here. I think it's going to be a whole lot of fun, but we'll be back in the future. But thanks again and I'll see you again. It, bye.

---
