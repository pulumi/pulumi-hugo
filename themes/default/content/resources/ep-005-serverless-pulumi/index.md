---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Ep 005: Serverless with Pulumi"
title: "Ep 005: Serverless with Pulumi"
meta_desc: |
    This week, Luke will take us through serverless (or function-based) programming with Pulumi: build lambdas as lambdas, and get productive with a pu...
url_slug: ep-005-serverless-pulumi
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Ep 005: Serverless with Pulumi"
  description: |
    This week, Luke will take us through serverless (or function-based) programming with Pulumi: build lambdas as lambdas, and get productive with a pure code approach to serverless.
  sortable_date: 2018-07-11T19:23:21Z
  youtube_url: https://www.youtube.com/embed/Yb0gwYJiDmw
transcript: |
    All right, good morning everyone. Uh Luke Hoban here, um This week's episode of Pulumi TV. Um This week, uh we're gonna be talking about serverless with Pulumi. So, uh for those of you who haven't joined us for any of our previous episodes, um Pulumi uh is a cloud development platform uh that helps you get code to the cloud faster uh and together, and Pulumi is all about making it easier to bring the skills you have as a software developer to managing uh your infrastructure, including uh containers, serverless infrastructure and the combination of all three. So today, I want to really kind of deep dive into uh the serverless piece uh and take a look at kind of what it looks like to build a serverless application today. Um And uh how Pulumi can help make that easier uh in a really fun way to get your serverless applications running. So, uh first off for those of you who haven't uh installed and then start with Pulumi. Uh you can come to Pulumi dot IO uh download uh the command line installer uh and go ahead and get the cli and today we'll be spending our time looking at uh code and running commands and all of that uh you can get started with uh right away. So uh if I come up to Pulumi, one of the great ways, there's a lot of uh great ways to sort of learn about the various capabilities. But one of the great things I always find useful is just looking in at a bunch of examples. So we have an example is repository uh which has many different uh kinds of examples of things that folks can do uh and have built with Pulumi. Um And uh so I'm gonna be using a couple of these today. Um But if you're interested in uh learning about other kinds of uh things you can do with Pulumi, whether it's using other clouds, like using Azure or using GCP or Kubernetes or whether it's about using other languages like Python or go uh or about using um uh other libraries and other capabilities. Um All of that you can get uh in these examples repair right here. So I'm gonna get started um just to kind of talk a bit high level about um why it is that sort of service is kind of interesting and and why it is that the Pulumi in particular uh plays a role there. So uh so serve sort of uh has become a very significant part of a lot of teams uh way of thinking about how they want to deploy code and I think it's driven by kind of three things that sort of for me at least define what service is all about. Um The first one is serve uh service platforms are consumption priced. So they, you pay only for what you actually use instead of renting some uh some infrastructure for, you know, hours uh weeks, days, months, uh you, you pay for only the amount that actually gets consumed. So the amount of traffic that actually goes through the H TB M point or the amount of invocations of a function. Um And that can uh mean significantly lower prices uh depending on the utilization you would have had of that infrastructure, um servers can be a much cheaper solution, but it also feels much more flexible if I can optimize my solution to uh take less traffic, uh then that I can immediately see the returns on that. Whereas I might not if I um am am renting some fixed amount of hardware. Uh The second one is that obviously the sort of no serverless part. Uh So, so there's no servers I have to manage. Uh And that's sort of a really important piece. And so in the terms of kind of raising the level of abstraction and in part, that's what uh sort of has attracted so many kind of application developers to servers is that they don't have to worry about sort of V MS and managing infrastructure and, and updating and patching uh their OS and that kind of things, they can just think about their application and then getting that running uh in in the cloud platform. And then the last thing is sort of event driven. Uh So one of the, the key things that sort of happens, especially as you think about sort of consumption price, uh um workloads is the the pattern of the application kind of changes a bit. Um Instead of being just I have some code that's running all the time, it tends to be instead that uh that I have um an event driven architecture where uh the some, some set of things that happen inside my my infrastructure or my application cause events to happen and those cause uh functions to execute on demand. And that way of thinking, lets me think about that consumption price aspect in a much more uh raw way. And so these things are big together uh create sort of an opportunity to create new style of applications on top of surplus and to reduce costs um by using CPS. Uh And the, these are very attractive. One of the challenges I think that a lot of teams have when they come up to serve, they really like the promise of it. Um But especially when those application development teams come up and say, hey, I've got some code, let, let me go and just run this inside a lamb or in, in Google cloud functions. Uh They run into the fact that uh it's actually a lot of uh because they, they don't have to sort of manage the VM, they do instead have to manage lots of granular cloud resources to, to actually deploy that application. So they've got to use something like cloud formation or um terraform or one of these sorts of tools to describe all the various different pieces of infrastructure that they need to get every single one of those functions and, and uh API S and whatever they have uh running in the cloud platform. And so one of the sort of most significant things that serve kind of has done is actually mean that development teams have to own a lot more infrastructure, which is sort of maybe counterintuitive. Um But it's been one of the big shifts that's happened. And as a result, a lot of these teams are looking for tools to help them manage that at kind of a bit of a higher level um and a bit more easily. Um And so there are some tools out there that do this sort of thing. Um I'm gonna show you kind of how Pulumi in particular uh fits in this space and provides a combination of a lot of flexibility to do anything you want with the infrastructure, but really some really beautiful uh ease of use around uh serverless patterns. Um And so with that, I'll just kind of start diving maybe into some code and show you uh what this looks like uh when we're using Pulumi. So let me come over here uh into visual studio code. Um I'm gonna show some of my um code demos in here. Um And so this is that same examples repo that I showed you in github. Um And again, we have many different examples. And the one I'm gonna start with here is this uh Aws TS serve raw. Uh And this is an example of just what the bare bones way to use Aws infrastructure uh to build a serve application looks like. Uh And to give you a sense of kind of what Pulumi uh can do. Pulumi embeds uh the ability to sort of program the cloud program cloud infrastructure into uh your favorite programming languages. So in this case, we're using typescript. Uh we could use javascript, we could use Python, we could use Go. Uh And here, I'm just sort of describing all the infrastructure that I want to exist inside my application that point. Um And so I, I am using this Pulumi Aws library which gives me access to all of the different uh um primitives in Aws. And so for instance, I can create an I A Dynamo DB table which is gonna be my counters uh describe that it has an ID and it has uh a certain read and write capacity on it. Let me just open that up again. OK. Uh And then I can describe a various variety of other resources that I have. So I can describe a policy document, I can describe a role, these are sort of uh identity and access control things. For AWS, I can describe, I can connect that role, policy, I can take that policy document to that role with a raw policy attachment and then I can create a function. Now, all of these are just the raw building blocks of how if I'm using AWS, I need to describe all the various different components that I want to put in. Uh that I want to define in my cloud platform as part of deploying this. And so this might look similar to what if you've done cloud formation or terraform or anything like that. Um These kind of uh resources are going to look similar and at this level of abstraction, uh we're really kind of doing many of the same things we might do. What we're doing. In this case is we're actually deploying an application um that's written uh in this dot net application publish folder, which is uh in this location. And in this case, uh we actually have a little dot net core application. Um So just this, you know, 100 lines of code here. Um And this is just a little application that every time uh it gets uh an API request to it, um it increments a counter and updates that inside um the A dynamo DB table. Um and so a very simple piece of logic um that I'm just going to embed inside this application. But to do that, um to get that piece of code running, I need to sort of describe all this infrastructure here. So I need to describe that I want a dynamo DB table, I need to describe that I want a Lambda function. I need to describe the role of policy associated with that LAMBDA function. Uh And then I need to describe uh an API um And so ad has API gateway which allows me to describe um which allows me to describe the resources I need. And so in this case, I'm gonna create an API gateway, rest API uh and then a deployment and then a stage. Uh and then I'm gonna create the permission that gives that Lambda the ability to uh be invoked by API gateway. And so there's a lot of complexity here in how I need to build this up. I need to describe this swagger specification. I need to describe uh the, the overall body of this swagger spec and what routes I want to include. Uh And this is really, um you know, this is really sort of the, the bare bones that someone's gonna have to do if they come up to serve us and want to get sort of a simple rest API running uh with AWS something on the order of this kind of code is sort of the bare bones ways that Aws provides to, to use this functionality. Um The problem is that if I, if what I need to do to get an API running is to write all of this code. Um That's really a fair bit of work and really the infrastructure side of that work way outpaces the application behavior of that uh of that piece of code. And so what we really want is a way to get all the flexibility to use all these powerful capabilities of the underlying platform. Uh In this case of ASAP I gateway and flam and of all the variety of other uh resources we're using here. Um But to do it in a easier way. Um And so to take some of these patterns uh and, and create uh nice reusable abstractions and libraries over them. And really this is where Pulumi uh can shine. Uh because Pulumi by using languages, uh lets me write, uh lets me refactor my code and create reusable abstractions on top of it. And so you see a couple of simple examples of that here where for example, to build up this swagger specification instead of me having to write it all as one big uh you know, Jason document somewhere, I'm able to actually write code that constructs it. Um And so in this case, I have a function called swagger spec which can build up uh the, you know, the my swagger specification, I have a swagger route handler which describes how to take a lambda's uh A RN and embed it into a route to create the, the, the portion of a swagger specification that describes that route. Uh And these, let me just give names to and factor my code in the ways I would want to um and not have to kind of fit that all into just one big uh Declarative Jason or YAML specification. But we can go a lot further when we have a language and we can actually take uh the um the ideas that we want to express like I want to create a rest API with these reps and we can turn that into its own uh reasonable abstraction uh and give that a name and then use that instead of having to use all these individual small building blocks like rest API and deployment and stage. And so let's take a look at one example of what uh that looks like. So instead of me writing all the code below, uh Well, actually, before I do that, let me just run this and show you that we can uh what it looks like to kind of get this code itself into production. Um So here I am over in a uh terminal, I'm in that same folder and I can run Pulumi stack, LS and stacks in Pulumi are instances of an application. Um And so in this case, I have one instance running I'll actually just go ahead and spray that, uh, too, so I can show you what it looks like to run this from scratch. Uh Let me see what the, uh, well, actually what I'm gonna do, I'm gonna just gonna create a new one so you can see that. Um, and I'll say Pulumi TV. Uh, ok. So with stacks, I can have an isolated instance of, uh, an application and so I already have one running, uh that we I saw before, but instead I'm just going to create a new one here and I'm gonna go ahead and uh configure that. So I'm gonna say Pulumi stack, uh Pulumi config set AWS region and I'll say us West two because I'm out here in Seattle and then I'm gonna say Pulumi update. Uh Let me actually, since I'm using typescript, I'll actually go ahead and build that and then I'll run Pulumi update now, Pulumi update deploys my code uh into that running application. Uh And so this will show me uh here are the set of resources that I want to create as part of building the application. And if you look at these, these are really kind of 1 to 1 with the stuff I had in my code. There's that table, there's that function and there's that rest api in the, the various pieces needed to deploy it. So Pulumi update starts by giving me a preview of what changes it's going to make to my cloud platform. In this case, it's going to create all those resources because this is the first time I'm gonna go ahead and say yes uh to run that update. Now, you notice I'm getting these warnings here and that's because I happen to be doing some uh development on my machine uh and have a DEV build installed uh for those of you who go ahead and download uh the um that function. Um Now it's going ahead and creating the rest API and the various other pieces. And so when it finishes, um it then prints this output. Um So Pulumi has the notion of exports from uh your uh your top level program which are outputs. And so, in this case, I, I defined an endpoint output and so I can go ahead and curl this endpoint here. Um And I'll just pass, you know, hello, oops takes just a second to for the cold start. Uh The first time we run this function, uh Especially since this one is uh implemented with dot net. Um I've noticed dot Nets cold start time is just a little bit longer um than other things. But um uh so this will, what it will do is actually um increment this counter every time I hit this endpoint. And if I go to a different end point, like if I correctly spell, hello, uh we'll see we get a different count. So this, we went 123 here. So this is a very simple service application that's just counting how many times this given path has been hit. Pulumi. Um OK. And so that was running it, create a new stack and then deploy it into that stack and about getting point. And this shows that I can sort of use all the capabilities of aws. Um And I could do that I could bring in a stream, I could bring in, uh anything else that I want to uh from Aws into this program. But as we're talking about, uh before, what I really want to do is kind of make some of this stuff uh simpler. And when we talk about uh how great Pulumi is for servers, what we really are kind of talking about is the uh abstractions we've built to make it really simple to work with servers applications in Pulumi. So we have a library as well as the raw Aws library. We have a library called Pulumi Aws service. Uh And this is a set of helpers that let me work with uh serverless API S. So let me take a look at kind of what some of these things are. So serve has uh uh currently a handful of uh helpers to let me work with various different kinds of event sources uh that might exist for serverless functions in Aws. And there's things like topics and cues which I can handle events off of. Uh really simply it's things like cloudwatch timers like buckets, which I can handle when uh objects are put or deleted from that bucket. And then for our case, right now, there's API gateway, which is the ability to define an API whose routes are handled by uh by LAMBDA. And so let me create one of these, let me say constant uh yes, new API and I'll just call this thing API and then it has a bunch of arguments that I can provide. Um And so one of the nice things, of course, we're using uh typescript uh in this particular case, um because I'm using typescript, I can kind of get uh a bunch of developer help so I can get, you know, intelligent and completion lists here. I can get error checking. So if I, you know, misspelled API gateway, I get that feedback immediately. I got that help to actually explore the various capabilities of uh of the library in here. So overall kind of nice uh developer friendly things that you get as soon as you embed this um this kind of pro cloud API inside a real programming language inside tools like like visual studio code here. So I'm gonna do a couple of things. So first I'm gonna, I have this stage name uh property which I used above. And that's gonna be uh in this particular example you saw that it was in under the API uh stage. So I'm gonna pick what name I want to use for that. And we'll see above, I had a variable called uh stage name for API. And then I also want to define the routes. Um And so routes we can also go and look at and see, hey, what, you know, what is the shape of this thing? So it's an array of routes. Um Each one of those routes is a path, a method and a handler. So let's go ahead and, and write that. So we're gonna just have a single route. Um We're going to implement the same thing that we kind of had down here where the path was just this. And so we're gonna have, um you know, method is gonna be any, we're gonna accept any uh any routes on this thing. The uh path is gonna be the same as down here and then the handler is going to be uh this Lambda. And so we have this Lambda up above the same one we created before. Which one is that C# code? What we'll do here is we'll just pass it in uh to this handler here. And so what that does is this uh server dot API gateway dot API really just takes everything that was in this code below. Uh and wraps it up into uh a simple to use API. And so in this case, now, I can just say API dot And I get a bunch of different uh variables that give me access to the implementation details of that thing, including I can just get the URL. And so let me just change it to that, um come back over here and say N PM run field and now I'll do another Pulumi update. And so one of the things you'll notice is that we're actually changing our program in place here. And so we've already deployed an instance of that. What we're doing is we're updating that existing running instance. And so the first thing that Pulumi will do is tell me, hey, here's the preview of what's going to change and we'll see kind of two things. One, we are deleting the existing rest A P that we defined and we're going to create a new one, we're going to create roughly the same set of things, but with some slightly different names because they're created by that separate component. The other nice thing is that because this is part of a new component, this API gateway call an API, you'll see it, we're nested. Um And so all of the resources that are needed to build, that particular part of my infrastructure are gonna be nested in this view. And that lets me sort of understand how the different pieces of my uh application are related to one another. So I'll go ahead and say yes and we'll make those updates. Um So this will go ahead and create that new rest API and then it will delete the old ones that are no longer being used. So because of that, we now have a new endpoint that this is exposed at. So let me curl that. But even though we have a new api end point note that we actually um are still using the same dynamo DB instance because we allocated that previously and all the other changes we made didn't impact that uh our application is still continuing to use that same uh Dynamo DB instance. And before I jump back into the code, let me also show one other interesting thing which is um you'll see this Perma link here. Uh It's part of uh it's part of what we have offered with Pulumi. Uh We also offer the ability to sort of look at all of what you're doing inside the Pulumi console at app dot Pulumi dot com. And so every one of the updates that I do um is actually available here and I can see the details of those updates. So this first update I did, we can see all the different resources I created and all the details of those. And for the second update, we can see just the smaller set of updates that we made um in particular here, we added five and removed four and uh updated one. OK. Uh But the more interesting thing is I can come over here and see uh my resources. Um And so in this case, I can see, you know, that rest api and deployment, I can also see the table and the function. And so, for example, for this table, I can click on that dive right over into my dynamo DB instance, look at the items and see here's the the counts for all the different routes associated with that. Um So by having this sort of project centric view uh inside the resources tab here that lets me jump immediately into those resources, it becomes really easy to get at the underlying implementation details of my application. OK. So um with that, we kind of have this application running, we've made it uh quite a bit simpler by moving over to this method. But one of the things if you noticed earlier when I showed you the implementation of this code, um you notice that there sort of wasn't that much logic in here, right? And even a lot of the logic that is here is kind of just plumbing. Um it's just deserializing things, you know out for figuring out what the the table to connect to is deserializing and connecting to that really the only logic here is sort of in these lines right here. Um And so this is often the case that um you know that the lambda uh are very simple pieces of code that I'm just stitching into my infrastructure somewhere to give me access to some internal uh details inside my application or that I'm using to uh you know, traffic some data from whenever something gets put in this bucket, I want to also put it on this SNS topic. Um any of these sorts of little pieces of sort of glue that, that stick my uh applications together. And so because this kind of pattern is so common, one of the things that we want to be able to do is instead of you having to create this lambda manually and, and point at um an existing application and write that application in a whole different language and a whole different tool chain. Uh We want you to be able to actually write that just in line. And so for instance, I can say EVCTX, the same uh signature I'd expect from A A BS lambda and I can just put that in line here. Um And so let me say undefined. Uh and we'll see here that um I actually get in teen, I'm, I'm writing here the implementation of a uh handler for uh an API gateway rest API. And so uh I'm, I'm able to write that in line inside my Pulumi application. And this is code that's gonna run when this API gets hit. So instead of me running that Lada written in C#, I'm gonna run this code that's implemented right here. Um But I get to write it just in line and get to have access to everything else inside my application. And so this particular case, let me just do the simplest thing which is to immediately return. Uh And I can see here, I actually get inte sense for the information I need. So in this case, I want to return a 200 and then I want my body to be uh some Jason. Uh I want it to be the same thing that I saw before. Um And so over here we see path and count. So let's make it path and I'll grab the event that I got passed and grab its path and I'll put count. And for now I'll just make that always be one. OK? Um So here I just implemented a very simple uh instance of that same sort of thing, but directly in line inside javascript. Um So let me come over here, run M PM, run build. Actually, let me also just do a quick thing. Um And I'll just log out what path I I saw as well. Let me do everything right field. Now you put the update, OK? Um So we see here, uh We're actually going to create that new serverless function. Uh And so here that that function uh is, is just these three lines of code. And again, it's underneath a little component. Um But then I'm also going to replace some of the details of the rest API because the rest API now needs to point to that new function instead of the old one. So I'm gonna go ahead and say yes. And this is gonna create the new function and it's gonna update the existing rest API And so let me try going ahead and hitting that end point again. Ah OK. I think I know, uh let me actually just very temporarily, I'm going to uh comment this out. So I think uh right now, um there's an issue which means we'll actually uh um when we try to make that update and change the functions being called, it's not working correctly. So I'm gonna just uh remove it and re add it. Um And we'll work around that for the moment. OK. So you see there, I moved uh the API um And then I can just go ahead and add it back. Um Go ahead and say yes, and we'll create the same function uh function object again uh as well as recreate the API that points to it. So one thing you just generally notice there is it's very easy to just make changes in my code uh very quickly do Pulumi update. Um And see those. And so the inner loop here for actually modifying my infrastructure, modifying my application code um is actually very fast. Um And so here, now I have uh this URL to my end point. And so let me say um we see, now I have count uh 14 Pulumi. OK? Um That's because I've hard coded in the count one here. So now that I have that I can sort of get rid of all of this code. Um And so that uh that code um was to embed the C# LAMBDA. But instead I can just write it in line uh like this, there is that I can also just take this function uh and give it a name. And so I can say, you know, and I can also use um a sync, so I can say as sync function handler. And then I can also say this is going to return a uh cus an API gateway response. Um So the event is actually a surplus dot quest. OK. I'm gonna change this over to be um to use uh the new support and nude uh 8 10 in, in uh lambda for return for using a functions. Um And so here I see this and so I can just return this directly instead of using the call back. OK? OK. So I can give that thing a name and just pull it out like that. And so now I can just write my functions uh along along these kind of lines. Now let me uh M PM run bills, let me update. So we're actually getting rid of the old function that we no longer needed. Uh And now let me just curl that same end point again. Um So we see we still get one just like we expected. Now, one other nice thing I added that logging statement there. Um I could just jump over and I could come back into here and sort of say, hey, I've got my, my function. Let me go over there. Uh Let me refresh this, the change to the function. Uh Let me come over to my function, uh come to monitoring and uh a few blogs in cloudwatch. And so we see we've got some of the logs for this thing that are printed out the path that got printed, so I could come and do all these clicks, but it's often much easier to just be able to do it from the command line. So if I write Pulumi logs, I can actually see all the different logs and they would have gotten through cloudwatch, but I get them pulled in here. And the other nice thing is that this will actually aggregate the logs over all the various different end points that I might have in my code. So in this case, I just have this one lambda. Um But if I had multiple of these, um I'd get all the Los uh right here. OK? Um And so the other nice thing is that I could go ahead and use the, um you know, the A SSDK in here um to make uh calls and to do that Dynamo DB thing. Uh For now, I will kind of skip writing the code for that. Um Just to keep things simple. But the uh the main takeaway here, uh is that actually I'll, I'll show just kind of a, a sketch of what um I can do and I'll show some other examples in just a second of this. But one of the notable things is that I have this counter table here. Um And so I can make a call to, you know, um imagine that I have uh just write it down, you know, uh access the NSDK. And now maybe I, I create a DB is um way, way start document clients. And then I say DB dot you know, update. Uh And uh one of the things I need to pass to this is the table name. So I can, instead of me having to pass an environment variable or something, I can actually just say I've got this counter table. So let me say counter table dot name dot net. Um And so now I can have access to any of these variables that are part of my infrastructure. So in this case, the table itself that I defined and managed along with this application inside this file, I can just use its table name directly and capture that. And so one of the nice things that Pulumi does when it takes this function code and turns it into a Lambda on your behalf is it figures out that this variable is being referenced and knows how to pull off the right details of that, the, the name uh and embed it into uh the generated LAMBDA function for you. And so you don't have to deal with all that serialization and de serialization logic yourself. Uh You can just use counter table like you kind of expect to. So uh that's a quick kind of tour of kind of how we get from uh the very low level working with uh API gateway and LAMBDA to this much higher level ability to sort of describe just the routes that I want to handle on an API and the implementation of some code I want to, to handle for those routes. And so the end result is that with just a handful of lines of code here, I have kind of an example of an application that uh manages a ODV table, a lambdas and API gateways all together. But the service, this library has support for many other kinds of uh um capabilities as well. And so let me show you a few other examples of the sort of things we can do uh with the A a servers library. So if I come uh let me first come over to you um A OK. So this is uh our A bear servers library. Uh And if I come over here and um look at the examples folder, we can see we have a handful of examples in here of some of the kinds of things we can do with the uh a bear servers library. And so for example, uh let's look at this topic uh example. So in this case, we create an A SSNS topic uh which is a um database resource that I can use to publish uh um publish to from one set of uh peak code and then uh consume from another piece of code. And, and topics are a great example of a place where I might want to use LAMBDA because I can just subscribe to my uh SNS topic and say here's some code. I want to run every time and gets pushed onto that topic. Instead of me having to sit there polling that, that ns topic for, for new items. And so in this case, uh, in this case, I'm, I have a little example and it's, uh, doing a, you know, this is something you would imagine a sort of like a web crawler or that sort of thing. Any time I push something to this topic, I'm gonna go and fetch the results of, uh, of the URL that I got pushed. And so in this case, um, in this case, I'm going to take a look at the, uh, the S MS message. So the message is the contents of that SNS uh, message that came through. And for every one of those, I'm gonna grab that URL. I'm gonna do a fetch of that URL using just the normal node, uh, fetch library and I'm going to bring out an error message if it failed. Now, you could imagine me doing even more things taking the contents that I got back from that fetch and putting them into an S3 bucket, um, or any, any other variety of things. But the interesting thing here is that again, this lets me manage both the topic that I'm defining, uh, and a subscription to that topic. I could, of course, also just, you know, include a bucket. Uh, so I can say a U aws dot S3 dot bucket and I could say, you know, uh files. And now inside here, I could just, you know, use the A US SDK uh to uh to write into that bucket instead of uh instead of uh just printing out an error message. Um And so it's very easy for me to sort of define both the infrastructure that I want to have access to as well as the code that's gonna go and operate on those things uh in the same file. Um So being able to subscribe to a topic, makes it really easy to sort of build decoupled uh uh kind of pieces of code uh in these sorts of examples. Of course, uh Another really useful thing to be able to do is just uh um is to use timers. Um And so in this, in this little example here, we're using a cloud watch timer. And so this says hourly, uh in this case, it's going to be rate 60 minutes is the aws uh uh way of describing uh six a job that runs every hour and says every hour I want to run this code. Um And so again, this is a simple thing where frequently the description of what I want to do with a timer is actually a very small piece of code that really just reaches out and touches a handful of other uh things that are running inside my infrastructure. And so in this case, every hour I just want to publish onto an S and topic and then I'll handle that in some other way. And so these are very natural things as right as in line pieces of code like this, even though I could go ahead and write them as a, a lambda written in, you know, Python or go or C# or dot net or, or Java or anything. Um oftentimes these are so small and so intertwined with the way that my infrastructure is stitched together, but I actually want to do them in line like this. And so this is a very simple example of that where I just publish uh that item uh into uh an NS topic. And so then again, I have, I can handle that SNS topic through code and I can just, you know, print out a message every time I handle that SNS message. And so this shows sort of coordinating between two kinds of events uh inside one of these examples. Uh Of course, the, the other one we can do is sort of buckets. And so buckets I can handle when an item is put into a bucket. Let me run some code. And in this case, every time that an item is put into the bucket, if its name is not a record file, then uh we will update the record file file with the uh metadata about the last written item in the bucket. So this gives me a way to do some sort of auditing or access logging of puts into my bucket. Um And so you can imagine it's very easy to then just go ahead and stitch these pieces into existing infrastructure, existing service applications and to really take any of the event sources that are available inside uh aws and build applications uh which sort of uh react to those in natural ways. OK? And then the final one of course, uh which we just sort of showed I spent a bit of time with is using um sort of API gateway as an event source. Um And so in this example, again, um uh I'm not sure why. Um But in this case, we're using two kinds of handlers, uh both the kind of handle where we write the handler in line like this and the kind of handler where uh we pass in an existing Lambda function. In this case, a Lambda function that was implement this javascript. Uh So in this case, we can implement it this javascript but put it in its own um own application. And that would allow us to maybe unit test this thing as a standalone piece of code um instead of uh putting it inside my uh my application itself. Ok. Uh So that's a quick tour of some of some of the capabilities in uh in this package. Now, one of the really interesting things um uh that you're now able to uh handle uh items put into that queue using a Lambda function. Um That's been a, a feature that's been requested for uh for pretty much since the first day that uh Lambda was available uh several years ago and uh that was added just to AWS about a week and a half ago, I think. Um And so one of the things we did when we saw this, we said, hey, we want to have that available in this library. And so we actually added support in this library for hooking up two queues as well. Um And so, in this case, uh very similar to the topic, uh we have a cube uh visibility time out of that queue and we just subscribe to it. And so now we get all the events uh that get um pushed into that queue. Uh We will, we will see here uh And we see batch size, we can specify so we can say we, we expect to get things in batches of one or we can say up to 10 to, to batch up the entries that we get, uh, and to have those delivered on a more, um, course grained uh, cadence. Um, but then of course, we can do whatever we want inside here, like put an object into an S3 bucket. Uh And so this time, every time we push something into SQS, we'll see it in that bucket. And so it was really nice. We were able to light this up. Um, uh A s added the feature. Um uh we uh worked with uh um the Terraform Aws provider to add support for uh uh for cues uh as an event source uh to Terraform. Uh And that allowed us to use it from the Pulumi Avis library and to light it up inside a service in result is, um you can now use Q as well uh as, as a service event source. And so along those lines, one of the examples that we added um uh last week as part of that was this uh Slack message thing. And this is, uh you know, we, we slack a lot here at Pulumi uh like many uh many of you probably do. Uh And uh so we wanted to build something which just allowed me to every time I pushed to uh uh uh A two sqs US Q, uh I will post a message into Slack. And so here I have a queue, uh batch size one again. Uh And every time uh a message gets posted that queue. I'm gonna look at all the records and then post, use the slack client here uh to post a message to that queue with this message. So we can see this is the kind of message that uh that we get from it. And so our team had fun kind of playing around with that, but this gives you a sense of the kind of simple things you could do. Now, I can hook this queue up to uh some other piece of infrastructure. Um And so I can say in some other piece of infrastructure, every time, you know, in a three bucket gets published, I want to push something into this queue and then I'll batch these up and send out a message about how many items got pushed um very easy to, to put these little pieces of code uh inside my applications and get them running and deployed in a matter of just a few seconds using Pulumi. Um So that's uh that's kind of a quick tour. Um The, the thing, uh you know, if you've watched previous videos, you've probably seen that kind of the place where some of this gets really exciting I think is when you combine both servers with some of the other kind of capabilities you may be wanting to use. And so many other tools that help make serve easier on AWS. One of the challenges they have is that they sort of really focus just on sort of lambda and event sources. And that's what we saw kind of in some of these examples. But as soon as you want to use other features of Aws, like you want to use, um you know, maybe you want to use Athena to do querying or you want to use RD as a data store or you want to um use containers. Uh It's a bit harder because the abstractions can't um extend into those uh realms as well. One of the nice things about using just a programming language is the ability to create sort of arbitrary um kinds of new components is you can make it really easy to use both uh some of these servers capabilities and uh some of the container capabilities. And so, for example, uh this is uh one that is probably familiar if you've seen um previous videos we've shown uh but just to give a sense of kind of what the next level of this can look like. Um We can see things like here, I have a bucket and I have that cirrous kind of on put event on the bucket. But inside this code, I wanna actually run uh some container based compute maybe um as a result of this. And so in this case, I can use this uh FFM peg thumbnail task, which is a uh cloud up task, which is a little wrapper around all the capabilities of uh the container service inside aws. Uh to run a set of dockerized code. And so in this case, it's a Docker file that's built from uh from this particular Docker file right here. And I can just go ahead and run that. And so the ability to create a simple abstraction like this one where just in a few lines of code, I can wrap up a Docker file locally into uh some code that can run Dockerized inside aws. And I can connect that into all of my existing serverless applications. And that combination of being able to do raw infrastructure, do really high level uh simple work with containers and take advantage of all of these kind of features of um of really productive serverless development. Uh I think is, is what the real magic is of kind of what modern application development for the cloud uh can look like. And so that's what we're really excited about um with Pulumi. Uh So that's kind of it for my tour of uh of Pulumi uh today. Um If folks have any topics they want to drill in more uh in the coming weeks, feel free to reach out to us on uh on Twitter or on our Slack. Um You can come in uh here and join our Slack channel um uh from Pulumi dot IO. Uh take a look at Pulumi, download it uh at the URL here, uh join the Slack and reach out to us if you have any questions. Uh and uh, have fun building serverless applications with Pulumi. That's it for me. I'll see you next time. Thanks a lot.

---
