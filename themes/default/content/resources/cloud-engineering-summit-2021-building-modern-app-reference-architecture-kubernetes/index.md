---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Cloud Engineering Summit 2021: Building a Modern App Reference Architecture for Kubernetes"
title: "Cloud Engineering Summit 2021: Building a Modern App..."
meta_desc: |
    In this talk, we will discuss the NGINX MARA project; a turnkey modern application reference architecture. With the help of Pulumi, this project ca...
url_slug: cloud-engineering-summit-2021-building-modern-app-reference-architecture-kubernetes
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Cloud Engineering Summit 2021: Building a Modern App Reference Architecture for Kubernetes"
  description: |
    In this talk, we will discuss the NGINX MARA project; a turnkey modern application reference architecture. With the help of Pulumi, this project can take you from an empty AWS account to a fully deployed modern infrastructure deployment in under an hour.  Talk by: Damian Curry & Elijah Zupancic
  sortable_date: 2021-10-20T23:00:40Z
  youtube_url: https://www.youtube.com/embed/4FGQS1Cwa1E
transcript: |
    Good morning everyone. And thank you for joining us today. My name is Damien Curry. I'm the tech community and Alliances technical director here at NNX. And today we're gonna talk about building a modern application reference architecture for Kubernetes. So like many projects, we kind of got to go back to the beginning and talk about, where did this all start? So this really all came about with everybody asking what is a modern application. Um You know, you hear a lot of things, it must be a micro service, it must be containerized, it must be cloud native and you know, well, it, it, it obviously can't be a monolith or it can't run on bare metal. Those are, you know, legacy ways of doing things. Um But really, that's always not necessarily the case. You can operate a monolithic based architecture or even a bare metal based architecture in a modern way. And really the more we thought about it, the more we came up with the outcomes are more important than the pieces. So really, we're looking at what does a modern application architecture provide and the main four points we've come down to are portability scalability, resiliency and agility. So with all of these different pieces, that's what you're looking to get with your architecture. So you're able to, you know, run the, run your infrastructure wherever it makes the most sense, whether it's in a cloud multi cloud in a data center or all of the above. Um you know, with that, it also lends to you availability when you have that portability to run on all those devices, it's much easier to scale out because we are no longer looking at having to build out data centers and scale out in that manner. Now, you can simply move into different geographical geographical locations based on where your users are uh resiliency that's all leads into resiliency. The more sites you have, the more resilient your site is gonna be and of course agility. Uh None of this is possible without that C I CD pipeline to make quick updates and, and move through everything. So the more we talked about this internally, the more we figured that, you know, it, it needed people needed a diagram to look at. So we ended up putting together a diagram that has gone through many iterations like everything else and we kind of end up here. Um We're kind of just wanting to touch on the core pieces of what it means to have a modern application. And in, in my mind, one of the core pieces of that is, you know, that everything runs as code. So that's why when we're looking at this, it's not just the development team that is pushing code into the code, repos and C I CD pipelines. It's also your DEV ops team, your platform ops, team, your ops team. Uh One of the core things to being able to run this modern architecture is having everything defined as code. So when you can define your infrastructure as code that provides you to be able to more easily have that resiliency, have that portability. And also, you know, have that agility because it's all based in code. Um It also frees you up to have a more accurate representation of your production environment throughout the non production sta stages and life cycles of your application. So at the end of the day, that provides you more resiliency because you're able to better test your code and how it's actually gonna run in production. So, you know, now we've kind of got the easy parts done, right? We, we came up with a definition, we, we made a pretty diagram that people liked. But then we figured, you know, we, we need to actually show this, how can we actually build this sort of modern application reference architecture in a way that's actually usable for people. So this kind of, you know, kind of comes down to the key point of our talk today and it's what are we trying to build? The main thing we're trying to build is an easily deployable kubernetes based architecture that isn't just a toy. Um This thing should be able to be easily stood up um with hopefully people with very little kubernetes expertise and it will actually stand up something that is built in a production ready mindset. Um It's also gonna provide us a platform to highlight F five end partner products um as well as you know, provide an easy push button deployment for our ingress controller. And one of the things that's very, very important to our team that are working on this is to provide stable examples of how things are done in production. Um That's one of the many reasons why we've built this around Pulumi. And we really love the, the project. It allows us to, to have these different components of the architecture defined separately. So you can run just the pieces that you need or everything. Um Again, we wanted to, you know, illustrate those modern design principles and also, you know, have build a community driven project that gives back to the community with this plug deployment framework. And again, going back to the steal code, we hope that, you know, somebody will be able to help kick start their journey down the micro services or road by looking at this and, and hopefully cutting out some of the uh big hurdles to get started. So, I mean, that's a lot. It's a, it's a very advantageous uh project we started down here And so this is kind of what we have today. Uh We're developing this completely in the open, it's on github. Uh It's all out there. We want people to look at the code play with it, mess with it, you know, give us, give us uh insight back what we're doing, right, what we're doing wrong. Uh We have infrastructures code using Pulumi and Python. Uh because we were kind of focusing this at the platform DEV ops SRE sort of space. The Python is a very commonly known language and makes getting started and modifying it pretty easy. Um We either have the option of building the engine X plus ingress controller, uh container image manually or pulling it from our private repositories or in the case that you don't have or don't want to use an open uh plus license. You can also just leverage our open source option that gets pulled from Docker Hub. Uh We're currently deploying KTIS via aws Eks. Uh We're using log management tools from elastic. So we're running the Elk stack. We have TLS enabled via cert manager. And the demo application that we are running is what we are calling Bank of Serious. So it is a fork of the Google Bank of Ant app that we are um leveraging to use as an example micro service. So here's kind of the breakdown. You can see the different pieces that we're running and, and how everything goes through the process being deployed by Pulumi. So first we, we stand up a VPC, you know, basic Aws stuff, you know, get everything that's the baseline and pre rex for an Eks cluster. And we go ahead and turn on Eks uh configure an ECR repot. So we have somewhere to, to store our images. Uh then we have the image build process. So this could either be the build process or just a pull process. Um Then we are then pushing that image into the ECR repository. Now, that's gonna happen whether we build the image or not just for best practices of, of pulling it locally in the future. Uh Then we use HELMM to deploy the Ingres controller on the EKS cluster. Uh Then the log store gets deployed so that the elastic Elk stack infrastructure is in place on the Eks cluster, followed by the actual logging agent being deployed that will then collect those logs and send them to the Elk stack. Uh Next, we're gonna deploy the cert manager uh that will go ahead and allow us to have uh TLS certs enabled uh with currently being provided by lets by lets encrypt. Um And then finally, we're deploying the bank of series that we call it, which is the fork of Google's Bank of Ants application uh that we are taking and modifying and, you know, turning it into something and, and using it as a way to leverage some of the different functionality that you can do with using logic in the ingress controller rather the application tier. So that's where we're at today. Um This is still definitely a, a new project where we're not even to what we would like to call a V one, but we're getting very close. Uh So some of the next big hurdles we want to get done before we push to V one is gonna be, you know, getting that observably and, and tied up uh using open telemetry and Permetheus and Grana. So it is a very interesting project that we're on. Now. The open telemetry stuff is an awesome tool. But you know, it, it takes some work to stitch that together. So we're hoping that this will lead to some good uh content for not just this sort of environment but just using open telemetry in general. Also, we plan to add some uh more intelligent uh CD examples. We're currently looking at ARGO uh to run the CD pipeline. Uh We're also building in a performance testing framework so that we are able to easily check and, and see the performance impacts and benefits from different changes that we make in the cluster. And also just to give a really good baseline COTIS performance repeatable performance test framework. Um And then the last thing we're working on, we're still kind of up in the air of whether it's gonna be in one do or not is breaking up some of the functionality so that we have an application cluster and an admin and admin cluster to more mimic what we would, what you would see in a production level environment. Uh just to, you know, get those different, those different utilities separated so that they're not stepping on each other's toes and so that you can adjust the different parameters for resourcing and things like that, um how you see fit and what's necessary in your environment. So I know that was a ton of information. Uh We've got way more to talk about if you'd like to hear more, please join us at our office hours. They're gonna be starting right after this and uh yeah, hopefully we'll see you there.

---
