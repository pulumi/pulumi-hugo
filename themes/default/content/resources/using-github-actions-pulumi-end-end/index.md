---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Using GitHub Actions with Pulumi: End to End"
title: "Using GitHub Actions with Pulumi: End to End"
meta_desc: |
    See an end to end example of using Pulumi GitHub Actions deploying Dockerized Ruby on Rails app to Kubernetes, in addition to GitOps workflows that...
url_slug: using-github-actions-pulumi-end-end
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Using GitHub Actions with Pulumi: End to End"
  description: |
    See an end to end example of using Pulumi GitHub Actions deploying Dockerized Ruby on Rails app to Kubernetes, in addition to GitOps workflows that use GitHub PRs to promote code to production.  Learn more about Pulumi GitHub Actions  * Our announcement blog post: https://blog.pulumi.com/continuous-delivery-to-any-cloud-using-github-actions-and-pulumi  * Documentation on using them: http://pulumi.io/github
  sortable_date: 2018-10-16T20:16:44Z
  youtube_url: https://www.youtube.com/embed/1Et2TkuxqJg
transcript: |
    Today, we're gonna check out how Pulumi can work with github actions to do continuous deployment to your Cloud of choice, Aws Azure, Google cloud or even Kubernetes in any of the above clouds or on premises. And we're gonna use a GIT ops workflow to use branches to push to staging and promote that to production. Uh This application is actually Ruby's on Rails app. So if we go in the app director here, we're gonna see standard Scaffolded Ruby on Rails application. We've added a little to do list manager in here that we're gonna be editing as part of this demo. The only difference you'll see here is notice there's a docker file here. So the application is fully dockerized. Uh And we'll leverage that in just a moment as part of doing the deployment. Um If we go back into the of the repo, the Infra directory actually contains the Pulumi specification for the infrastructure required to run our application. This is not your average Rails app. Uh It turns out this Pulumi program actually creates a GKE cluster uh that we're gonna deploy into. So this is fully self contained environment, we can stand up any number of parallel versions of this, you'll see here, we actually have a development in instance, a broad instance and a stage instance and those typically map to branches, which we'll see is how the uh deployments work. Uh We also provision a manage post database. Uh That's a Google cloud sequel post database. So we don't have to worry about managing backups and persistence. Uh If we were to spin up our own say database uh service. But if we go look in the uh main file for this application, we'll actually see that we're building a Docker image uh in code. So all this is in typescript, we're building a Docker image uh and it's gonna be published to the Docker hub as part of doing a deployment. Uh And then we'll see uh we're doing a Curtis deployment and a Curti service. And so this is typical tti stuff that we're doing here. Uh That's gonna be part of the deployment. So basically, we're spinning up a GKE cluster, we're building a Docker image, standing up a cloud SQL database um publishing the image to Docker hub, pulling it into the kite cluster and deploying Curtis updates all in a single unified workflow. So a few other minor points before seeing it in action, we've got this dot github folder. This contains the workflow file uh And the workflow file is the new github actions uh capability for doing um actions triggered by pushes and pull requests. Uh And so we're just using that very simply here. What we're saying is on push, we're actually gonna deploy to the current stack. Uh The stack is basically Pulumi version of uh a branch. If you will, it's a, it's an independent environment you can tie uh deploy into. Uh and then we'll see pull requests. We're actually previewing what would happen before we merge the pull request. This is actually a useful feature. We'll see. Uh Pulumi has a github app that's integrated into pr workflow so that you can actually review changes before they're made uh and deploy to your environments. Uh The last piece that we'll see is this dot Pulumi folder and this simply maps branches, master and staging to stack names, P CS pro P CS stage. If we actually look at the Pulumi cloud console, we'll see that there are actually pages for these stacks here already and we can go drill into them. Uh And this keeps track of all the deployment history and we'll see here, we've got a URL that points us to the rails application uh that's already been deployed. Uh And then we can go look at to do list here and we can add, you know, to do lists and so on. Um Just to save time later, I'm actually gonna pop up the production instance as well. Uh and just open up that web application here and we'll position on it. We're gonna change the to do list application. Uh And so we'll want to see that in action here. So the to do list is empty here. So now let's go back and we're just gonna make a simple edit to the application. We're gonna make our update in the staging branch so we can see what the work flow looks like there. We're currently even with master. If we just go to the APP logic here, uh an app, we're gonna change one of the views, we'll find the to do list view and I'll go here and we're gonna use our to do list as a fancy comon board. Uh So change to list to comb on board. Uh And then we're actually just gonna commit these changes directly from the U I. So this already has kicked off a workflow in the background. Uh And we can see that in action if we go back here. So one commit ahead, let's create a polar request and create the pull request and we'll see that we're already have kicked off two steps here. And if we look, um we'll see that it's actually deploying the testing instance. Uh And then after it's done that, it's actually gonna preview what would happen if we were to merge this change into production. And that will just take a few moments. It's actually in the background, it's building the Docker container and it's publishing it and it's gonna rev the cnet's deployment. OK? Great. All the updates have occurred. Uh If we look at the details here, we're gonna see actually the Pulumi uh added information to the pull request uh the bot so that we know what's gonna happen. So here we see uh the preview of the production stack. It's telling us, hey, there's one resource that would be updated if we deployed this. If there was any downtime, we'd see that here. In this case, it's a rolling up update in. So there isn't. Uh And it says the staging branch was also updated successfully. Um If we want, we can hop on over to the cloud console and see details about this update. So the Pulumi console keeps track of, you know, the the resources that are updated, it links back actually to github. So we can see the commit that was deployed. Uh We can look at the full Docker build blog, we can see what cnet's resources were updated. Uh And in fact, we can go look at a full history which often corresponds to uh the GIT commit history. But since we just deployed this into staging, let's go ahead and take a look at the app and refresh. Uh And sure enough, it's turned into a fancy on board. Um So we can go and modify and remember all this is getting stored in that Postgres database. And so you saw even though it did rolling deployment, our old entry was still there. Uh And so that's because the post database was persistent the entire time. Now, let's say, you know, production, if we reload, production, production is still the same old boring to do app. So let's go ahead and actually merge this. Now, this is a ops workflow. So normally what would happen here is people would be looking at these changes. They'd be debating if that's the right change to make, they'd look at the impact. And, you know, maybe if there's down time, that would be surprising. And, and our, our teams, your product, the, the product actually integrates with this to allow approval workflow. So if you want your devs master to approve all changes to infrastructure, you can do that. Um But here we're just gonna go ahead and create a merge commit and remember from that workflow, the merge commit is gonna be very similar uh in its impact. Um But if we go here and we're on the master branch, we can see that, hey, this has been committed. Uh And we'll see that it's actually now deploying to production. Uh And so this is the GB action that now is taking those changes that were verified and staging now it's supplying them to master. Um And as soon as that's done, we should be able to go back to the app, check it out and it will have our new con on board. All right. And you see now, finally, it's uh finished deploying the uh production update and we can see the full update of, you know, all the Docker image uh builds and all that good stuff. Um But the more important part is we can now go back to the application and refresh. Uh And now we've got a board and there we go, that's uh Pulumi and could have actions together. I think it's really exciting that this enables sort of a, a more git style workflow which a lot of teams are moving towards. And I should have mentioned earlier, but we could have been updating things like the cluster size. We could have been changing the database, the backup schedule, all the infrastructure, all the application we can update in exactly the same way. So I think this is super cool and I can't wait for customers to get their hands on it.

---
