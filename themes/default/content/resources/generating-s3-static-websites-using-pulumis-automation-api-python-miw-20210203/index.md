---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Generating S3 static websites using Pulumi's Automation API in Python | MIW 2021-02-03"
title: "Generating S3 static websites using Pulumi's Automation..."
meta_desc: |
    In this week's episode we build an API that lets callers create or update an S3 static website. We do this by using a combination of two Pulumi pro...
url_slug: generating-s3-static-websites-using-pulumis-automation-api-python-miw-20210203
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Generating S3 static websites using Pulumi's Automation API in Python | MIW 2021-02-03"
  description: |
    In this week's episode we build an API that lets callers create or update an S3 static website. We do this by using a combination of two Pulumi programs: one that creates the API and underlying Lambda function and another that is actually an inline Pulumi program using Automation API within the Lambda function itself.  Code for today's episode is available at https://github.com/pulumi/pulumitv/tree/master/modern-infrastructure-wednesday/2021-02-03  Today's example is in TypeScript and Python, but Pulumi makes it easy to stand up infrastructure in your favorite languages including JavaScript, C#, and Go - saving time over legacy tools like CloudFormation and Hashicorp Terraform.  Get started: https://pulumip.us/Get-Started
  sortable_date: 2021-02-03T16:28:32Z
  youtube_url: https://www.youtube.com/embed/8XFjqzX9ZK4
transcript: |
    Hello and welcome to another episode of Modern Infrastructure Wednesday. I'm your host, Lee Zen. Today we're gonna be talking about uh having an API that we're gonna build that lets us dynamically provision static websites. So kind of funny that we mix those two words together. But the idea is that I want to be able to have an API where I can call that API with some parameters. And when I do that, it's going to either provision or update a static website on my behalf. And how we're gonna do that. We're actually gonna use Pulumi in two ways. Today, we're going to a use Pulumi to build that API and we're gonna use Pulumi to actually be the underlying function that, that API executes uh to provision and uh update that website. Um And that second part is gonna be using uh the new support we've added in Pulumi for automation API in Python. Uh So I, I think I previously in a previous modern infrastructure Wednesday episode showed how to use automation API in node. Um And this time, I'm gonna be showing how to use automation API in Python. Uh and also actually kind of showing you uh recently, I've done, I've done some videos uh around uh building lambda functions as a container images or using container images as lambda functions really. And uh we're gonna actually be mixing that in here as well, which is kind of cool. So um kind of showing you all these different concepts combined and at the end of it all, we're gonna have an API N point we can call uh with some parameters. And then every time we change those parameters, we're either gonna get a new website or we're gonna end up updating an existing website. So let's, let's jump right into it and see how it's all gonna work. Um So let's start with this javascript program. We're actually gonna be mixing languages too. One of the cool things about Pulumi, if you're not familiar, it's infrastructure is code language of your choice. Uh So we support multiple languages, typescript, Python go C#, you know, the dot net languages, um, starting with typescript here and then we're actually gonna jump into Python for our, uh second part of the second half of the application. So, um, because we'll see how all that works together on, on this side of things. Um, I've already written everything, so I wanted to debug some things and make sure everything worked, uh, and actually read into some interesting, uh, little things here and there that I had to debug. So, uh, um I, I'll talk through those but that actually saves us a lot of time in the video since uh you don't have to watch me debug live. Um So, yeah, one of the things, for example, I forgot is that um I ended up having the wrong uh permissions here. So I had to kind of tweak the permissions a bunch of times. Uh But anyways, uh what are we doing? First? We're taking uh this image that we're gonna look at in the second this app uh image and we're building it. And uh that's so this, this is the Docker build context uh app. And we're gonna go and look at what's in the Docker file and the actual uh application there. So we build this image and it gets pushed to ECR so uh elastic container registry uh in AWS and on top of that, uh we're also going to create a role and this is the a rule that we can have our Lambda function assume. Uh So you can see here we have this assume uh role policy which we, we let lambda assume this rule and we give this rule to permissions. We let it uh have basic execution rule for LAMBDA, which basically means it can log to cloudwatch logs. And then we also give it to S3 full access. And the reason we give it S3 full access is we want this role to be able to create buckets, uh put the objects into buckets, uh update bucket policies, et cetera. So we just give it full access and uh obviously you can scope things down if you want, you can change these policies. But for now, I'm just using these as, as uh simple things. Um And then we, we create a function. Um One of the things I I had early on is I had to set at 1 28 megabytes, which is a little bit too low to do a bunch of the things I want to do here because we end up uh bringing in a lot of libraries. Um So kind of I bump this up to 10, 24. It actually doesn't take the 300 seconds, but I just give it a five minute time out. And then, so yeah, so what we do is we create this function where we wire up this image that we pushed earlier. So this is the, this is the image that we're wiring in right here. Uh We give this function this role and then uh we also give it in the environment variables. My, I've created a Pulumi axis token in this stack as a secret. So actually, if you look in my, you can see it's just this, this uh encrypted value here. Um And so that, that's what's gonna go into the environment in, into the environment. So that, that this function can actually use this axis token. So um what's gonna happen on the back end and we're gonna get into that in a second. You'll, you'll see why we need this access token in, in just one sec. Um And then finally, uh we create an API where we have this builder path um where you can post a value to that builder path. And um the event handler is this function we called uh we created earlier called builder. And then finally, I export two values from the stack. One is the image in case I wanna uh you know, do some debugging against the image and uh one is against the actual API uh end point so that we can actually make curl uh requests against it. So yeah, super simple. This is very similar to previous examples I've shown around uh wiring up a container uh having that act as a lambda function uh passing you know environment variables to that function and also um creating the right set of policies uh for that function to execute. So, so what is, what is the actual application that this function is, is, is what is, you know, what is, what is this function? Let's take a look. Uh We have a couple of things first, we have a Docker file. This is what's gonna define uh the actual uh uh image that uh is going to be deployed as a function. So we start with a base uh image from, from a W where uh these are the lambda images. They, they have um they have them for all the various lamb to run times. In this case, we're using Python and uh we set up and install the dependencies required for our program. So we have this. So we require the pool cli and the Pulumi Aws SDK. Uh And then on top of that, uh we install Pulumi. So the automation API which I'll talk about in a second, uh requires the Pulumi cli. Uh One of the things I ended up debugging is that uh Lambda doesn't like running things uh out of here. So I move it to a place. It does like uh and add it to the path. And then I create a home directory in a writeable place because uh the normal home directory is not writeable. Uh And so, uh you know, we wanna set Pulumi home which Pulumi uses for uh some, some workspace management stuff. Uh So we set that up and then we finally copy your actual program. And so now let's stick into this. So this actually uses uh We don't need this uh automation api uh you can see here with this import for auto and what are we doing? Uh So we're actually using Pulumi in a programmatic way. Uh So not as a cli indication to actually manage uh state and to create infrastructure on someone's behalf. And so that's what's gonna happen here. And so you can see here with this function called create static website bucket and uh this function does what it says the function name it, it uh it creates a bucket. This is just like a normal Pulumi program you would run Pulumi up against, except here it's gonna be executed as a Lambda function um without ever ever having to invoke the Pulumi cli. So this is actually using Pulumi in a completely programmatic sense. So we talk about pooling programs, obviously, they are just normal uh you know, programming language programs, but normally you would execute them or not normally. But you know, typically, I guess, you know, in the past you execute them using pulling me up or some other pulling, you see life command here, they're getting completely executed within the context of some other larger scope program. So here in the, in the context of a lambda function, and so um we have this function creates that a website, it creates a site bucket. Uh This, this, this function takes in a bucket, name and title in the body. You can see we substitute that title and body into this into this content uh template and then we create this object. Uh and then we stick that in the bucket and then we make sure that the bucket has a uh uh public permission so that people can actually go get those, those, those uh those things. Then we export the website. You were super simple Pulumi program. But what's cool is this is in line within the broader context? Of our lambda function. So our lambda function, all it's gonna do this is the Lambda handler. Uh and LAMBDA function is going to, since this is wired up, the API gateway is gonna take the body from the API gateway request, uh decode it since it's gonna be base 64 encoded. And then we're gonna take the bucket title and body values uh from the request. And we're going to go ahead and uh instantiate a Pulumi stack. So we're gonna create uh that stack. You can see here, create or select stack based on the stack name. And the stack name is gonna be based on uh the actual project name and bucket name. So here, the project name, I'm just hard coding to be website builder and the project name is actually uh the bucket name rather is passed in as a parameter from uh from the api invocation. Uh And then uh we're gonna, you know, pass in the site title inside body as well that we get from the actual API invocation. And so what's going to end up happening is we're gonna create the stack and we're gonna run, we're gonna, you know, install the plug-in. We're gonna set, config these are again, kind of, these are the analogs of what you might do on a cli basis. Um And then we're gonna run stack up which basically says go update the stack. Uh And so we're gonna see how this ends up working and then you can see at the very end we're gonna return back, um, the URL, uh, to the, uh, to the caller. So, uh, I've already gone ahead and actually deployed the stack already. Uh You can see I was already playing around with it. So let's, let's start over. Um, you, you know, so let's, let's do this. We're gonna call the endpoint, um, but we'll, we'll, we'll pass in some different parameters this time. Um So, you know, as we talked about earlier, uh we give it, we can give it a bucket name. So we can say, for example, uh you know, Miw episode demo. Um And, you know, we can give it, you know, the title LMIW and the body could be, you know, um automation API reps. And so these are the parameters that are gonna get passed uh to this Lambda function. And the lambda function is gonna execute a pluming program that's going to create the bucket, create the actual index dot html file, put that in the bucket and then create the bucket policy to let that be readable. And assuming all of that works, this should come back with AJ Jason Blob that looks kind of like this. Um with the actual uh URL, we can go use to visit that website. So here you can see everything I created. I can go visit this website. So let's go check that out. And you can see we got automation API rocks. So that's, that's pretty cool. Um You know, why is this so different from, for example, if I in this function just created an S3 bucket, like if I just use the AWS SDK to create the S3 bucket and, and upload a file into that bucket, like that's not so different, right? But if we do a subsequent invocation of it, then you'll really see the difference. So let's, let's keep the bucket name the same. But let's say we changed the title to, you know, we decided we'd actually, you know, wanna kind of change that we had a comma here. Hello, comma Miw and then, you know, body automation api rocks uh Pulumi manages state. And so we have a, we have a different string set of strings here. And if you think about what I just said, if we had used the AWS SDK, we would have had to keep track of like does the bucket exist? Does the file exist if it exists? Like go replace that, you know, kind of have to do all this extra logic here. Our program is super simple. We're using Pulumi the way you would typically use Pulumi where it's it's desired state. So, you know, the bucket is a desired state like it already exists, it's not gonna go recreate it. And similarly, um you know, this, this bucket policy is already the say the bucket policy already exists. We don't have to go recreate it we don't have to decide whether or not we need it or not. All we have to do is update the bucket object, which is what happened here. And if we go visit the site, you know, it didn't have to recreate the bucket, but it did update the values. Uh, here you can see, uh, let me actually bump the font size, it updated the values, uh, but didn't have to go recreate the bucket. And actually, we can see this uh if we go to the Pulumi console in, in the says um in the miw episode, if we look at the activity. So this is, this is actually what I meant here by Pulumi manages the state. I'm using the A and that's, oh I totally forgot to mention that earlier I mentioned, oh I, I pass in this Pulumi access token and that's what's, that's what it's needed. So that when we, when we go create the stack, it by default, it's, it's interacting with the Pulumi, it's interacting with the Pulumi Saz to manage the state. Um So you can see the first update if we look at the set of changes here, you see what we expect. We create that bucket, we create the bucket object and we create the bucket pops and of course that we have this kind of meta stack object, but we create all these objects because the stack didn't exist yet. The second time I called uh the second time I invoked this API N point, uh All that we updated was the bucket object. So I'm gonna let that sink in for a second. So we didn't have to encode any extra logic or anything. We just used Pulumi, you know, in a natural way. And then all we did is we wired that up to a Lambda function and had lambda execute our Pulumi program. Um And so, you know, there's all sorts of scenarios you can imagine doing here where you're automating infrastructure in a programmatic way that lets you, you know, on the fly, create, tear down, do whatever you want with your infrastructure in a, in a desired state model uh in the context of a larger program. So, so really cool stuff. Um And obviously, you know, I, I think I, I think uh this, this hopefully gives you a good sense of how automation API works. Uh You can see kind of how easy it is to use automation API uh in Python. Um uh Here, you know, there's not, not a whole lot of lines of code like all this is just a typical polluting program, so not a lot of lines of code there. And then here, I'm just doing some, you know, uh munging of my data. And then really like this is the bulk of the program. This is, you know, hey, let's let's create a stack, um you know, set up a stack, let's install some plugins set up some configuration and then like run the Pulumi program. And that's, that's the entirety of the, of the lambda function. Obviously, you know, we should probably add some more error handling here. Like if, if this, you know, if this has an error, we should return a different, you know, value, like we should return like a 500 error with, you know, with the actual error and, and what the user can do or we or we could add in automated error recovery handling in here. Um And then also you could also, you could totally imagine that, you know, this post endpoint, you could imagine adding a, a delete endpoint to the same path or something like that where we actually end up by executing a similar program. But instead of running, you know, stack up, we, we end up running stack destroy. Um And so, you know, you, you could, you could have this whole thing wired up. And then you could imagine finally like wiring up this API N point to, you know, some beautiful website where someone can go and, and uh kind of like, you know, imagine in, in a company context or something like that, like, you know, you have some non-technical users who want to stand up their own websites. But you as the as the actual technical side of things, you know, you want those managed in the desired state model, the way that Pulumi does. Well, you could do something like that and, and they can go, you know, people could go bonkers creating static websites uh on their own or something like that. Anyway, uh hopefully, uh you had fun watching this episode. Got a good sense of all these things. I just talked about tying together uh in recent episodes, you know, having um having a container run as lambda function and then kind of showing you how all that gets wired together. But then using automation API is the actual Lambda function uh to manage your infrastructure. I hope you enjoy today's episode. Uh Make sure if you haven't already to subscribe to Pulumi TV. For more content from Pulumi, you know, we talk a lot about automation infrastructure, infrastructure, code, fun topics uh related to the cloud. And so yeah, make sure you subscribe to Pulumi TV. And also if you enjoyed this episode, we love to hear your comments and feedback uh in the comments below or just hit that link button at least. So I know that uh you enjoyed today's episode and hopefully we'll see you next week on Modern Infrastructure Wednesday.

---
