---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Ep 007: Migrating to Pulumi"
title: "Ep 007: Migrating to Pulumi"
meta_desc: |
    This week, Luke will take a look at how to migrate to Pulumi. We'll cover Terraform, CloudFormation and more: getting things done with real code.
url_slug: ep-007-migrating-pulumi
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Ep 007: Migrating to Pulumi"
  description: |
    This week, Luke will take a look at how to migrate to Pulumi. We'll cover Terraform, CloudFormation and more: getting things done with real code.
  sortable_date: 2018-07-25T19:59:11Z
  youtube_url: https://www.youtube.com/embed/R3OfgFHkj3o
transcript: |
    All right, good morning, everyone. Uh Welcome to this week's episode of Pulumi TV. My name is Luke Hoban. And today I'm gonna be talking about uh migrating to Pulumi. So if you've joined us for any of our previous uh live streams, uh a lot of the demos we've shown have kind of been about applying Pulumi to new kinds of applications, uh taking um a standalone new application. You want to build a Greenfield application uh and using Pulumi with that. Um But when we talk to users and customers and, and about how they're adopting Pulumi, um a lot of the questions and the, the um the discussion is about the process of migrating from some existing system uh to Pulumi. And so today, I wanted to spend a little bit of time talking about that process. Um Kind of a few things, one where people are thinking about migrating from uh to Pulumi, uh how Pulumi is, is um fitting in with their existing systems. Um And then when they do think about uh migrating to Pulumi, where is it that uh you know, what are the tools to, to do that migration? Uh And to, to help uh to help, you know, sort of match the concepts from uh within the previous system over uh to uh what they're going to do with Pulumi. Um So along the way, I'll show a handful of kind of uh examples of, of um using Pulumi uh in some of the domains that uh that folks have been migrating from. Um And uh of course, in future, uh in future video streams, we'll kind of dive into some of these specific areas in more depth. Um And talk about that migration process as well. Um But for today, uh let me start kind of high level and talk about um some of the ways that we've seen folks um migrating to Pulumi. So, uh broadly speaking, I sort of see two kind of categories of uh when, when, when I go and talk to somebody about uh Pulumi uh the existing tools they're using, which Pulumi, which they, they're looking for Pulumi to, to replace or to augment. Um One category is they've got a set of kind of infrastructure markup tools. Um And so this could be either they're using the, the native uh um uh systems in, in the individual cloud providers. So cloud formation or as a resource manager or even here, we might consider um you know, TCM or something um the underlying core kind of API representation for the cloud platform uh or they're using some existing tool that layers on top of that, like terraform in each of these cases, they're kind of using some way they're already kind of bought into infrastructures code. Um They understand that that's valuable. Um But they want to move for infrastructures code where the infrastructure is software and to um take instead of just a low level building blocks to be able to, to treat their, their complex uh infrastructure as something that they can manage with, with pure true software. Um And this is what's sort of motivating them to, to look at Pulumi. Uh the other side of that uh is kind of folks coming from more domain specific tools. So folks who really want more productivity than they can get from working with the raw building blocks in cloud formation or terraform or, or, or what have you. Um And so they're looking for one of these tools that really makes a particular vertical um really nice. So serverless framework, if they're doing serve um applications or a Docker compose or, or helm, um if they're do doing container based applications or a variety of other sort of uh integrated vertical solutions that really say if you're working within a very kind of specific sandbox, um you can get a really great and productive um experience. Um but you may not be able to easily move outside of that sandbox. And so this is sort of, you know, on the left, we've got sort of the lower level um you know, details of the underlying platforms. On the right, we've got the higher level product productive um model of development. And really in both of these cases, the folks moving to Pulumi, you kind of tend to be looking for both the infrastructure of software, being able to use software and all the benefits that provides to manage this kind of infrastructure. But also the ability to not have these two sides be siloed to be able to get the productivity of the high level domain specific tools. But combine that with the level control that they need from the underlying platforms when they need it. Um And this is sort of what Pulumi does. Uh And Pulumi can sort of uh you know, creates a kind of a continuum between these two ends of the spectrum. Um And really can, and we've seen examples of Pulumi being used as a replacement or augmentation of um sort of all of these tools uh plus some others um because it can sort of um uh scale up and down. Um But across this spectrum. So I want to talk about um uh some of those in more detail. But, but first I should mention one important category of migration that uh that I sort of skipped over in that first uh um slide. But that actually is sort of almost the biggest category of, of um of things we see when we go out and talk to customers. And that is folks who are, haven't even gotten to the stage kind of, of really thinking about infrastructure as code yet or not, not thinking about it really seriously. Um And those are folks who, who maybe are um either pointing and clicking on the console to create some resources and that's kind of how they're bootstrapping their, their cloud application or they're using, you know, bash scripts or, um or some sort of, you know, imperative Python application uh to go and, you know, hit the API S and, and create the resources they want. Um And so this uh you know, most of the benefits we're talking about here are things which are generally true for any infrastructure's code offering. And so Pulumi really one of the key differences Pulumi has from, you know, just using a Python script to call the uh the A API is, is that you get this true infrastructures code, you get to describe the desired state of your infrastructure, you get to run an update and that will make the minimal set of changes to achieve that desired state. Uh And just as importantly, then you have repeatable deployments. Uh So when you, when you have a Pulumi program, you can go and take that and stand up a new copy of it um completely isolated from the previous copy, you can do that just on every pr to your application or you can have a DEV and staging build or you can have um a DEV uh a DEV environment. And so this ability to sort of describe your infrastructure with code uh is really um you know, a significant benefit that that many folks um have the, the key thing that Pulumi sort of brings to this is uh that as well as being able to get the benefits of infrastructures code, you don't have to leave all the creature comforts of a real programming language. Um So for folks who are familiar with, with javascript or Python or go or any other other languages that, that Pulumi supports, you can get all of these benefits of infrastructures code and about, you know, desired state uh um of your applications and be able to, to um deterministically drive towards that desired state, but you can still get all of the software engineering benefits of, of being inside kind of a real program language. Uh And so, you know, that's really the main thing that uh you know, and folks are, are, are talking about moving from something they're managing using sort of scripts or a console um into Pulumi. It's often the case of, you know, they, they're coming for an application development background, they, they, they feel more comfortable using code than using sort of a, a new Yaml dialect they've got to learn. Uh And so, you know, uh Pulumi looks attractive uh from that perspective. Now, for when, when you're coming uh along this, this sort of uh dimension, there's a few things that are sort of interesting to, to keep in mind as you think about how you can kind of map this into Pulumi. Uh So the first is, uh you, you don't have to do this sort of transition all in one. you know, it's very easy to just take one little piece of an application or, um, or just some net new pieces of an existing application and incrementally adopt Pulumi into those. Um And so if you've got existing infrastructure, you can just continue to use that and manage it in the existing way and uh and access it and build on top of it um from within a Pulumi program. And so there's a couple of tools available for this. Um Generally, uh these dot get API um which allow you to access an existing resource um and use that as an input to new resources. There's also a set of tools for kind of adopting these then into your application and having them be uh managed by Pulumi now instead of being managed by uh by the console. And I'll show those just in just a second. Uh The second one is um you know, really because uh you know, Pulumi is letting you use uh uh a program language, you can continue to do all the free form sort of stuff you might have done uh using uh scripting or back scripts or whatever. Um And you can go and uh shell out to a tool you have locally that you need to go and create something you can use built in libraries in Python or javascript to uh you know, parse some file format that you need as input. Um all these sort of free form things, you sort of are worried, you might be constrained if you go to some kind of ya based uh system, uh you have those all accessible to you uh within Pulumi. Um And so that's an important thing to keep in mind as you're thinking about this, many of the constraints that you that may have kept you away from adopting infrastructures code in the past are not as significant. And because you can sort of do this free form application of logic into your infrastructure's code definitions. And then the last thing is uh application code and this is something that we just uh you know, like to as we introduce programming languages as a tool for doing the infrastructure provisioning. Um We do like to remind people that this does not constrain the kinds of applications that they can deploy. So uh you know, you can write your infrastructure and Pulumi using javascript or Python or go. Uh but you can still deploy application code written in any language if you have dot net and java inside your uh inside your company, uh you can deploy applications in those and just, you know, write your deployment scripts in javascript. And so the using Pulumi does not constrain in any way, what kinds of infrastructure and application code um you're able to deploy uh into your application ultimately. So with that, let me just talk a little, let me show a quick demo of what that looks like to do some of this kind of incremental um adoption and I'll show a few of the tools that are available um to do that. Uh So here, I've got just a very simple um Pulumi program which creates an EC2 instance. Um and it creates this army and I just grabbed this as the, the army for Amazon Linux inside um us West two where um I'm going to deploy this application. Um But you notice I left the Subnet ID um blank. And so uh uh to get a Subnet ID, I might want to sort of attach this instance to some existing subnet that I have inside my cloud platform. I may not want to create a whole new VPC and Subnet just for this instance. Um And so this would be, I've got some existing infrastructure may be managed with cloud formation, may be managed with uh that I set up through some uh some scripting. Um And so I'll show a few of the ways that I can go and uh integrate this into um that existing infrastructure. So the first and sort of the most obvious um is I can come over here and I can actually just find one of my submit I DS that I want to attach to in the console. Um So let's say I had point and clicked around, created a VPC. Maybe I'm just using the, the default VPC that, that a W gave me for free. Uh I can just go ahead and grab this sub ID here past this in and uh and now I can go ahead and deploy this and just for those of you who haven't seen kind of Pulumi being used to deploy something, let me just um come back over here and I'll just say Pulumi update and show you what it looks like. So this is a stack that I have. Um uh and a stack in Pulumi is an instance of this application and you see this instance just wants to deploy a single uh um EC2 instance. Um And in this case, I'm deploying that into us West two. So I can say yes to the preview because I do want to go ahead and create that instance and I'll just watch this create. Um And when it does create, we should see that I have a new instance um inside running inside uh that new that submit and I'll come back and show that in just a second that probably will take about 30 seconds. Um So, but I might not want to hard code uh this string in here. I might want to actually make this a parameter so that you know, if I'm in my staging environment, maybe I attach it to a different subnet. And so for that Pulumi has support for config. And so I can say that config equals new Pulumi dot config. Uh And I'll call this um since this is in the migrating project, do that. And then I can say config dot require and I'll say submit ID maybe. And so I'm gonna say, let's submit ID. Yeah. So now I can do this sort of thing. Um And just pass that as a configuration and what this means is, I'll get it from the externally provided configuration. And so every time I stand up a new instance of this program, I can parameterize it with uh a new Subnet. And so over here I can do, and I actually will see that I already um I'll just do it here migrating submit ID. So I'm gonna do Pulumi config set and then I'm gonna set this to that same uh Subnet ID here. And then I'll go ahead and uh replace that and I'll come over here and say Pulumi update. And actually, because I didn't change anything, uh This should say that I don't need to make any changes to my uh my application. And so it says no change. Uh And I see the details and it will say that this is the same. Um And so we gonna go ahead and uh not proceed with that because there's no changes to make. And so you can see that I was able to move from hard putting that in to uh passing it in through configuration. Um Just uh without actually having to change the name of my existing infrastructure here. Um And that's an easy way to sort of parameterize uh on that subnet id. Um Now if I set up an instance of this stack that uses a different subnet id, or if I change the, the configuration setting, maybe I change it to uh point to this subnet id happy that and now I run Pulumi update again. Now we'll see we actually have to tear down the old instance and create a new instance, we have to replace it. Um So that we can stand up for the instance in uh the new subnet. So all that's kind of what you might expect. Um There's a couple of other tools you have available um to sort of adopt in and, and use existing infrastructure. Um So one of those is uh you know, if I want to actually get this subnet and get other properties of the subnet, I may not want to pass individual uh parameters or configuration into my program, I may just want to be able to parameterize by a subnet id and then just go and find all the other details related to that and use those as inputs. So I can do that saying by saying something like let Subnet equals um database dot ec2 dot subnet dot get. Um and this will be, I'll call this submit and now here I can pass that Subnet id. And what this will do is look up that existing Subnet in AWS in this case, buy it Subnet ID. But now I have a full instance of this subnet where I can get all the different properties available on that thing. So I can get, you know, what, what availability zone it's in. I can get the tags on it. I can get the VPC ID that's part of. And so I can use this. So instead of me having to pass in all of these pieces of information separately, I can pass in just the one I care about and then find all the other information and use that to parameterize things. So I can use this VPC ID for example, as input to some other resource in my application. So that do get is a very handy tool for being able to take existing resources um in your target cloud provider and bring them into a Pulumi program without having to change things this dot get. Um we actually also store that into uh the state of the application. And so you can, for instance, uh uh use this to import a resource and then you'll have it waiting in your uh in your program and then you can change that over to be actually managed by Pulumi um in a future uh update. Well, there's also a set of useful tools if that by itself is not sufficient. If you want to do some sort of richer searches, you can do something like AWS do. It might be easy to do, get instance, like let's say I want to find an instance and I want to find it by some parameters. So maybe I pass in some filters or some tags that I expect to be on it. And so I can use these to go and search aws in some richer ways for existing existing resources and then pull those into the program and use those from within polluter. So the core goal of that is just it's very easy to go and take um existing resources um and start using them from within a Pulumi program uh in a kind of robust way. Uh And so I'll just get back um and kind of talk about how we use that in some broader examples. So that first example was really kind of about uh you know, just sort of infrastructures code uh benefits in adopting existing resources. But a lot of the folks who are coming to Pulumi do actually um have existing experience using a tool like cloud formation or arm or terraform uh to do infrastructures code for uh the cloud. Um And so for these folks, uh you know, the thing we, we hear kind of from them generally is a few different things that are really attracting them uh kind of to Pulumi that are causing them to think about. Uh Pulumi, the first is the benefits of real software engineering, effectively treating infrastructure as software, not just as code or not just as text. Um And this is a variety of things, this is the ability to get rich tooling that you expect from, you know, the kind of software and application code that you write. Um whether it's in Java or C# or Go or um uh javascript or whatever it is you're doing in your application code, you get a bunch of really rich tooling um and bringing some of that kind of tooling experience into your infrastructure um is really important to scaling uh infrastructure up in a reliable way. Um One of the key pieces of that is getting sort of type checking. Um so getting, you know, getting feedback as you're working, uh getting completion lists, getting error reporting, um making sure that you get that feedback early and often around uh the correctness of your um of your infrastructure software. And then finally sort of functions and abstraction and the general ability to um to take, you know, take pieces of your code, give it name, uh you know, create reasonable components and then ultimately to put those into package managers um and share them and use them between members of your team and across uh folks inside the Pulumi user community. Um And so this packages notion is really what enables folks to use higher level components instead of just copy pasting around blocks of YAML or blocks of, of declarative markup. They can really reuse packages and importantly because they can attach to existing package management ecosystems. They can actually use packages and so packages which uh are versioning as part of the package manager and can be pulled in at specific versions and, and using sever um uh make sure that they remain correctly up to date um uh with the latest fixes from downstream and then can adopt breaking changes uh when they need to. And so really the sort of robust package management kind of discipline that folks expect from their software, uh we can apply that also with Pulumi to infrastructure. Um And then finally, uh you know, a key benefit of that folks see relative to sort of cloud formation. And as a resource manager is having a unified model across clouds and also sort of across technology. So, you know, whether you're doing containers or servers or raw infrastructure using a single model to kind of talk about all of those things. And so there's a few things that that sort of are worth calling out for folks who are using some of these systems. One especially for folks who are using Terraform often have questions about kind of the state files. And so Pulumi uh you know, by default stores, all the state files in a backend service and so you kind of don't have to deal with a lot of the management of state files in the same way as you might with, with Terraform. And so these uh this current state of your application is stored in the Pulumi service. Um And you can always run deployments from your local machine. And those deployments are um are executed entirely on your local machine, but the state is backed up into the Pulumi service. Uh So that multiple people from your team can work collaboratively on a on a project or you can move between machines uh easily and have your state robustly managed. Um And so that you won't, uh there's no possibility of accidentally losing or corrupting those state files. Uh The second thing which is sort of notable for all three of these is the Pulumi providers, the Pulumi uh the way that Pulumi talks to the target cloud platforms um actually generally sit on top of the Terraform uh provider ecosystem. So the Terraform provider ecosystem is a great set of open source projects for um reusing uh the the various cloud platforms through uh through a schema of those platforms. And so one of the things this means is that uh in general, folks kind of coming from Terraform uh or who have existing Terraform assets uh can, can port or can sort of evaluate their code on a kind of 1 to 1 basis. Um So, you know, you can take an existing uh terraform resource and very easily say, here's the, the 1 to 1 translation of that into Pulumi. Uh And folks using cloud formation and arm uh this generally because these are um a representation of the each individual resource in the cloud provider. There's normally a very close mapping between those two. So it tends to be very easy if you've got existing resources in any of these systems um to map those into Pulumi. Um The, the key thing though is then once you've done that, then you have the opportunity to really take advantage of all the things that the Pulumi provides. Um So that's when you can then start refactoring your code to take advantage of functions and control flow and, and you know, uh parameter and all these nice things that you get. Um and you can add sort of richer typing and structure over top of the code to make sure that you are able to catch bugs earlier as you iterate on this code um in the future. And so all the benefits we talked about um you can apply kind of after uh have imported some code. Um the last piece to kind of think about in all of these sort of DS LS, whether it's cloud formation, YAML or terraform HCL uh is um kind of interpolation. So all of these systems have some way of kind of embedding some uh some extra logic inside um the way that you map between outputs of one property and inputs of another property. And those tend to be these very specialized and somewhat ad hoc uh kind of um languages that are embedded inside um these, you know, uh these YAML files. Um And so one of the key things in Pulumi to think about is whenever you have one of these interpolations, you actually kind of get the full capabilities of the host language. So javascript or Python to replace those with. And so instead of being constrained to maybe five or 10 built in functions that might be available in, for instance, cloud formation alarm, you have access the entirety of javascript and of the no Js run time and even of the no S package ecosystem. So if you need a library for uh doing computations of cer blocks for your networking stack, you can go to M PM, look for that library, pull it in and use that if you need to parse some file format that you have on disk that you want to use as parameter. Um you can just use, pick up a library from M PM that knows how to parse that file format um and use that from within your application. And so this ability to embed you know, any code you want to any logic you want um inside uh of your deployment programs is actually one of the really significant uh changes that you get kind of as you think about moving from cloud formation in arm and form to Pulumi. And so let me uh quickly show kind of example of some of that. Um And so I have uh over here uh a example kind of in terraform. And this is I I'm doing a terraform example here. This really could be an example in any of these um from any of these systems. Um But I'll start with a terraform one just to give a sense of kind of uh uh what some of this looks like in this kind of 1 to 1 translation and then what some of the benefits are um that Pulumi can offer. Um So for folks who haven't seen Terraform before, this is uh you know, um uh Terraform HCL and sort of uh kind of its own domain specific language. That's a very kind of declarative model for um describing infrastructure. And so let me kind of uh just hand translate this to begin with and kind of that 1 to 1 form. And then I'll show some of the improvements that we can make. Um So first off, uh this creates this IM for lambda. And so let me uh you know, create that role. Um First thing we see is this is a resource ad si M roll. And so we can access that by saying a two S dot Im dot Roll. Um And so you see it's sort of a very 1 to 1 the same shape of resources that are available here are gonna be available inside. Uh Pulumi the difference being that I actually have kind of rich in teens and um completion lists and I can go and explore what kind of things are there in this. I am space, you know, there's roles, there's role, policy, role, policy attachments and get the documentation for those things right in line. Um And if I mistype, you know that uh I can get this, you know, error message. Um uh I can get this error message saying, you know, did you mean roll? Um So you know, easy feedback, quick feedback on some of those things. So I'm gonna call this IM for lambda to match that previous example. Um And then similarly, I can kind of get uh completion that's showing me all the different properties that I um you know, must or may specify. And so you can see there's only one that I must specify, which is this is no policy. And so I'll go ahead and do this and I can do the sort of the same thing as what, what was done in that example. One key thing to note though uh in this example is I kind of had to do this with this, you know, embedding, just some raw text. Uh And so this was just a way of embedding uh you know, some other completely different file format inside of this program. Uh because javascript you know, Jason objects are a frequently used thing. It's actually very simple. I can just copy paste this in. Uh And now I'm actually uh um you know, embedding that Jason right inside my javascript file. So very simple to do that. Um And I have kind of a working Pulumi program and here I didn't have to sort of break into some totally different file format. It's really just uh json objects. Um And then I'm turning that into a string to pass um to pass in here. So let me then go and take this other uh resource and I can say a dot lambda dot functions, let's, and I'll call this Lambda. And similarly, here I can do, you know all the, I have all the same kind of properties available. And so, for example, even that uh more interesting environment, you know, I can go ahead and do this kind of thing, right? Um But you notice things like I get error reporting saying, hey, you know, you're missing some properties. Um So if I hover over this error, you can see the property handler is missing. So a few of the, the properties I needed to specify over here. Um And so I won't go ahead and do all of these things, but, you know, you can imagine uh I can kind of fill these out as well. Um And so I should note actually this example that I'm showing here. Um If I come back over. Uh This is actually just taken from the Adibi lambda function docs um on the form sites. And this is just sort of the, the, the most basic kind of lambda example in practice, um you know, these things often get uh more complex as well. Uh It was just sort of starting with a very simple example here. So just delete this for a second, so I can show a couple of other kind of handy things that we get um uh with this assume real policy. So, uh because uh uh we know what some of these shapes are actually supposed to be. I can actually also go ahead and say let's um policy type a S dot im dot um policy document and I can come over here and just paste this thing in. And the nice benefit I get again here is now if I make a mistake, like I mistype the name of a statement or I um say, you know, don't use the right um uh uh kind of effect. Uh There's only a few kinds of effects that are allowed. I actually get errors in my program. And so again, I can find these errors all the way deep down into uh the specific file formats and and Jason payloads that are expected for some of these things uh right in line um by, by doing uh because I have a type system available in Pulumi. And so uh I'll keep that like it is. Um And uh yeah, so this gives me the ability to get type checking on that thing. Um But because we have arbitrary functions as well, we can also create little hand handlers that help with this. And so uh one of the um uh uh folks who uh has been an early adopter of, of uh Pulumi um actually did a recent contribution to this library that uh adds a little helper function as role policy for principle. Um And this function uh actually takes, you know, uh just the principle and then automatically creates all the rest of the boil plate you need for an assume role policy because they're, they're always um effectively the same. So here, I can just say service colon lada dot amazon aws dot com and that was just this part of the, the document. And so now this is a little handy helper where I can just specify just the piece I care about. Um And I get then a policy document and that ability to sort of give these things names, uh share them. We can publish that in, in this package itself or in another package. Um is a really handy thing to make, create sort of reusable uh components within uh our applications that we don't have to repeat this kind of boil plate over and over and over again inside uh our software. Um And so that's, that's a very simple example, but you know, in this example, the sort of the biggest thing you kind of notice is just, hey, this is a lot of stuff I've got to do just to kind of get a function running. And so that's when we kind of have um, uh some higher level wrappers that kind of do more of this for you automatically. And so in previous examples, we've talked a lot about some of those, but one of those we have is new aws dot serve dot function. Um And here I'll call it Lambda. Um I can pass some options so I can, you know, specify the, the role of the policies. Um So I can say uh give it EC2 full access. I don't know if that's really what we want and then I will um pass a event handler. So and so here um I can create a Lambda but instead of me having to put it inside a zip like this and get the zip, you know, author that in some other payload and embedded inside like this, um I can actually just write the code for this in line. So I can say here console dot log, you know, CTX dot uh And then I can say maybe the, the function name every time it gets invoked. Um And so this is our ability, we have this handy ability to kind of write uh Lambda in line. And so we in, in this case, we built this little wrapper, uh it'll be a serve function over top of that to make it really easy to create simple Lambda that want to live just in line uh inside your program. Um And so this is the core kind of building higher level components and starting to get more of that kind of servers and high level um experience. Um But um based on top of the, the raw building blocks of uh of the same things we can do here eight of us dot lambda dot function. OK. So that's a, that's a quick example of kind of uh what it can look like to move over um some kind of terraform examples. And let me then go ahead and talk kind of from the other end of the spectrum. Um And so it's the other end of the spectrum, we're kind of talking about some of these uh um high level tools that let you work with either containers or serverless applications. Um But that really kind of treat those as their own little sandbox. You typical, typically kind of have to use these in combination with other tools to manage your cloud deployments. Um uh And they sort of are their own little uh islands that you kind of work on for the subset of your application that gets to take advantage of either containers or servers. Um And so again, there's key benefits that you get, you know, with Pulumi around sort of software engineering instead of using YAML files, that sort of thing, you get, you know, uh the full benefits of sort of tools and type checking. Um And you get that unified API across clouds and technologies. But the one key thing uh that I think most folks uh using these tools find um they're looking for uh when they, when they consider Pulumi is the ability to not kind of have a black box. And so the ability to when they want to get down into a low level detail to just have a really easy escape hatch, to combine some raw Aws infrastructure or raw a infrastructure with the ability to write very simple compo darker compose like uh um container uh definitions or very simple high level serverless applications that stitch together um event sources and functions and deploy them all in a really convenient way. But while still having the access to provisioning the raw data resources with the full uh capabilities of the underlying platform. And so the two things to sort of keep in mind in this category, um one, you know, because it's not a black box, uh Pulumi will give you visibility and access into all the individual resources. Um And so it's not trying to like some of these tools like uh Doctor Composer services hide the underlying abstraction. Um Pulumi really is trying to give you visibility into all of the actual resources that you're managing even while it's giving you access to some higher level components uh to use to put those things together. Um And so that, that is a difference in something that um that some folks find is actually um really helpful for them understanding how their applications are gonna work. Uh The second one is uh that um whereas with, with many of these tools um sort of they separate the notions of the application code and the infrastructure code. So the description of how to uh deploy the infrastructure lives in a separate file from the description of the actual application code itself. And they typically versioned on a different uh cadence and that's certainly possible with Pulumi but Pulumi because it sort of unifies these two worlds, um also gives you options to actually combine the way that you deploy application code and infrastructure code. Um even uh when targeting kind of real production kind of systems. And so that is something we often find, especially with kind of folks who are um thinking about how they structure their kind of modern uh cloud development teams. Uh More and more. So the application authors have dedicated infrastructure as part of that application, that version is really uh really 1 to 1 with the application logic for that particular component. So maybe they have a dynamo DB table that's specific to that application or they have uh a reddish cache that gets deployed specific to that application component or that service. Um And so in all these cases, they want to actually as well as deploying their code, they want to deploy updates potentially to uh their infrastructure. And so those things uh benefit from being version uh together, let me show really two quick examples of of kind of these style of things where we're moving from some other very high level description um into Pulumi. Um And I'll show you two examples, one kind of looking at darker compose and one looking at uh serve. OK. So I'll close this guy down and I'll open up a darker composed file. And this darker composed file is um uh in the, you know, darker composed tutorials. This is sort of one of the very first um examples they give uh for using darker compose and it just stands up two services. So it stands up a, a web service and a red service. Uh The web service is built from uh some local uh darker file uh And the reddest uh image is built uh from a uh a image on Docker hub for the Reddest alpine image. And so, uh the key thing for Pulumi is that um there's libraries that give us sort of a similarly high level view of how to describe and deploy containers. Uh but that do it on top of existing raw infrastructure. So, whereas this composed file really can be used just to deploy um uh locally uh with, with Pulumi, we can get that same kind of productive benefit of, of this kind of level of description. Um but we can apply it to um uh to real infrastructure running on AWS, for example. And so I have here, I'm using the cloud library um this cloud aws, which is a library that has a bunch of kind of convenient things built on top of all the underlying A BS resources. So in this case, I'll say, you know, let's uh web equals new cloud dot service. Um So just like we have services here, we have a uh a component called cloud dot service. Um And I'll, I'll call this one web and I'll provide some parameters. And so the core most important parameters has is a set of containers and so we can have multiple containers per um uh per service. Um But uh each one of those containers has the same sorts of options. So I can say build dot And I can say ports and this port is going to be a port 5000. Um And so similar kind of look to this um a few more lines of code. In this case, we're actually right now working on a change to allow you to, if you only have one container, just write it like this, which is even more similar to that. Um But even with this still very simple, high level way of describing, hey, I want this container built from this local docker file to be deployed into a service that is available on the internet. And then I can write the second one, I can say let read a Sequels, new cloud dot service and again, containers lettuce. In this case, instead of me building it, I'm gonna say um help, I'm gonna use an image uh instead of a build um so that I get it from Docker hub and so very similar kind of thing to what you see on the left. Um But here, uh the key thing is that these cloud up services are actually going to be deployed um into my target environment, which in this case is uh aws. And so these will actually stand up all the resources they need in uh in Aws, they'll stand up um some fargate tasks using the uh server, this container uh offering from a W they'll stand up a load bouncer in front of this port so that you can have access to it. Um If you want to specify that there's some number of replicas, um you know, they'll stand up that many replicas of the underlying service. And then for this uh example, that does a build. Uh whereas in Docker compose, I can only use build when I'm working locally in Pulumi, I can actually use build, even when I'm working uh with something that's deployed into aws and they can do that because we'll actually run the darker build locally on the machine. And then we'll push that up into a private repository that we've allocated for this service in uh in AWS. Uh And so all of that is just managed automatically as part of this cloud dot service. And, but it gives you again the very high level and simple way of kind of um of, of describing these things. The one other thing is that because we have kind of the full capabilities of the platform of the sort of a language and the ability to sort of integrate things using code. We can also take advantage of things like if I want to publish out the endpoint that this is available at. So the HDP URL where this website will be um will be available, I can say, you know, web URL and I can say something like uh web dot default endpoint and this default end point actually has a bunch of details on it. So what I want to do is um go and produce a string that has the exact format I want. And this is where it's useful to be able to use the full capabilities of javascript. So I can compose together HTP colon slash slash. I can say the host name of the endpoint, I can do colon and I can do the port of the endpoint. And so there we go. Now I can actually publish out to, to people who deploy this application that the web URL that I can access to set is running on this host name at this port uh and on this HDP um uh uh scheme. And so, so that's kind of the handy thing we can do because we have a language but we could also do uh anything else we want to, you know, pass outputs from this red image in this environment, variables on the web container. Um A lot of different things we can do because we're managing this um as infrastructure. But using the high level uh features of um of this describe the. Um OK, so that, that's sort of an example of, of Docker compose. Um Let me show uh one last example here. Um Well, actually, let me just show it in the uh examples we've run. This is one that I've kind of talked about um several times uh in the past, probably if you've watched these. Um And this is this uh this thumb nailer. Um And so this is an example that uses um kind of uh the surplus framework. Um It was based on a blog post um that talks about how to sort of build a serve application using serves framework and far. Um And so this example, you know, we have a um a video that can be uploaded into a bucket that can fire off a Lambda function. Uh And that will itself run a long running fargate task which when it completes will write AJ peg into a bucket with a key frame. Um And then fire off another lamb event. And so this is this kind of example, where we have a very high level description of our system, we want to sort of turn that high level description into uh into code. Um I'll show kind of very briefly kind of what that looks like um in uh uh in the circles framework example. Um we can see there's, there's several things in here, you know, set up some um some environment variables and, and uh im roles. Um But you can see, for example, the interesting part of this is sort of these two functions, right? And so we have this sort of very high level declarative kind of notion of uh I've got two functions, trigger on upload video and trigger on thumbnail CRE those two different uh lambda we saw in that diagram. Uh And, you know, they, they kind of have this very, very specific format here for how I can hook up the events and say this is S3 and hook it up to a particular bucket. Uh But of course, I have to sort of allocated that bucket out of band um that's not created as part of uh as part of this application. Um And then I have to sort of manage a bunch of these inputs and configuration manually through this system. One of the things we can do uh with, with Pulumi is we can sort of turn that all into, into code and get some of the same high level benefits of, of thinking about things just as event handlers and not having to deal with all the raw underlying resources. Um But with the flexibility to also integrate in all the other pieces of the application, like managing the raw infrastructure, creating that bucket inside the program itself, uh managing the uh Fargate task inside the same program. Um And so here, we've, uh we've created a uh a task to go and run this dockerized thumbnail extraction. Um But then ultimately uh to do the same sorts of things where I say bucket dot input uh and then key suffix JPEG. So the similar kind of thing to hook that up in a very high level way with the added benefit that now I can describe the contents of those functions actually in line here because in this case, and in many cases, the contents of those functions is actually very small. Um So in general, you can see this notion that if you have some existing kind of serverless application, and you're looking at one of these sorts of blocks like functions, we have a library called Alula which provides uh pretty much 1 to 1 things for all the different event sources you might want to use. So if you're using an S3 event source, if you're using a dynamodb streams, event source, if you're using an API gateway and event source, all of those cases, we have this uh Pulumi, a Urus library, which is a kind of 1 to 1 way to map these uh into Pulumi as well. So, ok, that was a quick tour of kind of some of the paths we've seen kind of folks taking migrating into Pulumi from various other sort of technologies for managing cloud resources. Um The couple of key things I'd sort of summarize with one. it's very easy to migrate into Pulumi, just some one particular piece of an application or just dip your toes in. Um You can, you can always reference existing resources managed by existing other systems, whether it's cloud formation or serverless framework or, or terraform or anything. Um And so uh it's very easy to get started and try out uh Pulumi inside um sort of an existing application. The, the second thing is uh you know, the general benefits of kind of providing a continuum between these um is that you can, you can kind of mix and match wherever you wanna be at a higher level, it's more productive. You can be whenever you want to be at a lower level where you have access to all the details of vendor and platforms, uh you can do that as well. Um It's that combination is really the thing that um that uh differentiates Pulumi from many different uh offerings here. And then finally, um really treating your infrastructure as software, not just as text um is, is uh is really valuable getting type checking, getting completion list, getting all these sorts of features. Um that is just brings the uh level of robustness of the software engineering practices uh up to a kind of a different level. Um And that's, that's a key feature that um we, we hope we can bring into many of these other domains as well. Um So with that, I'll kind of wrap up for today. Um uh You can reach out to us uh at uh any of these uh locations either on Twitter or on our Slack Channel um on github, um or drop us a note here on the Pulumi TV, youtube channel. Uh You can get started with Pulumi at HPS Pulumi dot IO uh where you can download the cli and um and start deploying applications with Pulumi right away. Uh Thanks a lot for joining us uh today. Um If you have any uh uh thoughts for topics we should cover in coming weeks. Uh Feel free to drop me a note uh on any of those places uh I mentioned before. Um See you again next week. Thanks a lot.

---
