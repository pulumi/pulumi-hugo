---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Cloud Engineering Summit 2020: Towards Application Driven Infrastructure"
title: "Cloud Engineering Summit 2020: Towards Application..."
meta_desc: |
    The evolution of infrastructure tooling is reaching the point where we can move beyond automatically provisioning infrastructure from static defini...
url_slug: cloud-engineering-summit-2020-towards-application-driven-infrastructure
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Cloud Engineering Summit 2020: Towards Application Driven Infrastructure"
  description: |
    The evolution of infrastructure tooling is reaching the point where we can move beyond automatically provisioning infrastructure from static definitions, to dynamically generating infrastructure to fulfill the requirements of the applications that run on it.  This talk describes the evolution of infrastructure as code from scripting to current mainstream tooling like Terraform and CloudFormation, which use declarative languages that specify infrastructure at a granular level.  We’ll then step up to application driven infrastructure as a strategy for planning and implementing cloud infrastructure as a part of system modernization. Rather than designing infrastructure in isolation, map the infrastructure requirements for applications and design infrastructure accordingly.  Modern infrastructure technology can implement dynamic infrastructure provisioning systems that automatically generate infrastructure from application requirement descriptors. This aligns with Cloud Native software, but can help with organizations that aren’t able to rewrite their entire codebase to make it containerized, clusterized, service-meshed, and fully hipsterized.
  sortable_date: 2020-11-11T00:30:02Z
  youtube_url: https://www.youtube.com/embed/cERWR9sLSS8
transcript: |
    Hi, thanks for joining me to talk about towards application driven infrastructure. So what I mean by, by this title is I wanna have a look at a quick look through kind of the history of, of infrastructure as code um where it's come from and particularly in relation to some of the the kind of trends and things that I think are, are relevant to where we're going. So we can talk a little bit about where are we now in terms of infrastructure um technology and, and, and kind of tools and, and, and languages and so on for defining infrastructure right now. Um And then where does this give us the opportunity to go to? Which I think is an interesting bit and that's kind of what I, what I mean as in, in the title about Application Driven Infrastructure is I think that the trend um is is now towards giving us the ability to kind of take a more application oriented approach to how we design and build our infrastructure. So I think the important thing to keep in mind is that we're on a journey I think by, by keeping in mind, I mean, like generally a as we kind of work with infrastructure and work with the tools is just like these tools are not quite um and, and the ways of working I don't think are quite where they're going to end up. Um I think we still have a lot of lessons to learn. And then particularly one of my, my themes, my focuses is that uh I think we need to draw more on um practices and patterns and principles from, from software engineering and software design. And we need to work on how to apply these to how we manage and define our infrastructure when we're using code and, and languages. Because I don't think currently, I don't think we've, we've really fully um brought those in. I think there's a lot of lessons um that have been learned in the software world that we haven't really applied to infrastructure yet. So this is why I wrote the book Infrastructure is Code. The first edition came out about 4.5 years ago. The second edition is due out at the end of this year. Uh And, and so that, you know, again, the idea of this was to, was to um talk about ways and think about ways to use uh code in defining our infrastructure um based on design patterns and experiences of software delivery, particularly agile um ways of working and, and, and agile engineering and, and, you know, so things like test driven development and continuous delivery are AAA big part of um how I approach thinking about infrastructure is code. I'm uh I work at thought works. I've been at thought works for about 10 years. Um I'm the uh global Director of Infrastructure Engineering, which basically means um I work with teams um and, and clients kind of around the globe exploring ways of using cloud more effectively the ways of, of, of doing infrastructure um and running projects and, and again, these engineering practices. Um So I'm, I've kind, I've kind of drawing on a lot on, on what I've seen um from, from working with different teams and clients. So to go to a brief history of infrastructure uh code, it started out, we, we originally kind of focused on server configuration um as as what to do with code and scripting and so on because that's where, that's kind of where the action was, that's where we spent a lot of our time. Um And energy was on um you know, installing applications and upgrading applications and all kinds of things around on servers. Um And also as the easiest place to run code um uh you know, that, that you could use um to manage, manage things on the server. So that was kind of a natural thing to do. Whereas things like um say networking devices and storage devices and so on were a lot harder in, in the early days um to really apply code to and, and, and to do that effectively, but then kind of with the advent of cloud uh so started with virtualization and then particularly with cloud, when, when we started having API S that we could use to manage uh a, a broader uh part of our infrastructure, it meant we could, we could um our, our kind of focus shifted up. Um And this is where we started looking at how to define I say infrastructure stacks um of collections of, of networking and storage and compute, you know, combined together. How do we, we manage that as code? So that's been one kind of trend um in terms of the flow of, of infrastructures code um over the years. So kind of going and looking at particularly in servers, like what do we do in the early days uh with servers, we tended to write a lot of scripts, right? And these were imperative scripts, so kind of functional things like shell scripts, Pearl Python, whatever. Um And these tended not to be, this was before the term infrastructure as code was coined. Um And it was because we didn't really use these things in the kind of holistic and comprehensive way that we do these days with infrastructure code. Um what we did was more task oriented. So we might have a script that runs in a Cron job and reports on disk usage or we might have another script that we use that we can, we can run um to go and, and you know, and install some, some bit of software and, and, and put some configuration files in place. So it was very task oriented in those early days. And so then kind of in the early to mid, I guess the mid two thousands, around 2006 plus is when infrastructure is code as a thing kind of emerged. So actually CF engine was the first tool um that kind of implemented this approach and then it was done in the nineties. So Mark Burgess um you know, created this tool and really pioneered um the whole idea of infrastructure is code even before that name um emerged. And so it was in kind of 2006, 2009, that infrastructure is code devs cloud, like all of these things kind of emerged and they all kind of really complemented one another um to, to drive this. And so this is when we saw server oriented configuration tools like puppet chef, Answerable and Salt stack, these kind of emerged. Um And let us do this kind of thing uh more, more um you know, better basically. And the, the approach that these tools tended to take was that they were declarative. Um So they would kind of let you state like this is what I want to have in my system. So I wanna have this software package installed. I wanna have this service running on these ports. Maybe I wanna have some files in place and here's the permission. So it's very much, you know, what I want to have as opposed to how to do it. So those scripts that we used to write were very much step by step, do this, that and the other and then the other things, one of the other kind of characteristics of these tools uh was that they tended to use domain specific languages, DS LS. So they invented a new language that was very um stripped down to focus on again. You know, what are those concepts that you need to declare for a server to expose those as, as language concepts? Um And to, to not have very much else in there. Um And then the third um kind of characteristic of these types of tools and languages was that they were item potent. So you could run the tool over and over again. And the idea was that it was meant not just to carry out a task like installing a server, but also kind of keeping the server configuration in a known state to match what you've declared. Um And so a lot of these themes have kind of continued in, in tools since then, another kind of I guess branch uh in this evolution of, of managing servers has been immutable servers. Uh And so the idea of the immutable server is that when you, you want to make a change to the configuration on that server rather than running a tool which, which changes an existing server instance. Uh you know, it's not allowed to do that. Or, you know, you, you don't do that as a practice. Instead, you apply the configuration change to a new server and you remove the old one and you kind of swap them out. And this is just to kind of um the idea of this approach was uh is around consistency to say that we don't want to make changes to a running server. Um And you know, which, which could potentially have an error. Um Instead we want to be able to test it um before we, we kind of load traffic onto it. Um And so the, the kind of the the relationship with this to code, there's, there's a couple of aspects to it. One is um that kind of simplifies, potentially simplifies the kind of code that you use. So those declarative tools, the, the, you know, puppet and chef and those types of tools tended to focus on where they were written for the case where we're not really sure what the starting state of the server is. When we run this tool, it might be a fresh server with a certain version of an operating system on it or it might be a been a, a server that's been running for a while, uh which may have had, you know, an unknown previous version of the, the, the code applied to it. Uh And so the the the tool is designed to kind of handle a slightly complex scenario which when you create immutable servers isn't necessarily as complex. Um And particularly the one of the kind of um big use cases for these kind of servers is more simplified cases like creating um docker hosting nodes for for a Cober based cluster, right? And, and in these cases, because the server is is very much simplified, you know, so, you know, you can start with a very basic operating system installed do or maybe a couple of agents and, and you don't need to do too much more. Um And from a known starting state having like a AAA set of simple scripts um to install the different different aspects and configure the different aspects is actually more practical. So it kind of simplifies the the configuration task. I think one of the big influences of this, this mindset of immu immutable servers has come with uh containers where we're creating a very stripped down and simple server. Um and a server image, you, you focus on creating the image and you don't really within a Docker instance, for instance, um you don't tend to make changes to the configuration within that running image or instance. Instead you create a new image, new version and you kind of push that out. Um And so this is the kind of immutable idea is, is kind of lives on, on that level. So I think a little bit about how um infrastructure stacks have evolved. So again, we started out with writing imperative scripts. So we wrote them in things like Python with maybe the boto library um Ruby and the fog and so on. So you would basically write a procedural script. Um You would use a library which lets you interface with the API of the cloud or infrastructure platform and then you would write the logic of how, as well as what. Um so, you know, this was where you would have to write the logic to say, um you know, for instance, if I'm running a script to, to, to for a server, is it gonna create a new server every time I run it? Or what if I have an existing server that I want to change? Is that scripts gonna know, do I have to implement loic in there? Um to decide, you know, what to do, whether to change an existing server and how to handle those different cases. Um So there's a fair bit of kind of things that you needed to do in that script and it wasn't that hard to understand by looking um at, at your code. Uh you know, what was a thing versus how you're creating it? And so there came the kind of um uh the tools like terraform was the first one of these tools that I, you know, that I came across and started using, which was similar to what happened with the tools like uh puppet and chef back in the day for server configuration. You know, these were tools which um abstracted out, um you know, split out the, the defining what you wanna have in your infrastructure and then letting the tool manage how to make that happen. So again, you would have a declarative language, usually a DS L um and that language would, you would use that to express here's what I want my server to look like. Here's what I want my networking to look like, apply it and then let the tool work out. Um you know, whether to create a new one or change an existing one, how to handle error scenarios and, and waiting for things to, to, to provision and, and all that kind of stuff. This is a big step forward and and has been kind of where the kind of mainstream I think of infrastructure um coding has been up until now, there's been another branch in, in all of this, which is the kind of containers um the, you know, the kind of cloud native world. And so this is the idea that um we can focus on our applications, right? Which is as, as you know, a really valuable thing to do. So it's the idea that, you know, we, we, we build our applications packaged up in a way that we don't really care much, don't need to care too much about what the infrastructure is. That's kind of um abstracted for us. The important thing is the infrastructure still exists. Even with serverless, you still have servers and you uh you know, underneath they're hidden away from you. Um And you probably have other infrastructure that you require things like, you know, networking. So if you're gonna have requests coming in to trigger your serverless code, I'm talking about function as a service here um or like maybe some storage to, to, to, to store and read data, uh message buses and those kind of things. So there tends to still be some infrastructure that you need to configure. But the nice thing is that you've got a nice kind of um contract, a nice kind of like um you know, division between those so that it simplifies writing and packaging applications and then it also kind of simplifies how you kind of build um the infrastructure and platforms underneath because you don't need to worry so much about what versions of say, runtime executables for like Java or Ruby or whatever. You know, that's kind of, you know, that, that that's been kind of separated. Those concerns have been nicely separated. People often ask me about with this world with cloud native. Do we not need to worry about infrastructure as code anymore? Is that no longer a thing? And I think as I mentioned because you, you still need to provision some things or somebody needs to provision some things like who creates that Cober cluster and, and then, you know, who manages that? We tend to still do that using some form of, of code um at some level, even if we're using a, a cluster provided by a cloud provider, like a kseks one of those kind of things or whether we're kind of using a package to, to install the the the cluster onto the onto servers that we've created, we still have work to do. We probably still do define that um as code. And so that's where my focus tends to be when I, when I think about infrastructures code for these things. So where we're kind of at now uh with our sponsors, Pulumi um and other tools like cloud development kit. Um There's kind of a new paradigm um which is writing our infrastructure as software. But the idea here in a way it kind of looks like we're going back to, oh we're writing a procedural code um in an imperative language um to define our infrastructure. And so our code maybe has to do a little bit more of the how things happen. But I think this generation of tools um are a bit different in that they, they provide a lot more of the basics um under the covers. Um so that you still focus a bit more on what you want and they also bring some new things to the table, which is the idea to um define and provision and create infrastructure dynamically, which is where I think some, some cool opportunities come from. The question is, is this the end of the declarative infrastructure like, is, is it all gonna be, you know, these kind of tools? Now we're gonna go back to using general purpose languages. Um You know, we're gonna use typescript or javascript or what have you uh to write our infrastructure code and we're gonna do it procedurally rather than, than declarative. And I think the answer is actually there's different tools for different jobs. So one of the kind of threads when, when um people I know. So at, at thought works, you know, we're very much development and application development, um oriented organization. So uh you know, I work with a lot of developers who just, you know, they're really gung ho on the idea of having a real programming language for their infrastructure. Um And when we look at cases where, you know, it, it's very easy to find um infrastructure code that is just absolutely horrific, right? It's like it, especially when you're doing things that they're using, uh whether it's a declarative um DS L like HCL that terraform uses or whether it's like YAML or Jason or some kind of thing which, which, you know, a toolmaker has kind of crammed in mechanisms to, to make it programmable. So you have loops and conditionals and stuff in these kind of uh markup languages um And that just, you know, it, it, it creates a big mess, right? So I think there are problems with that, but I think a lot of the problems we have with infrastructure code today is that we mix concerns. Um So we're doing multiple things in a single language, a single to a single, you know, bit of code. Um and it kind of doesn't matter which type of language you use or even which language you use. Um It's gonna be a mess no matter what. Um So to kind of give an example, there's a couple of different concerns and let's talk about concerns different things that you tend to need to do in your infrastructure code base, your infrastructure project um that are, are, are, you know, maybe need to be addressed differently, right? So one is defining the shape of an environment. This is where you write some code that says, you know, my environment or a part of my environment has, you know, these web servers, this is what the web servers look like and how you know how they're built, uh maybe some host nodes running docker instances, database nodes and here's the networking structures around them, right? So you kind of um defining what the environment looks like, but then you also wanna have multiple instances of this shape perhaps, right? So this is if you create the environment or, or or a stack or what have you that creates the infrastructure to, to run an application. Um You, you gonna, you want to reuse that in multiple environments for DEV test um and so on into production so that it's built the same way in each of those environments. Um But then if you're gonna do that, you need to have some differences between those environments, right? So if you have like a cluster of servers, you're not probably gonna have as many, you know, as big a cluster um in your non production environments as you have in production. Um And so you need to be able to configure um aspects of these. And I think where we often go wrong with infrastructures code is when we embed that into the same code. So you have a code which says here's my my application server cluster. Um And here's the, you know, the base image used to create it, here's the networking structure, load balance and all these things. And by the way, here's the code which needs to work out how many um you know, nodes to have in my cluster um based on, on certain things, you know which environment. So and so that's where you start taking code, which declares a thing and then you start having some logic and and cramming it into that same code and that's where you get the mess. It's one of the reasons why you get the mess. I'll talk about another of the, the kind of main cases in a moment. So where I think we're going, what I think we can do is, is have some different kind of models for how we structure infrastructure projects. Um And I think they're different based on teams. So I've seen some different kind of organizations and different teams um who approach these in different ways and it tends to depend on what they're doing and, and, and who their people are. So the kind of first um um model is with what most kind of terraform um and cloud formation and similar projects are, which is what I'm calling a low level stack definition. And the point here is that those languages um they directly expose the low level concepts uh from your infrastructure platform. Essentially the API, you're essentially a wrapper over the API to let you declare different things that, that um you know, the the cloud vendors API uh lets you define, right. Um And so when you write, uh when you define an environment with this kind of language, um you're really going into the details of like, OK, what are the networking routes, routing tables, you know, um permission things, you know, it, it, it's very fine grained. Um And it also tends to be. Um So this kind of project is, is where you're defining an environment. So the end environment that you want, you're using, you know, you, you're assembling those low level um elements together to create that project. So it's very kind of thin um as well. Um And so I think that the kind of use case for this is when you have infrastructures who are the ones building the environments. So when you have people who understand infrastructure concepts really well, um and they want to get down into that level of, of, of detail to be able to map things out. Um That's, you know, this is the tool for them, right? These kinds of tools are the tools for them, the ones that do the Declarative um stacks. And I think another benefit of those tools that Declarative language and the DS L um is that for them, it really simplifies, they don't need to, to know too much or think too much about how to write software, how to, how to do um you know, software design so much and, and code design it, it really is just kind of stripped down, it simplifies like just define this piece of infrastructure, this piece of infrastructure, the connection between the two and that's it, right? And so a another kind of characteristics of these kind of projects when it's this is the appropriate model um is when the the environments you're defining or the the the the stacks parts of the environment that you're defining are tend to be pretty static, they're not gonna vary very much, maybe in terms of some parameters, maybe you're gonna inject in parameters that specify things like that cluster size. Um that I talked about before. Um But it's not gonna really vary very much what kind of um infrastructure elements it's gonna create or, or too much details of how they're gonna be configured. It's fairly static. So then another model, it's a higher level um stat definition. Um And so this is where you're, you're kind of defining um the more of a uh a kind of a, a domain concept and entity, right? So I think about it, say an application um hosting, right? I have an application, I want to deploy it on some infrastructure. Um I'll define the things that I need for my application. So, you know, I need to, you know, um you know, I might need a, a virtual machine. Um I'm gonna tell you what kind of operating system, uh you know, maybe I'm running on Linux or I run on windows, right? Um How much memory do I need? Um maybe some, some details on the traffic uh like how you know where our request is gonna come into. So, and then, so you, you're defining that at the high level and then underneath are the components which dynamically create the the infrastructure uh accordingly, right? So this is obviously uh where the, you know, tools like Pulumi come in um that let you kind of write that intermediate layer. So I think the kind of the way that you know, the usage of this, this kind of model is uh where you have application developers who need infrastructure. Um and, and, and a, they may not have the expertise in their teams because, you know, if you have like a whole bunch of, of application teams, not every team is gonna have very deep infrastructure uh knowledge embedded into it. And P is kind of not their focus, right? I mean, developers tend to like platforms like HIRO or so on where they can write their code and push it in and they don't need to, to really get bogged down um into what's going on and, and configuring um you know, the, the the infrastructure at a low level. So it's a convenience for them to be able to focus on what they need to focus on. Um And so I think this kind of model will appeal um to those types of users. And then I think underneath that you're gonna have those infrastructure libraries, um components frameworks, what have you um built by, by specialists. And from what I've seen, the teams that end up doing this type of work tend to be uh kind of a mix um of uh so a bit of infrastructure domain expertise. So going back to that, that previous model, we had infrastructure experts defining um you know, environments. Now, you've got infrastructure experts probably working within these teams who are helping um you know, in how to, to pull together those different infrastructure elements. So they're looking at that you know the, the, the, the code that this team has, these teams have are um you know, working out what kind of infrastructure elements to assemble and how to assemble it. So they, they, they know how to do that very well. And these teams probably also have uh they tend to have software development um knowledge uh within them. So people who are really comfortable with, with, you know, programming languages and the tools and, and how to test and all that. So these teams and tend to blend these expertise, you have some individuals who are strong in both. Um We have some who come from maybe one side of the other and, and as they work together, they, they, they tend to kind of learn from each other and, and, and, and build up their knowledge, but it's this kind of combined um kind of thing. And so a note on this, right. So I think one of the pitfalls we've seen one of the, the kind of sources of, of, of terrible horrific infrastructure code that we've seen is trying to use uh declarative tools um to write modules. Um Right. And so this is where you say, OK, we, we, we created some different application servers, they tend to have some common code, we'll pull those out into like a terra phone module or a cloud kind of um uh you know, template that we can reuse across other projects. And that model is, is very limited, right? Because you're writing those modules and again, uh a, a non, you know, in a, in a declarative language rather than um an, an imperative language. Uh And so if those modules are just reusing code, if it really is a static thing of like, OK, here's a bit of code that, that creates a server that's pretty much the same every time um that works out. All right, because it's a, it's a declarative thing essentially inside that module. But when you start trying to make that dynamic and say, well, let's create the networking depending on different things. Is it traffic coming from public versus internal? Maybe, maybe we have some different policies, maybe we need to dynamically generate um you know, um security roles or what have you. It's when you're having to dynamically generate those things to handle different use cases that the declarative code just really, you know, it doesn't handle it well. And, and, and when you see modules declarative modules that try to do this thing to try to create, let's say an abstraction layer for other people to define infrastructure, it just doesn't work, right? It's just a, it's just a, a poor way of doing it. And so that's, I think another one of the big cases I mentioned mixing concerns is the reason why um uh you know, code gets really nasty, infrastructure code gets nasty and people want to go and, and use a real language Um I think this is one of the other big cases where people are trying to do something more dynamic and create libraries and frameworks um and abstraction layers um that it's a real push to, you know, you really do need a real language for that and an imperative language and, and ideally a general purpose language with a good ecosystem of support. Right. So I think this is kind of one of the the strengths here, there's a third model I'll talk about which is where you have kind of specialized requirements uh right. And so one of the pitfalls of when you have um teams having to use um uh libraries and frameworks and abstraction layers um for building their infrastructure is that in some cases that might not meet their needs, right? So it tends to kind of limit what you can do and in some ways that can be a good thing where it's like, you know, you, you, you wanna kind of simplify what people can do and also make sure that it's, you know, everything is built really, you know, properly according to your kind of policies and, and, and good design and good, good opera operability and those kind of things. But sometimes you get teams who have or who have more of an edge case um and need to do something different. So an example of that, that I've seen um is teams working on say machine learning. Um So you have like this kind of like abstraction layer that's in place or a platform that um is, is really good at, you know, it, it's focused on, on say application servers for, you know, Java and, and, and dot net or whatever kind of um application stacks, doing kind of web things and, and, and services, restful things and so on. And then you've got a team who's trying to do kind of machine learning stuff and they're using weird tools, they have weird requirements from, you know, to run them on and, and maybe using some unusual services from the cloud provider. Uh And so these are cases where um you, you know, you need to kind of have the options for people to kind of um do things a little bit outside, right? And so there's, there's a couple of ways this can go and you would tend to have, you tend to have in those teams with the developers, you tend to have people who do have some infrastructure knowledge or you tend to need to bring people with infrastructure knowledge and to support these teams a little bit more closely. Um And so how they can do that is, is in two ways. So in some cases, these teams will go and use that kind of static uh declarative type language, the low level kind of um tool like terraform and cloud formation. Um because it gives them the level of control they need to do their thing. Um in other cases, it might be that um actually there's that, you know, rich enough kind of set of libraries and things around um from a more kind of dynamic library of infrastructure code um that we can use for, you know, this team can use for, for a lot of what they do and then they maybe they need to just write some, some code um for their specific um you know, things that that doesn't cover. And so like they write dynamic code for that, right? Um And maybe they write libraries and of, of components that can then be reused. And I think what will be interesting over the next few years as, as these things all gain more traction is to see what the kind of um I guess market of, of, of shared kind of reusable components and frameworks and so on uh emerge. Um whether it's open source components or commercial or, or some kind of a mixture, I think we'll start to see a lot more of those. And so you'll have a lot more options to draw on things maybe for your domain. So maybe um uh you know, frameworks that are tailored to some of the requirements of, of say financial services, you know, uh you know, things that are set up to help you with compliance with regulations and those kind of things. So I think that'll be an interesting space to watch. And I think this comes to just this idea of application driven infrastructure, right? And so, um again, this is kind of what I talked about with that high level um stack uh project model um but applied potentially at a higher level, right? So it's it, you, you know, you might define what your application needs. Um So in this case, we've got a service which is a product browser for our online store. Um And it's gonna have requests coming in from the public. So directly from end users, um you know, it needs a database and so we define a little bit of information about what that is. It needs a run time. I mean, it runs on application servers, job application servers. And so as similarly, you know, so we, we declare all that stuff and then the layer underneath then can work out. Hey, do I need to provision stuff? Maybe it needs to dynamically provision um some specific components. So maybe it's gonna provision on my SQL um you know, database cluster um for this application um or maybe it's gonna be use uh in, in existing infrastructure. So maybe there's a shared networking that's already out there um created by a common stack or maybe I say a Cobert is cluster or what have you created by another stack. Um And so then this, what what this will happen when this kind of um um definition, the specification gets read is it'll allocate OK. I'm gonna, you know, grab you some space on that cluster or, or what have you and make it work. But again, this is creating, you know, the idea that you can think first about the application, what its requirements are and the infrastructure can be generated to satisfy those requirements. And so they this is this is kind of a cloud native is right, this is kind of the idea of cloud native is that you just you, you, you know, we we have some kind of emerging standards, things like um the open application model. Um and, and you know, things along those lines which are, are saying, you know, here's ways and frameworks and, and, and specifications for, for doing that for saying what your application needs and then creating infrastructure underneath I and I, I think this is good, right? It's a valuable thing, it's a really useful approach um for new applications. Um it tends to work well, I think that the the issue is that when people talk about cloud native, there's the concept um which is kind of generic, it's not really implement implementation specific. But then in practice, when most people talk about cloud native, they're really talking about containers, container clusters and service meshes. And they're even really talking about a lot for a lot of people when they say cloud native, they think oh Kubernetes, right? It's KTIS in Docker and maybe AC O. And so it's, it's kind of a fairly um I would say narrow um that's a bit unfair but it's like, it's, you know, it's a certain kind of um architecture um which is fine if your applications can fit into that architecture or if you're building new applications for that, that would be my kind of um uh that's generally my advice, you know, when, when, when building new things is to, to, to target this kind of a, of a platform because this is the kind of this is where things are going. But a lot of the clients that I work with at thought works are, you know, they've been around for, for, in some cases decades. Uh they've got a lot of stuff, right? And they can't, it's not all gonna fit into containers or run on Kubernetes um or it's gonna need to be ported and, and it, it's not always trivial, right? And so you kind of need, um you know, it'd be nice to have a way to satisfy the needs of, of, of, you know, existing applications um and to kind of help that, that kind of pathway. And so this is where I think when I talk about application driven infrastructure, I'm kind of thinking that we need to go broader than purely the cloud native, the kind of Kubernetes based things and, and create the ability to generate, you know, so we have that specification, that specification for an application and what infrastructure it requires, we should be able to support the idea that there those requirements might be uh virtual machines that might be static networking structures rather than kind of service mesh. Um It might even be bare metal and we might need to have, you know, a tool uh like crowbar or something go and provision um you know, a server on a rack um in order to, to, to make it ready for this particular application, right? So I think um we can use this is kind of the the value of the the dynamic infrastructure um programming tools like Pulumi is that it opens up the possibility to do this kind of thing. And I think a critical thing that we need to do to make this all work is we need to get better at infrastructure design. We need to get better at drawing on lessons from the software engineering and software design world and applying those to our infrastructure. And for me, the fundamental thing and in the book, um you know, this is, this is like it runs throughout the book that I'm constantly talking about. We need to build our, our system so that they're easy to change. I think one of the pitfalls we fall into with infrastructure is to kind of think of it as something that's not really gonna change. We're gonna build an environment, we're gonna build a cluster, we're gonna build the thing and then we're done with it, right? So when um you know, I talked to people about, well, you know, how are we gonna deliver changes to this? Should we make pipelines? Should we have some automated tests for this? It's often dismissed. People often dismiss it and say, well, we're not gonna need to do that stuff. We don't need to have tests for our infrastructure, like automated tests for our infrastructure because it's built, we test it and, and we're done. And then what you find is that actually teams who manage infrastructure, spend a lot of time on, on things that are changes, even if they're not thinking about them that way. So they're rolling out patches, they're making fixes, they're making improvements, they're upgrading, you know, elements of the, of the system. Um and this is constant and I think when you look at what happens in many organizations where the infrastructure uh function and, and, and capacity is seen as a real bottleneck. And a lot of times people wanna move organizations want to move to the cloud because they're saying, well, you know, we just can't get the environments we need, we can't get enough. Uh We're on really old versions of, of core software like operating systems and databases and application servers. We're just not able to keep up. And it's because in our infrastructure world, we haven't really um built it in a way that that change is a routine thing. We, we still view change as an exception. And so that is something that we need to kind of get over. Right. And so the, the important thing is to make sure that we know we were able to change our infrastructure rapidly, we can make frequent and, and quick changes. Um, and that we can do them reliably and safely and repeatedly. And these two things complement each other. Um They're not in, they're not things that we have to choose between, but actually the, the faster you can make changes to infrastructure, the more reliable you can make it, you know, the better the quality, you can remove technical debt. You can, you can, you can improve it more rapidly, then the better the quality that you build into your system, the easier it is to make changes. So these are really important things and why I really tend to emphasize things like testing um as a part of an infrastructure as code uh kind of ways of working. And then another thing we need to do to get into the design issue is it's about making smaller units of change. Um So I was um with an organization a while back uh which had a, a large um set of infrastructure that they managed in tariff form. And it was, it, it had grown so large that it took when running terraform apply, took anywhere from an hour to two hours. Um And so it was a very big, you know, terraform project all in a single state file. And so when we talked about when they were first started looking at, well, how do we uh make this more manageable? Um you know, their answer was modules, right? Let's break our infrastructure, uh you know, a terraform project into modules and that will make it better organized and easier to change. Um I think the issue there is that those things like modules and, and other kind of components for, you know, for that you use to assemble and, and, and create a stack um are make a smaller unit of change for the code at the code levels. OK? My, my code is now in a, in a smaller project that I can define and manage in version and even test, which is great. Um But it doesn't change the unit of delivery because the unit delivery is still that massive stack that takes an hour or two to apply. Um And so the fact that you're pulling a bunch of modules together um and that you're still applying them in one go uh with one state file and so on. So really the path um is to split things apart and treat stacks as components of the overall environment. Um And so this is where you have multiple projects um stacks, what have you um that have to integrate together. And so then this is where design comes in because what often happens again in these cases is where people say, OK, you know, um I've got my stack that defines this part of the, the environment. But in order to test that stack, um I've got to create a whole bunch of other stacks. I've gotta create all the rest of the stuff because it of the dependencies on there. So we need to make sure that each stack is independently deliverable. And this is where I use a pipeline. I use a pipeline to say that for each um infrastructure project, each stack project um I can spin up and test an instance of that on its own without the other other things around. Um To make sure, hey, this part of part of the reason for doing that is to make sure that it's correct. Um But stacks tend not to be that have that much variation. So it doesn't tend to need like loads of, of test coverage. It's more kind of a sanity check. But a really important thing is just to prove that yes, I can create an instance of this stack on its own because it forces the design, it forces loose coupling. And so this is the key thing here. Um And one of the things that I think we need to get better at with infrastructure um is saying that um you know, how do I make my my stack um you know, compos and more loosely coupled to where I can bring it up. So let's say I have an application server infrastructure, build an application server. Um And, and maybe just like, you know, um um some networking around that, but I've got to deploy that into shared networking VPC S and sub nets and all that kind of stuff. So I depend on that, right? How can I test my application server stack project without also having to create the full networking stack? Uh You know, from another stack project in order to do that, how can I make that loosely coupled? Um And so there's a few things to do. One is to avoid um in integration into other stacks that is, is, is is deeply integrated. So you have things like the the log demeter which says like my code and my stack shouldn't know the details of what you're providing in your infrastructure stack, right in your network, say your shared networking stack. Um And so this is where I'm I'm really um I really dislike this whole thing of integrating a stack by, by um looking at another stack's remote state, for example, because you're basically integrating at the data level. This is what so in the application development world, uh people used to do this uh with applications where you have my application needs to integrate with, with your application. Um So I'm gonna go and connect to your database and I'm gonna look at your database schema and, and integrate at that level. And then that means that it's very difficult for your application to change um Its database schema uh without breaking my application. So that creates AAA couple of the database and in the software world, we've learned that's not a good thing, right? We've learned to kind of stop doing that and to kind of identify that as a, as a problem as an anti pattern. Uh in the infrastructure world. There's still a lot of people recommending go ahead and integrate your stack with somebody else's stack at the level of of you know, the state file data structures and so on. So what I think we need to do is to kind of abstract that out and say I'm gonna build my stack um so that it, it needs a parameter. So it needs a subnet to create my servers in. Um but I kind of don't care how you create that subnet, what you name them or anything. So you need something else to kind of like pull those together. And what that means is I can create rather than having to create an instance of the, the full share networking stack, which might have a lot of things in it. Um You know, to have a fully robust, you know, production, ready hosting and er you know, networking infrastructure. Um maybe to test my stack, I can just create a sub net and hook it into that and test it and I can use it like a fake, you know, when we have in the software testing where we have you know, um um fakes and mocks and these kind of things. So you can do that with infrastructure as well. Um If you really kind of think at it and work on it and this is one of those things that I think again, as an industry, we need to work towards um driving towards this, recognizing that we need to have better patterns for this and then implementing our tools and our ways of working to support that. So this is the kind of stuff that I've, I've, I've got in my book. Um So please do have a look at it. Um And, and, you know, preorder it or, or, you know, have a look at it when it comes out. Um And also you can reach me um on um on Twitter at Keif. Um And uh you know, thanks a lot for taking the time to, to, to listen to what I have to say and I hope we can have some good conversations around this. Thank you.

---
