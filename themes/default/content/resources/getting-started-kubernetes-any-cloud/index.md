---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Getting Started with Kubernetes on Any Cloud"
title: "Getting Started with Kubernetes on Any Cloud"
meta_desc: |
    Learn how to use Pulumi to set up Kubernetes, deploy YAML manifests, and access API resources with less boilerplate by exploring the Kubernetes and...
url_slug: getting-started-kubernetes-any-cloud
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Getting Started with Kubernetes on Any Cloud"
  description: |
    Learn how to use Pulumi to set up Kubernetes, deploy YAML manifests, and access API resources with less boilerplate by exploring the Kubernetes and KubernetesX SDKs. Pulumi Crosswalk for Kubernetes makes it easy to follow best practices for Kubernetes on any cloud, public or private.  Get started: https://www.pulumi.com/docs/guides/crosswalk/kubernetes/  Follow along with code examples: https://github.com/pulumi/pulumitv/tree/master/kubernetes/intro-to-kx  Pulumi is a modern infrastructure as code platform that works with your favorite languages and any cloud.
  sortable_date: 2020-04-13T21:58:35Z
  youtube_url: https://www.youtube.com/embed/KPwM_Xalh5g
transcript: |
    Hello and welcome to Pulumi TV. My name is Mike Metro. Pulumi is a modern infrastructure code tool that allows you to declarative describe your cloud infrastructure using real programming languages. Pulumi helps developers and operators work students together by helping to drive cloud adoption much faster. We support many languages such as javascript typescript, Python go and dot net across the major cloud of writers and Kubernetes. In this episode, we'll give an introduction into our latest Fck Verne's X. Let's begin in this episode, we'll cover three different usage scenarios where you can leverage Pulumi to work with Kubernetes. First, we'll use Pulumi to deploy standard Kubernetes. Ye manifest that any user of Cotis is accustomed to working with. Then we'll showcase how to use Pulumi Verne's SDK to deploy resources in the language of our choice. These are deployments and service and confit maps that you're probably used to working with. And then lastly, we'll showcase how to deploy the same resources using our Kubernetes XSDK, but using less code, less boiler plate standard defaults and just an overall improved authorship experience. Let's begin when working with Kubernetes, you're going to actually work with many different layers and stacks provider all the way up to the apps. As you can see the level of configuration that you can have is going to depend on how much infrastructure control you need to provision. But also manage, we offer many different sdks as noted on the left hand side that allow you to service each of these layers. For example, at the bottom, you can leverage the pluming Aws, GCP, Azure and aws xsdks to provision the standard I A components. You're used to working with like V MS virtual networks, im and registries using languages. Instead of YAML JSON or templating, we can use the same SDKS. If we move on up the stack to provision the managed control plane of our co at these clusters, then once we have a cluster up and running, we can leverage the Pulumi Kubernetes and Kubernetes xsdks to then configure and deploy the cluster services app services and the apps we wish to run in our Kubernetes clusters. Let's see how we can leverage some of these SDKS to work with communities. We're going to be deploying a demo app across the three us of scenarios we aligned in the previous slide. The details of the app need not matter. But what we are going to focus on is the resources and COTIS used to compose our app at the center. We have a container that's wrapped in a deployment. This deployment will have a config map attached to it for data, a secret attached to it for secret data, a volume for persistence and a service to expose this deployment outside to the world. We're going to review how we can deploy this demo app as a component resource which is a custom resource in Pulumi using the three different scenarios we outlined previously. Let's check out what that looks like in our editor here. We have a typical Pulumi program, we import the various SDKS using the language of our choice. In this case, it's typescript will create a provider in Kubernetes, which is simply just a wrapper around the Q config file and optionally a name space to work within. We'll take this provider and then we'll pass it on to our three different usage scenarios, deploying an application using a yellow Manifest, deploying the same application using Cobern resources and then deploying the same resources by using our cities XSDK. Let's see what it looks like to work with. Yo Manifest. Here. We have a, a component resource that we've created for our custom need. As you can see, we've called it demo app. So it's a new class that extends the Pulumi component resource. In this actual object. We will have a constructor some properties, a super call and then we can actually get into the nitty gritty of our details. In this case, since we're deploying a YAML manifest, we're going to actually leverage a sub resource in the SDK that we imported from Pulumi SDK using node in this case M PM. And that's going to point to a local file on our file system where the actual resources are described. Once we deploy this manifest, we'll then pull out some information to display its RL. Let's see what that manifest looks like. If you've worked with communities, this look, this should look familiar to you. You have a deployment of X that deploys the engine X image references, A config map references, a secret has ports, resources has volume mounts for a persistent volume claim that we also instantiate. Here. We describe the config map. Here. We describe the service that exposes this application using a public load balancer, the secret that will be mounted in and lastly the persistent volume claim that will mount a volume into our application. This should be standard for most folks who are work with communities and who have worked with the M NFS. So as you can see, we don't have to migrate our entire set of resources from YAML into typescript which we're using here if we don't want to. This allows you and gives you the opportunity to find some sort of uh halfway point between migrating between standard YAML manifest management and managing your resources through Pulumi in the language of your choice. Now, let's see what that looks like deploying the same application using our Pulumi KTIS SDK. Here we have a second demo app class but under the name space that we've identified in our program here using the Kates app from our local file that describes it in this app. What we have are similar properties. You have a config map, a secret, a persistent volume claim, a deployment that references the config map, secret and persistent volume, a service to expose it and then the URL which we're going to extract from it. As you can probably tell. This looks very familiar to the same standard deployment spec we're used to working with except we're doing this in typescript to compare look at the Gammel manifest we have before the deployment looks pretty similar. Here, we have it in YAML and here we have it in text script, pretty similar. Huh? This allows you to not only describe your resources using real languages, but because I have languages at my disposal, I have abilities that Yale and Jason and other languages that aren't full languages. Unfortunately don't employ. For example, I can reference the name of the persistent volume much like I would any object in any given programming language. I do that for my persistent volume claim. I do that for the secret. I did that for the config map, I can reference objects for labels that I've defined up here. I have the ability to have my ID E tell me when my spec is mismatched, it says that this property doesn't exist. I also have the ability to jump into the documentation for the properties of my choice. So languages at the gates offer a lot of benefits over Standard Yaml and Jason. And this deployment of this application is going to be the same semantic output as you would expect using the yellow manifest. But we're doing it natively in the language of our choice. Now, let's see how we can do that in the community's XSDK using a similar approach for reference in our Kubernetes SDK. The one we just showed, we approximately have 100 and six lines of code. As you can see languages are powerful, but they don't really reduce the amount of boiler plate needed. When you compare it to say Yaml in our KXSDK, we've gone from 100 and six lines of code of Kubernetes code in text script to just 61 lines of code. So to compare 100 and six lines of code, 61 lines of code, that's a reduction of uh just over 40% of code lines that we've removed from our actual source. And it just looks cleaner. We have the same config map, we have the same secrets, the same persistent volume claims. But now we've introduced a new concept of what's known as a pod builder that starts with a root object and builds around it. So we can define our set of containers that will be living in the pod. As such as you can see, we already have standard approaches to defining our environment variables and a key value approach. This is very different depending on where the environment source will be coming from in com communities. So just out of the gates being able to simplify environment definitions, for example, reduces several lines of code. Compared to see. In here, we have approximately uh about 20 lines of code just to define the environment variables. The same can be done through referencing a config map in a secret in a consumable way through this function or rather method that exposes the data in these objects as values sourced and ready for environments. We can take advantage of many different properties of the language to reduce the boiler plate and ultimately improve the authorship experience. We don't create any new nouns. We don't create any new resource methods or for that matter, revamp the spec at all. What we do is we reduce the boiler plate as much as possible while still giving you the option to drop back into the Pulumi community's SDK to have the full spec as you would expect it to be for config maps secrets, volumes, deployments, et cetera. So for some reason, the community's abstraction or rather helpers because that's what they really are. They're helpers. If they don't quite cut it for what you need to describe, you can always fall back to the raw Pulumi CS DK to get the full spec at your disposal for the resource that you're working with. For most cases though P Pulumi community SEK is actually quite powerful and the authorship experience is not only much more improved, it's easier to read, it's easier to digest and more so it's just easier to, to compose and stitch together properties. But the main thing to take away from this for X is that even though we're writing new code, depending on the, on the library that we're using, what, what's actually happening is we're producing the exact same semantic output type you would expect for a pod for a deployment for a service for a persistent volume claim, a secret and a config map. And the rest of the resources offered in cobre, we just leverage code encapsulation and the ability to abstract away the nitty gritty to improve the experience when you actually stitch these together. If we were to run the actual program, we are going to get three different deployments. One for deploying through the yellow manifest. A second one for deploying using the SSDK and one using the XSDK and all will be deploying the same application and exposing it to the internet. Let's pull up my browser to see what these us look like. There's X using the communities SDK, there's engine X using the communities XSDK. And then lastly, we have the ability to actually check out the one for Yaml. Great. I'll produce three running copies of engine X in the same semantic way. Each of these choices allows you to approach with Pulumi in the familiarity. And the level of intensity that you so require. There's tradeoffs to each approach. Yellow Manifest give you the benefit of migrating slowly to Pulumi if you've come from an environment that still actively works with Yellow Manifest, but still intrigued to actually leverage a resource such as Pulumi that has the power of pro programming languages behind it. The Pulumi SDK allows you to then use the full SDK capabilities around any language that you're supporting to deploy and manage resources in communities but doing it in a real language and then the community's SDK is an improvement on the pollees SDK to reduce the Bolar plate needed to work with resources and just overall improve stitching resources together. Last but not least I wanted to take this opportunity and showcase one preview feature that we've supported. And that is the option to leverage Pulumi to render and generate YAML manifest using the language of your choice. This is typically for folks who are still traditionally working with YAML, but want to use the power of a programming language to proactively and programmatically construct these resources other than leverage a templating engine. What does that look like? Let's make a couple of changes. As we noted earlier, a community's provider is simply a wrapper on AC file and obsolete a name space to work with a provider that allows you to generate YAML instead of deploying resources into a cluster like the SSDK and the SDK do. We're gonna change providers just slightly. So as an example, I'll do this with the X, I'm going to swap out the provider that we use here. So in this declaration, we created a new provider called the render provider, which will render YAML from the resources we've created directly onto a directory locally on this. We'll solve the provider. I just swapping these two out and let's rerun this just real quick. So now we're going to do a Pulumi update. And what we've done is we've pivoted the KX resources that we've described from deploying it into a cluster to then rendering YAML locally. So that way we can deploy it using say Q control if we want to use that approach. So what's going on here is that we're removing the data that was created. In this case, the resources that the community xsdk created for us. And instead we're going to actually render YAML. Let's wait for this update to finish. This may take a little bit as we have to de provision the load balancer that we've created on the previous run and we are complete. So as we've noticed there is a new directory called rendered. What does that look like? If we look into that directory? If I had Cr Ds, we would be seeing the rendering of that in this directory because we don't have CR DS, we can skip desktop. But in the objects that did render, you can see that I have actual yellow manifests rendered from Pulumi Te script that allows me to leverage a language to do referencing to leverage all the gains I've seen of my ID E and just leveraging a language in general and more so just the reduction of boiler play that I have to work with compared to say Yaml. So if I check this file out, here's the config map as we had expected in Yaml. Summarily, let's look at a deployment. Great. All looks. Well, if I were to deploy this, I can say create this in a new name space, I'm gonna say new name space, create name space. My uh I don't have, I have uh my Cuban fig file over here. So let's see what this looks like. All right, let's move into that. OK. I'm going to take this coupon file and just use it over here. We export it to use coupon control and we can now see that it's working great. Now, let's actually create a new name space again. My and we're going to deploy this folder that's been rendered for us into that name space, right? And we can then see that in this folder, we can do a recursive out of that and all of the resources are created just like we expect them to be get all from the space. And sure enough, these resources are slowly coming up. As we've seen, we can use Pulumi to deploy YL manifest if we are coming from a YAML Manifest world. We can use Pulumi with our communities SDK to deploy resources in the language of our choice or we can use the latest communities XSDK to deploy resources using less code, less boiler plate and standard defaults. Here are a couple of references for you to work with Pulumi and communities. Here's a link to our SDK, our XSDK. Here's a link for some tutorials to get you started. And if you're familiar with our Pulumi TV repo, our code is available and accessible on github. For those of you who have visited, please come and check it out. Give us a like share, open up an issue or share it with friends. We hope this has been helpful for you that you've learned the various ways you can use to work with. And if you have any feedback, please let us know that's all my time for today. Thank you and have a great day.

---
