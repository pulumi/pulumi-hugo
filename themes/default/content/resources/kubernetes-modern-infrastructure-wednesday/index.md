---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Kubernetes | Modern Infrastructure Wednesday"
title: "Kubernetes | Modern Infrastructure Wednesday"
meta_desc: |
    In this episode of Modern Infrastructure Wednesday, David, one of our developer advocates, walks us through all the tooling available to up your Pu...
url_slug: kubernetes-modern-infrastructure-wednesday
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Kubernetes | Modern Infrastructure Wednesday"
  description: |
    In this episode of Modern Infrastructure Wednesday, David, one of our developer advocates, walks us through all the tooling available to up your Pulumi game with Kubernetes.  Learn more at https://pulumip.us/Get-Started  Code for Modern Infrastructure Wednesday episodes is available at https://github.com/pulumi/pulumitv/
  sortable_date: 2021-12-15T18:24:21Z
  youtube_url: https://www.youtube.com/embed/x-e9MexohKI
transcript: |
    Hello, welcome to Modern Infrastructure Wednesdays here at Pulumi TV. I am your host David Flanagan. Although you may know me from across the internet as rock today, I'm going to introduce you to the applying applications to Kanti cluster with Pulumi. Once we covered the basics, I'll share my three favorite tips for working with Pulumi and we've got a little bit to cover today. So without further ado, let's get started. So what we have here is a new but let me project using the type script here. The first thing we need to do is add the Ellis package to our package dot JSON. If you're using VS code, you get autocomplete to work out the latest version Nick. Next we can run M PM install this year. We have all the dependencies we acquire. Awesome. So here we have an empty index dot TS. The first thing we want to do is import star as is from the package. Now that we've done that we have access to the name space and all of the different resources enabled by this component. A common workload to deploy in cabernets would be engine X as a deployment because Pulumi understands the S API and that's the typescript. We can autocomplete our way through the entire creation of this deployment. So we've auto completed our ways through that. As much as copilot can get us. We can see on lane eight that we do have a red squiggle, we can hover over and we'll see that. It's telling us we do not have a selector that is required. So, let's add that. Thank you. Good pilot. No. Well, this isn't complaining at me, haven't worked with for a while. I know that the API server will complain that our template doesn't match our selector. We can fix that by adding some metadata labels. He goes on your legs. So this is how we deploy engine to Cotis web to limit it's actually right now, not many lines of code less than the gamma alternative. But you did see that because we're using our ID E which understands the tapes required to build this object as our ID E was able to guide us along the way. All right, let's deploy this to our cluster. We can run Pulumi up and Pulumi will give us a preview of all the changes that it has to make. We'll see that we have to create one year deployment type and we'll hit. Yes. Now what's important here is that on the right hand side under the info column, we can see some information first, we see that the minimum replicas is unavailable Pulumi is aware of what deployment is. Pulumi knows the replica sets and pods and images have to be pulled and created for this to be successful. In fact, Pulumi will wait for the resource to be ready before considering the Pulumi up successful and there we go. So here is step number one, this behavior is not something that a lot of people familiar with the Cotis ecosystem want COTIS itself is a reconciliation. And as long as Pulumi can give the request to the API server, we're happy for the handover to be completed. So how do we make Pulumi behaving this way we can change this behavior and tell Pulumi to skip their weight logic for this deployment. We do. So by adding an annotation plume provides a few special annotations that are available for us to tweak the behavior. The one we want to use today is skip a weight equals true. Now, we want to be able to force this update to be slow. Like the previous one, the reason the first one was slow was because of the container run time, pulling down the image. So let's also update this to engine X 121. Let's rumple li up and see what happens. Now, our deployment was updated in record time. That's because with the skip await logic, the limit applies the resource to the API server and it's done. All right. Now for tip number two, replicating Cooper's channel as a Json object and typescript or javascript isn't much fun. Fortunately, Pulumi using high level programming languages allows us to define abstractions to make our life easier. Pulumi have defined some of these for you to use today. These are available via the Pulumi Cotis X package. We can run M PM install to pull them in. So let's import our Kubernetes X package, import star as KX from Pulumi KTIS X. Now I'm feeling brave. So I'm going to delete our entire engine X deployment. I'm going to use some of the abstractions provided from the KX project. The first one being to define the pod spec to define our pod, we can use something called a pod builder to spec that out. The pot builder accepts containers as a list and we can add the image name that we require and remember to set the same image from before. Next, we can define our new deployment spec which is a KX dot deployment. We give this a name and open up the spec from here. We can see that the spec for this deployment is actually our pot spec as a deployment spec. This is a helper function to get you underway in as little code as possible. I'm also going to add the metadata that we used previously done. So what happens when we run me up? No, so we see that our resource is going to be updated and not destroyed and recreated. We can click on details to see what changes are going to be made. And you see it's nice and simple. The key X package has injected some defaults. So we a message from our initial deployment spec first, it set the default replicas to one. It also added empty definitions for env ports, volume amounts and the containers and volumes, let's say yes and let it go. So KX provides some wonderful abstractions that allow us to take potentially hundreds of lines of Yaml or even typescript and condense it into under 20 lanes. Check it out. Ok. Tip number three. What if you already have existing Coti channel? In fact, if we take a look at my guestbook all in one, this is a wordpress example from the KTIS example repository here. We have 100 and 49 lines of yellow. What's the best way for you to get this as Pulumi could? Well, Pulumi has a binary that can help you get under way. It is called Cube to Pulumi and you can pass in whatever as a fail or a directory of fails and it will convert them to the languages of your choice here. I'm saying convert them to all languages. So we're going to see a few different things pop out the other side. You can see it's generated Python typescript C# and go. Let's take a quick look. If we open main dot goal, we will see new services deployments, more services, more deployments, converting all of that Yaml into Pulumi goal from here, you can clean that up, remove duplication and bring in your own abstractions as required. We also have C# tape script from Python. One of the downsides to C to Pulumi is that it works against the Kubernetes V. One spec that means it is not aware of the multitude of custom resources that we have available at our disposal. However, we have an answer for that too. We have another tool called CRD to Pulumi that will help you get started with custom resources and your Pulumi projects. And my director here, I have the start manager project, the search manager project and its deploy folder has the CR DS directory that contains all of the custom resources that you can use when working with manager. Pulumi provides AC RD to Pulumi command that allows us to point to the custom resource definitions and generate sdks in the language of our choice. Here. I'm using the no GS to generate typescript bindings for search manager. From here. I can import star as search manager from source search manager. This now allows me to generate new certificates using the bailings created from the custom resources. And now we have the ability through autocomplete and type definitions to work our way through custom resources and or Pulumi code. Hopefully with these tips, you realize that your ability to work with the API using Pulumi is unbounded, whatever you take these tolls from here, it's up to you, build your own, telling your own abstractions and your own happiness. Have a great day.

---
