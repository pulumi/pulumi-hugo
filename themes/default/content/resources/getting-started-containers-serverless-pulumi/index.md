---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Getting Started with Containers and Serverless | Pulumi"
title: "Getting Started with Containers and Serverless | Pulumi"
meta_desc: |
    Pulumi is the easiest way to create modern architectures that use containers, serverless, and hosted services and infrastructure. Pulumi helps you ...
url_slug: getting-started-containers-serverless-pulumi
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Getting Started with Containers and Serverless | Pulumi"
  description: |
    Pulumi is the easiest way to create modern architectures that use containers, serverless, and hosted services and infrastructure. Pulumi helps you do this using your favorite programming languages including JavaScript, TypeScript, Python, Golang, and C#.  Get Started: https://pulumi.com/start Find us on GitHub: https://github.com/pulumi  Find the code seen in this video at https://github.com/pulumi/examples/tree/master/cloud-js-thumbnailer-machine-learning.
  sortable_date: 2018-07-15T18:13:48Z
  youtube_url: https://www.youtube.com/embed/Bofmh1qnNSE
transcript: |
    Hi, everyone. My name is Joe Duffy, founder and CEO of Pulumi. Today we're going to take a brief tour of Pulumi to see how it's the easiest way to create and manage modern cloud software. In Pulumi, you write code using your favorite language and Pulumi deploys that to your favorite cloud. You can use languages like javascript, Python go C# java to author cloud services applications and even infrastructure. And Pulumi uses an immutable infrastructure as code approach to deploy that software in a rigorous manner to your cloud of choice, Amazon web services, Azure, Google Cloud Kubernetes or even on premises using opens stack or VMWARE. Pulumi alleviates the need to write the ML and instead allows you to focus on writing code using your favorite editor, using your favorite package managers uh so that you can share reuse, collaborate and create powerful new abstractions using components. Let's jump straight over to some code to get a good feel for how Pulumi works. In practice. This is a Pulumi program written in javascript. Notice we're just using our favorite editor. This diagram represents the overall flow for this cloud application. It takes is input a video and that video will come in through a bucket. In our example, here, we'll be deploying this to Amazon web services. So this is an S3 bucket uh triggered off that bucket is a lambda, a serverless function that's going to do some processing. And ultimately, it's going to leverage containers. Uh in addition to a machine learning pipeline to extract an identified object from that video and create a thumbnail out of it and then it will write that back into a bucket. This diagram is nice because it represents the developer's intent, the way that they think about the system architecturally in today's solutions. However, usually this intent is lost somewhere along the way to L files and configurations. And Pulumi, on the other hand, what you'll find is because we're using general purpose programming languages, you're dealing in terms of abstractions that map closely to your intent. In fact, as we walk through this program, you'll see that it corresponds to that previous diagram very closely. This is just javascript. So notice up here, we're importing packages and packages in Pulumi are distributed using your favorite package manager. So in this case, we're just using N PM. This is standard node Js and we can import any package that's already exist. We can publish new ones, we can use existing private registries. Um The full power of no GS in the ecosystem is available to us right away. Notice that we go ahead and start creating these cloud resources. The cloud package is Pulumi high level framework for productive cloud programming. If you target it, then the resulting program can run on any cloud including Cober netti. In this case, we're going to be deploying to AWS. And so this bucket will correspond to an S3 bucket. We're basically declaring our cloud resources as we would any ordinary objects in our favorite language. And so we're just passing parameters and we're getting interactive intell sense as well as we go, which is great because now we have statement completion, we can navigate the surface area of the packages we're using just like we would normally. But this is easy to take for granted because you essentially get none of this if you're using YAML templating languages. So a cloud bucket just maps to an S3 bucket, you know where the videos and thumbnails will be stored. This cloud dot task is far more interesting. However, a cloud task is a docker container that can be run in an ad hoc way. We also support cloud services and a cloud service also is backed by a docker image, but a cloud service is load balanced exposes ports. And so that would be more appropriate if what we wanted to do is host a web server or other sort of server based application. In this case, a task is exactly what we want because we're just going to run an FFM peg transformation to extract the thumbnail. This build directive is actually very interesting. If we look at points at a Docker file, this Docker file is just an ordinary Docker file. You could be using an existing one that you've already got and it can run any language. So even if I've written my Pulumi program in javascript, I have a way of running any existing software. This makes it really easy to take existing code and translate it incrementally one piece at a time over to Pulumi. Next, I'm going to create this video label processor. This is a machine learning service and we'll see that in just a moment. But notice that this came from a package that we imported local to our project. That's actually something we call a custom component. It internally encapsulates the use of a bunch of cloud services without me needing to know exactly what it's doing. Things start to get very interesting as we go further down. Notice that what we're calling the input function on the bucket we allocated. Well, serverless programming today is event driven programming, but the way people express it is using YAML files and configuration. And so it doesn't look and feel like events. What we've done with Pulumi is brought an event driven style of programming to serverless. So you can wire up event handlers on objects and resources and actually just write callbacks in your language of choice. And so this example, we're using a Lambda and javascript to run and express the code that's going to run in our serverless program. Some interesting things to note here are, notice that I'm capturing a reference to a service that I've defined above this, encapsulates all of the need to pass configuration around secrets. All things that developers today often get wrong because they need to be passed around in an environment very or manually out of band in ad hoc ways. Whereas here, all of the secret management and configuration and everything captured is something that Pulumi knows about and can catch mistakes before they're made. And not only that, but it's just a lot less code for the developer. So what we've done here is we've started the machine learning job any time a new video with the MP four suffix is put into that bucket. And again, we're using an, a venture and style here so that when the video processing is done, then we will go ahead and actually run the FFM peg transformation which is kicking off a Docker container to extract the image uh and then that will be placed into our bucket. And at the very end, we'll just log the fact that we're done. And so this is a very simple program. It's 38 lines of code and usually this sort of thing takes pages upon pages and thousands of lines of YL. Now let's go and run this program to run this program. I'll just use the Pulumi cli I could alternatively do deployments from my favorite C I CD system. But for the interloop development scenario, the cli works just fine. The Pulumi of command evaluates my program and determines what cloud resources are necessary to run it. You'll notice this tree view that got printed above. This is showing me before actually doing a deployment, what resources will be created, modified or deleted. In this case, since we're standing everything up from scratch, it's a lot of creates you'll see in here abstractions that map closely to what I had written in my program. So you'll see cloud function and notice this tree view. It's showing us what resources are encapsulated within those higher level components. So I can see why certain resources are getting created. For example, if I ever wanted to know why this I AM role is created, I can see that it's attached to the function. Similarly, this log group here is attached to my cloud task. The CL I asks us if we would like to go ahead with this update. And we're going to say yes. Also noticed that as part of doing this update, the Docker build was occurring and this is nice because it means that Pulumi is managing deployment of not only the infrastructure but also my application code and containers. And so it's actually going to build push and provision if necessary a private Docker repository to hold those images. Now the creation is gonna take some time but notice that it's all happening in parallel. So it shouldn't take too long while it's happening. However, let's hop on over to the Pulumi Service. It might not have been obvious, but the deployment is actually leveraging the Pulumi service. This is done to ensure that your deployments work in a team setting so that multiple team members aren't deploying simultaneously and potentially causing corruption in your production environment. It also records who deployed what when and why when I logged into the Pulumi service. It actually used github as the identity mechanism because of that. It's showing me all the organizations, I'm a member of Pulumi for enterprise also supports Atlassian GIT lab and custom identity providers. Let's click on over to the Pulumi organization to see what's going on. Notice that I'm landing on a Pulumi projects page. And so each of these projects is something that either I or a teammate have provisioned and is under the management of Pulumi. I can click on over to the people tab to see who's a member of the organization. And notice that we've got roles here and we have role based access control ranging from simple where people can just simply be marked admins to finer grain control over who can deploy certain changes to different stacks. For example, you may want to ensure that your DEV ops team is in control of your network infrastructure, but developers are free to deploy containers and serverless functions. Let's go back to the projects tab these little purple boxes are something we call stacks. This is the web server project and each one of these represents an instance of a web server that's been stood up in a cloud and they could span different clouds. A stack usually corresponds to a particular environment. So let's say production or staging or in a more sophisticated deployment, production, East coast versus west coast versus Asia. It can also represent as you're seeing here, developer stacks. And one of the things that Pulumi makes really easy is standing up custom stacks. So each developer might have his or her own stack that they're using for continuous development or maybe even in a poll request, you're standing up a test stack that is then used for testing temporarily. And we can go look at any of these stacks and see when they was last updated and information about the current resources under management. But I bet our project is done deploying. So let's jump on back over to the thumb nailer and check it out. Well, it looks like our thumb nailer is deployed and we can see the output here including the full docker build and push output. So it got pushed to our private registry. So everything got stood up in about a minute and a half, which is not too bad now that the thumbnail is up and running. Why don't we copy a video to it to kick off the serverless pipeline to do this? I'm going to use the Pulumi stack output capability which takes a property out of a resource that got provisioned by Pulumi and allows us to easily script it. So notice I've uploaded the video and now I can run the Pulumi logs, command to watch to see when the video kicks off the pipeline successfully. The Pulumi logs command aggregates logs across all of my serverless functions and all of my containers into one place so that any console logs that come from any of my application component across many microservices and functions ends up in one place. Notice that it says it submitted the machine learning job for the cat video and here it comes back with the scoring and machine learning uh statistics as this is running. Let's go back up to our update and grab the ul that it prints at the end to the website we've landed on my sack activity tab where it's showing me the most recent update. This includes the 48 resources. We've just added a full build output which includes all the docker build, the resource change information and a link back to the github commit that was actually deployed as part of this change. I can also go and look at the history for this stack. In this case, it's just been me making a lot of updates. I can also quickly see if any updates have failed in the past and I can click into details on any of those, I can also hop over to the resources tab where it's showing me all the resources under management in this particular stack. So I can easily see here's an S3 bucket, here's a function and we can see the names of them, we can easily filter based on resource type. So if I was looking for that log group I knew was in here, I can go just click logs very easily and we have a search as well. You can also click on over to the resource graph view which gives you a logical view grouped based on the information in your program. And I can go collapse some of the more uninteresting notes here. If I was looking for that S3 bucket in here, I can easily see that here and go ahead and click on over and the S3 bucket is where the video and thumbnail are going and notice here that I've got an AWS link and so I can just click that and very quickly get to that resource in the S3 console. We'll see here that my thumbnail is actually already available. Let's switch over and just confirm that this is what we expected. And sure enough, we see here in the output logs that a new thumbnail was created. And so let's go back and take a look sure enough that looks like a cat. So it seems to have done its job that concludes our brief overview of Pulumi today. I hope it's given you a better appreciation and understanding of Pulumi can be used to build modern cloud software. Pulumi is free to download and use over at Pulumi dot IO and we also have team and enterprise editions available. Thank you.

---
