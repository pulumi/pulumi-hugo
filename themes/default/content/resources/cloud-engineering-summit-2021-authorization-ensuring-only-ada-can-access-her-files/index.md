---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Cloud Engineering Summit 2021: Authorization: Ensuring Only Ada Can Access Her Files"
title: "Cloud Engineering Summit 2021: Authorization: Ensuring..."
meta_desc: |
    When an application is small, few or even no permissions are needed.  However, as they grow larger, it is common to have increasingly complex permi...
url_slug: cloud-engineering-summit-2021-authorization-ensuring-only-ada-can-access-her-files
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Cloud Engineering Summit 2021: Authorization: Ensuring Only Ada Can Access Her Files"
  description: |
    When an application is small, few or even no permissions are needed.  However, as they grow larger, it is common to have increasingly complex permissions models.  While things are still small, it's easy to meet these needs through something built in-house, but as they become more complex, a better model is often needed.  The world of authorization solves precisely this problem.  There are several common models, including ACLs, RBAC, and ABAC, which work well for different use-cases.  In addition, there are several higher level architectures for implementing one of these as well as a number of different products available.  In this talk, I will discuss a high level overview of the authorization landscape.  I will then delve into more depth about how we approached this problem at both Box and Split and some of the things we considered.  I will include the pros and cons for the various options with regards to our use-cases and what we ultimately chose to do.  Talk by: Joy Ebertz
  sortable_date: 2021-10-20T23:01:21Z
  youtube_url: https://www.youtube.com/embed/WaBjJhCATWg
transcript: |
    Hello, I'm Joe Bertz and I'm a senior staff software engineer here at Split. And today I'm gonna be talking a little bit about authorization. But before we get too much into that, first of all, who am I, I like to write, I write about both running and text stuff so you can find my stuff on medium. I've worked at uh box for quite a while as well as Microsoft, a super tiny startup. And currently at Split, I'm a backend engineer. I work mostly in Java these days, but I've done a few other things. I've spent time at both Box and split on splitting up uh monoliths into microservices and microservices architecture in general. I've created uh API standards for both companies and rest API S and I've also worked quite a bit on authorization again at both Box and split. So today I'm going to go through first of all, a little bit of the difference between authentication and authorization since a lot of people get the two confused as well as a few definitions there. And then I'm going to talk a little bit about some of the different layers that you might have authorization within your company. And then I'm going to talk about some of the different types of access control and then we're going to get a little bit into some of the typical architectures at the end. So first of all, what is authentication versus authorization? So, authentication or A N is the process or action of verifying the identity of a user or process. Meanwhile, authorization or AC is the function of specifying access rights or privileges to resources ie defining the access policies. So the example I like to use is if you are going into a bar and you run into a bouncer at the door, uh The bouncer is going to ask to see your ID. And first of all, they're going to check, is it a valid ID? Like is this actually a government issued ID? Next, they're gonna ask like, do you actually match the photo on the ID? Is this ID actually for you? So they are validating your credentials. They're making sure they're valid credentials and they're making sure that they in fact represent you. This is authentication. Next, they're going to check your ID for your birth date and they're going to see if you are at least 21 years of age. And this is because they are now matching your age with the policy that the bar has about the age you need to be. In order to enter this is authorization, it is checking your permissions based on facts about you. OK. So a few more quick definitions before we get into other things. Uh Access control is the restriction of access access management is the process of restricting access, identity and access management is the framework of policies and technologies encompassing both authentication and authorization. This is also sometimes just called identity management, Aws, identity and access management or AWS I am is Amazon's specific customer facing authorization management feature. And I bring this up mostly because in a lot of context, when you see I am, they actually mean Aws, I am, they might not actually specify that they actually mean Amazon specific customer facing feature. They don't mean the more generic one that I just mentioned a minute ago. So that's something to keep in mind when you're reading more about authorization. Ok. Next, we're gonna talk about a few of the different levels of authorization you might have. Uh the first one is system and infrastructure authorization. The next one is customer facing author authorization features and the last one is application level authorization. So what do I mean by these system and infrastructure authorization? So when you have a group of users uh within your company, so I work at split. So this is the split employees shown here, you're gonna want to be able to restrict access to various things within your company. So for example, uh you want to be able to check if a user should be able to access the servers, right? Or maybe should they be able to access the production servers or should they be able to access the data, um you know, in their databases, either mysql, Mango DB, whatever or should they be able to access specific applications? So in this case, it might be salesforce or you know, something else. And the other thing to note here is that different users within your organization are going to have different authorization. So for example, as an engineer, I can access our servers but I cannot access salesforce. Meanwhile, our sales folks can access salesforce but they cannot access our databases, right? So authorization is different by user. Next, I'm going to talk a little bit about the customer facing features, which is at the totally opposite end of what authorization can mean within a company. So this is an example from Box box is a file sharing system. So uh when we collaborate a file with another user, so if I own a file and I share it with you, I can specify some of the different access rights that I want to give you on that file. So for example, I can make you an editor which means you can change it or I can say you can only view that file, right? And so you can actually change it. So I'm able to set authorization levels within the box application. This is what I mean by customer facing feature. Finally, we have the application level authorization, which is sort of putting together a bunch of different customers facing features and some other things into uh one authorization check within your application. So, um for example, uh within box, again, you might ask if Grace has access to a file, right? Maybe she doesn't have access, but is Grace on a team that has access, right? So we need to consider both of these things but not just Grace's direct access on the file. So that's that user facing feature, but there's other questions as well, right? Like is Grace's organization active, maybe they haven't paid in six months and so we've deactivated them. So, should she even be able to access box files at all? Right now? Or maybe this file has a specific feature related to it and that feature is not turned on for her organization. So that's another thing we need to consider or maybe Grace got fired last week. And so she shouldn't be able to access any of the content for her organization at all. Her account itself is not active, right? So application authorization is putting together all of these separate questions and making a single decision about whether Grace can access that particular file. OK. So that's sort of a quick overview of some of the levels of authorization and of these, I'm actually going to focus on that last one, the application level authorization for the rest of this talk, which isn't to say that this stuff doesn't apply to the other two, but that's, that's going to be my main focus for today. So, next, I want to go through some of the types of access control. So if you do an internet search, this list is pretty exhaustive. What you're going to find, there might be a couple of others, but as far as I can tell, they're basically not used. So this is mostly what you're going to find. It's a little daunting, we'll go through them a little bit at a time. Uh So for the first two, these are both about who controls the access or policies. So the first one, mandatory access control is an operating system level access control where policies are controlled by a central administrator and users cannot override policies. Meanwhile, discretionary access controls allows individual users within the system to grant access to objects. Most of the time these implementations involve the owner of an object, granting access to things that they own to other people. Owner is not actually in the formal definition, but that's how it's most often implemented. So to use an example from box, these features can live side by side. They, they do need to be a little bit separate as you might be able to tell because they have sort of conflicting definitions, but they can live side by side. So again, let's say we have an organization with a box account and the administrator of that organization is Grace, right? She is the box administrator and then Grace also has two employees within her company, Ada and Catherine. And there's also, you know, Dorothy who's in a totally separate organization. She works for a competitor, let's say so it owns a folder within her organization. Now, Grace can set a policy that says that her people within her organization cannot share content with anyone outside of her organization. This will be an example of mandatory access control grace as the admin is able to put a policy in place that doesn't, that prevents access to other people and individual users cannot override this policy. Meanwhile, however, Ada can actually collaborate this folder with Catherine and now Catherine has access. Catherine previously did not have access to this folder, but now that she's collaborated, she does have access. So this is an example of discretionary access control. Ada has granted access to Catherine as an individual user. So let's see. First two who are, which is about who controls the access policies. These next three are all about how the policies are modeled. So we have who and we have how Nora fast as you might guess. Uh you can actually combine these two in various permutations, right? So this rule set based access control is really just a combination of role based access control and mandatory access control. So I'm not really going to get too much depth about it, but it's mostly here to illustrate that you can combine these and have like pretty specific things that a lot of people use. And the final one I want to mention real fast is this policy based access control. So PBAC and a back attribute based access control are really, I would say 99% the same thing. There are, there are a few nuanced differences, but for all intents and purposes, for everything we're going to talk about here, you can consider them to be the same thing. So we're just going to cross policy based access control off the list. But if you see that know that it's pretty much the same as attribute based access control and everything we refer to about a back here. OK? So now we're gonna get into these three, the three about how the policies are modeled. So the first one you've probably heard of this mostly in the context of operating systems, but the first one is Ales. So access control us. And the idea behind Apples is you basically have a list associated with each object in your system. And that list is gonna say give list out the access rights for each user within your system. So on this folder, you might say Ada can read and write and Grace can read. And meanwhile, on this file, you know, Ada can read it and Grace can read it, right. So the big advantage to Apple is that it's really fast look up. So you know, Ada is trying to see if she can read this folder, assuming you've done your indexing correctly, you can just immediately find that access control list. And then again, you should be able to immediately look up a right. So really fast. Um sort of, and I guess the other thing that I didn't mention is this is also super fine grain control, right? You can very, very cleanly control exactly who has access to what one of the big problems here, however, is storage explosion, right? So, you know, especially within a system like box, you're going to have, you know, not a couple of files, but a lot of files, right? A lot of objects in our system. So we have to have an access control list for nearly all of them, if not all of them, right? Meanwhile, we also have a lot of users. And so when you consider the combination of access between all of these users and all of these items, you can see how that gets really large really fast. Similarly, within box, we have the ability to collaborates a group of people on a particular folder and they automatically get access to everything underneath that folder. So everything inside that folder. Now, let's say we want to move this folder into a different folder. We now have to recalculate the permissions of who should have access to this folder. And if we've individually written out a bunch of this information, we're going to have to both remove that as well as completely redes decide what he should have access to. And you can imagine this could be pretty complicated and slow depending on how many people and how many folders deep and a bunch of other questions. Right. Meanwhile, similarly, if we have a user within our system who has access to a bunch of content and she leaves the company, we're going to need to remove her access from every single one of those access control lists. And again, this could take some time as we have to update each and every single record with her name in it. So slow update. That's a big problem. OK. The next one I'm going to go through is a back and this is probably the most common type of access control. Um So our back has this really nice idea of roles. So the idea is you can assign users to roles and then you assign a set of permissions to the role as well. So if you have a user Grace who's an engineer, she gets the engineering role and let's say AA is her manager, Aa is going to get both the engineering role and the manager role as an engineering manager. Now, we can say that like engineers can read and write and managers can read and delete, for example, right? And this is really nice because if Ada decides she doesn't want to be a manager anymore and just wants to be an IC, we can really quickly just remove this rule from Ada and she's going to lose all of the permissions that she had for only being a manager. Right. Similarly, if we suddenly realize that oh, wait, managers shouldn't actually be able to delete things, we can remove that permission and every single manager is going to simultaneously lose the ability to delete. So again, it's really fast. It's really convenient. The big problem with our back was when we tried to fit that into the box use case. So in the box use case, we allow users, like I mentioned before, we allow users to collaborate individual items with anybody else, right? So we need this fine grain amount of control. And when we spent a long time trying to figure out how to map that to roles and sort of the best that we were able to come up with was sort of just doing these permutations of who can edit, who can read and you know, mapping things accordingly. As you can see, this really isn't any better than Echols. In fact, it's probably the same or worse and that we are now recording all of these permutations of who has access to what. And it has all of those same problems. We did come up with a few more fancy ways to do this, but we found that it didn't realistically save much space. And at the same time, they were really complex to make sure that they were right at all times. So long story short, this was just really hard to represent our use case. OK? So the final one I'm gonna talk about is a back or attribute based access control. And the idea with a back is that when Ada goes in to see if she can read a particular folder, we're going to find the policy that's related to reading folders, right? And then this policy is going to go and fetch any missing attributes that it might have written into the policy. And based on all of those, it's going to make a decision and respond to a. So because I was a little fuzzy, I'm gonna get into an example request and policy real fast. So an example request might be that this is again user with ID 123. So Ada wants to view, she wants to access this and she wants to view this file with ID 456. So it's a subject, wants to do an action on a particular resource. So now the policy might be something like if the action is viewed. So that's basically saying if she's trying to view the folder and the enterprise of the resource is the same as the enterprise of the subject, then permit access otherwise deny. So we're just basically saying if it is in the same enterprise as the file belongs to, then, you know, she should be able to see it. So in this case, we sort of fill in the attributes that we have from the request. So in this case, the action as we said is view. So we're gonna say a view is view and then we don't actually have the enterprise of the resource, right? But we do have the resource. So we're able to take that resource information that we have, go out and fetch the enterprise and return and fill that in now, right? And the same thing with the subject, we can go out and fetch the enterprise of data and bring it back and fill it into this policy. And now we should have all of the information we need in order to make a decision. So the really nice thing here is that we have fast update again because in this case, if we go out to a service and we change some information there or we change how something is calculated, it'll update immediately, same thing with the database, right? So we can change data's access instantaneously and it can also handle pretty complex use cases. So for example, if we have a file that's locked, then we can prevent access or maybe there's a legal hold on it, we can prevent access. So we can take all of these completely desperate features and combine them together to make a decision about whether A has access and these features don't necessarily even need to know about each other in order for them to work together for that final decision. The big problem, as you might imagine is that this whole system can be kind of slow because you're making calls out to external systems. And again, because you're calling external systems, if one of those goes down, your authorization decisions are going to go down. So it's kind of, it's kind of a mixed bag there. So throughout all of this, our choice at both split and box was to go with a back. So why a so first of all, it's an industry standard, that was something that we really wanted. We didn't want any homegrown solutions that nobody else knew about. Uh Secondly, there's no permissions update. Like that's something that was super important at both places. If permission has changed on something we wanted it updated immediately, we didn't want our customers to see a like there, we wanted it to be something that was relatively space efficient. And as I've kind of outlined going into this so far, it sort of just best fit our use case Echols and our back are a little bit too simplistic for some of the use cases we had. And so we wanted to be able to represent something that was a little bit more complicated and similar to that. I'm just going to mention real fast that it is possible to still have customer facing features that are, that are simpler built on top of a more complex system underneath, it's very hard to do the opposite. So in the box use case, they have that r back system built on top, but then they still have a back solution underneath. So what do the typical architectures for this look like? So first of all, a typical um web application might look something like this. You have a call that comes in, it's an API gateway um which calls a couple of different services Uh within that the API gateway itself might be an obvious choke point in place to put the authorization service. So you might have the API gateway call out to the authorization service, decide if the user should have access to whatever end point they're trying to, trying to call or you might try to save some time there even more and put it into the API gateway itself. So you save that network call. There are some API gateways out there that include authorization. So that is an option. Another thing you might consider is having it as a separate service that the individual services call before they execute their main code. Um And similarly, you can do this as a side card. There are pros and cons to each. Uh It's a little less obvious which is faster than it might seem at first due to cashing and a few other things. But those are two different options that you might have there. So what do we do at box at box? We have the API gateway as you see. But instead we went ahead and had it at the service level. So when uh the API gateway sends a request to the service, we have the PEP in the filter chain which is going to automatically intercept the request before it goes to any of the code in the service and calls out to the authorization service which makes the decision. Um And in box's case, we were using Bolano, which is an open source authorization, a back solution. And for PP, we built a custom library using the Jersey filter chain, like I mentioned and Jackson annotations. Uh So what do we have it split? It's pretty similar, a little bit different but pretty similar. So again, we're using the PP as a filter before we call the service. In this case, we're calling to a custom built authorization service that's mostly just a wrapper on top of a. So a is another open source solution that we're using under the hood and that's going to contain most of our policies, but we're fetching a lot of the attributes in the service itself. So it allows us to do a little bit of performance optimization there. Um Again, I guess I mentioned already we're using under the hood. And again, we're again doing a custom library with the Jersey filter chain and Jackson annotations. So that is a whirlwind through authorization. Uh Thanks for sticking with me.

---
