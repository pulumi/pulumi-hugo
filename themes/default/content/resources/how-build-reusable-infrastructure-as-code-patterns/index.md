---
preview_image:
hero:
  image: /icons/containers.svg
  title: "How To Build Reusable Infrastructure as Code Patterns"
title: "How To Build Reusable Infrastructure as Code Patterns"
meta_desc: |
    One of the great benefits of adopting Infrastructure as Code is that you can drastically reduce the amount of repetition when declaring your infras...
url_slug: how-build-reusable-infrastructure-as-code-patterns
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "How To Build Reusable Infrastructure as Code Patterns"
  description: |
    One of the great benefits of adopting Infrastructure as Code is that you can drastically reduce the amount of repetition when declaring your infrastructure. Using familiar languages like Python means you can use functions, loops and object oriented programming paradigms to reduce the boilerplate.  In this workshop, we’ll guide you through an example of building a reusable Pulumi component for a hypothetical “production ready application” in Python and help you understand how to build reusable abstractions for your infrastructure as code workflow.
  sortable_date: 2021-06-21T19:32:35Z
  youtube_url: https://www.youtube.com/embed/3BaDCrCw5FM
transcript: |
    Hey, welcome to how to build reusable infrastructure as code patterns with Pulumi. My name is uh Maddie Stratton. I'm a staff developer advocate here at Pulumi and I'll uh I'll be your guide through the next uh little bit. So we're gonna go along and see how we can use some of the kind of cool stuff by, you know, treating our infrastructure as, as, as software in this way uh to create a component that we can reuse. Uh maybe in some other things that we're gonna be doing uh with Pulumi because I don't know about you. But in my life in infrastructure, I find that I do the same thing with small variations over and over and over again and it's uh it's pretty, pretty good to not have to reinvent the wheel every time and recreate things. So I'm gonna start uh just, this is not an introduction to Pulumi workshop, so I'm not gonna spend a whole lot of time uh going, going through what Pulumi is really about, but just if you happen to not be familiar uh we use Pulumi really to, you know, think about the way we mod uh do modern cloud engineering. And one of the big benefits of Pulumi as we're gonna kind of see here is that I can write my uh code that I'm doing to deploy and manage my infrastructure to build, deploy and manage my infrastructure in the programming language that, that I like. You know, whether that's uh javascript or Go or C# or in this case, we're gonna be using Python today. That being said, while today's workshop is focused on Python. Python is the example we're using this concept works across all those programming languages. So if you're like, you know what, Maddie, I do not dig Python, I dig go like me. Cool. What you're, what you're learning today will apply if you're writing it in, in your Pulumi program in code, the concept is still still the same. So uh what we're gonna do, I put a couple links in the handouts. The one that's uh probably most uh everyone is gonna want to, to, to jump over to is the github repo and that doesn't have the example code in it. But what we'll be using for this workshop, you can do this all locally if you already have the Pulumi Cli installed and you have your own Kubernetes cluster that you want to use to deploy this stuff to, you absolutely can do that or uh but what I've done is I've provisioned the KTIS cluster that we'll be using for this because this is not uh a workshop on how to provision uh your cluster, but how to use it once it's already there. And I've also put a hand out um link to uh the cube config that you could use to uh access this cluster. That being said, what we're gonna use, what I'm gonna be using is something called GIT pod. And you'll be able to do this as well. I'm gonna show you how to do that in just a second. So you'll be able to do all of this in the browser. You don't have to have anything running locally on your machine. The cube config will already be there uh within the GIT pod, which is basically a browser based ID E for the stuff that we're gonna do. So I strongly suggest uh if you're coming along with me on this journey through the workshop and you're following along and doing it yourself, absolutely use Git git pod and I'll show you how to do that. So the first thing uh that we want to do, so I'm gonna go ahead and share my screen here and just give a quick uh walkthrough on, on kind of what we're, what we're talking about. So, yeah, this is the, the repo this Plumy component workshop. And the only thing that really matters uh to pay attention to is we've got this wonderful link that says open in Git Pot and I'm not gonna do that just yet because the other thing you have to have, uh set up for yourself is you need to be able to do this workshop. You need to have an account on uh Pulumi dot com, which is free, doesn't cost you anything and you can log in with github, uh if that's your preferred provider. So I'm gonna show you, I'm gonna do a quick step through of, of that process with a, a different github account of mine, which I'll be, be using for that. So I'm gonna go ahead and switch over to if I go to um Pulumi dot com and I'm gonna go ahead and say if you already have a Pulumi account or if it's a new one, either way we're gonna click this button here that says sign in, right. This is gonna take us there and I um apologize. I apparently in this browser, I thought I was uh signed in as somebody else. Let me go ahead and pretend this didn't happen. We're gonna sign out there we go and let me now. It should give me, there we go. So I'm gonna say I'm gonna off with github. Uh You can use all the whichever way is preferable to you. So I have this match Strat in one account. There's my other github and it's gonna go ahead and it's that simple. This is, gets me a ploy. So we wanna make sure that we have this because we're gonna need a uh token from that. Now, I'll, I'll show you how that's gonna work in a second. So we wanna make sure you're set up for this. And then if we go back to the repo to the github repo, there's this wonderful big button down here that says open in Git pod. So we're gonna go ahead and do that. And what that's gonna do is it's gonna create a virtual uh ID E environment that's already configured for everything that we need. So what it's gonna do is it's gonna have the Pulumi uh cli installed. It also has cube cuddle installed or cube control if you prefer or whatever way you want to pronounce it. That's a different workshop to argue about that. But we're gonna go ahead and kick that off. It takes a, a second or two to get going and it's uh when, when it brings up this git pod instance here, it's gonna run a couple of quick little shell scripts to get things set up. One of the things it's gonna do is it's gonna pull down that coup config which if you are doing this uh not inside Git pod and you need that coup config there's a link to a, a secret github just that I have in the handouts where you can get that uh cube config from this cluster is going away after this workshop. So don't think you're gonna go run your production workloads on my own um thing. And of course, because I'm in a, I'm gonna go ahead and, um, ok, so we're, go ahead. We're, we're logged in here and what you'll see is down here in the terminal. It's gone ahead and it's, I need to be logged in to uh Pulumi dot com. So, what we do in that case, if we go back to our, um, to our Pulumi log in under settings, we'll see there's access tokens. And so you're gonna need to create a token. So we're gonna call this one component workshop, which is gonna get us, you know, this is how we're going off to that. And then don't worry, this token is gonna go away. So, um I'm gonna go ahead and switch back over now that I've copied that. So when I'm back down in, in my command line here, I can paste in that token. And now if you, if for example, if you want to make sure it worked, if you say Pulumi, who am I? We can see that the pasting didn't work that time. This is what happens when I try to be, be cool and uh give you a whole new place. But now we see that by Pulumi, who am I said that? I am Matt Stratton one, which is who I wanna be. This kind of got us where we wanted to start. So this gets us into the position where now we have ourselves logged into Pulumi and we're kind of ready to get going. The one thing if you want to make sure everything uh is, is happy with on the Kubernetes perspective, we just wanna make sure that uh our cube cuddle is working. And if we just did our command line, if we run to cuddle cluster info, you should get something back that says OK, we got a control plane running. So it's connected to my digital Ocean KTIS cluster. So we are good to go with that. And now we can actually start doing some Pulumi Pulumi. I'm not sure like how to conjugate that verb. So in our command in our terminal here, the first thing that we have to do when we think about infrastructure and Pulumi, we organize them into projects. And every project is basically a single Pulumi program that when you run declares this desired infrastructure that we want to manage. So we need our Pulumi project and every Pulumi project lives in its own directory. So we're gonna go ahead and create one now. So we're just gonna do and we're gonna call it production app just like this. So just go ahead and do an MD and then we want a CD into that and this gave us a directory. Um Pulumi is gonna use this directory name as our project name by default. If you wanted to call it something different, you call the directory something different. Um Now all that a Pulumi project is, is, it's a it's a directory that has some files in it and you could do this all by hand if you wanted to. That being said, we can use this command Pulumi New, which will do this for us in an automated way. So we're gonna say Pulumi New Python. And this is gonna tell Pulumi to go ahead and create a new project using uh Python as sort of the template. And there's lots of different uh initial scaffolding you can do if you know you, it's gonna use Aws or it's gonna use Cober TTI in this case because we want to do a little bit by hand. We're just gonna say it's a generic Pulumi Python project. So we say Pulumi New Python and it's got ask us for a couple of things. We need to give it a name and it defaults to production app because of the name of the directory. Cool, give it a project description. Um And this is gonna be called, you know, Maddie's awesome component stuff. You don't have to give it a name, you a description. And now this is the trick. It's gonna, we need to say the stack. So Pulumi projects have multiple stacks, which you can think of if it helps you. Uh Sometimes I like to think about them as environments. They are different possible configurations for that program, maybe different regions, maybe all sorts of different reasons. You might use a different stack. We're just gonna use the default stack right now, we're using a single stack. The default stack is called DEV. So we're just gonna go ahead hit, enter, accept that. And so it's gonna do a couple of things here. It's because we're using Python, we use a virtual environment. It's setting that up and it's basically installing all of the dependencies that we are gonna need and creates the initial scaffolding for a Pulumi Python project. So now that that's in, we'll see that happen and that's cool. And now if we go and we were to poke around in our directory, we can see Pulumi created a bunch of files for us. And it's basically this is what a pro our project is composed of. We have our main dot pi which is our main entry point for our, our Python program. For the stuff that we're gonna be doing. We have a requirements file, which is our dependency info for Python. There's the Pulumi Yale, which is the metadata about our project. And in this case, it's just basically containing the uh name and its language and then it also creates a event. So the virtual environment uh for the project, the virtual Python environment that we're gonna be using. So if we were to take a look at our main dot pi, it's not very exciting. It's just kind of telling us um that uh we need to use the Python package to kind of get started. Now, we want to um we're gonna be using the virtual end in just a second. But we want to make sure that our all of our autocomplete and stuff is working in git pod. So we need to uh inside git pod install the uh dependencies we're gonna be using. So we just do pip three install and we're gonna install Pulumi and then also Pulumi underscore Kubernetes. So we go ahead and do that. That's just fun. Usual uh pit three stuff it's probably actually handled because of the way the git pod got built, but it's just kind of our safety step. So now we actually want to uh let's write some code, let's create our components. And what we're gonna be doing here is we're gonna be creating um we're gonna be using kind of the standard Pulumi approach to provision this hypothetical production grade application to Kubernetes. And we're gonna create a Pulumi component resource to do this. Now, we're not gonna be writing code in our main entry point just yet because first we're gonna create this component. So the first thing that we need to do is we need to go ahead and uh we're gonna create a new file called app dot pi. So if we just, you know, Touch App dot pi that gets us the file and there's nothing in it. Of course, because that's what Touch does. And we want to initialize this app by creating a class for production app. So we're going to import Pulumi and it's gonna look a little bit like this, right? So it's, we say we're creating this uh this class which is production app, which is a Pulumi component resource, right? And we will. Yeah, and this is just self name. And then we're gonna be because we're creating, gonna create this class for the production app arguments that we want to pass to it. Uh Sorry that the text is small. I will fix that. You know what I was even thinking I needed to do that. There we go. Hopefully that's better now. OK. And I'm gonna do this. OK? Is that, is that better? OK. And we don't need so much of the terminal. There we go. OK. So we're gonna, we're the next thing we're gonna do is we're gonna create uh a class for the arguments that we're gonna pass to that. So uh and then we're gonna bring in our Pulumi our resource options. Sorry. OK. Hey Maddie, would you mind uh bumping up the size of your text a bit? Oh Is it? It should be better now. I I boosted it a whole bunch. Yeah, that's why I was, I was uh sorry I was responding to that. Um we'll do our this and then we're gonna say it's, you know, production App index. So we kind of got, got this one handled, this was creating our um oh, the class is actually production app. That's what happens when I start talking uh while I'm typing. OK? And then we also need to create the class for production app ags that we uh reference there. So the same thing we'll do a deaf and then this give it our, we're gonna take, you know, but the, the inputs that come along for this and it's, these are, these are probab. Yeah. Sorry. I'm trying to think about too many things at once because it's taking input. It's because it's going to be taking these things like the image that we want to use. These arguments are gonna be coming from uh inputs from our Pulumi program which is why we, we are defining them this way, right? And then if we think about things that we care about with a deployment for our production app, it's gonna be the Docker image that we're used, the container image that we're using. I'm sorry. And then the part where that needs to go. So it's just self dot image equals image and port equals port, right? So that gives us our pretty much the only part of the production app that we're making configurable. What we're expressing that we can use in our Pulumi program are the image, the container image that we're deploying and then the port that it listens on. The rest of this is going to be defined by us, the experts on our platform. So this reusable component where this comes in to play is that people have different uh expertise, right? And maybe if I need to deploy this production app, the only thing that I need to know to do that is I need to know the image I want to use in the port. And all of the other great practices in my organization that matter for doing this are gonna be embedded in this component that we're creating. So right now, we should, you know, kind of look like uh look like this and just from a perspective of Yep, OK. Um We've got our production app ags and then we've got our production app that we're that we are continuing to use. Now, since we want to provision applications uh to our Kubernetes cluster, we need the Kubernetes Library for Pulumi in order to do that and it needs to be installed inside of our virtual environment because Pulumi runs inside the virtual end. So what we do for that is first we need to activate our virtual environment. So if you do, you know source and you do VN then activate, that's gonna now tell uh tell us OK, we're using that virtual environment and now here we are going to install the Pulumi Kubernetes uh library, right? And it's very exciting to watch uh software install itself. So cool. So now we have the, so now because what we've done before, we were only using Pulumi, but now we're gonna be using the uh KTIS. So we need to add uh we now, in addition to importing Pulumi, we need to import Pulumi Tuttis and we're gonna import this as K eight S just to make it easier for us to type because typing Pulumi Kubernetes over and over again as you saw, I could barely even type it for the import statement. And we're gonna add a couple of things to the, the production app class. So in addition to this, we now are gonna add uh some of the definitions from a Kubernetes perspective. So we're gonna add the app labels and the app labels are gonna come from the name. So it's gonna look like this. And then we also need to add the name space, right for cnet er that we're using for this deployment. So this is gonna be a K eight core, the one name space is what we're creating here is made up of name and then the options uh that we're, that we're taking for it look like this. You'll see. We're getting all this great autocomplete because it's coming from a library, you know, the Kubernetes library is providing this to us, which is making this a lot easier. Uh especially if you are bad at typing like I am as you're all seeing, right? So we go ahead and we do our ops and then we also are gonna add the metadata which is another K provider. Um oh and that's the name equals name, which we're gonna get from that. And now we have uh so we're setting the name of the name space explicitly so that we don't use Pulumi auto naming for the name space, which is gonna make it easier for us to find this name space, especially since we're on this shared cluster. So we've gone ahead, we've got this, uh got this saved in theory. I think some of my uh bindings are not where I want them to be. OK? Cool. So now we've defined what is a production app? That's cool. But wouldn't it be kind of great to use this component that we've created? So we need to import it into our Pulumi program, which is in main pie, right? So we're gonna go back to here, which was a very, you know, our, our scaffolding thing and pretty much we don't need to import Pulumi because we're not using any Pulumi stuff. So, but what we are do want to do is we want to import the component we just created. So we're gonna say from app and then we want to import those two things. We created production app, Arbs and Production app. So now we can use them in our Pulumi program. And then in this case, we're just gonna do the Coard and we're gonna say this is first we're gonna use it. Yeah. This existing one, it's a production app and then where you see uh and then you're gonna put in your name So I'm gonna put in Pulumi puts, this is because this is setting the name space where it's being used. So definitely don't use Pulumi, use your name, you know, maybe your first name and initial or something because we might have a little bit of a name space collision because we're all on the same cluster. And um so the, you know, we give it that it's production app and then the A ARG for it are the image is gonna be this, this one for the Co R demo, right? So it's on uh you know, the GCR dot Iokr demo and it's Coard MD 64 and it's the tag is blue is the one that we're using. And then also we're gonna go ahead and give it um in addition to the image, remember we have to also tell at the port because that's what we defined in our um in our component. So really that we have that. So what we've got there is we, we are saying it's a production app with the name Plume that's name space we're using. And then the arguments are what's the container image to use and what port do we want it to go on? So if we were to go ahead and um save this now, so now we have ourselves, we have a Pulumi program. Now, the way that we tell Pulumi to run is we run a command called Pulumi up and Pulumi Up will tell you what it's gonna do and you have to confirm that you want to do it. So it's totally safe to do this now. So if we were to say Pulumi up, it's gonna step through and say, OK, what's, what's the situation? And it's saying if I were to run this Pulumi program, now, this is what it would create, it would create, create a production app and it would create that Tutti's name space called Pulumi. So if we were to go ahead and do that and say, do you want to perform this update? Absolutely, I do because it's no fun to write code that doesn't do anything. We're gonna go ahead and run that and now it's actively going ahead and it created those resources. So if you're following along and if you did this, if we run Cube Cuddle, um and we want to get the name space and then if I put in, in this case Pulumi, because that was the name space I created, we will see that it, there is a name space for that and you should get a similar result. Obviously, if you, if you run the, get your name space, Pulumi plus you'll see my name space. You should see also for yours. Now, one thing that we may encounter as we're doing this, I've, I've seen this happen before when we've run on a shared cluster. Uh If a whole bunch of us are trying to run Pulumi uh uh commands, not Pulumi commands, but, you know, uh Kubernetes creation commands against the cluster all at the exact same time, we might get into a little bit of a thundering herd. So if you get a time out type thing from your Pulumi up, uh when it's, when it's CRE actually creating after you say yes, just try it again because too many of us trying to do it at the same time may uh result in, in a little bit more than uh what digital ocean's gonna gonna let me do on my. Uh um Also, I, I should, should introduce, I, I was remiss in this and I apologize. So my awesome colleague Zach is also here. Uh You'll see him representing his team Pulumi in the chat. So he's also here to help if uh people are running into any kind of uh obstacles or anything as we, as we move along. So I wanna just take a second and, and look a little bit more at, at, at what we did. If we go back and look at this component again, we've created a class that I can now reuse, so I can make this component available. But the person who's writing the Pulumi program doesn't have to know all these details. They just need to know the things that they need to know that follow according to our good practices. But we're gonna give a little bit more of that because this just kind of got us to show that yes, we can create a name space and creating a name space doesn't provide a huge amount of value to our uh end users who are, you know, helping us achieve hyper scale and whatever thing we're trying to do. So what we did uh just now is we built a boiler plate for our productions application environment, but this uh application component probably needs some services so that it can provide some value. And so if we go back to our component, in addition to the um to the name space that we create, we wanna create a deployment. OK? And so this is gonna happen right under the name space at the same level. And we're creating this deployment and the deployment is a K uh app deployment, right? So it's kubernetes apps V one deployment and it has a name and then we have our ops, right? So, and these are coming from and it's, it's taking the uh name space to help define that is how we're gonna do that. So we can take the options from the resource options and it's gonna take its parent is the name space from there. And then again, we have the metadata that's associated with this deployment is gonna be A K, it's metadata of just just like what we did for the one above. And we're gonna take the object meta AGS and we're gonna say what is the name space for this deployment. So the name, space is going to be that metadata, name that we create same space, metadata name and then the labels are um equals, you know, app labels. OK? So we got that, that's very exciting. That's our metadata. Now we're gonna create the spec for the deployment, right? So the spec is case apps V one and this is the deployment spec ar so, right? So these are, so we're, we're passing those along and we want to say, OK, we're gonna say there are three replicas for this. Now, one of the things this could always come from a different configuration if maybe this was something that we wanted to make configurable, just like we said that the name and the container image was configurable. We could do that. But in this case, we say no, we have our practices here. I don't care how many replicas you want, you get three, right? I don't, I don't know how you run your infrastructure, but I like to uh deploy with an iron fist. Um We have a KH meta and then we're gonna give it the labels, right? So it's label selector arcs and it's match labels to app labels and then the template is defined like this, right? OK. It's that I really need to catch up on my mavi speaking teachers typing uh is for sure. So uh then the metadata on the templates. Yes, a lot of work from app labels over here. But that's all right. And then the spec is created inside here, inside this argument, another core V one I, and what was his name? And now remember we've got our, our, our image this right, a image and then the ports, right? And we know it's gonna be on this and then the container or is again that argument, right? ARG dot Port port. And we'll go ahead and get all our commas all the way down situation. So what we've done there is now we've, we've created the spec for that deployment. Now, what we could do here if we wanted to is if I run a Pulumi up and I'm not gonna apply it, I'll clear this for you. So you don't see this. So if I were to run Pulumi up at this point, we can see that it's gonna, it would want to do something of, oh, there we go. Invalid syntax. What did, what did we not like here? Lion 85. No Lion 43. OK. Name equals name. But I know I'm missing something here. So just give me one second. Um ah OK. Wait, there's are our selector. OK. Replicas is equal three. Our selector. Yeah, I think hang on um Selector Kate's meta one label, selector arg match labels equals app labels. No, that should be fine. Line 42. Yeah. Oh yeah. Yeah. Sorry, I missed the, the we're not containing the um you're right. So it's uh containers. So it should be. There we go and then sorry, I'm just gonna do a quick little uh because this is what we want it to look like. I have this saved off somewhere else. So yeah, that was, this was the problem here. OK. So if we were to go ahead and save that now, let's loom me up. Thanks Alexie Alexi. Yes. So we can see. Now, it would say if I were to run this now would create this deployment. I don't want to do that yet because we're not done, but we can see that things changed. So now we want to add a service. So uh just like under here after this, we're gonna do our, we're gonna create our service, which is gonna be its core, the one and this is a service and our friend name gonna do our ops me and we're gonna take our name space again and our friend metadata. OK? And then this is gonna take the uh the fun part of this is because I, I wanted to do a brand new git pod thing for that. So this doesn't have my usual git pod preferences on it. So, uh some of my uh which is why it's not in dark mode, but that's OK. We're gonna get through it. Um We've got our object matter arcs, we set our app labels, we have our name space and now the speck on the service, right? So let's do a spec uh OK. It's a core one service. Now our service ags and then the ports on the service this time, we're gonna get this right. There we go. And then we do the hair. We didn't mess up this time. We already know that this is, this is the thing that we're doing. We're saying our target port OHCTP. And after this, and this is of the type load balancer And that's gonna go ahead and add our service. And the last thing this adds the resources their application needs. But we want to be able to know what it created so that we can use that. And that's one of the things really helpful with plume is we can export things uh that can be imported either into another Pulumi program if we're passing things along or even just back out to me something I want to know. So I want to register the outputs of uh of this component. And this again would let us pass the outputs from resources within our component to another component that we expose. In this case, we're just gonna use that to see the, the URL uh that gets created. But first, we need to let our component know what we're gonna do with the output. So what we wanna do there where we create our production app uh class is we are just at the very top here before we define it, we are just gonna say this is what we're creating an output called URL, you know something we're, and this is gonna grab a Pulumi output and it's a string, right? And all that's doing there is just saying now this class has URL, which is of the type, you know, Pulumi output in the string format. Then after everything, after everything is said and done, we're gonna go ahead and export this out so that we can, we can use it, right? So we're gonna go ahead down here and we're gonna say at URL for our component is SVC status apply. And it's, and this is gonna take the load balancer and just take the, you know, the first ingress that it's gonna, that it's gonna have because in this case, we already know one and it's gonna be the IP. So that's telling us what so and then what we do, if we say self, we register the output, that's gonna tell Pulumi that this is something to, to output, right? And so that's gonna be URL and it's gonna have the value of URL that we got from there. So if we, if we were to go ahead and save this now and now we want to go ahead and provision our application, we're ready to do this thing. So we're gonna go ahead and do ourselves a Pulumi up and this is now saying in addition to the name space, but this would say it still needs to. Now needs to create the service and it still needs to create the deployment because we didn't run this last time. So if we go ahead and say yes, go ahead and perform this update, it's gonna go ahead and that's exactly what it's gonna do, right. It's going to create that service and it's gonna create that deployment so you can go ahead and try that and then we'll be able to get the output, which is going to be that uh URL that we, that we pull back. Uh And it takes takes like a, a hot second here because Digital Ocean takes Cober daddy takes a minute or two to kind of allocate the, the IP address to the low balancer service. So uh we have a little bit of uh a little bit of patience uh where, where that comes um comes in. So while this is going, I think to me again, a lot of this, this reusable pattern uh is where a lot of the power of treating your infrastructure as software in this way comes in because I, you know, kind of in the my classic config management background when I always think about tomcat, it'd be like something like that. We're not talking about a patchy tomcat, but you know, you could have a service, you could have a thing that could have a whole lot of configuration to, but the person who has to actually get one of them only cares about a couple of things, maybe only needs to know a few things or you only want to expose part of that. So by defining it as a component here, we're saying this is how we do these things. When you want to deploy the application, you can just put in the parameters that matter to you for your specific uh requirements. And that's really when we start to see the power of infrastructure as software, right, where it's, it's, it's, it's applying in that way. I'm going ahead and letting this uh this one always gets me always like, I'm like, sure it's working, but it's totally working. And uh so it, it, it got the deployment handled that, that service just takes a minute, it just takes a minute. Uh a couple of things I want to mention while, while we're sitting and waiting, if you aren't already part of our community Slack. That is absolutely a great place to get help from people inside the plume community, which who may or may not work at Pulumi. And we also have just uh because as you may know, one of the downsides of slack is that it uh messages kind of roll off after time, especially if it's an active Slack like ours is. So we also just uh enabled, we have, if you were to go to the Pulumi slash Pulumi Repo on github, we have github discussions, which is more of a long-running knowledge base uh forum OK. So now we already, we got ourselves this and so if I were to do Pulumi stack output URL, I um did something wrong with that. So I don't know why I didn't get my um give me one second to it happened for him. We did register it as URL. So that OK, so wait, let me figure out why my output didn't, didn't come in here. So we do. Ah OK. Here's what I did here. I knew I missed the step because I was too busy talking component sends this output to the Pulumi program. We never told our Pulumi program what to do with this. So we're gonna go ahead and uh redo um the other thing is we wanna go ahead and create if we, if we have our uh we had this thing that was, it was called example before and I'm sorry, it was called Coard um which is fine. So we know that that's the the resource it created. And now if I do Pulumi export, I need to export URL, which is Coard dot URL. So, so now if I were to go and run Pulumi up again, it's gonna tell me it doesn't actually have to do anything. Ah we have to import Pulumi again because remember before I said we weren't using Pulumi. Well, we are because now I want to use that. There we go. So now you can see it, it actually would export that and if I run the Pulumi up, you're gonna see it didn't really, it's not gonna really need to do anything. So now if I were to say Pulumi stack, output URL, uh we give me that. So if I were to sit here and I were just a phone to curl and I can get that from the parameter and just say bloomy stack output URL. It's gonna go ahead and curl and I actually get my results of what my application does. This co R demo. And so again, so this is the component can pass that along which we can get. In this case, all that we were doing with it is just exporting that value. But my Pulumi program could do more things. Maybe there's things that does after it does it deployment where it needs to know the URL, it needs to know that Ingres IP so it can move on and do its next piece, which is where all of this stuff uh really, really comes in. Um So yeah, I wanna take a take a second, see if there are any uh questions. Uh And we've been, you know, kind of getting some, some feedback as we go if you have questions that occurred to you later. Our community Slack is great. You can find me on Twitter at Matt Stratton. I'm happy to, to try and help you uh get along with everything you need to. But we've got the github discussions of the great knowledge base as well as our community Slack, which is at slack dot uh Pulumi dot com to register for that. And if uh if we don't have any, any questions, I think we, we got ourselves through building this component. Uh It's the beginnings of things that you can do. And obviously, our infrastructure is usually a little more complex than, than a single deployment. But uh all of these pieces and parts together can, can give us a, a whole lot of power. And the final thing that I would do here is if I say, you know what I'm done with this and this is just a helpful thing to know as you're working with Pulumi. If I do a Pulumi destroy, this is gonna go ahead and it's gonna say everything that was created by this plume program, go ahead and remove it. So it's gonna go ahead and remove that name space, that service and that deployment when that comes along. So especially if you're using cloud resources and you're doing uh some, some labs and testing things out. Pulumi destroy. Uh can absolutely be, can absolutely be your friend. So um with no other questions, thank you for uh coming along with me today on this uh this workshop journey, find us in the slack and uh enjoy your uh infrastructure software and cloud engineering world. Hey, let me figure out why I don't know what I'm doing here. I apologize. I'm

---
