---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Cloud Engineering Summit 2021: Opening Keynote - Rethinking the SDLC"
title: "Cloud Engineering Summit 2021: Opening Keynote -..."
meta_desc: |
    The software (or systems) development lifecycle has been in use since the 1960s. And it’s remained more or less the same since before color televis...
url_slug: cloud-engineering-summit-2021-opening-keynote-rethinking-sdlc
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Cloud Engineering Summit 2021: Opening Keynote - Rethinking the SDLC"
  description: |
    The software (or systems) development lifecycle has been in use since the 1960s. And it’s remained more or less the same since before color television and the touchtone phone. While it’s been looped it into circles and infinity loops and designed with trendy color palettes, the stages of the SDLC remain almost identical to its original layout. Yet the ecosystem in which we develop software is radically different. We work in systems that are distributed, decoupled, complex and can no longer be captured in an archaic model. It’s time to think different. It’s time for a revolution. The Revolution model of the SDLC captures the multi-threaded, nonsequential nature of modern software development. It embodies the roles engineers take on and the considerations they encounter along the way. It builds on Agile and DevOps to capture the concerns of DevOps derivatives like DevSecOps and AIOps. And it, well, revolves to embrace the iterative nature of continuous innovation. This talk introduces this new model and discusses the need for how we talk about software to match the experience of development.  Talk By: Emily Freeman, Principal, DevOps Solutions, AWS
  sortable_date: 2021-10-20T23:00:33Z
  youtube_url: https://www.youtube.com/embed/42rWrRycw_o
transcript: |
    Hi, I'm Emily Freeman. I'm the author of Dev Ops for Dummies and the co-creator of 97 things. Every cloud engineer should know. I am thrilled to be here with you all and I just want to thank Pulumi and the team for inviting me to speak and share this wild idea. A complete reimagining of the SDLC. I want to be clear before I even get into this. I want your feedback, I came up with this wild idea, but I want to make sure that it works for you and your specific situations and I want to hear how you think it could be improved. You can always find me on Twitter at editing Emily, most of my work centers around Dev ops and I really can't overstate the sheer impact the concept of Dev OPS has had on the tech industry in many ways. It built on the foundation of agile to become a default, a standard we all reach for in our everyday work. When devops surfaced as an idea. In 2008, the tech industry was in a vastly different space. Aws was an infancy offering only a handful of services, Azure and GCP didn't exist yet. The majority of companies maintained their own infrastructure developers wrote code and relied on sis admins to deploy new code at scheduled intervals. Container technology hadn't been invented. Applications adhered to a monolithic architecture. Databases were relational and serverless wasn't even a concept. Everything from the application to the engineers was centralized. Our current ecosystem couldn't be more different. Now, software is still hard. Don't get me wrong. We continue to find novel solutions to consistently difficult persistent problems. Now, some of these end up being a sort of rebranding of old ideas, but others are a unique and clever take to abstracting complexity or automating toil or perhaps most important rethinking even challenging the premises. We have accepted as canon for years, if not decades in the years since devops has attempted to answer the critical conflict between developers and operations. Engineers, devops has become a catch all term. Then there have been a number of derivative works. Devops means 5000 different things to 5000 different people. Now, for some, it can be distilled to continuous integration, continuous delivery C I CD. For others, it's deploying code more frequently adding tests for others. Still it's organizational, they've added a platform team, perhaps even a questionably named Dev ops team or have created an engineering structure that focuses on a separation of concerns, leaving feature teams to not only develop but also deploy secure and maintain their siloed services, whatever the interpretation, what's important is there isn't a universally accepted standard for what devops is or what it looks like in execution. It's a philosophy more than anything else, a framework that everyone can utilize to configure and customize their specific circumstances to modern development practices. The characteristics of devops that I think we can all agree on is that it attempted to capture the challenges of software development along the entire path from start to finish. It's that broad umbrella that holistic view that I want to breathe life into. Again, the challenge we face is that devops is an increasingly outmoded solution to a previous problem. Developers now face cultural and technical challenges far greater than they did a decade ago. Cloud native is the future. The next collection of default development decisions. And one, the Devops story can't absorb in its current form. I believe the era of Devops is waning and in this moment as the sun begins to set on devops, we have a unique opportunity to rethink rebuild. Now, I don't have a crystal ball that would be mighty handy. I'm not completely certain what the next decade in tech looks like. No one does. I know that I can't write this story alone. I need you, but I have some ideas to get the conversation started, I believe, to build on what was we have to throw away assumptions that we've taken for granted all this time. In order to move forward, we must first step back the software or systems development life cycle. What we call the SDLC has been in use since the 19 sixties and it's remained more or less the same since before color television and the touch tone phone over the last 60 or so odd years, we've made tweaks, slight adjustments. We've judged it a bit. The stages and steps are always slightly different with agile. We made it a circle and devs and infinity loop, we've added pretty colors, but it's more or less remained the same. And the SDLC has become an assumption. We don't even think about it anymore. It just is universally adopted constructs like the SDLC have a, an unspoken permanence. They feel as if they have always been and will always be. I think the impact of that is even more potent if you were born after a construct was popularized. Nearly everything around us is a construct, a model, an artifact of a human idea, the chair, you're sitting in the desk, you work at the mug from which you drink coffee and sometimes an after work, beverage, buildings, toilets, plumbing roads, cars, art, computers, everything. The SDLC is a remnant an artifact of a previous era. And I think we should throw it away or perhaps more accurately, replace it, replace it with something that better reflects the nature of our everyday work. A linear single threaded model designed for the manufacture of material goods cannot possibly capture the distributed complexity of modern socio technical systems, it just can't. And these two ideas aren't mutually exclusive that the SDLC was industry changing, valuable and extraordinarily impactful and that it's time for something new. I believe we are strong enough to hold these two ideas at the same time, showing respect for the past while envisioning the future. I don't know about you. I have never had a software project go smoothly in a single go. It's always chaos. Software is a study in entropy and it's not exactly getting any more simple. The model with which we think and talk about software development must capture the multithreaded, non sequential nature of our work. It should embody the roles engineers take on and the considerations they encounter along the way, it should build on the foundations of agile and devops and represent the iterative nature of continuous innovation. When I was thinking about this and I took a lot of time to think about it. I was inspired by ideas like extreme programming and the spiral method or model. They were getting pretty close. I wanted something that would have layers, threads even a way of visually representing multiple processes happening in parallel. What I settled on was the revolution model. I believe this visualization is capable of capturing the pivotal moments of any software scenario. And I'm going to dive into all the discrete little parts. But I want to give you a moment to have a first impression and really absorb my idea, I call it revolution because well, it revolves, its circular shape, reflects the continuous and iterative nature of our work. But also because it is revolutionary. I am challenging a 70 year old model that is embedded into our daily language. I don't expect Gartner to build a magic quadrant around this tomorrow, but that would be really cool. And you should call me my mission in. This is to challenge the status quo and create a model that I think more accurately reflects the complexity of modern cloud native software development. The revolution model is constructed of five concentric rings describing the critical roles of software development, architect, developing automating, deploying and operating, intersecting each loop are six spokes that describe the production considerations every engineer must consider throughout the development process, test, secure ability, reliability, observ ability, flexibility, and scalability. The considerations listed are not all encompassing. That's probably what a lot of you are thinking there are of course, things not explicitly included. But I figured if I added all the considerations we have to think about, we might get a little overwhelmed. Certainly, I would now let's dive into each element. We have long used personas as the default way to divide audiences and tailor messages to group people. Every company in the world right now is repeating the mantra of developers, developers, developers. But personas have always bugged me a little bit because the approach is typically either oversimplifies someone's career or needlessly complicates it. Few people fit cleanly and completely into persona based buckets like developers and operations anymore. The lines have gotten fuzzy. On the other hand, I don't think we need to tailor messages. So specifically as to call out the difference between a DEV ops engineer and a release engineer or a security administrator and a security engineer. But perhaps most critically, I believe personas are immutable. A persona is wholly dependent on how someone identifies themselves. It's intrinsic, not extrinsic. Their titles may change. Their jobs may differ, but they're probably still selecting the same persona from that ubiquitous dropdown we all use when registering for an event. Probably this one too. I was a developer. I will always identify as a developer despite doing a ton of work in other areas like DEV ops A I ops Deverell, I think about problems from the perspective of a developer. It influences my thinking and my approach roles are very different. Roles are temporary inconsistent, constantly fluctuating. If I were an actress, the parts I played would be lengthy and varied. But the persona I would identify as would remain an actor, an artist, your work isn't confined to a single set of skills. It may have been a decade ago, but not today in any given week or sprint. You may play the role of architect thinking about how to design a feature or service a developer, building out code or fixing a bug, an automation engineer thinking about how to improve the manual processes that we often refer to as toil a release engineer, deploying code to different environments or releasing it to customers or an operations engineer, ensuring an application functions in consistent expected ways and no matter what role we play, we have to consider a number of issues. The first is test ability. All software systems require testing of various types to assure architects that design works, developers, the code works operators that infrastructure is running as expected. And engineers of all disciplines that code changes won't bring down the system. Probably testing in its many forms is what enables systems to be durable and have longevity. It's what reassures engineers that changes won't impact current functionality and a system without tests is a disaster waiting to happen, which is why it's first among equals in this particular round table security is everyone's responsibility. But I think few of us understand how to design and execute a secure system. I certainly struggle with that security incidents for the most part are what we call high impact low probability events. These are the really big disasters, the ones that get us all free credit reporting for a year and end up on the news. They don't happen super frequently. And thank goodness because we all know that there are endless small vulnerabilities lurking in our systems. Security is something we know we should dedicate time to but often don't make time for and let's be honest, it's hard and complicated and a little bit scary. It's intimidating. Devs. The first derivative of DEV ops asked engineers to move security left this approach meant that security was a consideration early in the process and not something that would block a release at the last moment. This is also the consideration under which I'm putting compliance and governance now it's not perfectly aligned, but I figure everything you call a lawyer for should live together. But in all seriousness, these three concepts are really about risk management, identity, data authorization, there's a ton of different derivatives. But the question is really who has access to what? When and how and that is everyone's responsibility at every stage site. Reliability engineering or SRE is a discipline a job, an approach for good reason. It is absolutely critical that applications and services work as expected for the vast majority of time that said availability is often mistakenly treated as a synonym for reliability. But it's not, it's a single aspect of the concept if a system is available and usable. But customer data is inaccurate or out of sync. The system is not reliable. Reliability has five key components, availability, latency, throughput, fidelity and durability. Reliability may be the end result. But it's resiliency. For me the journey, the action that engineers can actually take to improve reliability. I'll talk more about that. In another talk, observ ability is the capability to have insight into an application or system it's the combination of telemetry monitoring, alerting all of it, everything that is available to engineers and leadership to have visibility into their system. There's an aspect of observable that overlaps with reliability. But for me, the purpose of observable isn't to maintain a reliable system though that is important. Instead it's the capacity for engineers working in a system to have that visibility to the inner workings of that system. The concept of observably originates in linear dynamic systems fancy and is defined as how well internal states of a system can be understood based on information about its external outputs. It's critical when companies move systems to the cloud or utilize managed services that they don't lose visibility and confidence in their systems. The shared responsibility model of cloud storage, compute and managed services require engineering teams to be able to quickly be alerted, to identify and remediate the issues as they arise. Flexible systems are capable of adapting to meet the ever changing needs of the customer and the market segment. Flexible codebases absorb new codes smoothly. Embody a clean separation of concerns are partitioned into small components or classes and are architected for the now as well as the next and flexible systems change, dependencies are reduced or eliminated. Ideally, database schemas, accommodate change well and components communicate communicate via a standardized and well documented api the only thing constant in our industry is change. And in every role we play, creating flexible systems and solutions that will grow as the applications grow and the customer base grows is critical. Finally, scalability, scalability refers to more than a system's ability to scale for additional load. It implies growth. Scalability in the revolution model carries that continuous innovation of a team and all the byproducts of that growth within a system. And for me, scalability is the most human of the considerations. It requires each of us in our various roles to consider everyone around us, our customers who use the system and rely on its services. Our colleagues, current and future with whom we collaborate and even our future selves. Pulumi has this great perspective on cloud engineering that it can be divided into three main components, build, deploy and manage. I really love this. It's simplicity and clarity and I especially love how it fits the new model. If you overlay cloud engineering onto revolution, you get this perfect target that allows all of us to focus on the various roles and considerations. Software development isn't a straight line nor is it a perfect loop software is an ever changing complex dance. There are twirls and pivots and difficult spins forward and backward. Engineers move in parallel, creating truly magnificent pieces of art. We need a modern model for a modern era and I believe this is just the revolution to get us started. Thank you so much.

---
