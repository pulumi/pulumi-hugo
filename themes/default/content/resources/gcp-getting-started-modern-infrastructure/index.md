---
preview_image:
hero:
  image: /icons/containers.svg
  title: "GCP | Getting started with Modern Infrastructure"
title: "GCP | Getting started with Modern Infrastructure"
meta_desc: |
    It just takes a few minutes to get started deploying infrastructure on GCP using Pulumi.
url_slug: gcp-getting-started-modern-infrastructure
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "GCP | Getting started with Modern Infrastructure"
  description: |
    It just takes a few minutes to get started deploying infrastructure on GCP using Pulumi.  Give it a try: https://www.pulumi.com/docs/get-started/gcp/  Pulumi is free, open-source, and supports many clouds, including GCP, AWS, Azure, and Kubernetes.  The examples are in Golang but Pulumi makes it easy to stand up infrastructure in your favorite languages including Python, JavaScript, Go, and .NET - saving time over legacy tools like CloudFormation and Terraform.
  sortable_date: 2020-04-13T16:18:00Z
  youtube_url: https://www.youtube.com/embed/kpaaFuyH3y8
transcript: |
    Today, we'll use Pulumi an open source modern infrastructures code tool to provision cloud infrastructure. Pulumi supports lots of clouds and different cloud architectures. But today, we'll be using GCP to host a public website. We'll assume we already have the Pulumi cli downloaded and we'll create a new Pulumi project. We can name the project, give it a short description and we'll also tell it uh some things like our stack name and the name of the uh project we're going to deploy into. So once we've done that, we have a small pluming program template, let's take a look at what's in here. So you can see we import a couple of packages and then uh we're gonna go ahead and change the first line here to actually indicate the name that we want to use for our bucket. This is because we're going to create a website bucket and we'd like to actually have a website name that matches uh the corresponding bucket name. So we'll just call this uh a DNS name that we've already pre created that actually points out to Google storage. So here we have a name G CS example dot Pulumi dot TV. So we can easily run Pulumi up. What this does is it, it actually generates a preview of the things that we'll deploy. We take a look, it looks fine. So we say yes. And this will actually start to call the API S against G CS uh GCP. And you can see we created our bucket, we can actually open this in our Pulumi console and see that we have our preview that we have there. And then we also see the resources that were created. So we come back to our terminal and we can use GSU to take a look at the bucket and uh we can actually use the output that we generated from our program. So as expected, this will turn an empty result since we have nothing there yet. So let's put something in our bucket. Let's create a folder, dub, dub dub and we'll create uh index dot html and we'll create a very simple uh website, just throwing some stuff here. And now we have to read this file into our program. So how can we do that? We can just use the native uh primitives in any uh programming language in our case? And go, we can use IO Il and read that directory to find those files. So once we have that set of files, we can iterate through those files again, using the standard way you would do so and go and for each file will create a new bucket object, you can see that we actually have auto completion uh in our ID. So we name the resource, the name of the file and we pass in some uh arguments uh to create this object. So in particular, we want to tell it what bucket to place this file into uh the name that we wanna have this file be on the, on the, in the, within the bucket. Um And then finally, uh we have to actually tell it where to get the, the file. And so we can actually create a, a file asset. Uh This is a built in uh object in Pulumi as well. So we passed that www uh file uh path. So this will actually create a file uh in that bucket uh using the contents of the files we have on disk. So if we run, pull me up, we can see from the preview that we'll end up creating a new uh bucket object. But you'll also notice that nothing else has changed. Just this new bucket object is being created. So when we call the uh when we say yes and actually perform the update, you can see one resource is created. And when we use GSC, we can see that that file is now in our bucket. If we try to curl this particular URL, uh you'll see that this doesn't work. So we uh get this access denied exception. And the reason for that is we haven't configured the bucket to be a website yet. So let's go ahead and do that. So we can go and add this additional argument to the bucket itself. So we modify the bucket and now we're gonna pass in a uh parameter to give it uh to, to tell uh the bucket what we actually want. Uh As far as the website goes, uh there's a main page suffix. So actually, uh go ahead and say we want to use the index studies gmail file as our main uh page. And then of course, we need to make that file readable uh by the public. So we're gonna go ahead and uh add an apple to that object. So first we need to actually have a reference to the object. And then of course, uh now we can go ahead and add the, add the apple to the object. So that's as simple as adding another object uh in our programming uh code. And here we just create a new resource. You'll notice we can actually name the resource, the same thing we call it, file that name again. Uh Just like we did before. So as long as uh the names are unique across types uh within the same type rather, uh it's gonna be, it's gonna be fine. So here we create this new apple, we give it the bucket uh again, the same bucket from before. And we actually use the output name of the of the object um in case it's pre computed uh or it's computed rather. And then we give it a predefined apple of public read. You know, notice we actually wrap this in a Pulumi dot string. This is so that it's typed uh to be an input. And now if you run, pull me up, we'll see that we're gonna have a 11 diff and one create. So the diff is the diff to the update is the, the update to the bucket uh which you see that updated. And then the create is the create of the object ale. And now if we curl the website, it comes back as we expect. So, in a few easy steps, we've actually created a public website uh which is a few lines of code, we can now destroy uh the stack so we can call Pulumi destroy which will remove all the resources that we have created. And if we want to leave no trace behind of what we've done, we can uh go ahead and call Pulumi stack RM. So you can see earlier, I just curled show that that is actually gone. And then now finally, uh we've removed uh the stack as well while this example used go GCP and manually deployed from the command line. Pulumi supports many different languages, cloud environments and C I CD environments to make automated delivery easier. Pulumi is open source and free to use. Give it a try today.

---
