---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Cloud Engineering Summit 2021: Building Arm Compatible CI/CD Pipelines"
title: "Cloud Engineering Summit 2021: Building Arm Compatible..."
meta_desc: |
    Arm architectures are increasingly popular and are becoming widely adopted by teams and organizations. As this adoption grows, developers and organ...
url_slug: cloud-engineering-summit-2021-building-arm-compatible-cicd-pipelines
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Cloud Engineering Summit 2021: Building Arm Compatible CI/CD Pipelines"
  description: |
    Arm architectures are increasingly popular and are becoming widely adopted by teams and organizations. As this adoption grows, developers and organizations must ensure their software and services are capable to support Arm architecture which begins by ensuring their CI/CD tooling and workload are Arm capable. In this presentation, attendees will learn how to ensure their CI/CD pipelines and workloads are Arm compatible and capable of providing Arm support in their products.  Talk by: Angel Rivera
  sortable_date: 2021-10-20T23:00:43Z
  youtube_url: https://www.youtube.com/embed/oVFw-QhbACw
transcript: |
    Hello, everyone. I wanna welcome you to my talk today. And in this talk, I'll be discussing how to build Docker images for arm architectures from C I CD pipelines. Before I get into that, I'd like to introduce myself. My name is Angel Rivera. I'm a developer advocate for Circle C I. And in my role at Circle C I, I'm engaging the developer community and understanding how they're using technologies as well as some of the struggles or obstacles they face while implementing or using these technologies. I bring that information back to my team at Circle C I and we use those learnings to build valuable features for our developers and our customers to ease their lives while developing software. If any of you want to reach out to me after this talk, uh you know, to discuss the talk or discuss anything in general. Uh You can reach out to me via Twitter. Uh My punk uh my punk, my Twitter handle is at punk data. So, uh again, if anyone wants to reach out and have a discussion or just, you know, to chat uh Yeah, hit me up at punk data on Twitter. Uh here's some fun facts about Arm. Uh If you didn't know arm stands for advanced risk machines. Although in 1984 when arm was originated or created uh in England, uh it was actually initially named the Acorn Risk machine. In 1987 arm became the first commercial risk processor available. And in 1990 the Arm LTD company was formed and that's when the name changed to what it, it's currently known as the advanced risk machines, uh uh processor. And you know, arm has been around for quite some time. Uh In 1986 it was powering the Apple two GS and in 1993 it was also powering the Apple Newton device. Uh So again, it's been around for quite some time. But in recent years, there's been some evolution or innovations made within the Arm architecture. Uh If you didn't know arm processors power a lot of uh smartphones, tablets, uh Raspberry pies and also tons of IOT device and smart devices such as televisions, appliances and wearables. You know, arm is pretty much in almost uh all of the things that we probably use, you know, our mobile devices that we use on a day to day. Uh And it's been supported by pretty much all the major operating systems. Uh It's definitely been supported by Linux for quite some time. Uh You know, and I know that for a fact because I've been using Linux, Linux for many, many years. And always have seen the Linux distributions right uh for for arm, which is pretty, pretty cool that you know, that operating system in that community has always kind of been there to support uh those arm architectures. Now arm is pretty popular in those, you know, mobile devices and IOT devices, smart devices because uh the arm processor does a great job at processing data while using very low power. So compared to the X 86 processors, which are, you know, a bit snappier. Uh and, and and faster in certain regards, um it still uses way more power than an arm processor. So you know, that's why it's kind of a great fit for uh these uh mobile devices. Anything bat uh battery powered right arm is a great fit for because of this uh low power consumption and it's still pretty quick at processing data. So it's a it's a good fit. Now. Um I wanna talk about uh arm and, and implementations of arm. I kind of gave you examples already about, you know how it's powering smart devices, smartphones, um you know, and all the uh kind of battery powered devices. So I wanted to share some information about, you know, some of how arm has kind of uh been the innovations within arm have kind of been uh applied to uh a real world use case. So let's talk about IOT sensors. Um What I'm gonna use in my example is a moisture sensor which is essentially detecting how much moisture is in something. Uh In this case, I'm gonna use the example of a moisture sensor in a farm, right? So this is a real world use case where uh farmers are using moisture sensors to detect how much moisture is in the ground so that they know how much water uh to, you know, apply to their crops. Uh This is a great way for them to kind of be efficient with watering and also helps with their growing process. So if you look at the sensor that I'm showing you in the slide um has a little wire connected probably to a battery. And you can imagine that also has a cellular type device to connect right uh to a cell tower and then send the data from that moisture sensor back over to some server, some infrastructure that can capture that data and make sense of it. Uh In this case, right? Um the moisture sensor probably has an arm processor. Uh But you know, again, it's, it's supposed to be a, a power, a battery powered device, right? Because you're sitting in a farm, you don't need to have cables everywhere. Uh Also, when you're picking the plants, you don't want to get caught up in any cables. This is all kind of wireless technology. Uh But the idea is, you know, uh those sensors should have a long battery life and the only way to do that is to conserve uh on things such as, you know, processing and then also uh chirping or sending that data back to the data center um in recent uh years or, or yeah, years, you know, this has evolved, the, the arm ships have evolved, they've become more powerful, they become uh more efficient with power. And one of the cool applications that I'm starting to see is, you know, when you have IOT devices sitting in a farm like this remote um the the farm or the the the organizations that are uh you know, implementing uh these, these moisture sensors are now leveraging uh something called an edge server. And an edge server kind of sits a little bit physically closer to the moisture uh sensor so that it can capture the information. So it's no longer sending data to, you know, a cloud and, and seeing more battery power, it's actually uh sending data to a device or, or some sort of system that's on site next to or clover in close proximity to the to the moisture sensor. And it's not consuming a lot of power. It's also uh able to process data uh you know, directly from the sensor in kind of a a near real time situation and then send uh a more polished or more refined data set back to the ultimate infrastructure, right, which is maybe some, some server and some cloud system somewhere. Uh But at the end of the day these edge services are, are basically like preprocessing, right? They're taking some information from the moisture sensor and then processing it uh maybe doing some kind of uh even A I on, on, on the data and then sending you know, data up to up to the uh the final infrastructure that's capturing it. So, you know, these are the kind of advancements that are being made. Um And these these edge servers are starting to be powered by arm processors. And the reason is number one, the power right consumption again, uh you know, even though you have a device that that's uh you know, processing stuff, uh it it could still use a very, you know, benefit from using very little power consumption. And the arm processor does that uh the other part to that is the arm processes are getting faster. So they're able to um you know, uh process that information just as good as an X 86 architecture. So yeah, be on the lookout for kind of these arm powered edge devices which are, you know, kind of uh becoming the norm within IOT type architectures. And it's a pretty interesting time to be uh you know, viewing or, or seeing how, how this is a advancing and and the innovations that they're making. So again, right? Um with the IOT uh services or, or device edge edge devices, um they're gonna need IOT edge applications, right? So those devices are gonna need to run applications that, you know, whenever the, the data from the sensor comes in, it's gonna have to, you know, do some calculations or, or maybe even uh do some sort of, you know, uh machine learning type situations where it's identifying patterns of watering patterns, right? And then spitting out the best uh the best times to water or, you know, any kind of application like that. But at the end of the day, uh those edge server devices are gonna need iot uh edge applications to run them on. And what I'm seeing a ton of is um these devices are running uh some form of kubernetes, right? Uh And that's where kind of where if, if you're running kubernetes, you're definitely gonna have to be running uh your application inside of a Docker image. And that's where we have to build a Docker images that support arm architectures. And I'll get into that in a few. Uh So another application for arm architectures or CP US or processors are for arm powered servers. Um Some cloud companies now are actually offering up uh cloud resources or compute nodes that are arm powered, right? Uh That means the, the underlying hardware that hosts your virtual machines are using an arm processor and also uh requires you to use an arm uh capable kernel. Uh And the reason is because um you know, arm and X 86 architectures are not compatible. Uh And the reason for that is uh they just use different instruction sets, right? So the processors understand uh their directives in a different way. And that's basically one of the reasons why, you know, you can't use an X 86 architecture or kernel uh or applications with an arm uh uh processor. Uh it will not understand the application, right. Their application is built for a specific instruction set and you can't mix and match those. So that means, you know, you have to compile your code to whatever architecture you're targeting. Uh because actually the code doesn't really care about where it's operating on. Uh But the the hardware actually cares about what kind of uh software is being compiled and executed on it, right? So uh the software, if it's built for XX 86 and again, you're running it on an arm uh hardware, it's not gonna understand that the process is not gonna end the, so understand the software and what it's trying to do. So that also uh kind of leads into uh Docker images that incompatibility, right? So with arm uh you, you need to be cognizant of when you're building Docker images that you're building to an Arm architecture and not an X 86 architecture. So arm compatible Docker images, right? Uh Again, you need to need to be be cognizant of where you're targeting. Uh And again, if you're targeting an arm uh architecture, you obviously need to build for that Docker image for an arm uh processor, right? So one of the ways you can easily do that is by implementing, you know, building your docker images within C I CD pipelines um that streams line streamlines the process. The problem is a lot of the uh current uh C I CD uh providers uh don't have arm uh building capabilities or arm uh capabilities to build your software. They don't have the hosts in, in the runtime to build your software. Uh But you're in Luck Circle C I has actually recently released uh that uh arm uh resources. So we now have the ability for people to leverage uh arm uh in their, in their C I CD pipeline. So you can build your app application to an X 86 platform or if you choose to, you can also build it for an ARM architecture. And the way we did that is providing what we call resource classes, which again are arm capable underlying hardware, right, where you're running your code. So with that uh addition of the armed resource classes, uh we're able to en allow developers to build uh their applications, compile them for arm, right? And they also can build Docker images that support the arm architecture. Uh And that'll give a nice clean arm uh feel across the board. So you can test your applications in arm, you can run uh you know your code on an arm uh hardware or arm uh processor and know that the applications, the Docker images and anything you build uh on that platform, the arm arm platforms within your C I CD pipeline are gonna function uh in whatever arm architecture you're targeting, which in this case could be a kubernetes cluster. So in this demonstration, I'm gonna go and show you how uh you can implement AC I CD pipeline within circle C I that actually builds tests and deploys an arm capable Docker image to a newly created infrastructure. So let's get started with our demonstration. Uh What I have here, what I'm showing you here is uh the code example that I'm gonna use for my demonstration. Uh Essentially what it is is a simple static uh no Js application, it just renders a page. Um And this will be uh any code changes will trigger our C I CD pipeline that will do a couple things. So let's take a look at uh the C I CD pipeline. I'm gonna jump into just the building the Docker image portion of this pipeline uh or the job which is um listed right here. As you can see, I have a job named build on Docker image. And essentially what I'm gonna do here is uh build a Docker image that is uh built on an arm compute note or executor on the circle C I platform as well as create a new Docker image from this application. And the changes made to the application for deploying to an elastic uh container service on AWS. Uh and the container service will also use plume uh to be provisioned, right. So Pulumi will create all this infrastructure and it will also deploy this docker image to this newly created uh uh elastic container service cluster. And by the way, the cluster will also be uh uh powered by uh uh aws gravis on two arm compute nodes. So it's kind of an arm end to end arm experience uh with the C I CD pipeline. So let's get started. Um I'm just gonna quickly cover the main thing that you need uh to leverage an arm executor uh is and it's just these quick keys here which are essentially, you know, the machine which tells it tells the uh uh platform to execute or to give you an executor of machine type, which is a virtual machine. And then the resource class is actually where you uh define what kind of uh of executor you want to use. In this case, we want to use arm. So we would put the value of arm dot medium or large or whatever, you know, capacity compute node you want. I'm just gonna use medium here. And then finally, um let's jump over to the main point though one of the main points here is that um in order for you to build a Docker image that will be arm capable, you have to inherit from the docker image base, right? So Docker works as uh with inheritance, it inherits its uh kind of uh capabilities from a previous image. In this case, we're gonna use the arm 64 V eight version and with a node uh image, right. So this this line right here is essential in your Docker file uh to create a arm capable uh uh image Docker image for whatever service you're going to deploy to. Now let's show you how we're going to um you know, trigger a pipeline. So basically we got to change some code. Uh And I wanna add just a quick message here, no serve, node server running. And then I'm just gonna add, you know, some dots or whatever. Uh Then I'm gonna save it and I'm just gonna go through my regular flow, right? Like uh I don't know uh let's see, trigger build, right as a commit message just to speed things along. And then what we're gonna do is oh, we forgot to update that. So we're gonna say uh just call a trigger, right? Another message we'll do two pushes or two commits and we're gonna push this upstream. So once we have that pushed upstream, we're gonna jump over to our circle C I dashboard which has detected my code changes and it's going to run all the jobs defined in my config dot yo file. Now, um we'll get into the details of this after uh uh things have have run and uh been provisioned. So our Docker image uh job has completed. Uh And the Docker has been pushed to Docker hub. Let's check on our plume uh provisioning process. Uh So Pulumi is an infrastructure is code uh system that enables developers and operators to basically build uh their architectures and uh other cloud resources using code, right? So uh you can define all of those things uh using code in this example, I'm using Python. Uh And what I'm creating here is and AWS elastic container service powered by Aws Graviton two arm uh compute nodes. And then I'm also, you know, creating things like security groups, VPC S all from scratch, right? So the idea here is to build a pipeline that will test my application to in in the environments that I'm targeting for deployment. In this case, it's an ECs uh uh close powered by uh arm compute nodes. So our Pulumi application has deployed provision and deployed our application to uh the ECs cluster that it created. Um And we can test that the application is actually functioning on that cluster live by just, you know, copy and pasting the URL that was created. And then we'll just um show that to you here. The application is running in an ECs cluster. Uh If you want to take a look at that, we can show you that uh the cluster was created here. It's called APP arm. Uh And as you can see here, um you know, it's got a pretty much a service running. Um Here's some EC2 instances. Uh So it's a three node cluster. Uh And what I'm gonna show you real quick is uh the fact that uh it's running uh on a Graviton two arm compute node which is uh this designator here. Uh T four G, the G at the end or at the end of this uh initial uh designator or, or compute node type uh signifies that it's a graviton two arm uh compute node. So again, right, like this cluster is powered by arm. Uh the Docker image is, is built for arm uh and um the pipeline itself uh if you want to take a look at that uh actually um does what, what I call a smoke test. So as you can see, right, it did all of these things built a Docker image uh created and deployed this Pallo infrastructure. Uh It also performed a smoke test, meaning that it was uh the application deployed and is it functioning uh the way you know, we designed it to function. Uh In this case, it's a simple test that's just checking for an OK 200 which is it is responding and we verified it manually. But you can, you can imagine as a developer you're working in your flow and uh you don't want to stop to check if your app is running and then you continue on. Uh what you do is you build a pipeline like this. Um And then, uh you know, it'll automatically go through the process, smoke test. And then, uh right now I put it in a manual uh job is what we call it. Uh And the reason why I put that here is for this demo. So I could show you like, you know, you can do things like manual jobs if you actually want to that's running. But normally what I do is I just don't have this approved job step here. Uh Because what happens is um once it's, you know, smoke test pass, it'll just go ahead and destroy that cluster and I just click that button in order uh for the next step of my pipeline, which is to destroy all that awesome infrastructure we built using Pulumi. So that's basically it in a nutshell. Um If anyone wants to reach out to me uh to ask questions or, or, you know, get further details on this uh demonstration, um uh just hit me up at Punk Date on Twitter and I wanna thank you all for attending this talk, right? I almost forgot. Um I'd appreciate any feedback if at all possible uh from you. Uh If you could uh just use the RL that's on the screen and uh you know, send me some feedback, instructive criticism on how I can make this talk a little bit more informative or more exciting or just better it all the way around Uh I'd appreciate that. Uh, again, thank you and have a great event.

---
