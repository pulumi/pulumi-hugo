---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Getting Started with Policy as Code for Any Cloud"
title: "Getting Started with Policy as Code for Any Cloud"
meta_desc: |
    Prevent configuration mistakes from reaching production with Pulumi CrossGuard -  a policy as code platform for defining infrastructure policies fo...
url_slug: getting-started-policy-as-code-any-cloud
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Getting Started with Policy as Code for Any Cloud"
  description: |
    Prevent configuration mistakes from reaching production with Pulumi CrossGuard -  a policy as code platform for defining infrastructure policies for your stacks, teams, or organizations. Erin and Cameron from Pulumi show you how to create and enforce policies using your favorite languages.   Get started here: https://www.pulumi.com/docs/guides/crossguard/
  sortable_date: 2020-04-21T15:39:29Z
  youtube_url: https://www.youtube.com/embed/_8YYfhtTs94
transcript: |
    My name is Aaron. I'm a software engineer at Pulumi on the service team and I've been working on our policies code solution for a number of months. Now, Cameron, would you like to introduce yourself? Yeah, and I'm Cameron Stokes. I'm a customer engineer here at Pulumi. So I help out on the customer side of things and support side as well. So, one of Pulumi main focuses is enabling engineers to deploy infrastructure quickly. And on the the top gift here, you see that we are creating a ton of resources, right? We're moving quickly getting all of those resources provisioned, but that same stack below is actually halted to a stop because of the policies that we have in place. So we're gonna first start with a overview of, of why we wanted to create a policy as code offering. And then we'll look at the approach that we took at Pulumi and finally, Cameron will work, walk us through a demo so that we can see how you can use cross garden. In the past. There was uh a few select individuals or teams responsible for operations. This was a centralized team that had a lot of specialized knowledge on infrastructure. But now as we move to more distribute engineering teams, sort of this devs model, more and more people are responsible for infrastructure. And moreover, there's a lot of complexity with the number of cloud offerings as well as the number of clouds out there. Polling makes it easy to go multi cloud. But we wanted to also provide a way for users to do so safely. So we asked ourselves how we could help build in guard rails for organizations to to go multi cloud. And you know, there's a lot of articles out there. Uh We see kind of pretty frequently about uh a mis configured database or a mis configured S3 bucket. So our answer to this was was cross guard using policy as code. You can write expressive policies that enforce security practices, best practices, uh cost control, et cetera, and these policies get organized into policy packs. We leave it up to you on what you want to include within a policy pack. So you may choose to make one that is aws based, you can make one that's cost based. Um It's really up to you how you want to organize the policy pack. And here we have a, an example policy pack with just some Aws rules. There are two policies and each policy has a name, a description, an enforcement level and a validate resource or validate stack. And we'll get more into that later. But, but basically, it has an enforcement level which is either mandatory, meaning it will prevent the actual resource from getting created or advisory. This is just some advice that I'm giving, but they can still go ahead and create the resource and then there's that validator. So, validate resource here is what's actually validating the resource and is what's checking that the resource is in compliance using general programming languages. We're able to write uh policies that are expressive for a variety of use cases. So let's go look at um a bit of those different use cases that we see. So first cost optimization, you can write policies that ensure that a particular stack is is meeting some cost related guidance. So for example, you may want um cost allocation tags on your resources, which is this first policy that we see here. You may also want to have life cycle rules on logs to make sure those are getting cycled out appropriately. Your policies can ensure your data is properly protected. So here we have one policy that requires that storage be in us regions. And another one that requires that versioning is enabled on estate markets. Obviously, security is something that often goes with, with policy. So here we have one policy that prevents older versions of uh R DS or older versions of managed services. You wanna make sure that you're always using up to date managed services to get newer security patches and things like that. And the second rule is making sure that your security group is not accessible from the public internet. So using policy for in terms of security, you can make sure that your environments are always secure. And lastly, we we see um policy also being used for enforcing best practices. There may be best practices with in that piece of technology. So for example, here we have a Kubernetes policy that doesn't allow the use of pods and instead encourages the use of deployments or replica sets, something that has that built in replication. Now, this is like a technology uh best practice, but there may be something that's like team specific. You may have a naming convention that you use uh things like that that can also be written into policy form and then enforced on all your resources. OK. So kind of have an idea of what policy is and let's have camera now walk us through a demo of policy as code connection. Thanks. So uh to start, I'll, I'll spend a quick minute or two just describing um this plumbing application that I'm going to use as part of the demo. Um This is a typescript uh application but the same principles, the same concepts apply in all of the different languages that we support. Uh It's also an Amazon uh demo example. But again, same concepts in terms of how the pluming application as well as how the policies that, that we'll show here in a bit, uh also can apply across the different providers that we have as well. So at the very top of this uh typescript file, I'm, I'm just doing an import of our aws, our A DS X in our plume uh software libraries. These are no libraries because I'm writing a typescript. But again, these are available in all the languages that we support and these are just standard language libraries um to uh provide the capabilities of, of aws and plume as such beyond that, uh I'm importing a number of uh configuration values. Some of these are coming from the plume config system itself. Uh Others are uh coming from like a, an A DS query to, to, to find an Ubuntu Ami or an Amazon Ami and so on. And then uh we're gonna use the P Pulumi config system within this file directly to, to pull some dies out, define a few constants here at the top. So uh a set of tags that I'm going to apply across all of my different resources, a a public and private network space to, to use as well. And then the next bit is where we actually get into defining our actual resources that we're going to, to deploy and manage using Plume. Um In this case, uh I'm gonna create a VPC. This is using our A DS X uh crosswalk uh library that makes it really easy to create um kind of best practice. Uh VPC S and in just a few lines of code without having to, to, you know, redo that yourselves. Uh Every time beyond that, we're gonna create a security group, uh We're gonna reference our VPC that we defined above as an input into our security group and just define uh an ingres rule on that security group itself. In the last slide, we're gonna create a, a number of EC2 instances and we're doing this based on this instance, count uh configuration value that we're setting as a part of our, our config system. And then you can see we're just doing a simple four loop to create an instance. Uh you know, based on that instance, count that instance itself has an instance type that is set on it. Uh In this case, a T three medium, we're gonna associate a public IP address, we're going to uh use an ubuntu ami uh use the Subnet from our VPC and so on and so on. So pretty straightforward um uh plumbing application here, pretty straightforward architecture, just a VPC subnet, all of its related resources in that AWS X VPC security group. And an instance, it's kind of the normal um uh flow of of deploying an application or deploying infrastructure using plume is to do a plume up or plumy update. The first thing this update is going to do is uh actually run a preview. So this preview is kind of the, the dry run phase of Pulumi execution, which is, is gonna show you what uh Pulumi is going to do before it actually does anything. So this is your chance to review this, this preview. Um you know, decide, yes, this looks good based on, on the code that I've written, this is the, you know, the, the number of resources that I expect and, and so on. So in this case, uh we see my, my VPC, uh the subnet and route, route tables and so on that go into creating that VPC, see my security group and lastly, uh my instance count configuration value is currently set to three. So I'm, I'm having uh three instances be created as a result. So all that looks good. So I'm gonna go ahead and hit yes uh for me to go ahead and, and uh start creating and, and um deploying these resources for me and you'll see it should be pretty quick, probably take about 30 seconds here for, for everything to kind of get up and running. Um Looks like we're kind of done with all the VPC and related resources and now just waiting on those instances to uh to start up and again, this is without any policy in, in place. So uh uh I essentially have, you know, full access to all the the resource types and, and as you agree, some properties and I don't want to set here, the very end it prints out a link into the pluming console. So this is where we actually capture the same uh um output data that we saw on the train line. Uh We actually expand this and and see the full depth view of each of these resources as well to kind of see all the all the specific details that went into creating his resources. So uh let's say we actually want to put policy in place and then put some kind of guard rails on this to, to kind of limit what we're doing and limit um uh you know, some of those bad practices that Aaron mentioned earlier. So uh to do that, we, we create a, a policy pack as she described. So in this case, our policy pack um uh is uh named EC2. So uh all of these are gonna be EC2 related uh policies or a S related policies. Um But as Aaron described these, these can be kind of any, any grouping that you wanna do of your policies. So that could be uh cost reporting, that could be security, that could be best practices and, and so on this first policy that we have is going to uh do a, a resource uh validation or essentially a resource check. So it's gonna check every EC2 instance in our stack and it's gonna check that the associate public IP address value is set to true and if it is, it's going to report a violation and that associated public IP address should be set to false. Um, so essentially we're just checking that, uh, or rather we're discouraging the use of public IP addresses directly on our EC2 instances. And we're doing that with the, the, uh, enforcement level set advisory. So this means that it, it will be allowed, I'll be allowed to continue with any deployments that have these violations. But I will get a warning, uh, when I do that, that, uh, that, that is discouraged. Our next policy, uh, is to check for required tags. And specifically, specifically, it's gonna check for a name, uh, a call center tag and a sack tag. Um This one is set to mandatory, meaning that any violations that are found will actually block or, or prohibit my update from continuing, uh, if, if the uh violations exist. So again, we're specifying the type of instance, sorry type of resource that we want to check. We're gonna check for a call center, uh, tag. And specifically, we're, we're gonna check that this call center tag matches the name of our project. So not just that it exists, but we're gonna check the, the value of it as well. Same with our, our stack tag. We're gonna check that, uh, not only does that stack tag exist but it's set to the name of our stack. So in this case, it might be dev or demo or production. And then last way we're gonna check that, uh, a name tag has been set. In this case, we, we, we're not picky about the value of the name tag. We just want a name tag to exist there. Moving along. Our, our next policy here is gonna check uh um all of our A DS EC2 security group resources and it's gonna check that uh for each ingress rule on that security group and each side of block and that ingress rule is not set to uh the public internet. So again, just for um uh enforcing that we're not opening up uh you know, ports to the public internet in this case, uh Again, this one sent to advisory. So just get a warning if we have any violations here. So uh uh a few more policies, I'll go through and then I'll actually show this in execution. So um our next, my next policy here is going to check for uh allowed or even prohibited services. So, in this case, we're, we're specifying that IOT and Redshift services are, are prohibited. So, uh you know, I am not an IOT developer, neither am I a data engineer. I don't need to be deploying either IOT or Redshift resources. We just go ahead and prohibit those entirely. That means anything under the like IOT and Redshift umbrella of services or umbrella of resources rather uh will be, will be blocked from being deployed. Our next policy is a bit more of a of a complex one. So this is actually the the stack validation that Aaron uh described. So rather than checking an, an individual resource, we're gonna be able to do kind of an aggregate check across multiple resources in our stack. So in this case, I'm just gonna get uh essentially a reference to all of the resources in my stack. I'm just gonna filter it based on a S EC2 instance, that same uh resource type that we've been using, just compare the length of that, that uh list of, of resources that is found against a maximum in instance instance, count variable. And if it exceeds that report of violation, the distinction here is that we're, we're making this maximum instance count value configurable. We're, we're setting it to a default of two. So we're actually limiting the number of instances to be quite small number. Um But when we publish this to the plume console and, and actually go to configure it, we can apply uh a different um configured value here, two different stacks. So, meaning if I'm in DEV, we might want to limit the size of those um the count of the instances in a DEV stack to a small number. But if I'm deploying to production, I might need a much larger number in order to uh you know, to service our production workload. So when I again publish this, the console, I can set this maximum instance count to 100 or even 1000 or something, you know, um reasonable for our production workload, but for, for DEV and, and less critical stacks, uh I want to limit the size of that and limit costs essentially. And then lastly, uh this is again, kind of a, more of a complex check. Um We're gonna check that the AMI that I specified is actually owned by the, the appropriate account. So, um in this case, we want to allow uh self. So meaning any ami s that, that my account owns are, are are within my account or any Ami S that are owned by Ubuntu. We we trust that Ubuntu is publishing, you know, hard in this trusted, a trusted ami uh So we're gonna allow Ami from them as well. And this one is again a bit more complex because we're actually gonna use uh the AD BS API itself to query for details about the AMI that has been specified and then check the owner ID value of it compared to that list that we specified and then report a violation based on that. So this is one that's a bit more dynamic. And then we're also got querying for additional data as a part of this violation or part of this policy rather. So now that we know how we can use policy, let's take a look at how we went about implementing it and some of the features. So the first thing to policy is offering policy packs, we currently support writing policy packs in typescript javascript and python and our multi-language approach actually allows you to use uh a policy path back of another. So you may have a stacker in and go and you can enforce a policy pack. That's Python based. There are two types of validations, there's resource validations and those are sort of what we looked at earlier and those validate a particular resource type and they're run before the resource gets created or modified, there's also stack validations and those allow you to look at the stack as a whole and validate against all of the resources these get run after all the resources have been registered for the registered with the Pulumi engine. And so if you want a stack validation to actually halt the deployment, you do need to run it in a preview and we'll see that later on in our demo, that stack validations still can halt in a preview. OK? We've added a policy pack flag and this allows you to run policy packs locally against a stack. This is great for development of policy packs as well as is it's part of our open source offering. So you can use this without actually using the Pulumi service. And uh it's also a great way to run some tests. So uh there is actually a a blog post, I don't know if it's out yet or coming out. Um But on, on using policy packs for testing, so using the console, you can also enforce these policy packs on your organization. So there's a concept of policy groups, policy groups are basically just a grouping of stacks and then you can enforce a policy pack on that policy group. This can be used for having one set of policy packs and policies for non product and a different set for production. Using the Pulumi service allows you to automatically enforce these policies on your stacks and therefore it can catch problems before they get into production. So it actually incorporates the policy pack as part of your, your C I. And lastly, we've made policy packs configurable. So we wanted people to be able to reuse policy packs from one environment to the next which, which sort of talked about earlier, the having maybe a policy group for nonprofit, we have a uh an allowed regions array that is configurable. We've set the default to the US S two, but using the console, we're actually able to go and add to add regions to that allowed list uh instead of having to go in and edit the policy pack and republish it to the service. And by default, we also have the enforcement levels configurable so those can easily be adjusted to. So let's see this in action. So uh I've already completed my plume update. All of these resources have already been deployed. So I actually want to uh run this with policy in place. I use a policy pack flag that a legend this is just gonna run this, this policy pack code, uh, that I've just referenced in my, my local directory. Uh, show me any violations that are, that, uh, currently exist. So now up here we have a number of violations. Uh, each of these violations is based on one of these report violations, calls and it's gonna um specify the actual resource type and, and specific resource that had the violation. So I'm gonna scroll up to the top here. You see, the very first one that we hit is that discouraged uh EC2 public IP address policy. And it's gonna be for actually each of my instances that I've defined. So this next, uh next two policy violations are the same thing, but just for the other um, instances of that instance, next uh violation we have is that my security group, uh is in fact opening up uh a cyber block or opening up an English rule to the public internet using that uh 0000 sidewalk. I do have too many uh instances defined in the stack. So based on that instance, count config value on, on specifying or rather I'm deploying uh more instances than I should based on uh a default of two. And then I'm certainly missing some, some tags here as well. So, uh my call center tag does not match uh my, my, um, project name, my stack does not match my stack name and so on. And so on. So I've got a number of violations I need to fix up here. So I'll show, show fixing a few of these and then I'll go into actually publishing this policy pack to the console and seeing the results of that as well. So just to do some, some quick and easy ones here, um, I'm missing that base tags, um, um, value within my tag. So that's gonna add back my, my cost center, uh, and stack tags to my instances. I'm gonna go ahead and switch over the, uh, network, uh, that box that I'm specifying as well as a part of my, my rule. So I've not actually fixed all of these. I'm just gonna show what this looks like after fixing a few and then we'll go through that, uh, that publishing workflow. Mhm. So again, we're gonna see the same preview that we saw before. Uh, we should just see a number of, uh, a lesser number of violations at this point. So I'm still exceeding the, the number of instances that are allowed. Um, I have not yet actually addressed the associate public IP address, uh, uh, property. Um, but you can see, I've, I've cleared up the, the tags and my, uh, side block uh, violation has gone as well. If I scroll further up, you can actually see in the preview the, the actual change that would happen if I were able to continue, um, with this update. But I need to clean up the rest of those uh violations first. So, what I'll do now is actually publishing this policy pack to the council and seeing how the council can provide that organization wide enforcement across all of the stacks in my organization. So that I have a kind of a strong guarantee that uh my stacks are following policy and following those best practices that we have uh that we specified. So I've just changed directories into my. Um my policy is code directly where my policy pack code lives. I'm going to uh use the um the command line just to to publish this policy pack into my demo organization. So really all this is doing is just kind of zipping up this code, pushing it up into the console so that I can configure it and enable it uh within the console. So provided a link for me here at the the end of that uh publish. So I click in, I can actually see um some kind of high level details about the the policies that are in place in this policy pack. I can see the names, the descriptions, their their default enforcement levels and I can actually override this enforcement level when I can figure it uh when I apply this. So I click over to policies again, I'm within my demo organization. So this is the the point at which I can enable that policy pack that I just published and then have that organization wide enforcement through the council. So we have AAA default policy group again, a policy uh group as Aaron described earlier is uh a way to um group and enable your policy packs across the stacks within your organization. This default policy group just lets me turn on or or rather enable a policy pack across every stack in my org. So I'm gonna hit add, gonna select uh the policy pack that I just published and we select the latest version as well. So we actually allow you to publish new versions of your policy packs without yet enabling them or putting them in place. So this lets you have kind of a, you know, a a controlled and, and stage rollout of updated policies so that you're not surprising your developers and interrupting their workflow. So once I've selected that latest version, now, uh I'm getting the option to, to configure it. So we can see in my, in my owner's policy, we have the, the default values that I specified um in the code of itself so of self and then the ubuntu account, we have all the uh enforcement levels that I configure I can configure. And then lastly, we have our maximum instance count policy which is currently set to two. So again, I'm gonna leave that as default. I'm gonna submit, go ahead and enable this with those default values. And below, we can see all the stacks that this is going to apply to. So I've been working out of this demo ts web server demo stack, but this also applies to every stack in my organization. So now that I've been able at the, at the uh organization within the Pulumi console, when I come back to my um development environment and go to do a pull me up, the client is actually gonna handshake with the console and effectively say, hey, which policy packs do I need to run alongside this preview, download them and run them um Just as it was doing before, but without having to specify that policy pack flag. So again, as a developer, I don't have to remember to run that every time. Uh the console is ensuring that it's getting run every time regardless of uh of providing that flag or not. So uh we see the same violations that we saw before. If I go into the console here, I can actually see that. Now the policy is enabled. I can see all of the stacks that my policies are being applied to. So at a quick glance, I can see that I have policy enabled across every stack in my order and then click into the the demo stack specifically and see the history of it here. So uh through all the updates I've been doing so far, I don't have policy in place. Uh I, I've done that, that preview, but I've not yet actually completed it up. So let me uh resolve this last violation and then we'll continue with that update and see that uh see that in the console as well. So um my uh instance count value is again coming from that instance, count uh configuration value. So I just need to do a plum config set instance count. Let's set it to two, which is that maximum number of instances that's being set. Now, when I run and pull me up, I should see the same, um, uh advisory messages that we saw before, but now that I have no mandatory, um, uh, no mandatory violations, I'm actually allowed to continue with this update at this point. So this looks good based on, on my updates. Uh, we can see by changing that instance count config value from 3 to 2 actually deleting that third instance in this case, which is what I expect. Go ahead and head and hit. Yes. And now is gonna go and update my security group with the syre rules, update tags on my remaining instances and delete that third instance at the same time. If I go back into the console, I can see that particular update uh in flight right now, I can see that it's protected by policy and here in the next, um, you know, 10 seconds or so that answer should be deleted. And uh we should you done? There we go. So in this case, we can see kind of the hint as to what uh what happened as a part of this update. But we can also see that it is now protected by policy. So uh just to recap what we've seen, we uh saw how we can have policies that enforce um uh cost reporting. So make sure that there's a cost center and a project tag on our, on our resources, uh enforcing security best practices. So not assigning public IP address, not opening up security group rules to the public internet. Uh And then uh probably most importantly, publishing those policy packs or policies to the App Improvement Council and getting that organization wide enforcement of policy uh across all of the stacks in my organization. So I know that any, any of my developers that are pushing or, or promoting updates through any of the stacks in my or have these policies in place to protect them and, and put the, have those guardrails in place, so they're not doing anything against those best practices and against those policies. So now that uh Cameron has showed us what a policy has to offer, you can go ahead and try it out for yourself. There are a ton of resources to get you started for SARS. We have a getting started tutorial on the Pulumi dot com site. We also have examples in the examples repo under the policy packs, subdirectory. There's example packs there for Aws Kubernetes Azure, as well as Google cloud. We have a sort of uh token policy pack, which is our Aws Guard. It sort of shows you how to structure some larger policy packs. And then lastly, we have our Pulumi Policy robo, which whereas uh a lot of the magic or not magic, but the code behind the cross guard is in here. And it's also where you can open up issues for new features you'd like to see or any issues that you encounter.
---
