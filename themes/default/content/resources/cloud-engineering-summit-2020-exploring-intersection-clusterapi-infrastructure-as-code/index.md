---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Cloud Engineering Summit 2020: Exploring the Intersection of ClusterAPI and Infrastructure as Code"
title: "Cloud Engineering Summit 2020: Exploring the..."
meta_desc: |
    Cluster API is a Kubernetes project aimed at bringing Kubernetes-style declarative APIs to cluster lifecycle management. Pulumi aims at enabling de...
url_slug: cloud-engineering-summit-2020-exploring-intersection-clusterapi-infrastructure-as-code
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Cloud Engineering Summit 2020: Exploring the Intersection of ClusterAPI and Infrastructure as Code"
  description: |
    Cluster API is a Kubernetes project aimed at bringing Kubernetes-style declarative APIs to cluster lifecycle management. Pulumi aims at enabling developers and other professionals to leverage the power of general-purpose programming languages to declaratively define infrastructure-as-code, policy-as-code, and more. What happens when these two technologies are combined?
  sortable_date: 2020-11-11T00:29:37Z
  youtube_url: https://www.youtube.com/embed/ugdt-9p7vlw
transcript: |
    Hi, everyone. My name is Scott and I am gonna be talking for the next little bit about exploring the intersection of cluster API and infrastructure as code and what it might look like when you want to combine these two technologies together. Uh So I hope that you find the session uh useful and uh interesting and I hope uh that I'm able to share something that's uh you know, new that you haven't seen before. So let's get started. Here we go. All right. A little quick uh blur about me. I do strive to be a lifelong learner. I'm always uh looking at uh learning new things, which is one of the things that led me into. Um Pulumi. Um I was looking for ways practical ways to help expand my programming knowledge, which I'm still a new B at. So don't laugh at my code and I found that um using Pulumi and writing general purpose programming code uh for managing my infrastructures code was a nice use case that kind of helped me get a little deeper in some of the programming languages. So um obviously I'm a Pulumi user. I started with typescript and then, uh moved to go, um, a little secret, I'll share with you the reason I moved from typescript to go, uh, was that, um, there was a change in the Pulumi STK that required a typescript started using promises and a sync stuff and I totally didn't and still don't understand all of it and couldn't make my code work. So I was like, ok, fine. I'll just switch to go. I wanted to learn more more anyway. So worked out. Uh I do work at VM Ware. Uh I came in via the acquisition and my job there is to help folks with um stand up Cotti optimize their environments, that sort of thing and um sort of related to that. Um That means that I'm a big fan of cluster API. Um And I'll talk more about what that is in just a moment. All right. Um So speaking of cluster API, what is cluster API? It is a project, it's led by SIG cluster life cycle. Uh It's a project to bring Declarative style API S to cluster life cycle management so much in the same way that you would use a Declarative API to say I want to run this container image and I wanna have this many replicas of it and I want you to expose it on this port. Um And then goes and uses its core reconciliation loop to ensure that what you've asked it to do is actually, you know what's happening, right to reconcile desired state and actual state. Um The idea is we can use cluster API to bring the same style of declarative API S to managing cluster life cycle. So we can say I want there to be a cluster and I wanted to have three control plane nodes and I wanted to have a machine deployment that I can scale for worker nodes and so on so forth, right? And then we apply those definitions uh you know, stored in A L manifest. Um That Declarative state, we apply that to what is known as a management cluster. And that's a cluster that has all of the cluster API components and controllers and CR DS and such installed. And then again through that core reconciliation loop, that management cluster then realizes the desired state of saying that the A cluster exists and it it exists in this, you know, configuration, right. Um The cluster API was written in a way that allows you to use different is providers. So there's an ISP, there's a provider, a cluster API provider for AWS, a cluster API provider for vsphere for Azure, et cetera and so forth. And um as if it, you know, it wasn't confusing enough, we have cluster API which we refer to as CE and then the providers are the cluster API provider for AWS. So it's called CAP A and then cluster API provider for CAP for Vsphere, cap V cluster API provider for Azure cap Z so and so forth. Um Normally when cluster API interacts with these is platforms like Aws or Azure or whatever it will go and it will create all of the necessary infrastructure that you need. So you'll give it a manifest that manifesto define what the code infrastructure needs to look like. And then the provider knows what it has to create underneath that to support said S cluster. So on aws, um which is what I'll be using today to show off how some of the stuff works. Uh It would go and it would create a VPC and subnets and you know, gateways and route tables and all the necessary, you know jazz and um and it'll just do all that for you. And so the idea is that, you know, a user could then go and, and not have to worry about managing infrastructure. They can just do it all through cluster API however, for a variety of reasons, customers may want to consume their own infrastructure. Uh They may already have existing AWS structures that they want to use, they want to have cluster API simply use those instead of creating new ones. And so there is the model for supporting what we call, bring your own infrastructure, right? And which would allow you to say, well, here I already have a VPC and subnets. I want cluster API to use those instead of creating its own. Um And I'll, I'll show you what that's look like. And in fact, that's gonna be, you know, a key sort of part of the entire presentation is how we can use the cluster API um manifest or, or cluster API itself with infrastructure created using Pulumi for infrastructure code. Um And we'll look at some different ways to do that if you're interested in more information about cluster API itself. This is just a simple high level overview. Um go to the cluster API home page at cluster dash api 0.6 dot s dot IO or check out the github repository there um On the screen. Now, I wanna show you real real quick before I go on what um it looks like to um see a cluster API manifest. So let me switch to my demo screen here. OK. Here we go. Um And I'm just gonna manual. I have um a here we go a manifest. This is a cluster API definition. This is a complete definition that will create uh an, an entirely um independent cluster. And so you can see we have these custom resource definitions that cluster API uses things like cluster and AWS, cluster and QBDM control plane. And we have, you know, various fields that we can figure that what region it's gonna be in for AWS, what SSH key it's gonna use so and so forth. Um We can specify replicas and versions and so on and so forth, right? And uh we can map that down to specific, you know, instance types. So we could have, you know, the control plane. In this case, you see if CS demo control plane is the name of this object and I'm mapping it to a T three large because this is just a demo environment, but I could map it to, you know, an M five, you know, X large or whatever um here. And uh that gives you an idea of what's what's going on. So now let's flip back over to the presentation. Here we go with that in mind. Then um you know, what does it look like to have cluster API use existing infrastructure, what we call this BYO I bring your own infrastructure model. So users can create their own infrastructure, they can use an infrastructure code tool like Pulumi, they can create all the necessary pieces that are there and use all of the best practices that they would wanna use for infrastructures code, right? Um And then you can integrate that. So you know that that third bullet there on the screen, you know, is it possible to use IEC for BYO I with, with? Yes, absolutely. You can use infrastructure as code to manage the infrastructure that you are bringing into a cluster API environment. Um The answer to that fourth question, whether I can use even more acronyms than that in a single sentence we'll have to explore in some other session. OK. Uh All right. So uh let's see what we got here. Um What information does cluster api need about the infrastructure that you're bringing in if you're gonna do that. So if you're going to bring in your own infrastructure that you are managing through uh an infrastructures code tool like Pulumi cluster API has to have some of that information. So it knows that it's not supposed to go out and create new infrastructure. So what is the information that it needs? I'm speaking specifically here about Aws. So for other providers, it may vary. Um but each of the providers is pretty well documented in terms of like if you're gonna do this on Azure, you should be able to check the Azure documentation for the cost of A P A provider for Azure and see what information is needed, right? For Aws, you have to have the VPC ID, you have to have a list of subnets. Now, there's two types of subnets, there's public subnets and private subnets and cluster API has a series of checks. It uses to determine which is a public subnet, which is a private subnet. Um You need both. Um and typically a private subnet would be a subnet that um has to use a NAT gateway to get to the internet, right? So it's not exposing public IP addresses, it's not using an internet gateway, you have to go through a NAT gateway. Um So you have to have that list of, of subnets and and cluster API will prefer the private subnets to place the instances that it's going to create. So these machines will be on private subnets, they won't be exposed to the public IP address. And you'll be able to necessarily like SSH them directly. That means typically you're gonna have to have something like an SSH bastion host. If you want access to the, the nodes, there are other ways, of course, but an SSH bastion host is pretty common. And in that case, you're also going to need a list of additional security group I DS because cluster API can create the bastion host for you if you want. But you're probably going to be co locating because you're using existing infrastructure, you're probably gonna be co locating the scrub cluster in a VPC or in subnets that may have other things there. And so you may already have an SSH bastion host and associated security groups. So we use this additional list of additional security group I DS to tell cluster API put my instances into this security group so they can receive traffic from the bastion host. For example. Now full details on what is needed to do, bring your own infrastructure is at the URL here at the bottom of this slide and they'll give you all the details on what you need to bring and what cluster API will create on its own, right? Basically what you need to bring is a VPC sub nets. Um and those security groups, right? And then cluster API will create um EO BS uh as needed. It'll create instances and it'll create additional security groups that it uses for its own purposes to allow the nodes to communicate with each other. For example, it also in that document outlays specific requirements for AWS tags that are acquired by the AWS cloud provider for it to function correctly. And you do wanna make sure that your code that creates this infrastructure does assign those tags or else the Aws cloud provider will fail to function properly and then your cluster API uh your your cluster excuse me won't work like you expect it to work. All right. So I've laid the groundwork for, you know, sort of what cluster API is and how we do bring your own infrastructure and you know, have said, yes, you can absolutely do. I ac with something like Pulumi and use that with cluster API. Now, I wanna show you what that actually looks like. So we're gonna spend the rest of the time in this session, probably another 10 to 15 minutes or so, actually looking at this um through a set of real world examples, right, of potential ways that you could integrate an Infra infrastructure as code tool like Pulumi with cluster API. I've taken all of the examples that I'm gonna show you here. They're all in the github repository. You can see the URL here. So it's github dot com slash Scott low slash 2020 C SI AC I'm very imaginative when it comes to naming things like this. So, you know what we have here is 2020 Cloud Engineering Summit and virus code cluster API very imaginative. So let's look at this uh in my terminal, I'm gonna switch over to my demo terminal here. All right, there we go. And I've already shown you what the base looks like. So I'll just pull this up again. This is the base configuration we're gonna be using throughout all of the different examples. I'm going to show on how you can integrate something like Pulumi with cluster API. And this is a bare bones cluster API manifest. I created it using the cluster API tool, cluster CTL. So I gave it some information like this is how I created it. Um The information on the specific command that I ran for example is in the read me um uh in the uh in the repository, the repository that I just shared. Um And the first scenario that I'm gonna show you is this manual scenario. And so in that uh directory, um I have a few files and this read me here is where it'll actually tell you uh what command I use like right there you can see here's the cluster CTO config cluster blah blah blah, right? Um So take a look at that if you're interested in sort of replicating this on your own um the CE S demo yaml. That's the base configuration we're gonna use. You'll see a customization ya here. We're gonna use, customize one of the later scenarios. So for now, just ignore it. But um I already have this stack and let me see if I can remember. Actually, let me look at my history here. Let me, here we go. OK? So I already have this stack that I am using. I've called it a full BYO I and it goes through and it creates all of the objects that are necessary to do bring your own infrastructure with cluster API on AWS. So it creates VPC sub nets, route tables, gateways, net gateways, um all that kind of jazz and then it ex exports these fields so that we can use them later on. And when it comes to integrating infrastructures code, like what we're doing here with this Pulumi stack and cluster API you, you could do it manually and you could use a tool like um YQ or whatever. Now, I have an example of using YQ to pull this information out, right? And I've put them all into a script just for sort of ease of use. So let's take a look at that. So I have some variables at the top that just make it easier later on, you can change these. And the read me has information about what needs to be changed. If you want to replicate this on your own. Keep in mind this is a total hack. I wouldn't recommend this for like, you know, real production sort of use, but it will work and it will give you an idea of, of one way that you could integrate these two if you're interested. Um And so I'm using this tool YQ um There's a link to that and it's gonna have repository in the read me. But what I do is I, I make a copy of the original and then I write these additional fields that are necessary for cluster API. One of these is this network spec dot VPC dot id. And then I use the Pulumi stack output command to reach into my project into my stack and pull out the VPC field that I exported in my code. And then I do the same thing for the public subnets and then the private subnets or vice versa, actually sorry private subnets and then public subnets. Um I tried to use a bash for loop here but I kept getting errors. So I just hard goed it again. This is an example. It's a hack, right. And what this will do is it will go through and it will write all the necessary fields that are needed for cluster API to use the existing infrastructure, the existing VPC and the existing subnets. This example does not write any additional security groups in there. I'll do that in another example. So if I run this it'll take a minute or two to run while it goes and reaches into the stack and uh gets information out. And then, now I see I have a new file called modified. And if I look at modified at first, it looks like it's normal. But then when we get into the AWS cluster object here. So the second document, uh second YAML document in this file, you can see that this network spec VPC and SUBNETS is added there. And if I get back to the CE S demo, the original and I look there, they didn't exist before, right? So what we've done is we've modified the base configuration so that it has the information we need to use existing infrastructure. And if I were to apply this manifest against my cluster API management cluster, which is where the cluster API controllers and custom resource definitions live, then it would go and it would create a new uh what we call a workload cluster uh cluster that it's managing via cluster API and it would do so in the specified VPC. Um And in um the specified subnets, OK. Um There's additional stuff, by the way, if you need to, I if you want to distribute your cluster across multiple availability zones across multiple A Zs, um There's some additional fields you have to add the the control plane will do that automatically. So if we were to apply this, then we would see the control plane if there's multiple instances in the control plane, it would automatically distribute them across a Zs um worker. Nos are a little different. Um All this is in the documentation upstream, the, the link that I gave you earlier and I'll, I'll show it on the screen again towards the end of the presentation. So you have it and then I could just use QC TL to then apply um this, this manifest, right? I could just QC TL apply dash F. Now, I'm not gonna do that just yet because I have another way of doing that that I want to show you. But this gives you 11 idea of one way you could, you could do this right now. The other way uh one of the other ways is um here. And in this case, what I'm doing is I'm using a go template that I created from the base configuration and that's this ce S demo dot T MP L and then I have some go code that I wrote and that go code will generate that template using information from the stack and to pull the information from the stack, I'm using Pulumi automation API So let's take a look at first the template. So, so this is um a pretty standard, you know, go template. At first you don't see anything here, but then it's all, you know, standard, right? But then we get into the network spec stuff, which is where we need it. So you see, I have a reference to a V BC ID and then a range object for some Subnet I DS. And then further down here you'll see me use a field called hack. I'll explain what that is in just a moment. Um There's probably a better work around than what I'm doing here. But this is what I had to do for now to make it work. And then further down, I'll show you this is where we add the additional security groups. So under this AWS machine template, we have the spec, the template, the spec and then additional security groups and we would have a list there of any additional security groups that we needed to add. This case is only one and that's gonna be the bastion security group that will allow it to communicate with the SS bash. Now let's look at, look at the go code that I wrote. Um again, be gentle. I am a newbie programmer. So first I'll the find a truck that has the fields that I'm gonna need. Um And I'll uh there's that hack field. I'll come back to that in just a moment. I use the automation API to reach into my stack. I then pull out some values that I need. So the VPC ID, the bashing security group, the public subnets, the private subnets, put those in a combined field. Um And then down here, the hack field, there's a subsequent round of go templating. That cluster API does when it uses the template to create the cluster. And so what I did here because I kept getting errors in my go templating that it didn't understand what you know DS metadata was because I don't, I'm not passing that data to it. So instead I replace um my temporary field with the ultimate field that cluster API will use. Um And so where in the template it sees hack, then when I make my templating round, it will then substitute DS metadata, local host name, which is what cluster API will use and require. So then the rest of the code is all straightforward. It just generates the template and off it goes. So let's let's do this. Um We know there's no, there's no YAML file here, just the template, right? We're gonna do a go run main dot go. This will execute the code and it will use the automation API to reach in to my ce S demo stack, pull out the values it needs and then use go templating to generate uh a template. And so when I look at it here, now I have a YAML file based on that template. And if I look at that YA L file whoops helps to type, then uh we see YAML here and we see that we have the VPC spec and the subnets listed. And if I go further down um here under this configuration where you see name DS metadata. That's my hack, right? They replaced my hack field with a proper field that the cluster API round of um go templating will, will look for. And then down here in this AWS machine template, you can see that it populated the security group ID that it needs to communicate with my preexisting SSH question. And so now I could again use QC TL, apply dash F this emo file against my management cluster and it would go and create that, but I'm not gonna do it yet because I have one more thing I wanna show you. So let's go here. OK. So in this last example that I want to show you, I have uh built on the previous example, I'm still using the automation API. In this case, I have another local project that's stored in this Kates directory and it uses the provider and it's built in customized support. And what I'm doing here is I'm templating out some customized overlays that will receive the values from the Pulumi stack. Then the provider will use customized to apply those, those overlays against the base configuration. And that's defined in the customization dot Yale file. And that's why we had a customization dot YAML file in the manual directory because that's the base configuration that it's gonna be applying against. And then uh the provider will automatically apply that against my management cluster. So first, I'm going to uh my SSH channel is probably timed out. So I'm just gonna make sure that. Yep. OK. So let's reestablish that. OK. There we go. Now, you'll see that I'm talking to my management cluster. I told it to do get clusters this, the fact that it doesn't find anything, just shows that there are no workload clusters to find in my management cluster. So it doesn't have any clusters to find. And after I run this code, then we're gonna do this again and we're gonna see a cluster there which means that it has successfully generated the code and is looking at um and and is created in the cluster using the information from uh Pulumi the Pulumi stack to populate an existing VPC and existing subnets. But before we do that, let's look at the code. So first, uh the main code here, this is just an iteration from the previous one. So I still have that same struck because I'm using a template. And then I reference my original stack, my cafe full byo I stack which generates all the underlying infrastructure, pull the values out that I need just like I did before and then I define my templates. These are what, what will become the customized overlays and then it iterates over that list and generates the templates and then uses the automation API to drive that Kate stack which uses the customized or the coupon provider. And it's customized support to automatically apply this against my management cluster So let's look at that. Um So this is a pretty traditional looking set of Pulumi code. Um I left some comments in there in case you wanna try this, but you don't actually want to apply it. Um You can and then change down here on line 21 that you want to use that other provider that will just generate a set up of against uh directory, the rendered directory on your local file system. So you can see what customize is doing. I use that to test, but you might also want to use it just to see how it works before you actually try to apply it against an actual management cluster. So we've got our, our high level go program which is using the automation API it's gonna generate customized overlays and then drive the Kates project to actually apply those through uh customized. So let's do a Gory main dot go. The first part of this will run, it'll take a couple of minutes uh or about a minute, whatever and you won't see the output and this point it's going and it's generating the customized overlays um and uh and getting all that prepped and then in a moment, we'll see the Pulumi progress streamer pop up. There we go. And at this point it's gonna give us updates. So here it's actually running the customized overlays against the base configuration and then automatically applying them against my management cluster and it'll take a minute or, or, or so, and we'll start seeing some objects populating here. Here we go. Um And what we'll see when it starts populating objects is we'll see it populating cluster API objects. So you'll see a cluster object, an AWS cluster object machine templates, you know, control planes, blah, blah, blah. Um All right. So it creates all those, those items. Um says, OK, I'm done. And if I now do my CTL get clusters against my management cluster, bam, we have a cluster actually provisioning and you'll have to take my word for it that it's actually going into the uh VPC and subnets that we specified. Um and uh not creating a new set of, of resources, right? So we are using Pulumi to create our base infrastructure and then um driving pulling that information out from the base infrastructure to give it to cluster API so that it can leverage that. Now you, you could obviously take this even further with the automation API and you could, you could write a high level Go program that runs the initial stack. So I ran this or I created the ce S demo stack myself, right? But you could have it run the CE S demo stack, then pull the values out and then run the Kates thing. And it would be completely automated. So you wouldn't have to, to do anything. You would just run the Go program and it would create the base infrastructure and then you could para para it um so that you could just reuse that over and over again. Right. That would be cool. I haven't gotten all the way there yet, but the skeleton of what you see here should give you an idea of like what that would look like. Um And Evan uh Boyle um his examples on the automation API or on github. I didn't include a link to that in the presentation, but definitely look at those if you're interested in using the automation API. All right, we'll switch back to the slide deck now. OK. So that's um just a quick demo of, you know, some of the ways that you could integrate your infrastructures code solution using Pulumi with cluster API. Um And so you can obviously adapt those or use those as a springboard to come up with other ideas or whatever. Um Just wrapping up. Then here is a list of all the resources that I've referenced in the presentation. So all the links gathered together in one place. I also added um links to my site where I've done some articles on Cluster API and Pulumi. So if you follow those links, you'll get a tags page that just shows all of the articles that are tagged with that particular um tag. So all the, you know, cluster API articles or all the plume articles. Uh oh whoops. There we go. OK. So thanks for watching. I hope that the uh session was useful if you're interested in getting in touch with me online. I'm at Scott on Twitter. Feel free to reach out. Um Also Scott on github. Um Remember I am a, you know, new programmer, so don't expect to find anything like, you know, earth shattering there. But um I'm always looking for new resources. So if you are a more experienced programmer and you have some resources, you think I should take a look at, then feel free to reach out to me or uh whatever. And I'd love to hear from you. So, thanks so much.
---
