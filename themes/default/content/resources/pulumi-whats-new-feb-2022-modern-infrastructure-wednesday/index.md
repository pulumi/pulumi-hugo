---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Pulumi - What's New? (Feb 2022) | Modern Infrastructure Wednesday"
title: "Pulumi - What's New? (Feb 2022) | Modern Infrastructure..."
meta_desc: |
    In this episode of Modern Infrastructure Wednesday, David guides you through his three new favourite additions to Pulumi:
url_slug: pulumi-whats-new-feb-2022-modern-infrastructure-wednesday
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Pulumi - What's New? (Feb 2022) | Modern Infrastructure Wednesday"
  description: |
    In this episode of Modern Infrastructure Wednesday, David guides you through his three new favourite additions to Pulumi:  1. Update Plans 2. Top Level Async Await 3. Local and Remote Command Execution
  sortable_date: 2022-02-23T22:00:14Z
  youtube_url: https://www.youtube.com/embed/DNIUvtMXtlY
transcript: |
    Hello and welcome back to Modern Infrastructure Wednesday here. A Poli view. I'm your host David Flanagan. Although I go by the name rock code across the big bad internet. This week, we're taking a look at three culinary features that were released in just the last six weeks or poli. Let's not waste any time and dive straight in. All right. So let's take a look at the newest feature and Pulumi. Before we get started, we need a very simple Pulumi program simple. OK. So the first feature we're going to look at just now is update plans. This is a long requested feature that gives people the confidence to run Pulumi and a pull request and continuous delivery process. When the branch is merged, what you want is to ensure that a plan is generated at the pull request page saved as an artifact. And then when a pull request is approved and merged, that same plan can be executed was the goal being that there are no changes that would cause anything to slip through the net. So let's see what this looks like with Poly. The first thing we need to do is export an environment available to tell Poum that we're happy for our experimental feature to be played with. We turn on Pulumi underscore experimental equals true. No, when I run a Pulumi preview, it shows us that it wants to create a random password. Assuming I'm happy with this, I can save my plan as preview plan. There's nothing particularly fancy about what is saved. It's just a Json artifact that describes our plan. We can see that we have a new resource to be created. Then it was to save their plan. This modifier code, let's come in and generate one more random password. It's time for our admin user du du du. So this is a rather contrived example, but the use case and the situation may be. So when you approve something on a pool request and it's merged to your main branch, is that what you get may be slightly different? So let's see this in action by running Pulumi up pass in dash dash plan and pointing it to our plan fail. What should happen is that plumier will detect of what is in our plan is now drifted from what is defined in our code and no pluming update will be action. Perfect. Pulumi has noticed the drift and told us that create is not allowed by the plan. No steps were expected for this resource. This is the new admin password that we added after saving the plan file. So let's assume we're happy with this and we can save in your plan. And now we have that saved. We can run plan again. We can run, we can run Pulumi up and pass in our plan fail. So now you can have guarantees that what happens on a pull request can be saved and executed safely upon marriage. Ok. Let's take a look at our next feature. This is another long requested feature for Poli and that is top level a think away with the node Js run time. It's a pretty common request from pluming users, but they want to be able to use top level away in their pluming programs. And there are various use cases that make sense for this feature. It could be that you're trying to resolve the latest version of a docker container image for continuous delivery. You need to send an asynchronous request to the registry to pull back a list of tags and parse them. Typically, that response would only be available within a Zen block with top level of weight. You can say that you wish to await the result and carry on your program without too much juggling. Let's take a look at a more contrived example. Let's assume that we want a super secret information and we're gonna use the fetch EPA to do so. So the first thing we do is import fetch from an old veg and now we can see that we want to hit HT PB dot org. Anything message equals hello. Don't worry if you're not familiar with a to be be, but essentially that we pass to the anson end point will be returned in a response. And if we highlight the super secret information, we'll see that we get a promise of a response. Tap it away, we drizzle then and we'd get data and we could work with it. Yeah, I think so. But working within these band blocks can be rather cumbersome and recent versions of no GS using ESM support top level away. So let's delete all of that. And instead say that we wish to await that result, we can then say data equals or super secret information dot JSON. And if we look at this, it's also a promise. So we'll await that too. So let's just quickly con the log and see what we get you can run. So let me up. I will see that we have now successfully fetched and printed out are very valuable information. We could now consume our arnt message as the docker image tag, create a Knaus deployment and were plane sailing from here on in. But there's a few things to know about how this was set up. First. You need to come to UTS con dot JSON and you have to set target and module to es next, the next thing you have to do is come to your package, do you? So you have to ensure that you have the latest version of Pulumi. Remember if you're generating your plum project from Pulumi year, those boilerplate templates may have a slightly older version, always upgrade to the latest. And finally, you have to modify your plume YAML and add a node Js run time web options that tell it to use the TS node ESM loader and for this to work, there's one more thing that you need in your package dot JSON and that is TS not and that's that you can now use top level of weight in your preliminary programs. And the last feature I want to show off today is the new command package. So let's see this in action. First thing we need to do is import star as command from the command package from here. We can say that we want a local command equals new command dot local command. Now calling us, who am I from here? We can define commands to run when this resource is created and when this resource is deleted. So we're gonna keep this nice and simple and run. Who am I on to create on a delete? We're actually going to do echo. Bye. Bye to a fail contemper. Bye bye. We can then export the output and said that to our local command. The standard I I know when I run me up, they'll detect our new local command and when we run it, we get the who am I response available? You get the response available. At our stack. Finally, we can run for let me destroy and we have bye bye and the fail. Bye bye. You can also use this for remote commands. We can see a command dot remote man and run the same thing. We specify the create that. But now we can specify connection details. This can take a host as well as the port password, private key and user name. So whether you're using Pulumi or not for provision machines, generate SSH keys, you can provide everything that you need and a single program to handle all your local and remote command requirements. So that is my three favorite features of the last month from Pulumi. We have the ability to generate update plans and that gives us guarantees that what we're merging from our branch and pill request process is what will actually be executed. When with me, if you're not using a proto requests process, you can still use these plans to make sure that there are no side effects and what you're trying to do, we also take a look at no GSES top level Asyl way. This is going to allow for much cleaner code or one win for everyone. And lastly local and remote commands. Local commands are great. If you just need to be able to read something from a file or work out some context from the environment in which Pulumi is running remote commands are great when you're spinning up virtual machines. And you want to interact with the user data in some way, perhaps if you're spinning up a K DS cluster and you want to pull that coup config back to allow deploy in with a dynamic cober provider. And in fact, I wrote an article on this on Pulumi dot com slash blog. So thanks for watching Modern Infrastructure Wednesday. I'll see you all in two weeks time. Have a nice day.

---
