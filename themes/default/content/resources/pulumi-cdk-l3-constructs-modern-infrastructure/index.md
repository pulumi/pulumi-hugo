---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Pulumi CDK: L3 Constructs | Modern Infrastructure"
title: "Pulumi CDK: L3 Constructs | Modern Infrastructure"
meta_desc: |
    In this episode of Modern Infrastructure, David shows you a new Pulumi feature: interopt with AWS CDK. David guides you through using an AWS CDK L3...
url_slug: pulumi-cdk-l3-constructs-modern-infrastructure
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Pulumi CDK: L3 Constructs | Modern Infrastructure"
  description: |
    In this episode of Modern Infrastructure, David shows you a new Pulumi feature: interopt with AWS CDK. David guides you through using an AWS CDK L3 Construct.  Article mentioned in the video: https://www.pulumi.com/blog/aws-cdk-on-pulumi/ Pulumi CDK: https://github.com/pulumi/pulumi-cdk
  sortable_date: 2022-06-02T10:20:29Z
  youtube_url: https://www.youtube.com/embed/R4ut-C7XECE
transcript: |
    Hello and welcome to Pulumi TV. This is modern infrastructure and again, we are doing this live. So please feel free to be involved. If you have any questions or you want me to dive into anything in a little bit more detail, then please drop something into the comments and I will do my best to tackle them as we go. If you haven't seen modern infrastructure before, my name is David Flanagan and I am your host Modern Infrastructure. It's a show that we do every single week on Pulumi TV, uh where we try and show you some of the new things that are happening in the Pulumi Space or just new ideas and patterns with things that you can do with Pulumi that you may not be familiar with today. We are gonna take a look at something that was announced on May the fourth uh at our Pulumi Up event, which was our Pulumi and CD K and now my colleague Lee Brexit and I actually did a session at CD K day just last week where we actually showed people how they can, you know, pull and the CD K constructs enter their P program and run them all as one which is a really, really cool pattern because PLI really wants to be the tool for universal infrastructure is called our our opted ability does not end or start with CD K. You know, we support bridging terra farm providers, we support working with many other tools within this space. We have really great Cotti support and we integrate with other getups tools as well. Um So it's really just nice to be able to run a new plumbing program, pick your language of choice and be able to consume all of these different other ecosystems and the patterns that these, these other ecosystems are developing as well, which is what I want to show you today. So, uh I think without further ado it will pop over to my screen share. Uh And this is the article by our CTO um who talks about our CD K support on and he's got a few examples in here. You know, the first one is just using a CD K construct. This one is pull in the CD K lab AWS event target also pulls in lambda. And what you'll see here is that it defines the lambda function as a new rule and then uses the scent, have your viewers TDK before you'll be pretty familiar with this sub command. And this is what produces the output of the plan for things that are going to be run. Pulumi can consume that and put it into the Pulumi resource graph and then you just run a stack and the only thing special here and that is that we create a class that extends our Pulumi CD K dot stack. And that's it. Once you've done that, you then call the super and we have this remap cloud control resource, this is kind of emitted in this article. Uh Luke does talk about it but I want to show you exactly how to do this because from speaking to people adopting plume and using CD K constructs, this has been a bit of an opaque or confusing thing for them. So I'm gonna break that all down for you today. Uh And hopefully under 15 minutes. Uh and we have a wave. Hey Chris, how's it going? Thank you for joining us. So, uh yeah, there's more to this article and then goes on to talk about some more stuff here and eventually we get down to the remap control resource. Um So what happens here is that the AWS native provider and Pulumi uses the cloud control API to generate our native SDK. We don't use cloud permission whatsoever. We speak directly to the AWS API S, but we only have at least in our native provider knowledge of the resources published via the cloud control API, which admittedly is pretty vast. But there are a few things that slip through the cracks for that. We actually need to map them to resources on our Aws Classic provider, which is the one that bridges the Terraform provider. So you'll see here that a Lambda permission may not be an object on the cloud control API or Aws native. But we can tell it that, you know, when we get something that looks like this, this is how we construct it and I'll show you how to debug this as well. So don't worry, then goes on to talk about LC constructs. So these are really cool from the CD K ecosystem and this is where people are producing really nice fluent API S that allow you to do a small set of tasks. The one we were looking at today is where you want to deploy a land uh stick cloud front distribution in front of it and uh rest API proxy F VA API gateway like all of that can almost be one line of code and there are contracts that make that kind of possible. All right enough of that, let's get over to power code. So I'm going to open index and I'm using the API gateway Lada cloud front API L three construct. So the top one here is what connects all of the glue and makes our lambda available kind of publicly. But then we also need to use the lambda and API G directly. No, that's good. Creates a, well, this is just the properties and then we create it here. So we'll group, this is one right. But we're creating a Lambda function and we're doing it uh and online which means we're just reading this hello dot TS. And this is really simple. This is just a handler constant which is exported, which does a console log dot Hello world. So we read that and store that as a lambda and then code, we set the node GS run time and we tell it what the export is on the function and that will deploy our lambda. The next thing we need to do is define our API gateway properties. Again, I've put this into two, but you could do it in one if you wanted. And we're just saying that we, our handler is this function. Next, we use the LD construct from the CD K ecosystem where it, we pass in this API gateway and it does all the magic stuff for us with the proxies and the distributions we call the synth and then that's it. Um Then we have a component which I've horribly called my component. I am really sorry. Um But we just say we want a new component, we call it raw code. Now, I could change the interface to this. Of course, it may be that I want to pass in my javascript here. So this is entirely reusable. Um And I could do that too if I wanted. Of course, I'd have to make the, the A map and then we'd say code, you know something like that, right? And so once you get this working, it's up to you how you construct the API and what you want to make available to your developers or platform teams or anything like that. So this is really cool, but today's focus is on this remap method and the adapter and how do we make that work? So what I'm gonna do is come over here and run a prelim preview and this is going to kind of work to a certain point and then it's going to bomb out on. Uh And the problem here is that uh yes, there we go is that we have the resource type aws native API gateway, rest API is not found. So this rest API object is one that is not found in our Aws native provider and isn't mapped by our CV K INTEROP. So we can fix that. No, I've already adapter function. So I'll show you in a moment and it just lives in this adapter directly much like uh looks examples in the article. Once we have this function, we can modify the call to our super for our super tractor and we pass in a remap like so if we open this up, we open this up. All right, we'll do it this way. Uh We have a function here which takes in a whole bunch of elements. Now this is just the resources that involved the properties, the logical ID, other things to identify the resource that we're working with, we can normalize the props so that we can work with them in the standard javascript notation. And I've got one commented out here for a second. We'll come back to that, but here's the one that we're missing. What we say here is that we have an AWS API gateway rest API. Now, what's important here is that this doesn't actually map directly to the error message that we got, which is a point of confusion for people that are trying to work out how to build these adapters. Now it's close. Um But you need to be able to work out how do I know what that value is? And I'll cover that in a second. Uh Once we know what that value is, we've just used the Aws classic provider. So Aws here resolves to our Aws not native provider has the logical ID and then we expand the properties. Now, depending on what the properties are, you may get away with just doing props. But if there are nested values and a raise that need to be condensed into single values like this one here, um You will have to kind of deconstruct them the debugging approach to finding this identifier and the property values is the same um super hacking. But console dot log from here, we can say we found a type for and the properties of this type are X and this is going to give you everything that you need to know. Now, just one more catch to doing this. When we run Pulumi preview, you probably want to enable log flow and logs to standard error. Uh That just means you're going to see everything from the providers and no error messages are going to be left unturned. So that's from this. I have some coffee just now. So resources here. Um and maybe that I want to filter, I could wrap those constant and, and check for certain tags so that I'm not getting too much noise, but I know that we don't have too much here. So we are gonna scroll up and eventually. OK. Gateway roll. I should have put some Elaine's engine now. Where are you? Oh, I've been really silly. Uh This worked because I added the remap function. Uh Let's comment this back. I run it one more time. We want to, we want to see our type and then we'll see the properties. Uh So do we have to our, no. Uh Well, here we go. This is what we need. So, uh we have the fan type for AWS API gave a rest API that almost matches our error as close enough. We can see the properties here. We have the end point configuration which has types region and we have the name, which is the land rest API end point. We could see that types as an array where as an our native and our classic provider. We need to just have a single type and we break that down. Ok. Well, let's bring this back in. We'll turn off the noisy debug output. We'll run a preview one more time. We don't need the logs and that should just give us a happy preview. That just works awesome. It's gonna create 36 resources. I'm not gonna run it. It does take a bit of time. Um, but I'll show you one more example and we'll wrap this session up. So this works with, we got uh CD ecs. There we go. Uh This works with many of the, these patterns and resources ones. So I've got one more. Nothing on my VS code is working today. Uh So here we're pulling in the ecs patterns guide or um construct, we create a VPC, we have a cluster and then we're saying that we want a network load balanced fire gate service. There's a whole bunch of stuff that happens here. We don't need to worry about it. Uh We just provide a little bit of config and then we have a service with a scaling configuration like so uh and then we can send this just like we would anything else. So in order to run this, I need to modify my Plie gamma and I'm just changing the entry point using the main configuration to B ecs dot TS. And now when I run for preview, we will see lots and lots of things. Uh And now it's telling us that we have an Aws native application, auto scaling scaling policy not found again, we could turn on that debug logging come into our adapter and we'd see that this is actually called again something different than the classic provider. Aws at posing dot policy expanded all the props that's required, uh come back to here, runner preview and that will work. So what we're seeing here is that within pli programs we can use Aws CD K constructs. Oh, I'm just, I'm not expanding the prop trade, but I'm not worried about that. Um We did see that all the resources are here. Um But what we can see here with, with prelim programs, we can pull in CD K lib, we can use CD K contract even down to the L three advanced patterns ones to do a whole bunch of stuff for you and expose a nice simple API you do have to get familiar with rating the remap functions, do it once or twice, use console log as much as possible. And from there you'll be pretty happy. All you need to do is override or at least pass in and augment the options to the super const constructor with the remapping logic and your preliminary program will just work. All right. Thank you for tuning in. I hope that this is interesting. I hope that using the CD K within is something that you want to try. What I would encourage you to do is to one subscribe to this channel. Uh Give us a comment like this video, any of the above and stay in touch. I'm on Twitter at Rock Code. Happy to help you if you have any issues and we'll be back next week with more modern infrastructure. So until then, have a great day and I'll see you soon. Thanks.

---
