---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Learn GitOps with Pulumi and GitLab"
title: "Learn GitOps with Pulumi and GitLab"
meta_desc: |
    Deploy and update your infrastructure the same way you deliver the rest of your application: with real code delivered through your CI/CD pipeline. ...
url_slug: learn-gitops-pulumi-gitlab
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Learn GitOps with Pulumi and GitLab"
  description: |
    Deploy and update your infrastructure the same way you deliver the rest of your application: with real code delivered through your CI/CD pipeline. Learn how Pulumi’s modern infrastructure as code platform helps your team deliver features faster by helping you to define resources on any cloud using your favorite languages. Praneet Loke from Pulumi and William Chia from GitLab will show you how to super-charge your team’s velocity with GitOps.  GET STARTED: https://pulumi.com/start  In this video you will learn:     1. What is GitOps?     2. Create a simple infrastructure stack for a static website.     3. Infrastructure testing methodologies.     4. Setting up ‘PR to deploy’ via GitLab CI.  PRESENTERS William Chia - Senior Product Marketing Manager, GitLab Praneet Loke - Software Engineer, Pulumi  The examples are in TypeScript but Pulumi supports many popular programming languages including Python, JavaScript, TypeScript, Golang, C#, and F# and helps you define, test, and deploy cloud infrastructure as code with less effort than legacy tools such as Hashicorp Terraform, CloudFormation, and other template-driven formats. Pulumi works with all major clouds including AWS, Azure, Google Cloud, DigitalOcean, Alibaba Cloud, and Kubernetes.
  sortable_date: 2020-05-22T13:18:45Z
  youtube_url: https://www.youtube.com/embed/xI9uWFiEzAM
transcript: |
    Name is William Chia. I am a part of the product marketing team at GIT lab and in particular, I get to work with use cases that deal with cloud native software development using Cooper Netti and other cloud native technologies together with GIT lab and also our Gits use case, which is what we're talking about today. So I'm excited to be on the call and I am Pernet Loki ah and I work for Pulumi. Um I work on the service and our cli tools so to kick things off just to give a quick definition what is get ups. Um And there's, this is kind of a newer term, there's probably a lot of different definitions and practices floating around, but this is kind of how we define get ups. It's a, it's an operational framework and what you're going to do is take dev ops best practices that you use for application development. These are things like version control, code, collaboration and code review, all of your compliance and auditing that you get from your version control and automation using something like CCD. And you're going to take that rather than applying it to application development and deploying an application, you're going to apply that to infrastructure automation. And so today we're talking about infrastructures code policy is code doing your operations as code. And of course, we're going to show you how to do that with Pulumi. And so when you take those best practices, you apply them to your operations and you start to automate those, that is what we call get s and so looking at an application developer's workflow, you would have something like this where you start with a git lab issue, you create an issue and from that issue, you would have a merger quest to go and work on that, that particular feature. You commit your changes to the branch, your C pipeline runs your, your test and your build, you have some kind of staging environment, you can do peer review collaboration, discussion. Of course, there's an approval process and we'll show you that a little bit today, you then merge that back into master and your continuous delivery pipeline runs. And then of course, when you're running a production, you start monitoring that application. So if that's the application dev ops flow, let's take a look at the GS flow. It's exactly the same. The only difference is instead of it being application code, we're doing our, our infrastructure configuration. So as I mentioned today, we're doing this Pulumi but we're going to be storing our infrastructure is code and that configuration is code and the policy is code. And so you get all of these benefits, for example, the ability to do peer review and discussion and to do approval on changes before they go live. And uh I like to think about it get S and three main parts. So the first part as I mentioned is infrastructures code or sometimes you might call this access code because you could have other things like policy, your security, your operations, and then a really important part of get apps is that every change happens by merger request. So the change in operational structure here is rather than than manually going to your Kubernetes cluster and applying changes rather than logging into a particular virtual machine and SS somewhere and doing those changes manually. All the change to the infrastructure happens by merger request or on some other GIT platforms, they call this a pull request glab, we call it a merger request. And so what that allows you to do is that becomes the gate to any change happening that way you then have a log of all the changes that happen that you can audit, you could do compliance based on all of those changes. It shows who's allowed to make those changes. It makes access control a lot easier. All of these kind of benefits start to emerge, collaboration and review before just go live. When you have your, your configuration is code, your infrastructure is code and you're making changes by merger request. Then of course, if changes can only happen when you merge new code, then you need some type of automation. And so for, for GLAB, we're going to call that we're going to use GIT lab C ID to do all of our automation for it will show you what that looks like today. And with these three components, that's what we call, get up. So some of you may be already practicing some facet of this today. Um We can get a lot more sophisticated in terms of our automation, in terms of our practice, but these are the fundamental components and we'll show you how to get started with that today. So with that, I'd love to hand it over to Pernet. I am going to stop sharing my screen and give me just a moment to hand the presenter over to Pernet and uh that should be over to you to uh dive into the demo, right? Thanks William. Ah Hello, everyone. So, um as will you mentioned? Um So we do have ah demos today. Um So definitely hoping to not bore you with the slides too much. Um But ah the the demos are ah laid out in ah different categories today. Um So we'll, we'll take a quick look at um how to, how to get started with me. Um And then, ah you know, add a ah a GLAB C I configuration to it um as well as um deploying your infrastructure using Git lap C I CD and Pulumi um and making an update to your infrastructure um through the peer review process of merge requests which ah William talked about. Um And then also show you some of the features of Plume console and GIT lab um that allow you to troubleshoot any problems um that you may encounter with your infrastructure updates. Um you know, and, and basically understanding, you know, what, what's the uh reason for a specific update. Um And like what kind of information is available um and pulling me console um to help you understand that. Um So, um so uh uh what, so to talk about Pulumi itself, um you know, we uh Pulumi is not looking to redefine how you do um you know, uh the as code part that Will William is talking about, you know, we, we really want to leverage the power of uh general purpose uh programming languages um that, that are, that uh many of you are already familiar with. Um So, so I wanted to capture a um or, or show you a quick view of the canonical example of creating an S3 bucket um in one of the, in, in each of the programming languages that we support. Um So if you're a no Js developer, for example, you're used to creating um uh no Js apps by pulling in N PM packages. And, you know, you've, you've got tons of libraries that you can use. Uh well with me, you know, you'd, you'd be doing pretty much the same. Uh, we provide you with um N PM packages uh for various cloud providers that you can use. Um And by using a general purpose programming language, um you can apply the same concepts that you, uh that you apply with your application code, you know, um creating extensible com components and, um, you know, using um stack configuration or configuration that you can uh share across applications. Um you know, enforcing rules um based on your company's policies, you know, writing tests um and, and things like that and, and, you know, best of all, you know, it, it produces maintainable infrastructure code. Um One that is easy for you to understand even, you know, three or six months down the line when you're uh when you're trying to make an update to an infrastructure that uh that you probably uh wrote, you know, several months ago and uh you're navigating the code to understand, you know, why something was done. Um And, and so, um so that's really where, um you know, pulling me really empowers you. Um And um taking a quick look at um you know, how Pulumi itself um helps you with the C I CD um uh set up and, and, and specifically the ops workflow. Um So, uh while there are other commands that the uh Pulumi cli supports, um the two important ones are uh having the ability to run previews, um which we call the preview command and then having the ability to actually apply that update or we call it the up or update command. Um And, and the way that you would use these commands is um when you have a merge request, uh you would run the preview command. Um so that you get a sense of um you know, I, you know, I've got this, I, I'm trying to make these changes. Um How do these changes affect my infrastructure? Um And, and this is where Pulumi tries to um you know, look at the current state of your infrastructure and then look at the state that you're trying to change it to and show you a diff comparison of, you know, what those changes look like. Um And um with the up command, um you know, when, when your peer review process is complete and your approver approves your merge request and you've merged it. Um This is when you actually want to apply that update to your infrastructure. So there's this um you know, lock step. Um There's this um two step process of um having the reviews and then, and then actually applying the update itself um which, which ensures that, you know, you're, you, you don't have developers who are um just updating infrastructure as a please uh by going straight into the console or running one off scripts, you know, as as William mentioned, you know, um doing a bash and host and um, you know, updating infrastructure out of, um you know, out of band. Um So you have a clear and concise um trackable history of uh these infrastructure updates. Um And with the full context of why uh an update was performed. Um So without further ado, um let's um dive right into it. Um Like I said, I wanted to start off with um showing you how to get started with Pulumi, especially if you're new. Um And you don't know, um you know where to start. Um And, and then go on to showing you um you know, setting up the, um the project um and the con configuration to run an update. Um and then um show you how to make an update to your infrastructure. Uh Once you've done the initial uh infrastructure set up and then finally show you how to uh use some of the features and pull me to troubleshoot any problems. Um So, um so the first thing that you want to do is um make sure that we have the uh Pulumi cli installed. Um So I've already gone, done, done that um in the interest of time, but um uh if you have not installed the Pulumi cli on your machine, um you know, head over to Pulumi dot com um slash docs and then, um you know, find the installation instructions for your machine um and get set up really quickly. Um So I already have that. Um And a really good way to get started is um running the Pull me new command, which um gives you the option to um select a template that uh that suits your, um, you know, programming expertise. Um So that way, um you know, you can quickly get started or scaffold a project uh without having to worry about defaults and whatnot. Um So for this uh demonstration, I'll just go ahead and pick um aws javascript. Um And it's just kind of synonymous to um you know, for example, in, in the No jazz ecosystem, if you're, you know, if you're a no just developer you're familiar with or sorry N PM in it or the in it command of many of these CL I based tools. So this is kind of similar to that where it's a wizard based approach um asking you some questions about um you know, what your project is about and such. So I'm just going to go ahead and accept the defaults here. Um So this is an important concept. A stack is basically a large container. Um A Pulumi stack is a logical container of resources. So, um as you can see the default here is um you know, Pulumi is suggesting the name DEV for my stack name, but you don't really have to use that. Um You know, you can use, you can designate um your stack name um as you know, indicative of what kind of resources you put in there. For example, I've seen teams um call their stacks as, you know, database resources or, you know, or firewall resources. Um And, and so, and some other teams want to um use a mix of both, you know, it could be database resources, but, you know, it's the dev environment of that. So you may wanna call it that. Um So it really is up to you um to kind of easily identify what um does this stack contain? Um Right, especially if you're in a uh multi team environment. Um This, this is something that could be useful for, for other teams to easily recognize. So I'll just go ahead and accept the default and of course, this being an AWS um template. Um I'm being asked to pick a region. Um So I'll go ahead and choose us S two. And as you can see, this is a really nice way to get started like um it, you know, it sets up the default project files for you um installs the uh expected um N PM packages uh and bootstraps, um your uh infrastructure app with a very simple canonical example uh which in this case, is creating an S3 bucket for aws. Um And, and also shows you how you can um export um outputs. So you could uh for example, in your uh merger request pipeline, you know, you may want to um create your infrastructure, but then once something is created, you probably want to run tests against it or maybe you would like to make a web hook call um to post something to it. Um And, and, and so Pulumi gives you the ability to, to export outputs of your infrastructure. So, um here's an example of how um this um infrastructure app is exporting the ID of the bucket um as the bucket name. Um So you can use that to do other things with it. Um So, um I've actually um gone ahead and created a different project um uh for us uh for today's demonstration um which which pulls down our AWS S3 um static website example. Um We have a lot more examples available as well. Obviously. Um We if you head over to Pulumi dot com slash docs tutorials, um you'll see examples for examples and tutorials for um a lot of cloud providers as well as um in multiple languages. And we provide an easy way for you to get started by just simply clicking the deploy with Pulumi button, um which will take you through a wizard like walk through and then show you the commands that you need to run um on your local machine to, to pull it down and get set up. Um So, um so as you can see like um the example itself is pretty simple, um It's creating an S3 bucket. Um And then I've got a directory that contains a uh a couple of static files very simple. Um You know, it's, it's an HTM file that references um an image. Um the nature of the static website is um is uh sort of not important in this uh in this case because uh your, you know, your static files could very well be the final bundle output of say um a um a Gatsby Js app or it could be a React react app or an angular app, It doesn't really matter. But um you know, say you have the static files that you would like to host um leveraging um S3 buckets, static website feature. Um You know, and, and um this app basically shows you how to do that. Um So a very basic code here. Again, you can see the use of regular no Js modules, which is the FS and path built in packages. We use that to loop through and, and create the bucket objects to add those static files to that bucket. Uh And again, like I said before, uh we're gonna, uh we're gonna export um the uh uh the bucket name and the uh website URL um that the bucket publishes um as outputs. So I could do some interesting things if I wanted to after this to uh maybe curl that endpoint to run a smoke test of some sort um to make sure that um you know, that the website is actually accessible. Um So um let's um jump into our um plume console um and head over to our get lab project here. Um So, uh so I've already taken the initial um project um and um went through the um merge request um process of getting my um infrastructure applied. Uh And, and basically having a pipeline run um which, which runs the um Pulumi up command itself. Um As you can see, um Pulumi basically says um that it needs to create ah four resources. Um And um and because I'm running the uh plume up command, um It, it, it uh what goes ahead and um creates those four resources. Uh But um but how does um you know, how, how do we configure this? Right? So I talked about um you know, I talked about how uh you know, you run the preview command as part of merger requests and then you could run the update command as part of your master branch requests. Well, you can do that using a GIT lab C configuration file um and leveraging the um conditional build for uh that, that's available as part of GIT lab C I CD. Um So you can designate the Pulumi preview command to be run only for merge requests. Um And this way, um you know, your all of your merger requests will by default, run a pipeline that will run the Pulumi preview command. Um And that way a peer reviewer um is going to have that information ready when they're looking at your code changes, they also know how that's going to affect your infrastructure itself. Um And, and as you can see, the only other job that I have in this simple example is um basically applying the update itself um as part of the master branch pipelines. Um So if we step back to our um git lab um uh pipeline, um so with every execution of the um uh preview or up command, um Pulumi also gives you a Perma link to that specific update. So um I'll just go ahead and um go to that specific update um to show you that um uh the same information that, that you saw uh in, in the GIT lab um pipeline log. Uh But um the other thing that you can do is you can actually look at the diff view um which is the important aspect of uh Pulumi, which is showing you how a um you know, how a change can affect your infrastructure. So Pulumi can compare this with the current known or previous known state of your infrastructure uh versus the proposed state and then show you a diff view of, you know, this is, this is what it's um today and these are the values of the, these are the values of the properties of that resource and you know how and, and what you're changing it to. So this could help you kind of identify um you know, problems if something's not looking, right? Because you may have made a change that's causing unintended changes in other resources. Um So, um so that's great um that we have a baseline infrastructure. Um But um let's actually go ahead and make an update to our baseline infrastructure. Uh Right, because um that's the, that's the ongoing thing that teams do is, you know, once you have your infrastructure, that's not the end of it, you're, you're always making updates to your infrastructure. Um So in our case, we actually need the bucket policy. We need a bucket policy specifically one that allows um the one that allows an anonymous access to our bucket objects. And without this those static files that we copied to the S3 bucket, they're actually not accessible. And so um aws gives you this really nice way to control access policies um such that you can explicitly allow them to be accessed. Um So, in my case, um uh I'm going to apply that on the two bucket objects that I've already got. Um So let's go ahead and create a new branch. Make sure I have the change is saved. Great. And I'll give a all right, great. So, um I've pushed up the branch and let's go back to our project and create the merge request. So um as you can see, um it's just like any other merge requests. Um you know, I can view the diff um of of my code changes. Ah And then basically see that um you know, uh that that, that I'm trying to change the or, or trying to add the bucket policy itself. Um So that's great. Um But the real power is basically running that Pulumi preview command uh which I could run on my local machine too. Um But um but let's let's use the pipeline here to uh to run that preview. Um And so I'll just go ahead and pick William as my assignee because I would like him to review this and I want an approval. Um And alright, let's go ahead and submit that merge request. All right, great. So you can see that um you know GLAB kicks off a pipeline build because um as you remember from our um C I configuration, um we, we said that we want um merge request pipeline to run for, for uh for merge requests. Um So while that's running, um actually, um I in the interest of time, I actually went ahead and created a merger request already uh and um have the pipeline ready. Um You know, as you can see the pipeline is already complete, um We can see that the preview was already ran. Um And you can see the um see the Pulumi output of this, which is um you know, Pulumi runs the preview and then says what needs to be created. Uh But I'm actually gonna call on my teammate here um to, to verify my merge request and approve it so I can actually get this merged and uh and access my static website. So uh William, could you, could you actually look at my merge request and uh approve it, please? Yeah, absolutely. Let me see. This is merger request number six and I'm gonna uh see if I can uh show my version of the world here. So here I am in my git lab interface. And if I look at merge requests that are assigned to me, I see. I've got one here that says ad bucket policy. So uh here I am, this is a a reviewer's view. I can see that I've been assigned, I don't have permissions to merge, but I am a reviewer. So here I'm going to go in and I'm going to look at for these changes and I can see, OK, he's added some policy to create the ash three bucket and you know, I could potentially add a comment here. Um uh You know, let's double check. This version looks right to me though and uh you know, add, add some commentary there. And actually I decided actually that is good. So I can resolve that comment. A merger request can't be merged unless all the comments are resolved. But in this case, the review looks good. I can also from the merger request go and look at that pipeline that per was talking about. So for example, here's the job that ran the Pulumi preview and let's go take a look at that Perma link as a reviewer as well. I can go into uh Pulumi here, which is far forward, but that's OK. Here's an example of what it would look like where uh OK, I can review the resources. Um I can see the various buckets and whatnot. Um And uh so that all looks good to me. I'm gonna go ahead and add my approval here. I am going to tag print uh MS A looks good to me and I'm gonna uh assign for neat and I'm gonna uh unassigned myself. And when I make that comment, these are glab quick actions, it's going to perform those actions, assign it back to Prine to perform his part and that's kind of what the reviewer flow looks like. So with that, I'm going to hand the control back to Prine so that he can share his screen again. Great. Uh Thanks William. Uh I actually think that uh maybe the uh URL wasn't copied completely because I I saw last few characters being skipped there in the model. We call that a layer eight issue, user, user issue. Ah Great. Alright. So ah thanks for the approval. Ah I'm I'm going to go ahead and merge this um request. Um So while that's merging um and the pipelines running for that, um which actually applies to the update itself, let's go back um and look at our um ah our console itself. And so this is, this is basically um talking about um the, the last, last part of our demo, which is um which is troubleshooting. Um So, what kind of, ah, features does ah Pulumi offer? And what sort of integration do we have with ah git lab, ah, to allow you to have that ah ah to, to, to get an insight into your infrastructure itself. Um So, um uh so as I mentioned before, um you know, we uh so there, there's this concept of stacks. Um And um so each stack has uh a lot of activities. Um And, and so uh the Pulumi console shows you um these activities because um there, there's a service that, that is uh capturing the state of your infrastructure as the Pulumi cli runs. Uh So when you're running the preview and update command, um the plume service uh or the manage back and as we call it um is, is capturing the state of your infrastructure and as well as any intelligent information that the cli is collecting um about the environment and about and giving the service more context about each of the uh each of these updates. Um So, for example, um you know, here's the latest um preview that we ran um which was to create the or, or add the bucket policy. Um And you, you can see that um you know, as I said, like what you see in the pipeline is, is something that uh is uh is a quick view um which is kind of similar to what you see in the summary view in your stack activity. But the really, really great thing here is um looking at the diff view to see why Pulumi um you know, thinks that it needs to create something or update something or replace something, right? Um And, and this is really because um you know, Pulumi captures that, that state uh and, and compares that with the changes that you're trying to make um with, with a specific merge request or uh or a master branch pipeline and then shows you the properties that are changing about a specific resource. So in this case, it needs to create a resource because it does not exist currently. And so that's why you see that the bucket policy is being created, but nothing else is being changed. And that's an important aspect about this get ops workflow is um you know, that's similar to your application code logic. When you're, when you're making changes to your app, you don't want changes to have unintended effects elsewhere in your application. And, and it's a very similar thing in the infrastructure space as well. Um You want to make sure that when you're creating or updating something, you don't want to have unintended effects, right? And so you want to look for things like that, which is Pulumi is saying that OK, you're only creating one thing but your other four things are not being changed. In in this case, that is actually a good, a good thing because I don't want my existing four resource resources to change because I'm not modifying anything there. But there may be genuine cases where, you know, for example, because this is just a general purpose programming language, you could be passing values around, you could be relying on values of some other property, right? So as those properties change, something else could change. But um understanding um you know, the uh the reason for those changes is very important to understanding if, if an infrastructure update is going to introduce down time, you know, your services is going to be down after someone changed the port number for some reason. Um right. And, and so this is why we capture these, these updates and provide you with the full context of, you know, what was the stack configuration at the time of that stack preview, for example, or update in this case preview. And then what was the environment? What are, what were the environment details that was captured by the cl at the time of the update? Uh And, and of course, because we have integration tight, tight integration with GIT lab, you can actually see the pipeline or the job number that that caused this preview. So I can actually go here straight to the job or I can go to the um to the merger request itself and kind of see what, you know, what was the, what was the context behind this? Why was this update being proposed? Um you know, and then kind of see the conversation between my peer reviewer. Um and then, and then the author of the Mr and then uh basically answer the question that every team member ask themselves uh when they first encounter a problem, which is what was changed last time and why did it change? Right. And so these are the kinds of questions that um the plume console really tries to help um um to, to help you with. And, and of course, you know, um when ah when you know outside of the activity itself, ah when you look at the stack overview tab, um we show you the current configuration of the um of the stack itself. Ah And again, if you remember stack is a logical container of um you know, of resources, so it could really be anything. Um And you can see the outputs um of this um um of uh of my stack itself. And so um if we actually let's hope that we don't get a four, a four this time, great. So we actually got um we, we can actually access our static file. Um And as you can imagine, like I said, you know, the static file could be the output of a bundler like web pack or whatever for your uh react app or view Js app. And uh you know, your static app could be making um API calls as part of a jam stack. So, um you know, it really depends on, you know, what you want this um infrastructure to be. And of course, it could be as complex as having firewall rule creating firewall rules, um you know, as part of a cluster um service in AWS or, you know, GCP or Azure. Um So it can, can really be anything that your team um you know, needs to implement for your company. Um So, um so this is great. Um So we talked about uh we talked about how to get started, how to run um updates on a continual basis using peer review process. Um And, and using merger pipelines, we saw some of the features of Pulumi console and the integration with GIT lab. Um And, you know, and, and the two way integration uh and we talked about, you know, why it's important to run um you know, updates or previews uh in the context of AC I pipeline because you, you get that traceability, you know, you, you, you know, when you look at that activity page, um you get that full information about uh you know why a certain update was performed. Um you know, and it's really being able to answer those questions. And so, um I wanted to capture the difference between, you know, running an update on your local machine versus running an update from the pipeline, you can see that I ran an update on my local machine, but I see that it's failed, but I have no reason. Um like why uh why this update was ran. Of course, I can see what failed about this because Pulumi captures a log. Uh But there's really no other information about this, right? So, um so that um and so it's, it's an important reason for you to um have that review process as part of your get off work flow. Um And one of the um other things that um that um that we do as part of our application development process is we um you know, we typically run uh unit tests. Um So, uh you know, just because this is infrastructure, you don't have to, you know, miss out on those um methodologies. So you can still write tests for your infrastructure. So we provide a few different ways for you to write tests for your infrastructure. Um You know, and, you know, starting with um writing unit test, which is um which could be an idiomatic way to run unit tests in, in the ecosystem that you choose. So once again, going back to our no jazz ecosystem, you know, you could be writing moca tests to run unit tests which execute really quickly. Um And you could be running these tests as part of your merge request pipeline. Um And then you could take it a step further and you can you know, if you're in a team based environment and your infrastructure team wants to enforce rules to say things like, you know, hey, I've got the, the finance team kind of breathing down my neck and we really need to be tagging these resources uh because of like cost center control. Uh But also, you know, uh there may be like security controls that you want to put on your, um you know, on the infrastructure that your other teams are creating. Um you know, you, you would be interested in things like the policy tests um which run at the organization level uh for every step, so you can enforce certain policies to be executed uh whenever someone's trying to update um um any infrastructure uh belonging to your organization. Um And then lastly, um you know, we also have an automated way uh or uh automated way for you to set up your infrastructure and tear it down, um just kind of constantly running um what, what's equivalent of uh sort of a uh an integration test. So that, that, um you know, that validates that your infrastructure is actually going to, to work. So you're, you're constantly creating it and, and destroying it uh in a, you know, sort of emulating this ephemeral um infrastructure. Um And so we provide a uh integration test framework for that uh for that as well. Uh And of course, you know, this, this is just scratching the surface of of the testing strategies. Um So definitely do check out, ah, our guides on testing. Uh There's, there's, there's a lot more to learn there along with examples. Uh And, um, you know, and of course, uh if you have any questions, you know, we do, uh we do ask that you reach out to us. Um But uh with that, um I think, ah, I will hand it back to Isaac. Um So we can answer some questions today. Great. Thank you, everyone. Um Yeah. So uh we, we have some time allocated for just open Q and A. So uh you guys, if you guys can either propose questions in the uh the, the text box or if you want to ask a question on mic, if it's easier, uh just raise your hand and go to webinar and I will uh address you by name and, and unmute you. But while we're waiting for a few questions to roll in, I, I don't believe there was a question about, is it possible to run GIT lab uh completely offline? You wanna uh maybe address that question? Yeah, I think that's a great question. So, yeah, absolutely. GLAB runs both as a service on glab dot com or you can run GLAB self manage which you, you know, download and install on any type of server infrastructure that you'd like. Um The only thing you'll want is the way that the architecture of GIT lab is that you have a main git lab server and then there's a separate server called a runner. And that runner is a separate binary that you install. And that is what picks up and completes the CD jobs. Um So each task that you have to do, this is how you are able to run really, really large scale CD operations where you could have potentially thousands and tons and tons and tons of jobs all running. At the same time, you can spin up like 1000 runners to run all those jobs. And then when the load is gone, you can spin those all down. So those runners can auto scale in, let's say, like a cloud environment. Uh But we do have lots of customers that do run git lab in air gapped environments. And so if you wanted to run completely, completely on premises, disconnected from the internet, you could do so you'd only want a local connection between your runner and your git lab server. Um, and that would work out just fine for you. And then it looks like the, uh, the next question we have up here is, uh is there a git lab app app for, for Pulumi um, to uh, to glue together, merge request work flows? Do you want to address that? Ah, no, we, ah, we do not have a, uh an app today. Um, but, ah, we do have support for Webhooks. So it is possible to, ah, glue together um you know, ah using the web feature in git lab as well as um you know, perhaps using the web hooks feature in ah plume as well. Um But uh we, we do not have um a, an app today. Great. Uh Next question. Uh Do you, do you recommend putting uh infrastructures code along uh alongside application code uh or do you have different projects to, to manage the infrastructure um for, for all environments separately from application code? Yeah, no, that's, that's a great question. Um We, we actually hear that a lot. Um And, and honestly, there's no single answer uh or a single right answer for this. It's, it's really what uh your um you know, what, what your personal preference is and as far as you know, the, the size of your infrastructure and how you want to lay it out, uh If you are looking to create infrastructure that uh or stacks, I should refer to them as um you know, stacks that will be used by downstream teams um that, that have dependencies on, you know, some of the resources that you create. Um It's possible that you may want to create um or, or um host that source code in a different repository uh separate from your application code um just for the ease of like um uh you know, admin operations and things like that. Uh But um you know, like I said, it's that there's, there's really no single right answer for this. Um You know, we've seen teams put anywhere from, you know, three to up to even 10 or above. Uh do different things, you know, anywhere from hosting their infrastructure code along in the same repository as in my demo, um where I had the infrastructure app in the root uh and then the app code in a www folder um to having a completely separate stack um that is dedicated for infrastructure. So both have benefits. Um And it really depends on what you create. All right. Um I, I would agree with that as well. I'll just uh chime in to say that um there are features within GIT lab that will are designed for mono repos in particular with micro services. When you've updated a part of the code, and you only want to run a particular pipeline on a particular directory, you can leverage those features within Git lab within a certain scale. But I would say the majority of customers that I've seen once they, they are at a large, you know, for small simple apps as Ron mentioned, you know, have it all in one place is very simple. And when you are at a larger scale, having, having your infrastructure code in its own repository allows you to better manage access to it and those sorts of things as well. And maybe one clarifying question uh to, to both be and William. Uh I think the Kyoto is asking is it strictly C I offs with GIT lab instead of uh pure get off. Do you wanna, do you wanna address that? So, sorry, I, yeah, I would, I, I can go ahead and address that one. I would uh I would say that the uh the G ops term is probably one that's uh relatively new, it emerged out of the uh cloud native uh kind of community. So the first folks that started doing uh get were doing it in particular with um but that's not a, that's not a constraint or requirement. So with GLAB C I CD, you can actually do a gets flow and use any type of infrastructure. And so the important parts of the core components of GITS are the ones that I mentioned that you are doing your operations via git mege request um that you're automating changes to your infrastructure that you are taking advantage of the review properties of the auditing properties. Um uh Maybe other folks would kind of split hairs on what this that or the other is. But I would say that's our, our tent of what we would consider get ops is, is maybe a bit broader and more of a general definition that you could use any kind of tooling rather than being like very, very prescriptive in terms of what tool you could use. All right. Um So here's, here's one more. So, so what happens when Pulumi up fails and breaks? Uh breaks the state. Great uh great question. So um there, there are a few other commands like I mentioned, um that would help you uh kind of repair the state if it really gets to that point where you do need to do manual intervention. But in most cases, um you know, failures could be caught during the preview phase itself. But there may be situations where when running an update itself, it may fail. And in most of the cases, you should be able to uh rerun that pipeline. Uh And uh and, and me will auto correct um based on, you know, based on what type of failure it is. Uh But again, that is not the case all the time. Um And, and in some cases where, uh for example, um you know, you're running an update and then uh what would you really shouldn't be? Um also at the same time, like manually updating things in the con in like your AWS console or whatnot. Uh But if, if that were the situation where something else was um was happening, then uh you know, we, we have commands that allow you to directly edit your uh checkpoint state uh and then correct any mistakes. Um And also, uh I do want to point out that uh to avoid problems where there are multiple updates happening at the same time. Um This is exactly why like the service itself. Um It's a built in feature where we offer concurrency control. Uh So no two updates can run at the same time. Um And that, that's done to exactly prevent that type of situation. Uh But again, you know, it really depends on the type of failure that you encounter uh when, when the up fails. Great. And uh yeah, we actually have had a few, a few questions uh that are specific to uh cotis uh those may be a little bit more, more in depth answers. Uh So I, I would encourage the folks that are asking uh about specific configuration and setups uh to hop on to uh dot dot com. Um And let us let us know your questions there. We'll, we'll connect you with our Cotti experts. Um And I think with, with that, that probably that will say it covers the most of our questions. Um And uh again, thank you everyone for, for joining in this, this has been a great session. Thank you to uh for neat and William for, for hosting. Um And I know a lot of folks have also asked about uh the availability for recording. Uh We will be sharing that out as soon as we uh can, can download this recording and, and, and post it to youtube. So we'll, we'll have that posted shortly. Uh So thanks again and we hope you, you join us for, for future events. Thanks everyone. Hey, thank you.

---
