---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Automate your troubles away with Webhooks and Pulumi"
title: "Automate your troubles away with Webhooks and Pulumi"
meta_desc: |
    "Automate change log updates with GitHub webhooks for efficient code releases."
url_slug: automate-your-troubles-away-webhooks-pulumi
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Automate your troubles away with Webhooks and Pulumi"
  description: |
    Matt Ellis, Software Engineer https://twitter.com/ellism  Webhooks are a powerful tool which can be used to build event driven applications. However, often you spend more time building out the infrastructure to run your application than the actual application logic.  In this short talk, we take a look at using Pulumi and GitHub Webhooks to build a small bot that enforces some policies on pull requests, in less than 100 lines of code.  Recorded at the July 10, 2019 Pulumi Up Seattle meetup Repo: https://github.com/ellismg/github-webhooks-serverless  Blog: https://www.pulumi.com/blog/managing-github-webhooks-with-pulumi/
  sortable_date: 2019-07-16T20:04:07Z
  youtube_url: https://www.youtube.com/embed/KhHDhGCdU3c
transcript: |
    Um OK, cool. So, so we'll get started. Uh So the thing I wanna share with you today um is I think it's actually in some ways similar to, to kind of what Paul was showing. It's one of the things that like kind of drew me to the, to begin with and something I think that's, that's really, really cool. Um And uh it kind of give you, give you background on myself. So uh so one, I'm kind of a lazy person, right? Uh So like activation energy to something like I, I wanna feel like, oh man, I'm gonna be able to get something off the ground quickly and, and sort of get in that feedback loop, feedback loop like, yeah, things are getting better and better and better. Um Another thing is I, I spent uh before coming to Pulumi, I spent a long time uh building and designing API S as part of the dominant framework team. So I sort of really buy into this idea of like abstraction is the way to like hide complexity. Have experts be able to like say these are the hard problems you're not gonna have to think about them and, and, and put a nicer interface on, on top of things. Um And uh so I guess the other thing that I kind of like uh about me is III I don't like confrontation too much, right? Um And so I'm gonna talk a little bit about this thing that I have built uh over the, the course of working here is like a, a side project. Um That sort of helps solve all those problems. Um So I, I'll give you the, the sort of problem that I was trying to, to solve uh here. And this was uh we have this open source project in the root of every repository. We have these uh change log dot MD files. And the expectation is like when people are making changes to our code, they're putting something in the change log dot MD. That is like what happened, right? So when releases come out, people can like, look at the list of changes and go OK? I understand what's going on. Um So the the problem there is that uh for a very long time, we did not do that, right. And so we got sort of in the habit of never doing that, right? And so we, we introduced these chain log dot M DS. Um And uh for a long time, what actually ended up happening is any time we were gonna go do a release, uh I would sit there and like, look at git log and try to like write the github chain log entry for all these things. And I would like walk around and people would be like, I don't understand your commit message, tell me what, what to do. Like give me the two sentence summary. Um And I didn't like doing it right. Um And so then what we decided to do is like, we're just gonna, we're gonna write on a wiki thou must edit chain talk dot MD before checking things in, right? Um But again, like that's easy to miss, right? Like you've got this pull request, it's got a bunch of these like really meaty things that you want to review. It's very easy to see. Oh, they forgot to edit change log dot MD, right? So it's like, OK, well, now, now my job is like, I'm gonna just monitor every pull request and when I see change dot MD isn't, isn't there? I'm gonna like type a shame message like please go edit chain log dot MD. This is important. Um So that, that doesn't work great for two reasons. Uh One reason is that like, I don't like conflict. And so like, I hate being the guy that's just constantly hitting you with the the stick. Um And then the other thing is like, now I have to take interrupts every time pr s are open to like make sure the right thing, right? Uh And so what I, what I wanted to do is like solve this problem. I want to automate this problem with. Um and, and in theory github should make this very easy, right? So um github has this like very rich webhook interface where you can ask github to send you information when events happen and then you can go take action like these, these very simple event driven applications. Um When I originally started this, uh it's like, OK, I'm gonna want to use github web books. So what do I need to do to get github web books? Working? Well, I need an HDP end point somewhere that I can put in, right? Um And it's like, OK, now I'm kind of stuck again, right? Because as a guy who was coming to Pulumi from this dot net world where you're writing console applications all day, right? Like booty name, web server in the internet, publicly accessible, getting an endpoint, getting my code there. It's actually a lot of work, a lot of activation energy, right? Um And so what I did was for a while, just didn't do it, right? And so finally I get to the point where it's like, no, I need to need to come up with a solution here. And one of the things that, that II I try to do is like, well, let me, let me write down the code that I would love to write. Um And then let's figure out like how we can actually implement that that distraction, right? Um And so what I thought is like, OK github, webhooks like there's a lot going on, right? Like github, you, you need this hepn Point and github's gonna send you a message and that message is specially formatted and you have to validate that, that message is coming from github. And the way you do that is you give them this shared secret so you can like do a, do a hash to ensure like, oh yes, it actually is, is a valid message coming from github. That's a bunch of code. Uh I probably don't want to write that every time I make it a github web hook, I want, I want a really cheap way to, to build these web hooks to build these spots so I can uh do the automation and then get back to the the things that I enjoy, right? And so I thought, OK, well, what would it mean if I wrote this like new github web hook, right? And this is a a plume component. So what would this plume component look like? Right. Well, like all plumy components, I have to have a little name here. And so this name here is uh change lock status check, right? So I'm gonna use this Git web uh github web hook to, to deal with change log messages, right? So then what are the other things I would, I would really want to do? Well, I have to tell it, what what repository is I want to listen to, right? So in this case I'm saying, oh, I wanna listen to this fracture repository that I have on, on github, which is what I was kind of using for testing, right? And then what are all of the different events that I want to listen to? Well, the thing that I care about here is, is just right, but github has tons of different events and, and I could listen to some of them. I might wanna listen uh for when an issue is labeled and take ash cream on that or, or uh when a member is added to a team and take action on that, right? All these little things. So this one I I cared about, right? Um And now what I wanna do is I wanna just like write the code that takes action on that event, that does something, right? Um So here I have my, my code that kind of does the action. Um And that's all I want to write, right? I don't want to think about anything else, right? I don't even want to think about like, oh, once I spin that code up, it's got this hp end point and I'm gonna go to github dot com and I'm gonna like go to my repository to the web books page and like type that thing in, generate a secret, put the secret in here so I can do that validation. And everything. I don't want to think about that again, stuff, this is the code that I wanna write. Um And you, you may not be surprised to learn that, like, I actually can write this code here and it like actually works, right. Um And so I want to uh now show you a little bit about uh what the code ends up doing when you, when you deploy it with. So we'll jump into the terminal here. Uh And so we will do so first things we do to it so that, you know, there's no man behind the machine, I'll go to my uh my LSMG scratch repository settings. And if we look here in Webhooks says there are, there are no web hooks, right? Uh A web hook and I don't want to click this button because it's like I click this thing. It's like, man, here's a bunch of stuff I don't have, right. Uh And I don't want to move. So I'm not gonna click that button, right? Let me just stay away from the button. Stay away from the button. It should be like like this is a tagline of like infrastructure is good, right? It's like stay away from the button. Don't, don't ever hit it, hit it once to figure out what it did and then like coat it up and never put it. But um so yeah, so we'll do uh we'll do plenty update. Um So unlike Paul's example, which was like deploying a really bunch of heavyweight resources. This thing actually, uh can, can go quite quickly. Um And so we're gonna see first a little preview of what it's gonna do and we can see a little bit about the, the shape of um, what we're doing here, right? Um So I kind of said we need a, we need a couple of things, right? Like we need, uh this, this HBN point that has my code in it. Um And that's what this Aws X uh sorry, Aws API gateway, X API thing, right? This is a, this is an abstraction that we've built that makes it really, really easy to um have LAMBDA functions on Aws that are hooked up to KP I gateway, right? So you give me some code, I'll give you an HPN point. It's gonna run your code. That's great. You can see underneath this abstraction is actually managing the lifetime uh or the, the, the life of a bunch of different um Aws resources, right? So we have a permission for the Lamb, we have the API gateway stage, which is a thing that like, I kind of understand what it is, but I don't fully understand what it is. But fortunately for me, it's hidden behind this API thing. So I don't like really have to rock it at a fundamental level if I don't want to. Uh we've got the roles and the role policy attachments, we've got the actual AWS function like that, that you think of and the API gateway that ends up actually, you know, um exposing me giving me that, that, that um so I mentioned two that we kind of like need a, a shared secret, right? Like we need this secret that's gonna be in my code and it's gonna be on. And so we've got this thing in here where we're gonna create a, a number. And so this random number is like when you create this resource, you get a, a random string. Um And then it never changes, right? So this is kind of like a, a way to generate a random number once in your program. But then remember that value for the lifetime of, of executions, right? Um And then the thing that I need to do is I need to like, like once I've got my, my API gateway, I've got that HPN point, I've got my secret number. Uh Then I need to go tell github, hey, please register this web hook. I need to actually do that. Um And so that's what this github rest hook thing is doing. It's modeling uh the ownership of, of, of that registration. It's modeling the, the life cycle of that, but that hook that's registered in github. Um And so, so OK, so I've got like 12 things here. I think I have 12 things to create. Like that's great. Uh Do I want to perform the update. Of course, I do. Uh I want to perform so we'll, we'll hit enter and it will be uh quite quickly. Uh Assuming the demo gods are, are not on steel or whatever it is. So while this is working, we can go back a little bit and see sort of like what the code I actually wrote did, right? Um So we can see here like, like what is our handler gonna do? Well, we have this handler gets in an event, right? Um And this event here is actually typed as github web hook request. So I can actually like dot into this event and like see interesting things on it. So do like event to data ID type, right? This sort of stuff. Um So that's like one of the nice things about being able to define this like function in real code. Uh And, and, and have it live with the infrastructure behind it, like you get this very nice thing, right? So uh we're going to uh we get this pull request. Uh We've got some little helpers here. So one helper is this like log function that just prints some nice stuff to the console. Um The other function is the set status thing. And so this is what's actually going to put the github status check that says like you either get the, the, the green check mark or you get the red. It's like just like C I would have for you, right. Um And so we've got this little like status helper so we can use it a couple of times. Um You'll notice in here uh The status helper is just using the normal No, Js github API, right? So this is just like code that you would write in any sort of like no Js app. If, if you wanted to implement the hook, you're able to do that in Pulumi, but you're able to do it in the same program that defines the infrastructure that backs this thing, which is like kind of cool. Um So then we just have a bunch of business logic that like lets us decide what we want to do, right? So uh for these events, like we actually get uh a bunch of information from github on different things and there are some events that like some types of events that we don't actually care about, right? So we can ignore those and, and, and return from our handler. Um If this is the thing we actually care about, like this is an interesting pull request, right? Like we can try to see if the uh target branch has a change log dot id. If it doesn't have one, like we shouldn't tell you, please go update the change log, there's nothing to go update, right? Um And so we have a little bit of logic here about looking in the uh in the in the target branch to see if there's a change log dot MD and if there's not saying, oh, we're gonna log, there's no change log. So I'm gonna skip it. Uh These log messages will be, will be interesting later because they, they how you like debug the heck is going on, right? Um Well, I if it looks like we need to actually do this check, then we're gonna set the status depending, right? This is gonna give you the yellow circle of um and then what we're gonna say is, well, you know, there's a class of issues probably where you don't need uh to put something in the change lock, like it's uninteresting to put something in the change lock that like I made a change to C I or something. There's, there's stuff that's check, do that, that you kind of don't care about. Uh So we're gonna provide a way to say, OK, if this uh impact slash no change log required label is on there, we're gonna, we're gonna send the stats to success. Um Otherwise, what we're gonna basically just do is like get all of the, the files from the pr we gonna look through and if one of them is called change, we're gonna say, OK, you've edited the change log, that's great success, otherwise, failure. Um And then the last thing that we kind of so, so this, this here is all of the code that uh happens every time a pull request is open, right? This is, this is the, the, the business logic that runs uh every time. And the last thing that we have down here is this uh export statement that just lets us see what the URL that that book was created. Um That's just helpful for like development stuff, right? So we kind of ran this thing um And you can see it, it eventually did create everything. Um And it, it gave me as an output this hook, URL. And so if I went here, I would probably get uh a bad request because I have not, I'm not coming from github or, or whatever. Um But, but we've done that. So if we now alt tab back to this web hook thing and hit refresh, uh You can see, OK, now AAA web hook has been registered for a pull request. Um And it's got this thing and that the G zero thing sort of matches as well. Um So now what I wanna do is kind of show you it in action right now. And so if we go into scratch and you cook and then you're gonna say this. So we'll say that and then we'll say this is probably actually gonna yell me because I need to do a forces push. Uh That was Yeah. OK. No, it's good that I cannot buy those questions. I screwed up because OK, so we've, we've pushed the code uh now to github and so we can go back into our repository and we can go pull request, we can do uh it says ultimately amount to put this thing compare and pull request and say create pull request. And so the pull request gets created. Um We see for a second they were saying, oh, everything was ok. And then, then it said, oh no, there's a status check and that status check has failed. This is up with the update change one, right? Um So it's pretty cool like now I have this thing that like helps me machine people, right? And I can go add this label because we have this policy like, oh if I put this label in um kind of do stuff. Uh So we'll, we'll attach the label and then we give it a second and status check runs and then it should be green. I hope get there, get there, but it helps you shape, it helps enforce those practices across that is that is a much, much better way to say it, right? Um OK, so this, this didn't work. Uh And so you don't know. Yeah. Oh can I refresh? Yeah, I can refresh. Maybe, maybe that will be it. OK, definitely. I mean it's not a bug, it wasn't a bug on my end, it was on there. Uh That's good. Uh So, so I just kind of want to show you uh two other things real quick. Uh So first I'm gonna remove this label. Um so that we kind of go right again. One, right. Again, it's great. Um So I kind of wanted to show you too, like sort of the um some of the things that I like about Pulumi for like the development program, right? So one thing that I can do is I can run this POY logs command. And you remember in that, in that application, I was uh calling this log thing that was in the rocks. Uh So in my application, right? I was, I was, I had those log messages and I was writing things to, to stand out. So um those things get picked up by cloudwatch, like cloudwatch just picks up uh console rights that, that uh your lamb is due and plume here and it understands, you know, here are the uh here are the Lambda functions that are in your thing. It can go query Cloudwatch and say, please give me all the logs for these, right? And you can print it out. Um And so this is super helpful for, for debugging, right? Because um I can add as many log statements as I want and then I go take some action or unlu the logs again and uh and do this sort of stuff. Um So the other thing that's kind of nice in the development experience. Um And here's where it kind of, we have to be super careful because I have to type live code and I have to do it correctly. Um Those are always two very hard things. So uh one thing that we could do, right is we could like say, hey, you know what I'm, I'm mad. I wrote this bot. The bot should treat me special, right? I shouldn't have to update the GIN form, right? Like I'm, I'm a special guy. I wrote the bot. I should, I should get that right. Um And so we can just like add some code in here, right? And we can do if Pr uh pull request, I think it's, he's here. Uh So then what we can do is we can uh log, it says this OK. Sense. Um Oh my goodness, I've got to restart to Steams. I'm not gonna do that, right? Uh So I made this little change. Uh Now I want to deploy it, right? So I'm gonna run pollute. Uh This is similar to what, uh what Paul did. Um So I'm gonna run this and Pulumi is gonna kind of go figure out what needs to change. Um And so certainly the code inside the line that needs to change and Pulumi will detect that and, and show me that, hey, it's gonna go uh change that stuff. Um And then Pulumi uh is a conservative system. So it, it will say, hey, you know what, I'm not 100% sure that when I update that function, it's not gonna like change something about the function that has to be sort of pushed downstream. So we can see here that like this update, which is conservative says, well, I'm gonna go update the, the function and then this other stuff I'm gonna update because maybe these values end up uh changing. Um But if we actually go ahead and do the update when we say yes, um, it will sort of behave the way we want, it will just update the, uh the Lambda function. Uh So we'll run the update, that'll take a second or two. So it's updated. OK, great. And so we see like the hook URL didn't change because the hooky L didn't change. I didn't need to go change that relationship that I had with github. And if we actually go back here, you can, you can see that's true. Uh So the web hook here is, is good. Um And so now what we can do is we can go uh close this border of West. Why is it? This is that should be, yes. My strategy of always refreshing. Sounds good. So we'll say close floor request and then we'll say reopen floor request. So we get that, that event to happen again. Um And so what we should see is uh it should go green even though I have an updated uh perform request. And then if I come back here and I do logs, um it'll go get the, the logs from cloud watch. Um So we can actually see one of the things it did was ignore the events of type clothes and so we'll just do plume logs dash F that we follow. Um And actually, now we do see the logs from, from that event. So we see we saw this this as pending and then we say, oh, it's Matt I preview and we set the success rate. Um And so I really, really like this because I can like in, in, in 80 lines of code, I can like build this stage, right? And the, the reason that I can build that is I, I was able to use Pulumi ability to generate uh to, to, to build real abstractions to like do the hard thing once, which is like implement this github web hook thing. Um And then now I just get to use it whenever I want. And the other thing that's really, really great is like if, if we actually look at this um here, um this github web hook thing is actually coming from um this, this NBM package at LSMG, polluting get levels, right? So that's something that I have written and then I can just consume it like any other package, uh any other new package, right? Um And so I think that's like is pretty fantastic um because it allows me to basically uh do something hard once and then get it in a reusable artifact that I can use for like the rest of my life. Um and, and make all of my future problems. Um So that's kind of the thing that I like about Pulumi. Um And I think one of the things that kind of showcases, oh that the ability to build these abstractions lets you uh sort of start to program the cloud as we say, as opposed to just thinking of like, oh, I've got my infrastructure there and employed and I've got my application system. So, does anyone have any questions? Yeah. So does your uh uh package abstract, the creation of Lambda? And yeah, so uh so we can actually go to the, we can actually go to the, the, the uh code, I can show you this stuff. Um So how do I want to do this? I think I wanna do this. So we push and do set up as a Australia, the the body of or? Yeah. So I actually uh that, that's a great question and I'll actually show you uh show you the answer. Um So if I go into the, the github webhook service then and this actually is available on, on github. Um So it's, it's just a repository of github get web books or something in, in Sng. Um But we can talk a little bit about this, how this kind of works. So I think the first question was, do you, do you abstract away like, like do you extract over the Lambda? And the answer is that uh and I, I think that question is like, well, what if I didn't want the code to be in land which I want to be in a or Azure, you know, functions or whatever. And so the answer is um uh I do not today but like it's just code so you could go do that, right? Um So today I actually do hard code in using this um AWS X API gateway API thing, which is yet another abstraction that like Pulumi is built and lives in the aws package. Um But I could design this in a way where um I would be able to um like, like you would be able to, to, to that, right? Like if, if we saw what, what Paul had done, like, you could imagine adding an arc here that's like, you know, target environment, Azure or whatever um this sort of stuff. Uh I don't do that today but that, that's certainly something you could do. Um I think the other question was, do you upload like a um string or is it file for like sort of the body of the lambda? Um And so I, I will say that uh that is something that's actually when I'm using the subtraction is handled for me, right? So you'll notice in the subtraction uh the event handler for this, this slash this posting um is just again another, another javascript function, right? And so one of the cool things that Pulumi can do when you're writing for refers in javascript is it can take uh take these like actual functions and serialize them. Um And then sort of rehydrate them in the cloud, right? Um And so what actually happens here is a lot of this function is doing those things I didn't want to have to do every time. So I'm checking the signature. Um if it's an event that's like a ping event, that's something github sends every time you register a webhook. I'm just saying, well, I can respond to the ping event. I don't need to like call the user code to kind of go respond to that, right? So it's kind of all of this stuff in here that I don't have to want to write every time. It's this common code that happens for every gib web hook and then at the like at the bottom, what I do is I just parse the body of the event and then I call the handler that was passing me, right? So this is the user code that's actually um but when I give this whole thing to Pulumi to uh to the API gateway, what it's actually going to do is it's gonna serialize that Renda um into text. It's gonna find all of the things and new modules that you depended on and it's gonna, all of that stuff up and like set that off in. Um But, but I don't have to really think about that. I just know. Oh, I've got this AWS X API gateway API thing that I can give a javascript function to and it like gives me an hupn point in the cloud that like runs that code. Yeah, same deal for I'm assuming. Hook dot Ts is how you actually register the web. Yeah. Yeah. So uh yeah, so, so Hook dot Ts is like that and so Hook dot Ts um is actually uh so, so, so hook dot Ts and this is like the scariest code that exists. So I will say that this is not typical like code, this is like 405, you know, advanced topics in Kami level uh shenanigans that we're doing. Uh but one of the things that, that you can do in Pulumi um is you can implement your own uh resource provider, right? And so like if you have uh if you have an object that you can model as like has a life cycle, right? You can go write the information of create update, you know, read delete um in Pulumi. And then now you can start to use that. So this github web hook provider stuff is basically built on top of that, that uh provider thing where I've like, here's how I'm going to do diff when I need to go create this is creating the actual web hook, right? I'm going to use the github API, I'm gonna to authenticate to it. Um And then I'm gonna like call create hook depending on if it's an organization or an owner, depending on kind of what comes in. Right? But, but I am able to like do that and, and I'm able to model this thing which you may not think of as like a traditional cloud resource as a resource because it does have these like, right. Um And so I can, I can build these own my, these providers that sort of like help me solve this problem even if there isn't something built into the system today. So that was actually an excellent the other useful thing for data research providers. Sometimes the cloud will actually launch functions on their cloud without support either in their template language or uh or providers itself. And as long as there's some api you can create your own data, so you don't have to wait for one driver or wait for the cloud formation or arm support program right away. Yeah, this is what I think we've seen. Some of our customers who are like using that using Azure like Azure will add new services or there will be certain knobs on existing services that aren't exposed to the existing careful provider. And, and because of that, they're not exposed to today, but you can use this dynamic resource to go actually flip those, those knobs in the state control planes like life cycles or um so, so yeah, that's kind of yes, kind of going back to this guy's question. It's like, more broadly though. Um I'd love to hear anyone's opinion on it. Is that like one of the kind of implicit promises of terra form was that you could be cloud agnostic. Do you see that? But I feel like a lot of people were kind of giving up on that just because they won lock in a U. Do you think that's more feasible with terra or? Really? So I, so I I think there's like there's, there's two things to come back there. One is like a technical thing of like, can you design an abstraction that is like a cross cloud, right? Um And I think the answer to that is like, yes, but what it means is you end up targeting kind of the lowest common denominator every everything is there. And we've actually uh one of the things we have built in the past is this polling cloud package which was like kind of trying to be this. So we had this concept of cloud dot function, right? And when you were targeting aws, that means you're gonna do a land bill. When you're targeting Azure, you're gonna do an Azure function, make this sort of thing. Um And uh we, we had similar sort of extractions in there for like running services and tasks. So things that we create, you know, ECs services or um whatever Azure as your CIA C I. Yeah, as your container uh instances, uh, that sort of stuff. Like we, we had those things, uh, what, what we found is, um, people who are coming to us are like, they're always like, yeah, I want to be co crowd. I want the agility. Right. And then it's like, ok, well, you don't get to fiddle with all these knobs. Right. And they're like, no, no, I don't. I think I actually do want to fiddle with that knob, right? Like I'm willing to tie myself to, to interview. So um you can build the abstractions. I think it's still an open question as to like, will they come? Right. Um And, and like, will people actually use them? But uh I, I feel like it is easier in Pulumi to build this stuff in terraform because for these things where you, you actually want, like, you know, very rich decisions you like, if I'm targeting native us, the shape of my resource graph has to look like this. If I'm ta ta uh targeting Azure, it has to look like this other thing, right? Like it feels much more natural to me to write that sort of complex logic in a real programming language instead of something like HCL or, or gamble or cloud, you know, these, these, these uh sort of um DS LS for, for sort of describing resources, like at some point, like when you're building these powerful distractions, you need like powerful tools at your uh at your disposal to them. Um And so I think they are easier to build with poll. Uh The hard part is basically building them in a way that is like palatable to end users. Um Instead of saying uh because uh what we have found personally is that like end users say, oh, but I still want to control the knocks, right? And like once you say I'm gonna control the knocks, like, yeah, I can give you an abstraction but like that, that's cross Cloud. But when you start, you know, fiddling those knobs, it's not gonna be easy to move from AWS. Two of the things I learned that one actually is this particular example that Matt had is actually kind of wonderful because it didn't mention at all in the actual user. Um So there was no mention of anything. So it could have been, he could have gone and implemented Azure support for the exact same API and users of it. He could write the exact same code and then suddenly that code starts running on Azure the next day when they send it. And so that was a big good example where, you know, it didn't depend on it. Um use the other pieces like, you know, I think we have that experience at that cloud library where, you know, um it was good but people didn't want want to like fiddle a switch that, you know, wasn't available, come up with it. One of things we have done with a lot of users of who are themselves building their own sort of abstractions which hide away just the stuff that they want to hide away. It's hard to build a general purpose player. But individual users often can define and here's the abstraction makes sense for my kind of business use case that hides away as much of the complexity as I can. But it still gives me access to the stuff that I want to. I want to take some vendor walking over here because I want to use that thing. But I know that now when I move to Azure or when my boss comes to my door and says, hey, we're, we're moving to Azure or like I'm at least don't have to rewrite everything. I only have to rewrite 20%. Um And so we definitely see that that idea of wanting to be able to build abstractions as a tool to manage the risk of crime generally as something that a lot of folks who are really, they are doing the practice anybody else. So I saw you run, pull me up when I'm pushing code to production. I want you to know, test out first look like that is how would most customers handle this kind of scenario? Do they keep running that against the test environment and then check it in? Yeah. So I, I think there's kind of like there's kind of two ways to do it. So, so one thing uh Pulumi like Pulumi actually makes it really easy to um it it is kind of kind of talks and I think Paul had glossed over, but he had mentioned this thing about auto, right, which is like when we create these physical resources by default, Pulumi takes that they're, they're usually named by like what that first string parameter was, but it depends a bit of entropy there, right? Um And so what that allows you to do uh for a lot of stuff is basically spin up independent copies of your program, right? Um And so one thing that you can do is when you want to test it, like you can say, oh I just want a private version of this, right? So I do Pulumi like I do Pulumi stack in it, you know, my great dead stack or whatever, pull me up, deploys the whole thing there. Um Our service actually uh the infrastructure behind it is written in Pulumi. Um And that's what a bunch of our service developers actually do. They spin up their own private copy of the uh of the infrastructure and they get like everything you know, suited to us, they get uh the ECs cluster, they get their own private R DS database and all of this stuff, right? And they can start iterating on that. Uh The other thing that, that, that some folks do is again, they have like a, a shared you know, thing, right? Like you'll do a, we do a, uh, get APR into like a, a branch and then you'll do extra testing sort of after that. Or as part of the pr you'll, you'll maybe go check out an environment and, and go update it, right. Um And so you get to kind of choose there. The one thing that, uh, that I think Pulumi makes very easy is because by default, we kind of push you through this auditing and into creating um infrastructure that can beam all the incident. Uh it, it ends up being easier to get these mistaken like in general, like infrastructure is good over there. I think some of the that, that take that even further than in some traditional structures go. But like it's just really freeing aspect that once you like really got infrastructure to create in place with they like it is easy to stand up and the five easy federal testing of that environment like you don't have to worry about, oh I've got this one special environment where I can do validation and maybe it's slightly different than my production environment. But I'm just gonna hope that it's um you can really like take something that looks just like whatever your production school is recreate that do some validation density. So we, we do a lot of that when we see our users doing a lot of that kind of stuff. Yeah. Yeah, it's like a silly question. Can you put blooming into the web hook? So every time you do it, plus it creates infrastructure or something? Uh Yeah. Yeah. So can you bypass the B me up? So um so the like can you bypass flew me up? The answer to that is, is no. Um So, so what, what you would do uh is like you could definitely in the web book like, you know, uh container instance that goes and runs flew me up and, and you could maybe take some, you know, from like you could imagine design a system like, you know, has AAA control playing that. There's some resting and you poke events to it and behind the scenes, um it s Pulumi and hoops and does stuff. Um We've got some folks that kind of want to use Pulumi for that and we're sort of like exploring that use case. I'll say like today it is like, not as, it's, it's not a great, as great an experience as we would want it to be. Um And so that is definitely something like we're thinking about. How do we, how do we like, how, how are we able to take like the new technology and, and move it from a tool that is like generally run by an operator in a terminal or run in a in AC I setting and much more into like this embed sort of library that allows you to like uh do um you know, uh desired state management of infrastructure in, in a sort of library way instead of a tied to a tool with like this business. Uh So yeah, today it's shell out to Bloomy. Hopefully tomorrow we will be like, oh, we've got these API S for you can just go use them in your Express apps or, you know, but ok, well, thank you so much for coming and, and listening to me uh explain what makes me happy about. Hopefully it makes you a little happy about you too.

---
