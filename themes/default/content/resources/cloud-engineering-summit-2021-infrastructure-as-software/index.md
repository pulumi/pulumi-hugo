---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Cloud Engineering Summit 2021: Infrastructure as Software"
title: "Cloud Engineering Summit 2021: Infrastructure as Software"
meta_desc: |
    Let's put the Dev back in DevOps and talk about why Turing complete config management is an antipattern.
url_slug: cloud-engineering-summit-2021-infrastructure-as-software
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Cloud Engineering Summit 2021: Infrastructure as Software"
  description: |
    Let's put the Dev back in DevOps and talk about why Turing complete config management is an antipattern.  Talk by: kris n√≥va
  sortable_date: 2021-10-20T23:02:32Z
  youtube_url: https://www.youtube.com/embed/rtng6GNQd4w
transcript: |
    Hello, take 21. Hello and welcome. I'm your host Chris Nova. And today we're gonna be talking about infrastructure as software pig. 21. I have been working at this all day. So hopefully this will be a good one. We'll see how it goes. So, hi, I am Chris Nova. And today we're gonna be talking about infrastructure as software, um particularly what it's like to manage infrastructure with software. And we're here at the Pulumi Cloud Engineering Summit. A big shout out to my friends, Maddie and Kat for helping me get on board here. Shout out to Joe for letting all this happen and big shout out to my favorite underdog. My sister from another Mr, my girl Liz in Seattle. I love you. I miss you. I see you out there in the streets doing good work. I love you girl. I know you're out there. So anyway, um we're gonna be talking about infrastructure as software, so a bit about me um other than the fact that I give my, my presentation in a UNIX terminal here, um I am the lead senior principal architect um and I work on Kubernetes at Twilio. So we're, we do a lot of Cotti things and we're working on a new Cotti project and I'm the lead architect on the project. Um and you can find out more about what I do in open source on my personal blog at dot com. And I encourage all of you to buy several copies of my book, cloud native infrastructure, which we'll look at in just a moment uh for your friends and extended family and you can see all of my lovely open source code in chicken scratch on github dot com slash Chris dash nova. And um you can follow me on Twitch where I do a lot of live streams, not recorded streams because recording is really hard for me, but I do live stuff all the time. If you wanna come watch me live, I'm there pretty much every day. Um And I'm on Twitter. Please don't follow me on Twitter. You're welcome to read my tweets from time to time and they get me in trouble more often than not as we're about to find out. Cool. So speaking of tweets that get me in trouble. Here's a great one here on the left side of the screen. So I made the mistake of tweeting. This don't, you know, stop doing infrastructures code the other day. And this is what led me to realize I actually draw a line between infrastructure as software and infrastructure as code and I kind of thought everybody had made that, that mental leap at some point. And the more I talked to folks, the more I realized that I had created a big line in the sand in my own brain that I don't think other folks had created. Um So I get asked this question a lot, you know, how is infrastructure as code different from infrastructure as software? If I do my job correctly in this talk, you should have a good idea of what these words mean to me. And I will be gigantic because I do feel like in the the ability to be different with our definitions comes a lot of value and and ultimately, a lot of more resilient infrastructure for you and your team. So anyway, uh if you like this topic and you want to see more, go check out the book. We have an Ask Condor here on the screen that should match um our cloud native infrastructure Condor here as well. Um And a lot of what I'm talking about, particularly the infrastructure software, the testing, the infrastructure teams. All of this is, is also also found in the book that we published back in 2017. OK. So we'll start off with some simple definitions so that we can, we can grow on them moving forward. What is infrastructure? Um It's the bottom half of the O SI reference model, right? Application is at the tippy, tippy top of the O SI reference model and in order for an application to exist, we need all of this noisy stuff underneath and we call this noisy stuff infrastructure and typically people don't want to deal with it. We like to pretend like it's not there. It's stupid, it's hard. It's frustrating, which is why I'm in this biz. So anyway, um I like to break these down into my three favorite pillars or tenants of computer science, compute network and storage. I think everything we do in computers can be, you know, broken down into one of those three categories. So let's look at some example. So in compute servers, operating systems, container, run times processes, things that run things that uh start to give us abstractions for software storage discs, memory, uh staple discs, virtual discs. LV MS. These are all places where we can write things down virtually and, and come back and view them later. Network. Everybody's favorite the relationships of computer science like the drama, right? That's where all that's where all the good relationship stuff happens, you know, like the subplots and everything. Um load balancers, firewalls, network switches, security groups, VPC S, all this fun stuff that, that involves our network and how computers connect to each other. What is code uh in its most literal form. It's just the plain text representation of a program uh or a configuration. Yep, it's, it's just the shit you can read. It's a text file. So I look at some example, code here. So we have, you know, in, we have some uh example code that does various things. Uh We have some example, Python, I'm sure we've all seen Python before and you can see it. It does similar things. And what I want you to remember is the code is just the things that are important to humans, the stuff we write the stuff we can read and it's just the encapsulation of it, right? It's a text file, it has to live somewhere. Um However, there is a program that takes this text file and does things with it. And typically we as code engineers care very deeply about the thing that turns this plain text into whatever we wanted to to do. So let's talk about turn completion because this is gonna be really important for us to understand how code turns into the these programs that we want. Uh we want people to run, we want these programs to do things for us. So all a turn complete program is, is uh it's something that can compute any other program, right? It's, it's got some fundamentals of computer science, you know, the ability to manage memory, it's got iteration and it has a logical switch, an if statement, if you see an if statement, there's a good chance what you're looking at is actually turning complete at the end of the day. Um And because of that you can run theoretically any program on top of it So Microsoft Excel does have a concept of if statements, if this do that, which means in theory, if we wanted to write the abstractions, we could run something like doom on Microsoft Excel. We really could, you, you absolutely could make that happen if, if you truly wanted to um in, in most cases, that's just a thought exercise. But I think it's an important one to call out. So what is software? So it's a turn complete program like Microsoft Excel and it's, it's at run time. So when we say run time, we mean the time is now it's running now, you'll, as a side, you'll notice my screen is flickering and well, I run arch by the way. So we'll look at at these um these programs that run time and we can see that we, we provide ways little windows for us to view just very temporary. Ephemeral little glimpses of what the program is doing at a given instant. And we see things like process managers or task managers and their ability to uh represent what's happening. And the moment you view this, it's, it's already outdated because it's sure enough moved on at run time. So these are just small glimpses into reality. What is infrastructure as code? Well, think about it. If code is just the plain text representation, it's just our ability to represent infrastructure using code. So I'm sure we've all seen terraform before where we can write things like the cider block of a VPC and we can define things like a sub net and give the subnet, you know, a slash 24 from within our, our slash 16 above. And you can see that we can start to break apart different pieces of infrastructure and we represent them as code. Now in the same way that AC program goes from C code to AC program, your infrastructure goes from infrastructure code to and that's where most infrastructure code stops. And that's where the infrastructure code engineer mindset typically goes away, right? We, we say our, our code is done. Therefore, I'm done. I can go to lunch, I can have a cup of coffee. My work here is done and, and I'm here to challenge that. So what is infrastructure as software? Well, it's fundamentally it's the, the actual process that is that is running the code that we've already written and it's running that code um at run time and we take ownership of it. We are responsible for the pieces of software that are running on the back end. So I do believe that infrastructure software is an ownership change. It's a shift in ownership. It's putting the DEV back into DEV ops. It's saying we not only write the code but we also care intimately about the thing that renders the code, the thing that brings the code to life, the thing that does the thing with the code, we care about that in the same way that a, a Python engineer cares about which version of Python they're running. We as infrastructure engineers should take ownership of the thing that's reconciling our, our infrastructure. And now I'm not suggesting everybody to go rewrite Terraform. That's not what I'm saying here. What I'm saying is we can start to imagine as a, as a community as an industry, what little pieces of software you and your team could write that could do really handy things for you and we can abstract things away that our boiler plate like terraform does. And we can start to create little logical systems that do really powerful things for us. And we can do those in very, very solid insane way by following in the footsteps of our software engineering, older siblings. So here we look at the cluster EP I dot L and the YAML is defined down here below. And you can see that this YAML is actually the first half of bringing these pods to life. So here we have a cluster controller, we have cluster validation, we have cluster heartbeat and you can see these are small programs that I wrote. I'm a software engineer now and and I wrote these programs to manage infrastructure. And this one reconciles the cluster itself and this one validates the cluster and ensures it does everything I want it need cluster to do and this one just checks and make sure it's online and, and I can now start to weave these components together to build really complicated uh systems that are really easy to manage. So let's talk about software teams. A K A those meddling engineers, as I mentioned earlier, there's a lot we can learn from them and I do want to draw attention to some of the things software engineering teams do that I think works really well. The first one is feature driven workflows. So in a world where where people need things from you and your team, I'm I'm sure as infrastructure engineers, we're all familiar with somebody needing something, right? This is literally the story of our lives in a world where people need things or want things or think they need things. We typically are rewarded for responding with. Yes. Right away, we'll get it done immediately and software engineering teams don't always respond that way. Sometimes they say yes, we'll get it done, we'll prioritize it and we'll, we'll create a feature request for you and it will make it out on the next release. And as it turns out, people are actually more receptive to not right now instead of a hard no. So I think the ability to say not right now is actually quite valuable because it gives, it buys you and your team time to do the thing you need to do correctly. And it also gives the person requesting something from you an ability to deliver a promise. And that promise is not this week, but it will come soon. And with that promise comes trust and with that trust comes a healthy working relationship. And with that healthy working relationship comes the ability for us to buy the time we need to do things correctly. And that's how I think we stay out of infrastructure debt. Uh time based releases. These are your ability to, to cut releases on a timely manner instead of on a need to need manner. And I think any concern you would see with the software engineering team is equally as relevant with managing infrastructure as software. What about a release gate? How do we ensure that our software does what we want it to do? How do we ensure that that the, the person who's making a change is going to be able to programmatically prove it's gonna do what they advertise, it's going to do. How do we test, what about validation? How do we ensure that, that, that what we're changing is saying, how do we monitor it after it's running? What about logging? What if something goes wrong observably anything that we would potentially add to a modern software engineering stack? We can also adopt an application infrastructure engineering as well. Now, there's a very clear problem here, which is if, if we're now modern day application engineers, where do we run the applications that manage our infrastructure? And that's where I like to say we love infrastructure so much. We, we put infrastructure on your infrastructure. And that is a problem and it is a problem you have to solve. And I do think in my mind that this is evidence that that an infrastructure team is typically stronger and more needs to be stronger and more resilient than a typical engineering team because they have to do everything a regular engineering team does in more. So let's look at talk a little bit about what I learned at Twilio with Getups. And this is very relevant to the differences in what I see as infrastructure, as code and infrastructure as software. And I really think get ups is a good example of, of meddling the two and and why I think it's important to draw a difference between the two. So let's let, let's break get ups down what is git, it's a version control tool that, that, that you can use to manage software. However, this is designed for teams working on different sides of the world, you know, distributed teams to do things correctly. We want to be very meticulous and very intimate with our lines of code and we wanna work on needs and we want a really good way to manage these lines of code. In fact, we would be willing to exchange time for resiliency we value right more than we value right now. What is ops doing shit manually in a pinch? Right? I need to get things done and I need to do it now and these are chores, these are things that you do and typically these value right now instead of right. So get OPS is doing the right now thing using a tool that was designed to do the right thing. And I think that's why I think get ops is a bit of an anti pattern. I really do. I think that just because you put something in git or just because it has a config it doesn't mean it's a good idea. It doesn't mean that you're, you're using GIT. The way GIT was intended to be used. The whole point of GIT was to give us visibility into the changes. And I have seen that GIT is now just basically used as a database and you're still able to do just as much damage as you did SSH into a server. Except now you have three button clicks in a YAML file to abstract away your SSH command. I'm still able to break production using getups except for now it comes with the added complexity in a build pipeline to go into the the whole process. So I still look at get ups as infrastructure as manual chores if anything and it's brought to you by a fancy new pull request and some code. But look at the difference. We, we obsessed with get the code, the managing the code. We, we got very good at managing the code and putting the code in version control. But we were still doing the ops mentality. And I'm here to say, let's put the Dev back in Dev ops and let's consider dropping the ops altogether or at least being aware that we want to be DEV heavy in some cases. So here it is the whole point of the talk. If, if you take anything away from this talk, it should be this, this I ask you diagram with my ID E flickering in the background. Um I want, let's see if I can't clean it up. There we go. I want you to, you know, screenshot this, send it to your friend, you know, text it to your, your partner or whatever. Um What are the differences between infrastructure as code and infrastructure as software now that we've kind of defined them? Um So the big one is DEV versus OPS, right? I I think infrastructure of software is, is more DEV than OPS. Uh The next one is I think where they stop, right? It's, it's the definition of done in where it stops. I think that um infrastructure as code stops at a working config and infrastructure is stop. Software typically stops at what we call production ready. And I think with that paradigm shift comes a different level of responsibility and a different level of ownership. So I think an infrastructure as code, it's completely normal to have logical turn complete systems without tests. Think about it. How many of us have written Helm Charts or terraform or puppet or chef. And we didn't provide tests to our changes. We just wrote the if statement, we just wrote the for loop. We just wrote the logical system, but we didn't offer test to prove that it was going to do what we thought it did or prove that it was going to mutate the infrastructure the way that we thought it did. I know everyone out there has committed terraform or puppet config and pushed it live and hoped for the best or ran it. You know, it worked in staging and you're kind of like that's the best we can do. And, and that's what you do. Whereas if you look at infrastructure as software, you flip it around. It's actually unusual to have logical systems without tests. And yes, I know we live in an imperfect world where not every piece of software has tests. However, I think it's pretty common knowledge that we would like for it to have tests. You know, there is this concept of perfect world conditions that exist in a software pipeline that I don't think we see in an infrastructure S code pipeline. I don't see nearly as many folks making jokes about or our terraform doesn't test that our servers are online in the same way that we make jokes about not having unit tests in production. And that's because I don't think the paradigm is there. I, I just don't think that, that, that people and folks they see in the wild are really truly considering having an infrastructure tests. And I think we should, I really do. I think there's enough software in place today that we should be writing tests to go and actually validate our infrastructure does what we want to do and introduce confidence there. Um Because of this, I think we have a lower quality definition of done flat out. I just think that in a world where we're not considering validating and ensuring our shit does what we want it to do. I think it's just not gonna be as high caliber of a, of a product. And I think in infrastructure software, I think that naturally we're creating this, this more resilient, more meticulous and more testable and programmatic system that we use to work through and it's a workflow change. This is a big one, turn completion. We talked about this earlier. I think infrastructure is code doesn't embrace turn completion and it just says, yeah, you'll probably get there one day, right? Yeah, you might, you might throw it in a statement or two in, but it's nothing to, to worry about and you can probably just get away with not worrying too much about it. Whereas I feel like infrastructure software is like, bro, you're a software engineer, you're writing a turn complete program. It is time for you to accept the fact that you are a software dev and you're working on an engineering team and because you're ready to incomplete code, you should offer test for your code. Um Working as an operations team values right now, working as an engineering team typically values, right? Do I do the quality thing or the quantity thing? Um So I see, I think we see that a lot in infrastructure as code versus infrastructure as software. Um The endgame that you hope to get to with code is you'll probably end up with some logic. And if you're lucky that logic will work. Whereas I feel like the end game that you hope you get to with software is you probably end up with tests. And if you're lucky, your test will pass. And I think that we're just raising the bar. It literally is just raising the caliber of, of what we consider done. And ultimately, I think infrastructure is code is we get shit done quickly. And I think infrastructure as software is, our shit has test and we can count on it. It might take us a little bit longer, but it's not gonna break. And I, I think a lot of us are in the situation in our careers where we now are finding ourselves having more and more time to build right instead of right now. So let's answer some questions is infrastructure a software, right? For, for everything. God, no, no, it is not, do not stop what you're doing and go start writing, go and, and you, you know, building these, these things from scratch and telling yourself it's gonna make all your problems go away. No, don't do it. I know you're thinking about doing it, don't do it. Um Because this is the whole thing we were trying to get away from in the first place. What I am trying to say is that there are situations where adopting the mindset of a, of a team of, of the human resource element of a software engineering team where where you might actually find a lot of value in managing infrastructure as code as software. And as we saw with cluster api earlier, there is a big similarity between the code and the software. The code turns into the software. That's the point, but we're now taking ownership of the software as well. So look at this very simple. Lovely. Ask you diagram I did if this is you and you're managing a lot of fucking servers and those servers are are breaking from time to time and you're seeing servers coming into and out of existence, having a small piece of software to help you manage this and identify these might be a lot easier than, than trying to go and find it manually and you'll get here quickly as you and your team grow. So understanding that you're going to get here and that you're you can borrow from infrastructure as software early, is going to make this situation a lot more manageable when you get here. Ok, so I'm gonna stop here. We're at 23 minutes. I got seven minutes with my girl cat. We're gonna talk to you all about all kinds of fun stuff. And I wanna just again say thank you to Pulumi for, for letting me come and give this talk. And I'm going to also record a small 10 minute case study about program I did called Enamel. That is a, a concrete example of how to do some of this. And I'll talk a little bit about the pros and cons and I'll post this on my blog if, if folks want to see the case study of what I'm talking about later. So thanks for coming to my talk and I will see you all next time.

---
