---
preview_image:
hero:
  image: /icons/containers.svg
  title: "PulumiUP 2022: Opening Keynote and Welcome"
title: "PulumiUP 2022: Opening Keynote and Welcome"
meta_desc: |
    CEO and Co-Founder of Pulumi, Joe Duffy, walks us through the evolution of the cloud and the modernization of infrastructure as code to support the...
url_slug: pulumiup-2022-opening-keynote-welcome
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "PulumiUP 2022: Opening Keynote and Welcome"
  description: |
    CEO and Co-Founder of Pulumi, Joe Duffy, walks us through the evolution of the cloud and the modernization of infrastructure as code to support the changing needs of development and operations organizations. CTO, Luke Hoban will join him to introduce the new features of Pulumi that will further help teams tackle scalability challenges, increase developer productivity, and manage multi-could complexity. An industry guest speaker will join this session and share their insight and thoughts on these new features.
  sortable_date: 2022-06-13T01:00:09Z
  youtube_url: https://www.youtube.com/embed/ZHeFMmY88So
transcript: |
    Hello, welcome to Pulumi. Really excited to have you here today to talk about universal infrastructures code. We're gonna talk about some exciting new product capabilities. We launched just this morning. We're gonna see some exciting code centric demos and see some of what Pulumi customers in the community are building unbelievably. We just passed our five year anniversary as a company. We launched the open source project in 2018. And ever since then, we've had a constant stream of innovation with Pulumi 10 and then 20 which is introduced superpowers expanding beyond infrastructures code into policies, code and testing. Pulumi 30 just last year with exciting new capabilities around new languages and component models. And today universal infrastructure is code and we'll talk about that a lot more throughout the remainder of this time. But first, I really want to celebrate some amazing momentum. You know, ever since we launched community has been everything to us. Open source is, is where we start and where we end. And that's, that's where we spend most of our time, is making sure that the community is successful when the community is successful. Pulumi is successful and that's the mindset that we've had from, from the outset. It's great to see so much contribution coming from the community, 2400 contribution uh contributors um with over 35,000 poll requests up over 12,000 github star. There's, you know, there's just a lot of vibrancy and momentum there. In addition to that, we've seen incredible momentum in the partner ecosystem. And today, I'm really excited to announce some new partners including oracle cloud elastic cloud data bricks, J Frogard factory event store scale way, slack tails, scale twin gate check and build K. These are all new packages you can use with Pulumi that are now available in the Pulumi registry. Of course, we've got over 100 other partners that are very important to us that we continue to deepen relationships with and help with shared customers and ensure success. That includes Aws Microsoft, Google cloud. It includes the cloud native computing foundation with Kubernetes and Helm and other projects that we support natively with Pulumi. It includes large enterprise uh partners like VM Ware and Cisco and dozens of others of ISVS such as cloud flare and fastly that are helping with other parts of the cloud engineering ecosystem C I CD uh integrations with github Git lab at Sian Octopus, deploy Armory Travis C I. And the, the list goes on the partner ecosystem is vibrant and growing just as much as the open source ecosystem for us is we've also seen uh a lot of uh customer momentum here. And we find that, you know, folks love using open source, we love uh you know, our entire community. But, you know, we've seen a huge uptick in enterprise customers with over 350% year, over year growth over the last year in enterprises and adopting Pulumi that includes Mercedes Benz and Snowflake and Atlassian. Um but also, you know, some, some new customers are showing up just more recently including Facebook, Blue Nile, um and Block five and, and all these customers doing amazing things with Polly, just really leveraging the cloud, empowering their developers to move faster and empowering their infrastructure teams to do more um with less. And you know, Atlassian speaks to this, this point where, you know, they've reduced developer time spent on maintenance by 50%. That's incredible. They did this by giving developers access to infrastructures code in Python. It's a language they're all familiar with, they're very productive with it. And that reduction in 50% means that hey, 50% of their time is now freed up to go spend on adding customer value and customer innovation. And this is actually the bit bucket team themselves who adopted Pulumi. So incredible story. And this is just one story of many that we're hearing coming from our, our community and our customer base. I think, you know, why are people adopting Pulumi? Well, you know, the modern cloud, there's a lot of challenges in, in, in how we adopt modern cloud. I think there's many reasons to embrace the cloud, you know, rich services and capabilities such as a INML services, infinite data scale data warehouses, uh serverless capabilities where it's just much more cost effective than parking a virtual machine. Um The need to innovate faster and compete with new businesses. Um You know, we see that every industry is being transformed by software and we don't build software like we did 20 years ago, all software is cloud software. And so really embracing the cloud is really important to, to stay competitive as a business in this modern world, customers also have higher expectations. They, they expect, you know, new services and new products and, and you know, new capabilities and everything's online, especially in this remote world. You know, the expectation has just increased that everything is available in the cloud uh these days. And you know, the need for high scalability, you know, a lot of these services have to scale up from, you know, orders of magnitude from uh you know, quiet times to peak load. And how do we do that? Well, the cloud is, is a great way to add that elasticity into our workloads. Um So those are all the the reason we might go to the cloud. But you know, why, why are people struggling? Well, there's a lot of frustration when we talk with folks in the community and, and our, our customers where developers aren't empowered to embrace the cloud in most cases, which means, you know, the the feedback cycle is just a lot slower. The the ability to incorporate modern cloud capabilities into the actual applications architecture is limited. You know, you look at a serverless uh architecture that it really impacts how you build your application. It's not an afterthought. It's a deep fundamental thing that you want to integrate into the inner development loop and putting developers in the driver's seat is the quickest way to empower them to add value that for your customers. And but the the silos that divide, the fact that infrastructure Ds, LS and languages are very different from the developer tool stack. Uh just worsens this the situation. We hear that infrastructure teams on the other hand, are toiling away with languages and tools that just frankly aren't great compared to what we have in sort of the in developer land. You know, a lot of copy and pasting of YAML, a lot of copy and pasting of domain specific languages. Um and cloud leaders expectations aren't, aren't met even if you succeed at going to the cloud oftentimes, you know, the cost payoff might not be there. The the team still can't move as fast as as you wanted because of these prior two points, you know, the silos are still there. And as a result, you know, all of us are are are struggling to adopt a modern cloud, I think, you know, why are we here? Well, I think we've gone through multiple ma major iterations of the cloud journey. We started with cloud one dot which was really an on prem model with virtual machines. We started virtualizing and that was, that was great for more dynamic, you know, deployment of workloads. We didn't have to recon stack physical servers. So that was definitely an improvement laid for everything to come. But, you know, applications are very monolithic, you know, maybe you'd have two virtual machines and a database, very simple architecture. Um So that was sort of a cloud one dot I era. And by the way, we shipped once a quarter, uh you know, it was very common to, to wait as a developer for up to a quarter to get a new virtual machine when you needed to needed to scale up your workload. So the cloud two dot era was a, was a big improvement which was, you know, moving virtual machines to the cloud, still mostly static, but starting to break apart the monoliths, you know, maybe we have end tier applications, we increase the velocity of shipping from once a quarter to once a month or maybe once a week. Um We had tens of services we were managing, it was still relatively tame uh in terms of the complexity. But then, you know, we really accelerated as we went into the containers and circles. And in this modern cloud native era. Which we'll call, you know, cloud three do, but we're actually assembling lots of building block services, um including containers and serve lists and managed services. Of course, virtual machines are still there in the picture. Uh For many of us, you know, a lot of, a lot of folks are doing hybrid and that, and that's ok. That's, that's part of the, the cloud 3.0 era. It's an important piece, but we're shipping a lot faster. We're shipping continuously, you know, daily potentially on every git commit. And we've gone from tens of services to now, hundreds or thousands of services. The complexity of the modern cloud is just enormous and that requires a different approach. It, we need to move beyond copy and pasting scripts and copy and pasting Ds LS to really software engineering. And so our tools really haven't kept up until now where, you know, with Pulumi, we're really excited to talk today about universal infrastructures code. I think you infrastructure's code is the way you manage all of the resources in the cloud. It, it gives you a programmable surface area that allows you to provision, scale up, scale down and really program the cloud. And we're really excited about that and to us, universal cuts across multiple dimensions. One is the cloud itself. Uh I mentioned hybrid hybrid is a reality for virtually everybody doing something in the cloud. And what that means is you've got public, you've got private, you've got hybrid, you have great SAS services like snowflake that you might want to leverage as well. All of that is infrastructure and needs to be managed. And with Pulumi, with this universal approach, it gives you one workflow, 11 standard way of approaching the cloud. We're not trying to hide what makes each of the clouds, you know, magical and different. But we are trying to give you one standard uh approach to all of them. Universal also means every language, we wanna accommodate all different folks from infrastructure backgrounds, from developer backgrounds and really make it much simpler to to program the cloud and access the cloud. And to us that means you know, we wanna be in the language communities, meet people where they are and bring the cloud closer to them. It means every builder, you know, we one of the reasons for the silos is we have different tools for infrastructure teams than we do developers with Pulumi. We really see the world as we're all builders. We're trying to use the cloud. And we want one solution for all builders of all different backgrounds, whether you're an ops person, infrastructure platform person, a developer, fullback developer, a security engineer. Pulumi is the platform for you. It means every architecture I mentioned virtual machines sitting alongside containers and servers and managed services. And and you know, there's a lot of tools out there that are only for one of those particular points on the spectrum. We see a world where universal means all of those architectures and similarly, every cloud resource and so universal means no matter where you're coming from, we're gonna help you get up and running on infrastructures code Pulumi supports lots of different languages as mentioned, you know, no Js with typescript and javascript. We've got Python support dot net support. We'll see Sharp BBF, Sharp go uh and also open policy agent for writing your policies. What that means is not just the language but the entire ecosystem around that language. All the ID ES you can use great editors, you get refactoring support, you know, statement completion, interactive documentation, you got great tools, test frameworks, package managers, but also all of these clouds, you know, we've got over 80 cloud providers, many of these already highlighted on, you know, when we're talking about partners, every one of these is a partner of ours, we work together to make sure customers are successful and then your way, which means if you're gonna do C I CD, we're not trying to replace your C I CD system, we're gonna integrate with whatever you've already got, whether that's github actions or Spinnaker code, fresh octopus. Um And so really, we've taken this approach of integrating with the the world of, of languages, clouds and other tools that you might be using. You'll see a little bit of a blurry spot on the left. So we've got some exciting news to, to talk about uh shortly but um we'll get to that momentarily. I think one key facet since we're talking about infrastructures code today, it's important to highlight that by using general purpose languages, you're not losing the benefits of declarative infrastructures code. In fact, that's the magic of Pulumi is you get both of these, they're better together. You get all the benefits of industry standard programming languages, they're expressive, familiar user friendly. You get these great tool support that I just highlighted. You get abstraction with sharing and reuse testing, linters and great communities. You've got these, each of these languages has millions of people in the community. You can find things on stack overflow. People graduate from college, haven't learned these languages. So really betting on the industry's best programming languages is, is key and yet we've taken that and given you everything you've got with declared infrastructures code, you can preview deployments before you make them C I CD integrations, full access to the entire cloud for all these cloud providers and mentioned a history of who changed what when rich automation and workflows and the ability to enforce security compliance policies and best practices. I'm really excited to announce today that we're introducing Java to the family of languages supported by Pulumi is available today. And what it means is you've got the full richness and expressiveness of Java and the ecosystem around it. So it's not just Java, it's the entire JDM. So any JVM language which includes scho closure, cotton and ruby. And we've done, we've worked really hard to make sure that it's idiomatic and fits in with the entire ecosystem. So build tools ID ES package managers, test frameworks, everything just works. Um So if you want to use Maven and publish your packages on on Maven repository, you can do that if you're using. Great, great if you're using inte wonderful, but you can use Eclipse too. So really the full breadth of the Java platform and what that looks like is just writing normal Java. So you can crack open your favorite editor, write some Java and it works with the existing Pulumi tool chain just that you, you would expect cli everything just works uh out of the box. And you know, here's a fun example with groovy simpler, you know, scripting based language. And um but rather than just looking at slides, I'd love to welcome Luke Homan CTO of Pulumi to give a demo and then we'll talk to Brian gets uh architect at uh Oracle who works on Java to hear his thoughts on, on the new Pulumi Java support. Welcome, Luke, thanks Joe. It's great to be here and really excited to show off some of the new features doing starting with uh Pulumi. Uh Ja Awesome. All right. Well, to get started, uh we're gonna lean really heavily into the infrastructure's code thing today and we're gonna spend a lot of time in code uh in our ID environment, writing Pulumi code to manage uh cloud infrastructure. So to begin with, uh let's start with a blank slate inside our ID here. And we're gonna start with our Pulumi uh Java support. So we can run Pulumi new to create a new Pulumi project. And we actually see that as well as the existing languages that we support, like typescript and Python and javascript go and C# we now also support java. And so let's go ahead and create a new uh java project. And so we can name it uh when we have to have a demo, we can keep the default description, go with the default stack and go and deploy this in the US East one. So when we do this Pulumi new, we create a brand new Pulumi project, but in this case, uh deploying with java and using uh aws. And so just to give a quick tour of some of the core pieces of Pulumi from the Java perspective, we of course have our Pulumi file which describes that we're using uh the JB M as our run time. And so our, our, our Plume program is written in Java here. Uh We have a um Maven project uh and it uses has the dependent. So it uses our Pulumi library that we've now published on Maven Central, as well as our Plume aws library for working with the A W platform. Most importantly though, we have our actual java code. Uh And so, for example, here we can say, you know, we're gonna create an S3 bucket uh in aws and we're going to export the bucket's name. So we see here, we're just using normal Java API S to do this. Uh And so, for example, here we create a bucket and here we specify that we're gonna get the buckets uh name and, and output it. And so we can run just Pulumi up uh the typical Pulumi cli to deploy this cloud infrastructure that's authored in, in Java. And while we wait for that to uh to continue to deploy, well, I'll just go ahead and say yes to actually deploy that bucket now because we're in an ID here, we can actually get all the features of our ID. And so, for example, within the A S name space, I can see all the things that are available. And so it's not just the S3 bucket that we're working with here. It's dozens and dozens of different features of the A DS platform that are available and projected into our experience. And so, for example, I can go into EC2 and look at all the different features of the ec2 platforms that are available to me now from within my job at API S. And so all of the sort of hundreds and hundreds of API S from within the AD BS platform are projected now into Java API S and that's true. For AD BS but also for the 80 or so other providers that we have available for Pulumi, I can also go ahead and use the um Java API s that we support to specify additional properties. So for example, if I want to make some changes here, I can say I wanna pass in some bucket ags, I can use my intel sense to go create that and I can go and use the builder pattern uh to actually create the um properties. I want to pass to this with that, I get access to all the different properties of uh the bucket. And so I can specify any of the different properties I want to specify. So I could specify the ale on this to something that's not the default private or I could specify for example, the website and specify the bucket website, ags and keep on going from there. What I'll do is I'll just actually jump over to a slightly more complete version of this. It shows a handful of additional features uh in, in progress here. And so here we see that bucket where we specified the website and specified an index document. And they've also used some Java language features to take advantage of using the Java language as part of our infrastructures code definition. And so in this case, we've done a few things. We're using some control flow in the Java language like some four loops and some try catch statements we're also using built-in features of the java platform, like the ability to read files off of disc list, what's in a folder and for each one of those files, it's in this folder here, we're actually going to create a bucket object and specify some properties including that will use the content of that file as the content of our history three bucket object. So this is a very simple piece of infrastructure. It's gonna stand up a bucket and stand up the ability to deploy um some resources within that bucket. When I go ahead and do it, pulling me up here, I'll actually see some of the things that Joe was talking about in terms of this being the best of both worlds for being able to have imperative program but still desired state infrastructures code. So we don't have to recreate that bucket. We already created that with our previous update here. We're just gonna update it, add in that website property. And then we're gonna also create the new bucket object that we need to specify. We can see the details of that di exactly what's gonna change our infrastructure. We get this preview. So we know what's gonna change before we do it. And if we like what we see, we can go ahead and say yes to deploy that uh to the cloud. OK. There we go. We're updating our bucket and we're gonna also deploy the bucket object. We now get the URL out here and so I can do something like just uh grab this and say, you know, open that URL and there we go, we've got that file um stored now in a bucket. It's up in S3. We've deployed some real cloud infrastructure uh from our java code. Now, one of the really nice things about using programming languages is, you know, some of this control flow, some of the libraries are really nice. What's even nicer is the ability to create reusable abstractions. And so, for example, in this case, we've created the simple abstraction called sync files that lets us do that same thing um by using a simple API. So this is something that I can go and instead of copy pasting my infrastructure all over the place I can go and give this set of abstractions, a name this for loop that could upload the uploads bucket objects into this bucket. And here is uh I've defined that in some code just in the leather file here. And this is a, a simple java class uh that has that same code we just looked at inside it. Um But that implements the uh Pulumi custom resource uh some uh base class which allows me to sort of use all the features of Pulumi. Um But in a reusable component, this is a really important capability that allows us to really reuse code um within our project and then share that across other projects. Uh as well. Of course, once we've put our code into uh a reusable component like this, we can also now test this. So we could go take, you know, our favorite unit testing frameworks in java and apply them to this component to make sure that this component behaves as we want and then test that in isolation so that when we go and use it in other places, it works as we expect. Now, in this example, we looked at uh how to, we looked at aws and just one simple resource with S3 buckets inside Aws. Of course, Pulumi java supports everything that's available inside the Pulumi registry. And so that includes all 89 or so packages that we have here uh from our new oracle cloud provider that Joe talked about to our providers for our major platforms with database Azure Google cloud. And let's take a look at uh one additional example here of doing this with uh Kubernetes and Java. OK. So to see this, we can look at an example of working with uh Google cloud and Kubernetes. And so this is a much more complex example written in java and using multiple of our cloud providers. Uh And this example shows off a few additional features. So for example, from our java code, we can access P Pulumi configuration to allow users to specify when they deploy this stack. What is the master version I want to specify? And if not specified, we'll go and get the engine versions and just use whatever the latest version the GKE supports is we can then go ahead and create a GKE cluster. We can go ahead and create a GKE node pool and then we can use that node pull and cluster to actually create a cube config using java code. Uh That specified. How do I connect up to this uh GK cluster from Cuba? Of course, Pulumi also supports a provider and so we can construct one of those and use it to connect up to this new cluster we've created and then use that to specify some additional resources. So here we're going to specify a name space, it could be his deployment and a a service all from within our Java code. And all using the API S that we've just shown how to use. This example shows that we can build very rich things using a combination of all the features of Java plus all the libraries that are available from uh from and we can use those to specify complex infrastructure and chain things between these different providers. Now, this kind of complex code just like we saw before, we often are gonna want to take these pieces and we make turn them into reasonable components that we can use in other places. And so for example, one of the components that we have available uh for Pulumi is actually an Amazon Eks component which takes a similar pattern applied to the Amazon EK uh elastic containers, uh Cotti Service, it makes it really easy to deploy KTIS on aws with just a few lines of code. And this, unlike the, some of the other providers, we have, this is a component which means it's a piece of code written in Pulumi, not a thing provided directly by the cloud provider. And in this case, it's a component written in typescript that makes it really easy to work with uh Eks. So we can see an example of using that from Java here where unlike the previous example, which was, which was, you know, 200 or so lines of code and a lot more kind of complex infrastructure here, you've hidden all that complexity away behind a simple abstraction by using this Pulumi Eks cluster. And here we specify just a few properties, the instance type, the min size and the max size and then we can get out the cob config. So just to give you AAA feeling for what this looks like, we won't go ahead and deploy this because it'll take, you know, eight minutes or so. But if I do a Pulumi preview, we can actually see what Pulumi will deploy from this simple program. And we see that it doesn't just deploy this EPS cluster. It deploys all the different resources that we need to stand up for best practice as EPS cluster that includes obviously the underlying a Seks cluster but it also includes things like uh the, the roles and the security groups and the the launch configuration. Uh and even the config map inside the cobra cluster that we need to manage the nodes. And so this simple program, I get to use these higher level abstractions that are available from within. Uh now all these examples so far uh have been in DS code. Uh But we can of course also come in uh to other I DS like in, in this case and get all the nice rich features that they offer from really nice, intelligent to the ability to, if I make an error, I get nice uh highlighting on that and the ability to get uh really simple, you know, code completion within, within my code. Of course, when we're in in uh we can also take advantage of things like intes ability to convert java files to Cole. And so Joe talked about how we have access, not just to Java, but to all JB M languages. And so, for example, if we go ahead and convert this into Cot, uh we can see that now we're able to continue coding uh against the exact same API S available for uh for the JB M. Um But using the control flow constructs the, the uh and the expressions that are available within the cotton language. And so access to really everything uh that's available from the Java ecosystem. Uh now connected up into the powerful cloud capabilities to program the cloud uh using. Wow, that was a great demo. Awesome to see P Pulumi and Java in action together. Uh and to go deeper on Java and why we're so excited to bring Java sport to Pulumi and the ecosystem. I'd like to uh welcome Brian gets a Java language architect at Oracle. Hello, Brian. Hey, Joe, how are you? I'm great. How are you? Uh would you like to introduce yourself to the audience? Yeah. Yeah. So I'm Brian Getz. I'm the language architect for Java, which means I have the amazing job of charting the direction of the Java programming model uh over the next decade, which is lots of fun. Yes, I can imagine. Um And you know, what, what did you think of the demo, Brian? So, I, I mean, I thought it was great. I mean, I mean, obviously I like anything that makes it um easier to, you know, uh program with job in the cloud and uh deploy, deploy the Oracle crowd. Um But you know, it, it, you know, if I hadn't seen the list of languages that are supported in, you know, in the, in the demo, you might have been able to fool me into thinking that this was just a Java tool. You know, it, it, it looks like a Java program. Uh It uses all the modern, you know, uh Java Java, Api DM and it looks like an awfully pleasant way to uh to build an application configuration. Well, definitely coming from you. That mean, that means a lot. The team has been hard at work at this and, and, you know, every language we bring up, we try our best to be as idiomatic as possible. And so it's, it's wonderful to hear that, that you think we've, uh we've, we've succeeded at that. It looks awesome. You know, I, I remember a few years ago before we actually launched Pulumi, um I was talking with you at a conference, I think it's Q London maybe. And I was telling you about the idea and it, you know, the idea of doing infrastructures code in your favorite language is versus say an infrastructure specific DS L just really resonated with you. I'm curious if you could talk a little bit about why. Y yeah, absolutely. You know, there are a couple of reasons. One is the infrastructure's DS L tools are really not that great, right? They always have this bolted onto the side feeling. And the reality is that your application configuration and infrastructure is part of your program and it should be part of your programming model. And you know, if, if you have to build a program that is split across multiple programming models, things always fall in between the cracks, right? And, and you know, and, and we see this in the gap between our program and our build tools or our configuration tools where uh we have to make things agree on both sides. And there's plenty of opportunities from this. And there's, you end up using multiple different tools with multiple different paradigms. And the more that you can bring into the programming model with, you know, the your favorite language and you know Java statically typed language. So I love that you're bringing strong statically typed, uh you know, strong static typing to application configuration. It just makes everything more seamless. It's interesting, I think with modern cloud architectures, in particular, it used to be the case that we'd have a couple of virtual machines and a database and maybe it was OK to have completely separate config languages these days, modern cloud architectures just have so much, you know, so many moving pieces and with serverless and containers really, the infrastructure comes a lot closer to the application code. And in that in that world, you know, having a separate config language just really doesn't make sense anymore. A a absolutely and, and a lot of the config languages are pretty terrible languages as programming languages, right? They lack the basic um tools for abstraction and reuse and net and, and tooling for navigation ID E support all of those things. And as you say, you know, if, if you build your application out of two or three components, then having a script written in your favorite scripting language is just fine. But if you, you know, if you really want, um you know, if you're, if you're actively developing your, your application and it's actively changing, you want to be able to co co maintain your configuration with your application and you need a real programming language for that. It is funny, you know, uh I think the three of us have been working on programming languages for quite a while and, you know, DS LS always have a tendency to grow up into general purpose languages, whether you intended for it to happen or not. And in hindsight, you often would have done things differently once you get there a a absolutely. I mean, they, they, they often grow up into terrible programming languages because not only are you constrained by, you know, some relatively rigid format like XML or, or, or whatever, uh the programming language features are all often incrementally nailed on the side. So someone comes up with the idea of, oh, we need a loop construct. Oh, we need a conditional construct. And if these things aren't cosigned, they're gonna have, um, you know, odd variances with each other that makes it that much less fun to program in. Yeah. And I'm curious, you know, I, I spent a lot of years, you know, working on Java, although the language has come a long way since then, you know, II, I probably, you know, haven't really done much with, you know, generics and lambdas and some of the modern innovations. Um and Luke spent a lot of time working on Java script. Um I'm not sure how much, you know, Luke himself until we're bringing up Java has spent in the ecosystem. I'm curious, Luke, what are, what are your thoughts? And do you have any topics for Brian today? Yeah. Well, I guess, you know, one of the questions I have for you, uh, obviously Java has evolved a ton in the last, you know, 10 years or so. And I imagine, you know, over the last few years, there's been a huge amount of growth in the language. And, and I imagine that the cloud has played a part in that as, as developers are, you know, using Java are sort of deploying more and more into cloud environments. Now, how do you think about kind of how Java is, is growing as a language for the cloud? Yeah. So, so you know, one of one of the things that is, you know, that makes this job continually interesting is that the people, the things people want to do with their programming languages is evolving over time, right? And so we're in the middle of this migration from having built these monoliths to having, you know, built more loosely coupled applications that are built out of services. And what that means is one of the things that mean that means is the size of any given programming unit is smaller. And that means that more of the code is closer to the boundary and more likely to be dealing with data that's coming in from the outside world, not as a serialized Java object the way it was back in the Java ee days, but as a Json document to rece a result set or, or something like that, and even if it's coming from a place that has data types, they're not necessarily the same data types as Java has, they may not have the same range for integers. And so, you know, you don't want to have big expensive code at the boundary to, you know, uh translate from these formats because that will overwhelm your actual business code. And so one of the things that, that we've uh we've embraced is a sort of more data oriented programming uh and features like, you know, records and seal types and pattern matching, make it much easier to uh sort of define the boundary between your code and the UN type, messy real world code uh in a, in a flexible and relatively way. And, and I, I think that's, that's going to allow you to have Java participate in applications that might, you know, not just be pure Java, but maybe a mix of various things and, and still get all the benefits of Java without paying this huge tax of OK. Now the data is coming from this other UN type language into Java and I, I have to do something about it. Yeah, that, that really resonates with me, you know, the the infrastructure side is, is is difficult and infrastructures code is one key component, but there's the application logic, the, you know, the the need to build these finer grain services, even sometimes down to the individual function as a unit of deployment. And that really changes the way you think about data connectivity, concurrency. Uh One of my favorite books on my shelf pack here is your book Brian, you know, concurrency and practice. Uh And um you know, there's a new kind of concurrency that people have to worry about. It's, it's not shared memory concurrency really. It's, it's sort of this more distributed programming architecture. And I know a lot of the, you know, the future you mentioned you, your, your role is to invent the future for Java. And can you talk a little bit about, you know, what's on the horizon? What isn't solved yet? What are some of the, the challenges you're facing? Yeah, I mean, I mean, how much time do we have? Jeez um There, there is, there is so much yet to do, right? So, you know, one of the things that's really exciting about what's coming up soon is uh project loom, which is sort of rebuilt the concurrency model for Java by not rebuilding the concurrency model for Java, right? So for the longest time, everyone thought, oh, you should do ay weight, you know, or you should do a reactive library and we thought really hard about it. And we realized that the um the programming model, you know, with, with that java gives you with threads is actually pretty good. Uh And you know, and, and it gives you nice service ability and stack traces and all of that good stuff uh and code you can read. Uh But you know, the, the unfortunately, if you delegate management of threads to your operating system, threads are pretty expensive and you can only have a couple of 1000 of them. And that puts a limit on scalability. And basically we rebuild the thread implementation from the ground up uh where sta thread stacks can live in the garbage collected heap. Um And uh you can, you can now quite easily have a million threads running on uh you know, commodity, you know, uh desktop system. Um and, and still get the full benefit of the java sequential threading model with all the tooling and all the serviceability and, and everything. It's great. Yeah, that sounds, that sounds amazing. It's interesting, you look back the concurrency models in the two thousands, you know, with task parallelism and Ay Wade and just a few targeted changes to language in the run time really did change the game by an order of magnitude. Um Yeah, absolutely. I, I feel like we could be talking for days here and I, I look forward to seeing you at a real in person conference sometime soon. But for now I think uh why don't we wind it down? Thank you, Brian so much. And Luke, please stick around. We've got more demos to come. Thanks a lot. This was great. So we've seen why using general purpose languages is so powerful from uh an in infrastructures code standpoint, really giving you the full power of the cloud at your fingertips, you know, full program ability, great productivity. But we're gonna take things a little bit of a different direction for a moment here. You know, we, we definitely know that infrastructures code runs a full spectrum of, you know, simple use cases to very complex use cases. And being universal means that as Pulumi, we won't have a solution for all points along that spectrum. Um And you know, there are three kind of use cases where maybe a full programming language might not be the first uh thing to pull out of your tool, tool belt. You know, first is those simple cases, you know, maybe there's just one or 23 resources you need to configure, maybe you're code generating some IEC and you know, code generating a full language like javascript is always complicated, especially if you have to parse it afterwards because that's the first case, you know, the simple use case. The second is, you know, not every operator uh is, is an expert in up in programming languages or has an engineering background. Uh We've certainly heard a ton of amazing success stories of folks with it ops backgrounds, deciding to learn Python really up leveling their skill set and their career. Um and really investing themselves. We love seeing that, but we know, you know, taking a pause to go learn a full programming language isn't always top of mind for folks and, and isn't necessarily the, the next thing to reach for, um when you're trying to do infrastructures code. And then the third is ironically, you know, not every application developer really wants to go deep in the full program ability of infrastructures code, uh Maybe they'll get there eventually when they realize the benefits of bringing cloud architectures closer to their applications. But they're not infrastructure experts, they want a simpler approach for infrastructures code. And we see, you know, YAML is very common in the industry, it's sort of an industry standard you look at Kubernetes uh is, is all, you know all about YAML um cloud formation from A to BS uses YAML. I mean, there, there's a lot of YAML in the world in many cases, it's a problem um because people bend and twist YAML to do things that it was never intended to do. Um But it's an industry standard. Um we see, you know what can happen when people try to solve the complexity problems with YAML with, you know, things like helm embedding go templates. And this has led to domain specific languages like Hashi Corp configuration language HCL, which is a proprietary language that Hashi Corp has created for their infrastructures code tool. Terraform. Unfortunate thing about that approach is, you know, at least you're not jamming goat templates into YAML. But you also run into issues where you've got to create ID E support. You saw all the things that Luke showed with, with Java. We as Pulumi didn't have to go build all that support. We're just tapping into all of that great innovation in the community by going and doing A DS L. Somebody has to go recreate everything, you know, from ID ES to package managers to test frameworks, you know that a very long list uh that we love getting all those things um being able to stand on the shoulders of giants by tapping into programming languages. So we've taken a different approach to how do we solve for the entire spectrum of infrastructures code. And today, I'm really excited to announce Pulumi support for Yam and remember the L in Yaml stands for language. Really YAML is just another programming language to us. It's another way to access the entirety of the Pulumi ecosystem. You can express your infrastructure as code in a simple YAML file and you get all of the features of Pulumi, you can access all of the the different cloud providers. We've talked about earlier, those 80 plus cloud providers, you can even access components written on the other languages. So if your infrastructure platform team is creating components and go and publish them them, you can easily consume them from YAML. Very simple format. Um This really helps to bridge the de and ops divide. We find that, you know, this, this helps to round out Pulumi support so that we support all the way from very simple data format. Yam all the way up to the most capable most popular programming languages in the industry. And this allows you to scale up as you, as you need. You can even start with the animal and eject out of it as you hit the wall on complexity. So maybe you started with the animal because you had a simple architecture. Um But now, now you've refactored, it's gotten more complicated over time. You're starting to think about, hm I could use a for loop here or a function or you know, some abstraction. The Pulumi convert command actually just takes your Yaml and converts it to whatever language you want. Maybe you wanna go to Java next or maybe it's Python uh full support for the entirety of the Pulumi language ecosystem to convert out of Yaml when you hit that phase where maybe you've outgrown uh the needs of, of Yaml. One last thing to highlight here is because we're using an industry standard YAML. It's not a proprietary DS L. We get all the benefits of that ecosystem and one in particular that we're really excited about is Q language. The Q language is a templating language on top of YAML, it's sort of in between on the spec of YAML to a full blown language. So perhaps instead of converting out when you get to the need for some, you know, templating or, or uh more sophistication, maybe you can reach for Q or one of the many other industry standard YAML based uh tools out there. And so really embracing where the community is and helping to bring simpler in infrastructures code to us. That's a key component of being universal infrastructures code. And to see in action, I'd love to invite Luke back on stage and fire up that editor and see some memo. All right, really excited to be back to uh show off our Pulumi YAML support. Um So, as Joe mentioned, really with our YAML support, we're going to the opposite extreme here really trying to be the simplest possible interface to the entirety of the Pulumi uh platform. And so what we're gonna do is start it with a completely blank slate. Uh So we've got nothing here at all. We'll just go ahead and create a Pulumi L file. I'm gonna open that up within our Pulumi file. Um Just like we saw in our java demo, every project uh in Pulumi has a Pulumi file. It has a simple name like, you know, Yaml demo uh and it has a run time. And so in the last demo that was, you know, we're gonna use the Java platform in this demo, it's gonna be, I'm gonna specify uh ya. And so when we specify YAML as the uh runtime version for a polio file, it means that we can actually start to specify things in line inside the POMO file instead of specifying them in code in another language. And so in this case, we're gonna specify our resources. So we're gonna specify one and bucket resource and we want its type to be AWS as three bucket as well as specifying resources. We can specify outputs. And so in this case, I'll just specify the bucket name and say I want it to be the buckets ID now, just like uh with any other Pulumi program, we can use the Pulumi cli to deploy this infrastructure. And so in this case, we deploy the bucket, we go ahead and say yes and that, that deploys the bucket out into WS, OK? So just like we saw though with the Java example, we can use, we can specify additional properties. And so for example, here we want, might wanna specify that website property which has an index document we may specify that's gonna be indexed at html. We might also want to grab some additional uh code and I won't type this all in, I'll just copy, paste it so that we can move a little bit faster here. Uh And this allows me to specify an additional resource. I'm gonna index on html files and I'm gonna upload as a bucket objects just like we saw in the Java demo, just like we did in the outputs. We can also reference the bucket as an input to our bucket object by specifying the dollar currently. And this is a simple interpolation that let's just take the value of some output of resource and use it as an input to another resource. We go ahead and say pulling me up and we go and the exactly the same way desired state infrastructure code, I'm gonna update my existing bucket and I'm gonna create this bucket object. OK? So very simple code, you can do all the same things that we could imagine kind of from that java demo. But now just using this interface of a simple memo file, now this is a really simple example. Um but we can also do a few other things. So for example, I might want to specify uh a Cobert pod and so we have a Kubas provider. So I can specify, you know Kubernetes V one uh one pod, an interesting thing about this is that because is the sort of lingua franca of Cotis, I can actually come over uh into a site like this where I've specified uh where I find a few examples of of kind of pods in TTI I can go ahead and grab this text and just specify it right in line here which I just gotta specify the properties because it's just L I can literally copy paste this in. Go ahead and do Pulumi up. We see the Pulumi up here will actually say it's gonna remove the bucket and bucket object and create the one pulk. So let me go ahead and do that. We're actually gonna create a coupon, a pod in my local uh coupon a environment and then clean up the resources we no longer need. I can go ahead and say coup will get pods and see that exactly that pod that I just specified in that code that I copy pasted is available. Now, this is just uh YAML, so I can just copy, paste it from. But of course, I can also means I can sort of reference things that I might have defined somewhere else. So if I had the name of this image, it's that as Pulumi configuration, I could use Pulumi to coordinate that if I wanted to take the output of my pod uh like the pods identity and use that another resource I could easily do that. And so we can use all Pulumi engine's ability to do deployment orchestration along with uh the ability to specify things in this YAML format. Now, there's one additional sort of example that uh is maybe interesting to show and that is Joe talked about the ability to sort of use components built with other programming language, the typescript or, or java or go or any other language available in the Pulumi ecosystem. We can build reusable components, put them in the registry or define them for use within our organization and then consume them from our, from our YAML code. And this makes it so that YAML can be a very simple interface where all the complexity gets pushed into uh other places. And so for example, here, we're gonna have the EPS cluster. And if I just do a simple Pulumi up right here, we see that. Well, oh I didn't save my file. Now, let me do it, pulling me up. I'll actually see that even though I just specify this single line of code for the cluster, just like in the Java demo. Uh This is going to create many resources. Well, I need to specify the region as well, but just like in the Java demo, this creates many resources. OK. So this is a very simple, all these examples have just been a few lines of code. Um But of course, you can build more complex applications uh with the, the Pulumi support. And so here's an example that shows off a few additional features of uh Pulumi Eml support. So we saw resources and we saw outputs, we can also use configuration and variables. And so for configuration, we can specify those Pulumi config uh that we can set by the Pulumi command line. And here we specify that way a SQL admin uh configuration setting which has the default value of Pulumi, we can also uh specify variables and these are names that are going to be bound to the results of of making calls into the cloud provider to get information out and use it within our resources. So for example, call Azures get shared keys and Azures list registry credentials within our Azure program, we can of course do a lot of the more complex things that you can do with Pulumi. Um but all through this EML interface as well, so we can specify things like our resource group, we can use that resource group to create a cube environment. We can create an Azure container registry instance and we can use that container registry to then work with our docker provider to build and push an image to that registry and then use that image from within a container app in Azure. So complex coordination across multiple providers all with this very simple kind of interface, I won't show deploying this example because it'll take a while. Um But it's an example of how I can sort of build these more complex things. But of course, if I can build these more complex things, uh YAML can become difficult to manage once we get that to scale. And so there's a few ways that we approach how you manage scale for these YAML projects. The first is of course, because it's YAML, we can cogenerate this from other languages or cogenerate this on the fly from programmatic interfaces. And that creates a whole bunch of new opportunities for how you interface with Pulumi via this as a programmatic target. One example of that is uh Q and so a bunch of different languages that compile down to YAML, Q gaining a lot of popularity in some uh uh parts of the, the, the space and Q is sort of a layer on top of YAML or adjacent or these formats, which lets me introduce some additional concepts like they have reusable components that I can specify like the static web app. They have the ability to have some a simple type system that can do some type checking over my YAML files and the ability to specify defaults and, and structures and that sort of thing. I can then use that to take my uh reasonable component and instantiate it twice as the resources. And so, for example, if I run this, um I can run my Q tool to compile this down into YAML and then I can come over here and say, pulling me up to deploy this and here we go, it's gonna deploy two copies of all of these different resources. Um Because I instantiated my thing twice. Now, if I want to really take advantage of all the benefits of Pulumi as I scale up the complexity of my infrastructure, I can also go in uh convert my Pulumi programs right back into uh something that works uh in, in any of my existing Pulumi languages. And So if I take this project as I specified it before they go back into that folder, I can actually also run Pulumi convert. So let me convert, say I want to convert it to Python and specify that I wanna put it into this other folder. There you go, I'm gonna convert that and come over this folder and see that what I generated was actually a Python file that has the exact same definitions as my existing Yaml project. And in fact, I can go ahead and continue to develop from here. I can write tests using my test framework of choice I can use for lips. I can use abstractions, all those software engineering benefits and I didn't get stuck kind of at the limits of what YAML can support. I have a natural off ramp onto proper software engineering practices available inside richer linear languages. And so that's a great summary of kind of the Pulumi support from really simple programs to more complex things and then the ability to ultimately eject out into uh any of Pulumi existing languages. Oh Wow. That that was super cool. I have to admit I I'm really excited to be launching. That's probably not something that most people would expect for me to say. But you can see all the power and capability of the Pulumi platform just shining through with a simpler interface, the ability to grow up at as needed. Um Really Pulumi is the first universal infrastructures code tool that supports any cloud and supports YAML and the full spectrum of programming languages. We think it's just a you know, combination uh made in heaven. So super excited to, to be launching that today. And you know, we're talking a lot about infrastructures code, but it's really important to, to realize that everything we're talking about integrates with the Pulumi cloud engineering platform which enables teams to adopt infrastructures code and go beyond that. Um And you know, I want to highlight a few key capabilities of the infrastructure. Uh the way that cloud engineering platform works including we've got Pulumi cross guard, which is our policy as code engine uh supports, you know, lots of different languages for offering policies including open the open policy agent. We've got test frameworks and integration testing so that you can do continuous verification as you're delivering your infrastructure, whether that's testing your application code, testing your infrastructure code testing that you know, ephemeral environments are actually functioning before you do deployments. A lot of richness and capabilities there, get all these C I CD uh integrations so that you know, hey, it's a great developer desktop experience as you've been seeing with uh the demos, Luke has been giving. But when a time comes time to go to production, you can have secure pipelines and really put your production environments under lock and key. And actually, you know, really harden the delivery process and unify how you deliver applications and infrastructure to scale from one environment to 10 environments. You know, some poll customers are managing tens of thousands of environments using this uh approach. And so it's important uh to point out there, of course, secrets management is built into polling, it's not bolted on as an afterthought. So if you're, if you've got sensitive information and you're config you've got a way to do that out of the box role based access control, integrated identity policy enforcement. At the server side, a lot of great capabilities uh that enterprises need to operationalize infrastructures code. And from there, we're gonna talk a little bit about cross code. We haven't talked much about cross code, but this has been in the works for over two years now and cross code really is the secret sauce to making the Pulumi magic work. Uh Cross code is how we've been able to support the entire platform across all of these languages and to deliver it in an idiomatic way. And we'll talk about a few of the key capabilities and we'll talk about some sharing and reusing. Get back to some more demos with Luke uh shortly. I think, you know, one key capability of cross code that it gives us is universal translation. Um If you're starting from somewhere else, which we know a lot of people are, you might have used terraform and uh in the past, you might have used cloud formation, you might have some L arm templates, you might have manually pointed and clicked in the console, which is a fine way to get started. It's an easy way to explore and understand what the cloud has to offer. But now you're ready to move to a universal infrastructure code platform. I, you know, Pulumi, we've got a few ways to do that. Thanks to cross code, you can translate existing infrastructure. Uh We have a TF to Pulumi tool, an arm to Pulumi tool. You actually go to plume dot com and we have these uh both in command line form and a hosted website version to do this conversion. Um You can actually import existing resources and this is really mind blowingly cool. The Pulumi import command, which we have completely overhauled. We had a, a different version before now, we've hooked it up to cross code and it actually generates the infrastructures code that would have produced resource state that already exists in the cloud. So if you went into the console, you spun up some resources, you can actually run Pulumi import, give it the ID and it's gonna spit out code in your favorite language. Java, yaml, Python, any of the existing languages. And then you can take that and from there, your fully on infrastructures code really helps to onboard, you know, no matter where you're coming from, we've got a solution to help you get up and running on Plume cross code is also the way that we have cross language sharing and reuse. Um We launched the Pulumi registry last year and you know, the package model and cross code is enabling us to write in any language and consume in any other. You saw this in action in Luke's demo. You know, the EKS cluster is one example of a package that's written in a language, but you can consume it in in any other language. And we saw that you can do that from L, you can do it from Java. And the reason why on day one, we have support for all of this is thanks to cross code and of course, we support all the native package managers uh as well. So speaking of package management and building abstractions, I wanted to speak a moment about going from building blocks to architectures. You know, one of the key things with Pulumi is we support over 80 different cloud providers and we give you the full capabilities of the underlying resources, every property on those resources. We really want to get out of your way and just expose the entirety of the cloud in a programmable fashion. So you can use it from infrastructure as good. This gives you amazing control, amazing capabilities. The thing that I love about this. And this is really the way the aws platform was built is you have all these capable building blocks and you can stitch them together in infinite ways to build new uh architectures. But sometimes that can be, the daunting part is trying to figure out how do these things fit together. And frankly, you know, after your, you know, 30th time stitching together all of the things that constitute a virtual private cloud or an EKS cluster, it starts to get a little tedious and, and that's where abstraction and sharing and reuse and encapsulation come into the picture. We can build libraries, we can build entire frameworks on top of that and really deliver great productivity with best practices building. But let me crosswalk for Aws. We launched, uh you know, a couple of years ago, it's great. It has a lot of these well architected patterns and practices out of the box. I mentioned VPC S and EKS. It's got great abstractions for those, but also API gateway, LAMBDA, Cloudwatch, Im Load balancing ecs, if you're, if you're using, you know, the, the native container service, a lot of great patterns so that you can benefit from tried and true best practices. And this has been built with customers in the community. It really does reflect the, the common best practices that you would want um by default out of the box. And we're really excited today to announce that Crosswalk for Aws is now available in all languages. Originally, we launched this as typescript only. Um But thanks to cross code, we're now able to deliver crosswalk for Aws in all languages. Another exciting thing that we've we've done in our launching today is we've actually implemented support for Aws CD K on Pulumi. Many folks may be familiar with uh Amazon's cloud development kit. It's uh it takes high level languages and trans piles them into cloud formation gamma that you can then go take and deploy through cloud formation. CBK offers something called constructs very similar to Pulumi components. Uh Constructs are classes that encapsulate common patterns and the A DS teams themselves along with the community have built up a library of constructs and those are written in typescript and available in other languages. And what we've done is we've actually taken those constructs and made them work on top of Pulumi. So over 1000 different constructs that represent additional best practices and patterns can now be run on top of Pulumi. The great thing about this is it's not deployed through cloud formation. So it's not trans piling into Yamma like CD K typically is, in fact, some of our early adopters have said they actually prefer using AWS CD K on Pulumi to the native CD K itself because deployment is all orchestrated through the Pulumi engine. In fact, you can mix and match, you can use a little CD K here. So Ploy crosswalk over here, some Kubernetes resources, some Azure resources, all on the same project. And by the way, that slide with the cloud engineering platform, you're benefiting from all of that at the same time. So policies code is running against your CD K constructs. You can do C I CD. All of the Plumy platform is now available with CD K running on top and to see some of these uh sharing and reuse and abstractions and something we like to call infrastructure software in action. I'd love to welcome Luke back for another amazing demo. So in the last few demos, we've really seen how we can sort of take new programming languages and, and access the entire richness of the platform. But over the last six months or so, we've also been working hard on, on expanding the richness of the platform and what you have access to from all of the Pulumi languages. And in this last demo, I want to highlight some of the new things that we've added that are access to different capabilities in the cloud. So in the registry, uh since we launched this last fall, we've added dozens of new uh packages and I'll just highlight a couple of interesting new ones. One, you know, we added the command package. Um This has been one of our, you know, fastest adopted new packages, opened up a whole bunch of interesting use cases for, you know, access and running local and remote uh commands. Uh So promote, promote provision of EC2 instances. Uh All sorts of interesting things that are being unblocked and enabled um by this provider. We've also added uh lots of new cloud providers and stas providers uh working with various partners. And so, working with partners of elastic added support for elastic cloud um very easy to, to work with the cloud version of elastic um from within the program and to coordinate that along with your other cloud infrastructure. Now today, uh we actually also launching uh our own uh new package, which is a provider for the Halloumi service itself. So Jo talked about the cloud engineering platform that we offer through the Pulumi service. Uh And we've had obviously Pulumi users are big believers in I ac they want to be able to manage all the cloud platform, they have uh from infrastructures code. And so with this new provider, we give folks access to actually using uh Pulumi to manage the Pulumi service. And let's start by taking a look at that um in action. So I can come over here into my code and to say Pulumi service dot And see that I can access a handful of different capabilities of the Pulumi service from directly within my infrastructure's code. So I can manage teams. What are the teams, what stacks they have access to, what users are available in each one. I can programmatically provision and de provision, access tokens and I can create uh web hooks uh for delivery. When I make updates to my infrastructure, I want to get notified and be able to handle this. And so to see what that one looks like in, in practice, let me just say um it's con we book, it was a new uh web book. We can see, I can specify just a handful of properties on this. I want it to be active. I want the organization name to be my organization upstarts on the display name to just be, you know, Pulumi Pulumi, since we're using Pulumi to manage Pulumi. And then the last thing I need to specify a payload URL. And this is where do I want to send the web book. And of course, I could go and provision some infrastructure somewhere else to, to define uh a handler for these things. But of course, one of the things that's awesome about Pulumi is that it's really good at provisioning uh structure for other use cases. And so, for example, here I can just use a SX to create an API gateway that handles post requests to the route and then just prints out what it sees. And so now I can just hook those two things up. And so I want to deliver the uh webhooks to that URL come down here and just say, blew me up uh and deploy uh this piece of infrastructure, right? And so we see it's gonna actually deploy 18 resources including that Pulumi service webhook, but also a handful of other resources to define the API gateway and all the compute needed to run that. So we're gonna see it's gonna take a couple of seconds to actually deploy this. But one of the interesting things we can do also is click on this link here to go into the Pulumi service and see a little bit more information about this deck. So this gives us access to all the features that Pulumi cloud engineering platform. I can see the update deploying uh just as I would from the cli but now stored inside the service. I can see the various resources that are being managed here. Uh And so I can see all the different things that are so far available, some of them are still provisioning so they're not listed here yet. And of course, I can also go see what webhooks I have for vision. And so for my upstarts organization, I can come over to settings, look at integrations and I can see that I have this Pulumi Pulumi Webhook already set up that I just specified in my infrastructure program. Now, the interesting thing is if I actually click on this, I can see that we already have delivered uh a notification web book to that a few seconds ago. And that's because the update that created that web book actually itself was an update that needed to say, get sent to the web book. And so we've already actually invoked um the same web book by running that thing. So this is sort of an inception, the update triggered a webhook that ran uh and, and hit the end point provided by the update. And so if we do logs, we actually see that within my LAMBDA, I actually that I implemented here, I actually got logged that output and I can even come back here and see which update it was that triggered uh the web book. So really kind of cool that I can combine managing the Pulumi service with uh these other capabilities. Now we saw here using Abas X and it still mentioned, Adibi X is now available in uh uh all of the booing programming languages. So we can take a look at that uh in this example here. So Abas X offers best practices patterns for a for a number of different uh building block services. But one of the most popular is actually working with ecs and fargate, ecs and fargate are rich services for just running containers in a really simple way using uh using A but the interface to them from instructors code is is somewhat complex. In terms of the raw building blocks, you have to use all the pictures of of load balancing and all the features of target services and past definitions and all the different pieces involved in that. And so with AWS X, we give a really simple interface to that with where with just a few lines of code, you can build really simple uh applications that deploy containerized applications to aws. In this case, we just say we want an application load balancer, we want it to load balance on port 80. Uh And then we want to specify a Fargate service that's gonna run the the engine X image with a bit of memory um targeting the container port and using that load balance as the fault target group uh that was created above to specify this. We then go ahead and export the URL just by concatenating HDP to the DNS name of the load balancer. So I won't go ahead and deploy this. Uh This takes, you know, three minutes or so. But what I can do is actually run, let me stack this to see what we've deployed here. Uh And we can see that even though I only had to specify the load balancer and the fargate service underneath the hood because this is a library that implements best practices. We're actually creating all the different resources needed to do this from the fargate task definition and service to the rules and security groups uh to the load balancer, target group and listener that I need. And so this is what we mean by sort of taking those best practices, taking those um you know, same defaults and embedding them into a really easy to use library. And of course, now I click on the, the link that was provisioned. Here's my engine X container running inside uh aws. So A SX is a really nice interface, it's really polluting native uh that provides access to these features of the kind of core A S platform. But like Joe mentioned, uh the A W CD K also provides a bunch of constructs for working with a higher level with a bunch of the different uh a services. And these services are often built by teams uh at uh at AWS who are defining the sort of higher level interfaces to the various pieces of their platform. And so for all kinds of different services available from aws, we have these higher level libraries that I can go and look at and find the documentation for and start using from within I CD K applications. But with the new Aws CD K on a Lumi, we can actually go and do that in a really interesting new way. So this is an example uh piece of code that uses AWS CD K on. And if I look at this code and I'm familiar with the CD K, this actually looks almost identical to a CD K program. In fact, this code here is literally uh just a piece of a W CD K code. And in fact, I'm using the exact same libraries. So this is the, the CD K library that was provided by uh the CD K team. And these are the libraries for working with LAMBDA and event targets and events. And I'm using those within my code. The only difference is that I'm using this Pulumi CD K library and I'm writing this within a Pulumi program. And since this Pulumi CD K library says I want to go and deploy this LAMBDA stack component specified with the CD K libraries. But instead of deploying it to uh cloud formation, I want to deploy it as part of this Pulumi uh deployment. And so if I go ahead and do that, uh well, I actually went ahead and did that above. Uh it takes about a minute, so I won't, uh I won't just wait for it to happen. But you'll see that what happens if I go ahead and uh do a deployment of this program is that we have our polluting stack here and it inside it has a CD K stack and that CD K stack defines a bunch of CD K constructs. But those CD K constructs themselves actually, instead of deploying cloud formation, they deploy um Pulumi resources using the ABA and native base native providers. And this is possible because of our new Abas native provider that provides the exact same surface area as cloud formation, but as resources in Pulumi, so you can easily take anything that targets cloud formation and use it to build individual resources in Pulumi. What's even cooler about this is that because we're just using Pulumi to deploy this, all these resources are available and, and get to benefit from everything that we've got in the cloud engineering platform, including if I come over here and look at the graph view of this uh of this application, we've got all of our raw AWS resources at the bottom here. But it's also got all of our CD K constructs in our resource tree. And so the Pulumi service understands all these resources, understands what we're managing and can run all the features it has against, including policies, code and other features like that. So across all three of these, across the new Pulumi service provider, across the uh A SX available now for all languages and across our ability to use the A S CD K on Pulumi, we're giving developers access to tons and tons and tons of new uh API S and new things they can do across all of Pulumi languages. Well, that was really fun seeing the entire Pulumi platform in action, especially the inception moment with Pulumi deploying Pulumi through Pulumi with web hooks and lots of Pulumi. Love it. So let's let's uh wrap up. I just wanted to do a quick recap of uh what we heard today and talk a little bit about what's in store for the rest of the event today. So today, you know, we're really excited to talk about universal infrastructures code. We really are excited that Pulumi is the first platform to really embrace the full spectrum all the way from, you know, simple things, simple, hard things possible, great programming languages, uh you know, really highlighting the addition of java support, but then also YAML with full integration in the entire Pulumi ecosystem, that ecosystem is just growing really fast. We talked about some of the community growth. I, I think it's just gonna continue accelerating from here. Uh We're seeing tons of, you know, practitioners and companies really building amazing things using Pulumi. You can see that, you know, in the partner ecosystem growing, you know, over 1000 new packages uh in terms of, you know, CD K inter plus crosswalk plus, you know, folks like Oracle Cloud now integrating with Pulumi. Um and really all of this magic powered by cross code uh are open source cross language technology that allows for great translation tools, multi-language sharing and reuse everything today would not have been possible. Uh Were it not for cross code? And you know, in summary, why, why do people love Pulumi? Well, I think, you know, first, the universality, the fact that it can be for the entire team for developers, infrastructure experts, security experts and and everywhere in between folks with more of an it ops background, folks with a coding background, a software background, everybody can really use Pulumi. The second is it's a standard workflow for any club. Of course, we're not gonna hide what makes a special or Azure special. But the workflow, the way you interface with the cloud, the way that you do your deployments manage, apply policies that can be standardized across any cloud, public, private or hybrid. Um And that's really, that's really important, especially in this modern cloud era where we're mixing, matching lots of services. We don't wanna have to be doing ad hoc bash trips to integrate, you know, kubernetes coop control with terraform with cloud formation and this thing and that thing really Pulumi just allows you to standardize on one thing. Third best in class productivity people that try Pulumi walk away saying, wow, this is just so much more pleasant and productive. You get more done with less time and who doesn't, who doesn't love that? Uh The four is real sharing and read. So we go beyond copy and paste, you can actually capture and codify best practices, whether those are industry best practices or your own organization's best practices. Um You know, we don't have to copy and paste 6000 lines of every time you want a virtual private cloud, we can actually just use a real component. The fifth is really embracing this notion of cloud native, bringing the cloud closer to our application development while also giving great software engineering tools and techniques to infrastructure allows you to seamlessly scale. You know, both on the language side going from simple all the way up to full blown programming languages go from tens or hundreds or even thousands of resources and environments, you know, scaling worldwide as your company and your project succeeds and finally just shift faster with confidence. You know, uh many of our customers say they can do an hour is what used to take weeks and that's a pretty big game changer, especially when folks want to focus on business value. Uh Pulumi just really gets out of your way and just lets you innovate and, and create amazing things. And I love, you know, Flores's uh tweet here. This is actually multiple years ago. But you know, something, sometimes something special comes along that makes you feel like you have superpowers and enables you to do more and less time, makes your work feel less involved and ends up more robust to pollute. Is that special thing? I just love this tweet. It's made my favorite tweet of all time because I think it succinctly captures everything that I was just talking about on that last line. So thank you for joining me at the keynote. Uh You know, thank you Luke for some amazing demos. Thank you Brian for sharing your thoughts on Java. Uh really exciting day. Um But we've got a lot more in store. So we've got a practitioner track and a cloud leader track, the practitioner track. We're gonna go through some of the, you know Java and Yaml in a lot more depth. So you get to see uh the full capabilities of of what we got there. And we're gonna hear from some cloud leaders on what does it mean to adopt cloud engineering and how does Pulumi help the enterprise adopt cloud engineering at scale? We'll see from some customers talking about self service infrastructure using automation. We'll have a couple of great panels, you know, more of a developer practitioner led panel and then also a cloud leadership panel. Uh and then I'll be back at the end uh to wrap things up. And so thank you so much. Everything you see today is available free. It's all open source, go to plumy dot com slash start to get started and enjoy the day. Thank you for joining me.

---
