---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Cloud Engineering Summit 2021: Opening Keynote --- Kelsey Hightower & Joe Duffy Fireside Chat"
title: "Cloud Engineering Summit 2021: Opening Keynote ---..."
meta_desc: |
    Listen in on as Kelsey Hightower and Joe Duffy discuss the past, present, and future of the cloud infrastructure landscape. Hear key insights from ...
url_slug: cloud-engineering-summit-2021-opening-keynote-kelsey-hightower-joe-duffy-fireside-chat
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Cloud Engineering Summit 2021: Opening Keynote --- Kelsey Hightower & Joe Duffy Fireside Chat"
  description: |
    Listen in on as Kelsey Hightower and Joe Duffy discuss the past, present, and future of the cloud infrastructure landscape. Hear key insights from Kelsey on everything from best development practices to how to run an engineering that lives in the customer's shoes.
  sortable_date: 2021-10-20T23:00:09Z
  youtube_url: https://www.youtube.com/embed/w6Dj2zf-39M
transcript: |
    Could you reach out and pull that up? You know, I've been waxed today. Oh, if I start sweating profusely, they said they, they can Photoshop it out. Do I look at just this camera? Is that ok? And then get back. Welcome everyone. Oh, should I not talk to the camera? Everybody here already knows who you are not me. So I introduce myself, Kelsey. I think, I think you and I both sort of share a background in software engineering. We somehow found ourselves working a lot in the cloud and infrastructure for the better part of the last decade. I'm curious to hear a little bit more about your story and what led you to infrastructure and why are you excited about the cloud? Yeah, a lot of people um you know, you start your career in tech mind in particular tech support system administration. And I'm talking about the type where you're s into servers uh writing bash. Those were the tools that I started on. And I remember around like the 2009, 2008 time frame. And that's when I was introduced to that concept of configuration management and the tool I was using at the time, you know, its idea was let's bring a real programming language uh with the DS L to this space and formalize the way we're thinking about automation. And that was kind of my introduction to infrastructure as code. And then I went to go work at that place. So I think that's where we have a lot of commonality is building tools to help people automate those infrastructures. And, you know, since then I went full circle, you know, the whole container movement. This idea of even though we have infrastructure as code, should we think about changing the things that we're automating and deliver some new abstractions? Yeah, I remember, you know, back, back in the days where he racked in stack servers and then suddenly you actually had a an API that things were behind. What are some of the biggest changes that you've seen in the last 10 years since, since then? You know, when I, when I actually think through that, unfortunately, not a lot because the fundamentals are roughly the same. If you think about the whole virtualization path, it's literally trying to mimic and recreate that physical world, but in more, in a virtual sense, so it was almost one, a 1 to 1 mapping still IP addresses and virtual machines and Linux operating systems. And so instead of racking and stacking, you literally do have people that have a console of all their servers, they even give them names like transformer names. I like what are you doing? These are, you know, these are inanimate objects. Why are you naming them? But that's still a thing. So I think that the world as much as it's changed at some level, a lot of the fundamentals are roughly the same. And I think this is why it's still hard. You can't assume everyone has access to the cloud and the new abstractions most of this work. And I think the reason why Pulumi exists is because of all the complexity of trying to take multiple systems that have evolved at different paces and try to automate them to make them feel like a single system. So I think the biggest changes that I've seen that are on the positive sides are the new abstractions. You know, the whole world talks about containerization. And even with all the hype, I think the biggest thing that we've gained is more concrete abstractions like we have in the server world. When someone says that they rack and stack a server, they know it's gonna be about 42 inches. They know that there's gonna be a switch at the top and they can plug in an Ethernet cable. Pretty much everyone knows how to make one. So you have this level of consistency because we have shared vocabulary for that physical world. And now some of the newer attractions like containerization are giving us the same thing at the application level. And now we have a much better target in. Yeah. Yeah. It's, it's interesting for me you go and draw a piece of software or a architecture on a whiteboard. Often I find it's conceptually simple and then mapping that into the real world is where it gets messy. And a lot of the concepts you just mentioned are where it gets messy, you know, networking storage. Why, why is it that the gap is so large and continues to be so large? Do things like serverless and containers really promise to solve that gap. I think the biggest challenge is that we're all practicing, this isn't a hard science where these things are universally true for everyone. Like security isn't practiced the same by everyone. Some people need to take certain trade offs and some people can't make those trade offs depending on the type of data that they're handling. So given that this is a practice, there is no static way of doing it. This idea that there's a way of doing it, right. That's where I think a lot of times we get a stray in the industry. So new tools shows up will say this is the right way of doing something or we'll make a claim that this is the best practice. And then what I think that does is it starts to distract us from the reality is that every organization, every developer, every team, every situation is literally a practice and we have certain tools at our disposal to allow us to practice. So the reason why it's hard is that different people are practicing based on their own unique situation. If you've never had a security incident before, you have no practice. So this is why we're always learning on the fly. Most people are just learning in production. As we learn, we try to incorporate that feedback into the tools. And I think that's why it's hard and why it's never finished. When configuration management came on the scene, I first learned about it through promise theory. And if people there are not familiar with promise theory, I think the biggest learning there was these are promises. We are trying to tell these systems how we would like them to behave. We're trying to write code that make them behave that way. But it's literally a promise and those promises are built on assumptions. We are assuming people won't type bad things into that little text box that we give them to put their first and last name in. But when they violate that contract, then you have the potential for the promise to be broken. And so I think the fact that we're still kind of operating in this mode of like promise theory, there is no way to have some guarantees that we all assume in certain walks of life. My observation is many more developers are getting hands, you know, their hands dirtier with the cloud and really learning more about the underlying infrastructure that powers their applications. And and it, and actually some of the aspects of distributed systems are as powerful in many ways as the quote business logic itself because you can build these infinitely scalable applications. How have you seen the role of the developer change in these last 10 years? So there's some positives from that given the complexity of all of these systems and the amount of expertise it takes to operate at the top of the stack. You're a developer, you just want to write an app that people can just use, but that has to run on something. The unfortunate side of this is that someone needs to know all of this to be effective. This is the equivalent of asking someone who just wants to cook a dish like a chef. Hey, before you start making that macaroni and cheese, we're gonna have to teach you how the power grid works. We're gonna have to teach you how to run a gas pipeline to the restaurant. So you can actually have gas to create a flame in order to cook. Oh yeah. Before you can use a pot, we're gonna have to show you how to meld the pot from raw metal. Like this is insane. Asking professionals to have to learn every part of the chain before they can be productive has been a big productivity loss and loss of capital for the whole tech industry. The real question we have to ask is why, why is it necessary in 2021 I've been in the industry for about 20 plus years. And I know some people have been at this for 30 40 years. And if you ask them what they were working on then and what we're working on now is very similar. And so I think the question is, is there hope in these, we mentioned serverless platforms where we say if you want to send email, you can just use something like gmail, for example, and not know how to set up a mail server and secure from spam. Can we do that to other systems like compute and databases and networking? And I think that is the promise that we talk about when we say things like servers. And so I think that where we're evolving is that people now respect how hard each of those layers are and giving that respect. I think the more people that learn to trade off, are you willing to change the way you write applications to conform to the systems uh that are performing that capture all the things we've learned or do you wanna do everything you want? And therefore you're gonna have to inherit the responsibility of building systems from scratch to do so. And you mentioned compute storage services, more things, software as a service, effectively, more things available on demand behind an API so that it's easy to use without having to care about how the abstraction works under the hood. What is the role of the infrastructure team in this kind of modern world where they're trying to empower developers more often than not when I was driving on the way here, I was asking a simple question like what, what is the asphalt made of, of the road that I was driving on? I don't know you, I was wondering, I have no idea. I have no idea who made the concrete for the barriers so that I don't drive off the side. You don't know. And that is a good sign of infrastructure. The people who work on that are invisible. And the only time we think about the freeways is when there's a traffic jam, there's a pothole, right? You have a car accident. So usually something as bad as triggering the thought process there in enterprise. It typically most people have so much friction that they're always thinking about it. There's never this idea that you can get in your car and just drive straight to your destination and enterprise. It is like, all right, there's only one lane and, uh, I know everyone's on it and I don't think we fixed any of those potholes from the eighties, the nineties, the two thousands and then there's half built bridges. People are building bridges because they had to be done by Friday. The bridge is not even safe because you don't have time to test the bridge and you're the first car on the bridge and you're sitting there like, wow. I mean, this team has never built the bridge before. Is this even safe? Um And then you drive across it and you fall over and they say we'll fix it, we'll patch it. This bridge needs more than a patch. And I think a lot of enterprise, it systems have gone beyond where a patch is going to cut it. And so I think the biggest challenge we have in enterprise it is number one, we're asking people to build systems they've never built before. We're asking people to kind of figure out as they go and then have another team trust that it's going to be stable, that they can rely on it in production. And then we're asking our customers to trust this fragile machine with my data, my ability to jump on an airplane, my medical records. And so I think this is a real thing that all developers, infrastructure folks are coming to terms with is that can we reliably build infrastructure? Millions of companies all get to the same equal footing. And I think what we're learning as an industry is the answer is probably no, there's probably gonna have to be some area where we can trust each other just like the public highways. Let's get it right once. And ideally if we build it in a way that's fairly flexible, large tractor trailers can pass through it and even an electric bike if need be, I look at customers that we work with who are being wildly successful using things like GKE, you know, autopilot using, you know, Cloud Spanner big query, these hosted services where you don't have to be the expert in how to build reliable, robust infrastructure, you can depend on, you know, somebody who does that for a living. Um So that certainly, in my opinion, kind of plays a significant role in, in, in addressing some of this kind of to your point. The, the challenge that I see often is what are the best practices for how to stitch these things together? How do people navigate that? It's, it's a very complicated world. You know, we talk about the CNCF landscape and for those that have not seen that landscape in a long time, if you look at it, there's like 10,000 building blocks on there. And the, and the challenging part is some of the building blocks do the exact same thing. And so now you have to make a decision not just on all the layers, but which one of those building blocks, what are the best practices? And I think every 5 to 10 years ago, those best practices manifest themselves. And to me represents when you peel back the onion, it is the best practices of assembling a bunch of virtualization components and taming them in a way that you can use to deploy applications. But there's other things there, security policy. Where do you put your data? What part of the world do you run in for regulation purposes? Sometimes you need to run in multiple parts of the world at the same time. And this is where I think the service platform start to encode. So when we ask, when people ask me, what's next West next can be identified by the things that are lacking from the current tools. So as great as is all of its gaps, all its friction points, the things we're doing to solve that is the next thing. So I think when people say, what is the best practice, I always ask, customer, what are you trying to do? Exactly. Not what everyone else is doing. What are you trying to do? Exactly. And the better that answer the better the recommendation is and typically what we can do and say, look the thing you're trying to do. I'm gonna be honest with you as unique as your idea is, I'm going to probably guess that it's doing the exact same thing that everybody else is doing. And if that's the case, then you might be able to use an existing platform, but you're gonna have to conform a bit that your car can't be wider than a lane. If you can shrink the size of your car down and you can get to a tractor trailer size. So you should be able to accommodate what you're trying to do, then you can just use the same highway instead of attempting to try to build your own. How does somebody know whether they should go build their own thing versus just using off the shelf components? When when do you know your requirements are unique enough to, to go forge that path and try to build your own platform or build your own solution? A lot of these things are super domain specific, they're trying to address problems of the previous programming languages. And so in the case of like these new languages like Swift for the Apple ecosystem, if you want to write an application for the iphone, then Apple is gonna say the best practices come in this framework and that framework has a language called Swift. And if you learn it, we're gonna make it real easy, easy as possible to write a mobile app or iphone. If you want to write something for the web that works across multiple browsers, then javascript is gonna be your jam and of course you get to these things like frameworks. But I think the thing that is dangerous is is not the fact that not invented here, you know, that does lead to innovation sometimes, you know, for a fact how something works and then you decide from a position of educated position and then you decide to strategically make a new thing. The problem though is most people are not making educated decisions. Most people are just saying, I don't understand that. So I think the phrase is like not understood here, right? This is the real challenge. We don't even understand what this is. So you find yourself actually reinventing the wheel because you never saw one. And I think that's the biggest challenge. So I think as engineers, what we have to do is be learning, what are the things that are available? How do they work and make a real evaluation of when should you depart? And I think it's getting even harder because a lot of the most successful projects are open source. So the need to start something from scratch has been reduced over time. I think now at this point, worst case you can extend something that already exists to fit your needs. And I think the underlying systems are getting better at realizing that one size won't fit all and there has to be natural extension points. And I think that's just where we are in 2021 because you alluded to something a few questions ago around building half built bridges and then the, you know, not feeling like people can finish or create the level of stability in the infrastructure that's actually required of the organization around them. Is that, and you've told me you talked to a lot of CTO S and advise them on these topics. That is that a cultural problem? Is that a leadership problem? Is it a a tooling problem? Is the are the building blocks we're building on just fundamentally too shaky right now. Like, what, what advice would you give to people to navigate that requirement to, you know, ship fast and break things without breaking them? Yeah. I think society, it's a societal problem. It's just the way humans work with systems. Right. Typically we try to figure out and explore new things and usually during that exploration phase is it's gonna be less stable because we don't know, but we're still trying to explore and push things forward. So maybe we go into places that no one's ever gone before and that's ok. That's healthy. But at some point though, if you want other people to travel the same road, ideally, you wanna make sure that it's safe, is sustainable. And also think about who's going to maintain those roads if it's not you. And I think that's the part where most people don't think through these decisions. And so that's where we find ourselves in these tricky situations where I think the saying goes, most software is just abandoned, right? You launch it, you get some customers, you get some traction and it gets a little stale. Maybe we don't update to the newest version, maybe no one looks at it because it's working and then a decade goes by and then you step back and say, yo this is no longer secure. There are new ways of doing this and we haven't kept up incrementally and you just look at this huge hill to climb. So what most humans like to do? We start over your house is too old. Buy a new one. Your computer is too old, buy a new one. And the problem with software is it's not that easy to just say, let's just throw away this software and try to relearn everything that took us 20 years to encode into this application. So we don't necessarily have that luxury to just throw away all the software and create new ones. So I think that's the biggest challenge. Is it hopeless? Are there any techniques that you see enterprises practicing to help deal with legacy and, and modernize legacy? And what is your advice to enterprises dealing with that trail of legacy? I'm gonna go down the dangerous sports analogy path. But you know, like American football is typically someone will consider a young man's game and rookies are drafted every year with all this high potential and we applaud the fastest, the strongest, the people can jump the highest score the most points. And then if they do a really good job of that, we induct them in the hall of fame and their career is their legacy and then they kind of fade off to the sunset and the new players arrive and we repeat this process every season. And then you have people like Tom Brady who are playing into their forties and do you look at him because of his age and say he's a legacy football player. Do you induct him in the hall of fame even though he just won the Super Bowl? Do you say that this is the end of his career? And I think the way we look at software, even just like the word legacy, we don't necessarily use it in a positive way when we talk about software legacy is like the old thing that we all want to get away from and the truth is it still works. And I think the maturity part of software that needs to uh the discipline needs to be, who maintains it, who updates it. If you learn a new practice, for example, and some of the old stuff that runs on the mainframe, could you add health checks to it? Sure you could, you could implement the same new protocols that are available on cloud native based systems. And I think it's just that the maturity of understanding the platform and the fundamentals can be separated, you can implement most of the fundamentals on any platform. So I think that's the part where as an industry, we could do a lot better by not classifying these systems by their age. But asking ourselves like in the case of IBM, when the new mainframe rolls out, will it be able to support these new practices and fundamentals? When the answer is yes, then we can evolve that software to incorporate those versus abandoning ship and going hunting for a new platform. And the way I like to frame it is all the new stuff that we're working on. If we're lucky, it will be around long enough for other people to hate it. And I think the thing that we have to be careful with is separating the fundamentals from the platform, right? And the fundamentals and best practices evolve over time and when you think about it, you can take those fundamentals and best practices and apply them to pretty much any platform. So I think the goal really is to not necessarily think about them as legacy versus new versus cloud native. But to ask ourselves if this platform is capable of running these new fundamentals. Yeah, it's, it's interesting. I know there's a system, I think it's called Saber and I, I think a lot of airlines still use Saber and it was probably written in FORTRAN or something. I'm probably making it up. But I have to imagine given the high availability requirements of that system and the fact that it's available through modern web interfaces, there's probably a rest api there's probably health checks for all I know it's actually using containers somewhere under the hood and to your point, it's solving a business problem. Why go reinvent the wheel when the, when the thing actually works. Yeah, I mean, I could see a situation where some of that software is unsuited for, you know, certain capacity needs, you know, I think when the internet came around, it put a lot of stress on some of these existing systems, some of them didn't even support these protocols like TCP/IP. And so that means that those systems do have to evolve where things start to get dangerous though is when those systems get so old where there's no one that knows how to operate them, that education part. So we didn't really talk too much about as a industry who's teaching new developers for trend. And then you have a problem over time where when you're trying to hire people to come work on one of these airline systems and there's only like 10 people in the world that can do that. That's a major problem. So as an industry, we have to think about it is how many of these systems exist. And then how do we make sure that there's a healthy group of people who can manage those systems? And then how is that relationship with those vendors? Right? Because sometimes, and we've seen in the past when a vendor throws up their hands and says we're no longer maintaining this software and we saw that a lot with proprietary software in the past and there was no way for you someone else to pick up and continue on. So this is why I think open source is a really big important element to this because even if one company stops developing that technology, well, maybe another community can pick it up and train that next generation to keep these systems alive and evolving over time. What is the right level of abstraction is abstraction? A good thing when it comes to infrastructure or a bad thing because we all know, you know, abstractions can be leaky and when they leak, it can be painful. And at that point, you might just wish that you had coded to the underlying raw concepts under, you know, whether it's V MS or what have you. How do, how do you know which level of abstraction to pick both as a developer, but also as an infrastructure person who's trying to, to ship a platform to enable your team. Let's say you wanna target managing a database on kubernetes. So you take Pulumi maybe use Pulumi to provision the cluster, all right, cool points. You might use Pulumi to install the database. Great. Um But now you need to know everything that goes in that config file for that particular database. You need to know how to safely back up the database. When there's a new version of that database, you need to understand how to roll it out safely. And when you look at Pulumi, luckily, it's powerful enough for you to articulate all these nuances. But the reality is you're building a very complex state machine from the outside. And the reason why I picked something like a database is it's infinitely harder than like the web applications people build today on the database side, you literally need to know when it's safe to upgrade that database because once you lose the data, then all bets are off. So in the world of Pulumi, you can get really far from brute force. So then you ask yourself, is there a better way because now we're leaking too many of the details. And maybe you're gonna ask a developer to configure some of these knobs that should actually be inside of the system. So where do you put it? And I think the evolution where people explore is like maybe we put it in the platform. Some people would argue, maybe we tell Kubernetes to have better extractions for running a database. So maybe in the world there's something called database object and you can give it a database service and it will do all the right things in terms of generically attaching data detaching and attaching things when things crash or come back alive. But it'll never be perfect for every single database. Then you can teach Pulumi to target this database object. And so your Pulumi code shrinks way down because you're dealing with a much cleaner abstraction. Now there's still gonna be integration work. So you're going to take that database user name and give it to another system. So Pulumi still adds a lot of other value because you probably don't want the database passing out passwords to other systems. There's still going to be room for the second tier orchestration. But then there comes a time where you say what happens when the database gets way more complex. And should that database then take on the responsibility of having its own API for doing things like backups and self healing or growing its cluster horizontally versus forcing to do it generically. And in that mode, then we start to get this nice system of flow is when we learn new patterns, we can decide at what layer to put those patterns. And I think to wrap it up is maybe over time, those databases get so powerful in terms of their automation hooks that they expose, you might just be able to point Pulumi at the database and say deploy yourself to Kubernetes, right? That's the extreme side of it. So I think that's where as an industry we wrestle, where do we put these things? And also you gotta be careful. You know what if you start to put automation hooks for platforms that aren't very popular? Do you have automation hooks for Kubernetes, nomad cloud run and five other systems? That's gonna be the biggest challenge. Where do you place your bets? Yeah, I it's interesting working in the infrastructures code space. You know, honestly, when I started down the path that led to Pulumi, I didn't know I would end up in infrastructures code. It turned out that that is a highly programmable way to stitch together the building blocks. But one of the key traits is that it is goal state driven, you declare what you would like and then you let an oracle ie and infrastructures code engine figure out how to converge the current state to your desired state and leave the reliability and all the security elements and everything else to that oracle. So that you don't have to open code yourself. Kubernetes was built around this fundamental concept of eventual consistency, goal state driven configuration, uh a control loop that can continually converge towards that even in the case of unexpected failure. So self healing definitely, you know, from, from what I see, it's a, it's a great kind of goal posts for, for what excellent, you know, infra infrastructure self healing systems looks like. Um Do you think that the Cuban control plane is at the end of the day where where the dust settles? And that that is going to be the thing that rules the world of infrastructure management. It's a good checkpoint for all the things we learned before Kubernetes. And I think what people are starting to understand about complexity is it will live somewhere. And what brought to the table was um being very explicit about where it lives in the world. There's this idea of a controller and for most people and the things that you get out of in the box out of the box, you know, the ability to configure and manage low balancers to deploy containerized applications, those control loops is where the complexity lives. Because if you look in there, you'll see just how complex it is to support all of these low balancers that is forced to support. But since we encapsulate the complexity, we don't run away from it, we encapsulate it and be very explicit. And by being explicit, we created an API and that API is what we call that resource model. And I think from a configuration as management standpoint, you look at that and say yes, I can deal with this explicit API versus having to reinvent the stuff that we see in that black box inside of those controllers. So I do think has brought this very clear direction for infrastructure. We too can benefit from control planes that have API S and intentionality and then we can put the complexity in a box. But this time, a box with an API, I think that pattern, that formula is here to stay and we're gonna see that apply to other systems. So whether sticks around or not, that pattern will stay with us. I'm curious to hear, I I've heard wind of you've really helped to improve the usability of some of the abstractions that your team is shipping at Google. Um through, I think you call it empathetic engineering or something along those lines. Could you talk a little bit about that? And maybe some of the lessons learned that the audience might be able to take home with them. I read a story about a person who worked on like engines for cars, the person had no driver's license. And this is like a weird scenario. It's like, how do you know that you've built a great engine? You've never driven a car? And so I think there's a little bit of empathy that goes into the thing that I'm working on. How do I know? It's right. And so I think there's something to be gained from using the things. So in our industry for a very long time, we have that concept of dog fooding, using your own stuff. And then you create this very organic feedback loop. Turns out for the cloud, that's not enough. Actually, it turns out in the cloud, we have thousands and thousands and tens of thousands of customers that are all coming at this from a different angle of practice and they all need something different and to your point, they're all trying to stitch together other systems from other vendors. And so without experiencing that yourself, you could be working on one component, let's call it GKE. You could be doing a really great job, best offering ever. But what is it like to use? Kubernetes plus Spanner plus cloud flare, plus this DNS service that might be so much friction that one way to quickly elevate someone's understanding of that world is to put them in the customer shoes. So, empathetic engineering is really about how do you change the person that's writing the software? Right? We can all get formalized specs of what to build, but how do you do it with empathy? Right? I wanna know who am I building this for? What will their real experience be like? And so in order to create that we try to give people opportunities, whether they embed with the customer and build something together, maybe support a system where the pager or try to solve a problem using the exact same paths available to our customers. And what we've seen through that kind of work. This idea of empathetic engineering is when you go back to your keyboard, that becomes permanent. When you say something is done, your definition of done has changed because now it includes the customer's perspective. So that's what empathetic engineering is all about giving people the space and the opportunity and rewarding that discipline of understanding what it's like for real people to use what you're working on in real settings. I certainly experienced the dog food culture at, you know, working at Microsoft where sometimes it's painful, right? You're, you're using software that clearly isn't quite there yet. But that, that's part of the process of helping to, to get it there. But the point around cloud, I mean, it's highly fractal, you can't even imagine all the ways it's, it's gonna be combined and used thousands of services, you know, customers using a different scale. It's, it's definitely you know, a difficult world. So I love the concept of empathetic engineering. I think I'll have to borrow that. So I ask you a potentially dangerous question, but you can, you can take it or not if you like um prediction a lot has changed even in the last few years alone. Is it clear to you in five years where we're gonna be? And if so what does that world look like? Given the history of other areas like electricity, you turn on the light switch, it tends to come on the light does. That's the type of interfaces that most people want. I want to reduce the number of options. I have to make something work. You wanna get advanced, you can get a dimmer, I can turn it down this stuff. But the interfaces get simpler as we understand the problem space much better. When I look at infrastructure and the things we've been talking about today, we don't have a lot of options for people who want to flip up light switches. We're asking everyone to learn how to build power grids right now and that can't work. That's not gonna ever scale to where we want to be because I think what we want to do is go from, I think there was a time period through my career where the goal was to get the next million developers. At some point, you're gonna have a billion developers, right? These are people interfacing and customizing their own tools, right? You customize your budget, you customize your financial apps. All of these new tools are allowing customers to be programmers of their own domains. But in order to do that, we cannot ask them to learn the skills set of the people we've been addressing so far. So I think everything will eventually evolve to this ultimate utility that will allow 85% 95% of people to build and deliver things safely and conform to all those global things. So pick a topic. Look at where we are today, look at the problems preventing mass adoption. And I think that's where the opportunities will lie. Absolutely. Yeah, I think there's a lot of regulation, conformance, governments being more involved. Um Green, green energy, I love, you know, a lot of the carbon neutral emission commitments that folks like Google cloud and other cloud providers have made the climate. One is interesting because it's one of these things that now, you know, whether you were, you know, fearful of floods and, and forest fires, some people that wasn't enough. Um But I think now you're starting to see this situation where business interests now are merging with some of these things that should have been the forcing function all along. And now businesses are starting to understand if I can get cheap renewable sustainable power, then I can actually grow my data center footprint. I can have more powerful machine learning models and keep the cost down. So I think now that these interest has aligned, you're starting to see a lot more investment in those areas. And uh I think that does accelerate some of these technology advances that we've seen. Well, I could keep talking all day, but I think we should bring it home with uh one final question. One thing that's amazing that I know you do a lot is help mentor people, help them Uh early in career, later, later in career, um take me into one of those mentoring sessions, like somebody who's new to the space that's listening to this talk, what advice would you have for them? So this one like touches the soul because we all remember how we got into tech. And for me, it was really going to a bookstore and on my mom's living room floor flipping through that book. And you gotta remember at that time, college had the grades, but it wasn't something I saw myself doing. I didn't know a lot of people in other professional roles, like doctors, lawyers, software engineers. That wasn't a thing in my viewpoint. So flipping through that book was in some ways, hope that you could learn the things in this book and you can enter this profession that had less gatekeeping than all the other ones. And they paid well and you can actually choose to change your own destiny. And so I remember what it was like going through acquiring that knowledge and then translating that knowledge into a career and the agency that comes from having a career that pays well, but you can change a bunch of things, not just for yourself, your family and the people around you. So when I see new people getting into tech, I know that is a possible outcome. Look at the demand for people who do this and the way it's looking, it's gonna continue to grow. So the other thing that I realized is that this is hard if it was easy. I don't know if everybody would want to do it. I don't know if they would pay the way. So what I, what I try to explain to them is realize that they're probably drawn to this area for a reason and the reason why they're drawn to it maybe is to make more money or maybe they really like doing it. But the thing that's gonna be sustainable is the discipline that you're gonna be learning forever. I don't care if you have a computer science degree. I don't care if you're self taught and maybe you paid a couple $1000 to go to the local code school, you're going to be learning for the rest of your career. And then I try to make sure that, that we can demystify that as a senior software engineer. And I'm pretty sure you do it too. We just search for the thing we're trying to do and I have the same good developers, copy great developers, paste, you don't have to learn all of this stuff by yourself. There's nothing in human society where typically people learn everything by themselves that would be incredibly wasteful. So I try to teach them the humility of asking a question and think of anyone that takes time to give you the answer is an investment in that skill set so you can have agency on your own career and your own life. So when I think about mentoring someone, I think about being responsible for this person, the whole person, not just the engineer that they're inspiring to be, but the whole person who will be someone who can use these skills and everything that comes with it. Well, what a note to, to end on. Thank you, Kelsey Hightower. It's been inspirational and informational and a lot of fun. Thanks for having me. Thanks a lot.
---
