---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Q&A, importing from Terraform, Continuous Deployment and more | November 2018"
title: "Q&A, importing from Terraform, Continuous Deployment and..."
meta_desc: |
    CTO Luke  discusses some of the top issues and debates from the Pulumi community.
url_slug: qa-importing-terraform-continuous-deployment-more-november-2018
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Q&A, importing from Terraform, Continuous Deployment and more | November 2018"
  description: |
    CTO Luke  discusses some of the top issues and debates from the Pulumi community. â–º Join the Pulumi Community Slack: https://slack.pulumi.com/
  sortable_date: 2018-11-07T19:43:13Z
  youtube_url: https://www.youtube.com/embed/TD5f8ze92Fk
transcript: |
    All right. Hi, everyone and welcome back to uh Pulumi TV. Uh My name is Lou Cobin, uh CTO at Pulumi and excited to be back uh after a couple of weeks, uh after a couple of weeks off. Um we've had a fun time um out at conferences talking to a bunch of uh Pulumi users um and wanted to come back today um and spend some time talking about some of the things that are new and uh and talking about some of the questions that have uh we've heard coming up over the last uh week or so. Um We're gonna do something different this week actually and uh and drive the conversation from uh questions that have come up in our community slack. Uh So for those of you who are using uh Pulumi, you may have seen uh the links to our community Slack and let me jump over here and uh show you that um if you've jumped into Pulumi, uh we have links to the Community Slack uh on Pulumi dot com and Pulumi dot IO. Um That's become a really great place to ask and answer questions about uh about Pulumi having dozens of really great conversations per day on there about all kinds of topics, um both sort of centered around Pulumi but, but ultimately talking about um patterns uh for integration with many cloud providers, C I CD systems, application development patterns uh and a bunch of other things surrounding how people are, are using Pulumi in their uh in their projects. So a great place to go and learn how other folks are using Pulumi and to come and ask questions uh for the Pulumi team or the Pulumi community about uh about anything. Uh You're, you're curious about with respect to uh Pulumi. And so today, I thought I'd um I kind of open it up. Uh I'm gonna sort of talk about some of the topics that we've had discussions on that thread about that I think are interesting. Um And go to use those as a chance to talk a little bit about how Pulumi applies in some interesting uh use cases. Um And then also answer any live questions that we might have that come in on the um on the community Slack uh um instead of answering them uh by typing or we'll just answer them by kind of being able to do some live uh demo and that sort of thing. Uh So if you do have questions for us live, uh feel free to, to jump in the, the community slack um links right up here. Uh And otherwise, um we'll just get started with a couple of the questions that are already there. Um So I had a couple that I had pulled out. Um one that I kind of wanted to start with uh actually is not a question but something that we, we posted on the community slack. And then um there was a little bit of discussion around some uh topics related to this we put in a blog post. Uh I think just on Friday last week, um just a few days ago um on uh infrastructures code from Terraform to general purpose uh languages with Pulumi. And this is a pattern that we've seen many folks on the community slack and just generally in, in user and customer conversations, we've been part of have been talking about how they're um they're moving from some existing system, either Terraform or cloud formation or, or some other infrastructures code solution, really wanting to move to a uh an offering which can be a little bit more flexible and can use real general purpose program languages as a way of describing that infrastructures code. Um And so in this blog post, we just kind of talked about one of those patterns we've seen be very common uh which is folks coming from a tool like terraform and what the experience is like kind of mapping from the terraform experience over into Pulumi. And so for folks who haven't yet read this blog post, definitely encourage taking a look at this, especially if you're familiar with Terraform and trying to kind of understand how Pulumi um is different and, and the same uh and how it's motivated by some of the similar goals but provides a different kind of uh programming experience over top of that. One of the beautiful things in this blog post. If you kind of walk through the examples and things is you really get a sense of how Pulumi because it introduces real apartment languages and because it introduces the ability to create reusable components and control flow and that sort of thing can really simplify the way that you think about building up your infrastructure, reducing boiler plate, reducing copy paste, adding on top a richer type system and richer tooling uh and a bunch of other uh benefits you get from that. So definitely encourage folks to take a look at this um really great resource uh for getting started with Pulumi. Uh There's a bunch of other topics here that I pulled out that I thought were interesting. Um So I'll just pick off a couple of those and then I'll jump over to the general and see if there's, there's any questions that we can answer. Um So one is actually a node 11. So Pulumi, um you know, Pulumi is built on top of and supports you programming in a variety of different languages. So uh javascript and typescripts, Python go uh and more languages to come. Um javascript and typescript have been a popular uh language uh for among uh Pulumi users. And so, uh note 11 was just released, I think last week, maybe, maybe the week before. Um and initially, uh Pulumi did not have full support for node 11. Um And so there was a couple of questions that came up around this. Uh We actually just put out a release that fully supports node 11 with Pulumi. Um just jump over the question here. Uh fully supports uh note 11 with Pulumi. Uh I think yesterday. Um And so, uh for now, you know, now Pulumi is fully supported uh on node 11. So anything from node six up to note 11, uh you can use with Pulumi. And one thing that's sort of interesting there to talk a little bit about is actually um how you can see kind of the releases that we do around this. And so I'll, I'll show off kind of two things that you can use to understand kind of what's available uh from Pulumi. The first is actually our change log. And so this has the sort of full history of all the updates we've done. Uh You can see we released 0.16 0.3 with full support for Note 11. This was I think yesterday. Uh Yeah, November 6th was yesterday. Uh So, so this change log is useful to understand kind of what releases have come out recently, uh whether it's worth moving to a newer build of any of these packages. Uh The other thing is uh you know, we publish the packages because uh Pulumi ultimately allows you to program all these different cloud platforms using your existing live, you know, languages and package managers. If you're using node, then you're actually using the Pulumi Pulumi package on NPM. So you can actually go to MP MJS dot com, look up the Pulumi Pulumi package and you can actually see what versions are available. And so here the latest is that 0.16 0.3 but you can actually see all the versions so that that version is latest, which was published 21 hours ago. Um But we're also publishing nightly or actually per commit DEV builds. Um And you can see all of the other um builds and when they were published. So this is one of the benefits of using real programming language is not even just the programming experience, but the fact that you get access to kind of a rich and, and and already existing package management ecosystem like N PM or like pipe. Um And so you get all of that ability to do version dependencies and all that sort of thing just for free. And you can get access to things like the M PM Js console here uh to understand what dependencies are available, how they versioned, uh that sort of thing. Uh So definitely we're taking that out and uh if folks are moving to Note 11. Uh, you can go ahead and, and use Pulumi with, uh, note 11. Now, uh, let me just jump to one other. One of these, um, uh, that I'll talk about. Uh, let me pick, let me pick an interesting one here. Uh, oh, I talked about C I CD. So, um, because I think this is a topic that we may have some other questions about. One of the things we've seen, a lot of uh a lot of discussion threads on uh on the Slack Channel. Um is folks who are moving past just building a Pulumi app and really thinking about how do they integrate that deployment into their existing or new kind of C I CD pipeline. Um And this is something that uh we've done a lot of work on uh with Pulumi recently. Um You probably saw, we um did a demo uh at uh github Universe um as part of the announcement of github actions about how we can integrate into that environment. We've published uh articles actually on um in our documentation on continuous deployment and how we can integrate into a variety of different uh conti C I platforms. We've got several others that we're working on uh uh adding documentation for now. Um And actually just earlier today, we um announced uh support for a uh um circle C I org. So, Circle C I announced a new ability to um create sort of orbs which are packaged up uh descriptions of how to deploy, using particular uh targets. And we've now made available a Pulumi deployment orb, which makes it really simple within circle C I to uh to publish uh to do run deployments using Pulumi uh from within that environment. Um And so it's a really important part of the sort of end to end experience of Pulumi to integrate it into C I CD environments. Uh And so, um so there's been a lot of questions about that. Uh This one question from uh from KCR that came up on Friday, um was kind of about just how to think about accounts and, and that kind of thing. And we had a discussion about both where we're at today. Um kind of how you can do that today and some of the things we're thinking about supporting in the future. Um Today, one of the patterns that we often see is folks kind of just using uh bought accounts. So, uh you know, they'll, they'll make sure that their C I deployments are using an account they've created um in github or in whatever backing identity provider they're using with Pulumi. Uh And then using that bot account to actually do the deployments within their C I environment. And that allows them to get sort of a token or a Pulumi access token for that bot account that is constrained to the rights they want both the rights they want within Pulumi, uh so Pulumi has a role based access control system uh that you can use, but also the rights they want to give that uh that account within the C I environment in their target and cloud. So, uh making sure that they have a um uh an im role that they're using for that account in uh in AWS, if they're deploying AWS or that they have a, an account, uh service account in GCP, uh whatever they need to do to, to sort of constrain what access that C I CD environment has to do deployments on their behalf. Um But a really simple pattern is just to create that BO user and I can actually show you kind of what that looks like in our own environment. We, we do this, uh we, we uh internally Pulumi use Pulumi to deploy some of the parts of our uh product. So if I come over to the Pulumi Organization here, uh I can actually see that uh I have uh the, these bot users. Um So these are our, our bots and they have access to a bunch of different repos and write permissions. And we have this Pulumi bot user on github that does that, this is a pattern that, that folks can, can really easily use in their own environments as well. OK. Uh So that was two quick questions uh from that I had prepared but let me see if there's any questions that have come up that are worth uh kind of diving into a little bit. Uh So uh yeah, so a question from M four DC M four P. Uh I don't know how to pronounce that correctly, but uh I'll assume that's close enough. Uh Let's see what, what I mean, actually Justin, is it? Yeah, Justin Bailey. Ok, great. Um So a question from Justin. Um So I'm starting to use Pulumi with a S code built which is basically glorified bash prompt running in a container. How can I bring all that work into my Pulumi script? Uh building do images getting configuration running arbitrary shell commands. How do I integrate it with Pulumi preview, verse live run. Uh So there's a couple of different sort of uh layers to answering this question. So the first one is um you know, you can take existing systems like codebuild or, or really any um C inc D or you know, it was Codepipeline, any of these systems, you can integrate uh Pulumi into those just like you would any other kind of tool. Um So you can use Pulumi for that deployment stage of whatever kind of pipeline you wanted. Um And so you can sort of uh you know, if you have a build process already, if you have an existing kind of pipeline and description, you want to just uh replace, you know, maybe a a cloud formation deployment with a plume deployment, you can just plug Pulumi in, in just the same way, you would have plugged a kick off of the cloud formation deployment or a kick off of the Terraform deployment. Um uh really just AAA swap in of that sort of thing. Um And so that's the first thing to really understand is you can kind of just plug Pulumi into existing workflows with very little change to those workflows. But uh but probably more interesting is some of the new things you can also think about uh um as you uh as you integrate with Pulumi. Uh And so like to the, to the point of this question, uh you can also move some parts of this kind of uh of what you might have done inside your C I pipeline actually into the Pulumi program. And so, for example, one thing that, that we see folks doing often is this is the first sort of point that Justin made in the EG here is actually building the Docker images. So that's a task that, you know, many folks traditionally think about as sort of a separate phase of a build pipeline where they all sort of build their images and put them in a repository and then they'll have some separate phase that uh that deploys infrastructure and refers to that repository. And they'll have to do this sort of careful dance between those two, those two pieces. Um But Pulumi is actually really great at um at coordinating that dance because it understands the dependencies between things. It understands that when that build produces a new image, that means it needs to do a push. And that means it needs to, to refresh that service with that new uh built image. Uh And so that that process can actually be coordinated within a Pulumi program, it can even be coordinated down to, you know, like a very simple and abstracted view. So one of the examples that we, you know, kind of often show that gives a really high level sense of this is the uh cloud jazz thumbnail. And so in this example, I've got, you know, just this simple cloud dot task um that's going to run some long running um task in ecs on on aws um in the container service. Uh And one of the notable things about it is that instead of me pointing in a prebuilt image that I built in some other stage of my build pipeline instead, I just say build colon and then the the directory and in this case, that directory has a Docker file and it's a sort of docker build context and it could have arbitrary application source code as well. It could be my, my legacy java app that I want to deploy into my infrastructure. In this case, it's just some bash scripts of its own that run FF MP. Uh But the key is that, that build colon will actually uh will actually tell Pulumi to coordinate a bunch of this stuff for you. It will run the darker build in the context of where the Pulumi deployment is happening. It will allocate a ECR repository for that image to live at uh in a cloud hosted environment. It will push that image any time that it changes. Uh And in terms of the on disk build of that um in Pulumi changes and then it will hook up the s task to that ECR registry. So all of those steps, you kind of in the traditional environment would have to spread across multiple stages of your build pipeline and author in sort of your, your C YAML instead of in any kind of application level artifact that you can actually move into source code, move into components which are really robust and move into Pulumi and let Pulumi be the one to coordinate those, those steps. And so this is a general pattern. We've seen that Pulumi actually allows you to pull some of those tasks which you traditionally thought of as separate steps in ac pipeline into a single Pulumi program. Now, that sort of uh doesn't necessarily go, uh you know, you can, you can take that to kind of whatever level makes sense. Um that doesn't have to be, you know, everything that you would have done in your C I pipeline suddenly moves into um uh into the um into the Pulumi program. You kind of, it makes sense to move some things in some things you might want to intentionally version kind of separately. Um But for these examples, building Docker image is a very natural thing. In many cases to do as part of the polluting program running arbitrary shell commands. There's many kind of shell commands that make sense to actually do within the context of the plume program because whether or not to run them is sort of dependent on whether changes are being made to certain pieces of infrastructure. And so you want to chain that into that kind of Pulumi dependency graph of resources. Um And so, uh so I say, yeah, we absolutely can do that. Um It kind of depends on the specific use case and specific scenario, whether it, whether it will or will not uh be most effective to move those things into Pulumi. But we generally believe that there's many tasks that today are thought of as something you do in your C I system that you can actually bring into your kind of deployment management program using Pulumi. Um in terms of how you integrate that with preview and live runs. Uh I think, you know, preview and the sort of preview and update uh for the Pulumi itself inside C I is something that we talk about quite a bit in this uh kind of C I continuous deployment documentation. Um And I think there's some documentation on some branching strategies and that sort of thing. Uh there's a number of different patterns that people can follow. But sort of one of the most standard is, is really using a G based uh flow where each individual kind of um you know PR is into a branch will, will run a preview against that branch and uh merges into a particular branch if that branch has a long lived stack associated with it, like if the master branch has your development stack associated with it and your production branch has your production instance associated with it, then merging into those branches will actually cause deployments into the target stacks associated with those long lived uh branches. And so inside this pattern, there's sort of a natural place in that GIT flow where you will run a preview, a natural place where you will actually run an update. Uh And so that's easy to sort of um to script into any of these C I environments. So you can see examples of that in each of these drill downs including for a S code services. Uh There's a bunch of drill down into specifically how to set that up. Um So definitely uh love answering any further questions along around C I and things. But um but definitely there's some good uh pieces there. Uh Casey uh kind of here mentions guaranteed to be born at coupon. One thing I will notice uh several of us from the team will be a coupon. So folks are going to be a coupon or at reinvent. Uh We'd love to chat with you. Um, feel free to drop us a mention on the slack and we'll, uh, we'll set up time to, to chat in person uh, at those events. Yeah. Um All right. So, uh, let me jump back. Uh If there's more questions folks have, I'll answer those, but let me just answer a couple of things from, uh, from this list here. Uh So one, let me talk about secret uh generation. This is sort of an interesting question that uh that I think kind of is, is has some interesting answers in terms of Pulumi. So the question here is about, you know, is established pattern for secret generation. So, um you know, in this particular case, Todd was asking about um you know, being like Helm or HELMM will create random secret values uh if it's not populated. Um And we actually have a really rich way of doing that in Pulumi. Um Because Pulumi uh works with sort of resources and those resources know how to be created and then only updated if a requirement is is needed. Uh We can actually use the standard kind of Pulumi resource graph and the Pulumi resource model to uh allocate secrets that are live as long as a stack does. So when you first uh create a stack, it will allocate the secret and then it will keep that same secret around for the lifetime of that stack. But when you allocate a different stack, it will allocate a different secret. And this allows you to, for instance, every time you, you know, when you create a new development stack for an individual developer, they will get automatically allocated a secret that will be stored as part of that stacks configuration um but not actually have to be stored by the user themselves or, or made up by the user themselves. And this allows you to automate that process of being able to stand up an independent stack and allocate secrets for it um entirely within your control. Um And so I'll just show um OK, let me just kind of uh just open up a little terminal here. Uh Just start in this folder um just as a, as a place to start. Uh Let me just do N PM install and we actually have a, a package called Pulumi Random. Um Blueing random lets you generate uh random information. Uh And so I'll just delete all of this, I'll import Pulumi random actually just delete all of these. And then I can come over here and just say, you know, let's um uh secret its new random dot And then I got a bunch of different things I can do here. So I can do you know random UU ID for example. Uh And I can actually pass some Arbs so like I can pass keepers. These are the things which will force it to be recreated potentially. But I don't want anything to force it to be recreated. So I'll just go ahead and say that and then I'll say export, lets my secret string and that result. And so now if I do, you know Pulumi stack and knit, uh and then I do a Pulumi update, uh We see we're gonna create that one secret there um In this case. So I'm gonna say yes and we see it created a secret. Um And so I exported that secret value. The interesting thing now is because it created at that time, uh you know, it allocated this new secret. But if I do Pulumi the update again, we'll see it doesn't need to change anything. And so that secret will stay the same. And that means I can sort of reliably use this secret now as an input to maybe a password on a uh on a database. So if I need to stand up a mysql database, I can use this secret as the, the password that I allocate as part of that. Um And this secret is now stored, you know, if I come into my console, uh I have access to this configuration, I can actually because I exported that it's available here as a value. But if I didn't want to export it, I don't have to do that and then it's not visible here. Um And so the ability to have these uh these secrets be allocated and then to manage them as part of the Pulumi stack with the access controls that are associated with being access to Pulumi stack itself. Um Is a really nice way to kind of manage secrets in a fully automated uh in a fully automated way. OK. Uh Let me just do one more from the list and then I'll jump back over and see if there's other uh questions there. Um uh All right. So one question, this one, I won't go in demo, but I'll talk about it because this has come up quite a few times. Actually, in, in uh in the community slack is any way, easy way to run Pulumi up uh programmatically. Um And so, one of the, you guys have seen from a lot of folks uh has been wanting to actually not just use Pulumi up for kind of just that, you know, development and, and sort of C I integration, but actually to use it as an as a programmatic part of some other uh provisioning system. And so have some higher level system that, that thinks about, you know, a, a more abstracted notion of what a component is that needs to get deployed. And then to use some uh programmatic means to deploy Pulumi stacks and to keep them up to date. And so we've seen lots of different use cases of this uh where we're using Pulumi during kind of dynamic provisioning for, for provisioning in multi tenant environments. We're using Pulumi just to, to redeploy and to keep up to date some, some particular pieces of infrastructure, a lot of different use cases for running Pulumi up programmatically. And this is actually something that we're actively working on. The approach we're taking to. This is actually just uh initially to make sure that Pulumi up and all of the different Pulumi commands can support a really nice Jason output so that you can, you know, invoke them via um any kind of, you know, shelling out to the Pulumi cl I and then to be able to programmatically parse the output from them and make decisions about that, about how to integrate that. So we're starting with that because a super flexible way to integrate into just about any environment folks have. Um But we're definitely thinking about how to layer on top of that, some sdks uh for some of the popular languages we've seeing people using uh for that programmatic plug in so that you can get sort of an API over Pulumi itself. Um But this is something we're working on now. We have support. I think for several of the commands for getting Pulumi stack outputs programmatically for getting um uh Pulumi stack ls to understand what stacks are available programmatically. Um These are two key points. Um We're working right now on Pulumi up and making sure that the full stream of data out of that um can be accessed uh programmatically as well. Um But in general, we've seen many use cases and we've done it ourselves where um for things like the github actions integration that we did, uh We actually, in that case do use Pulumi up fairly programmatically. It's sort of scripted through the um through the integration with actions. And then uh it can be plugged into any kind of github flow there. Uh And so we have many use cases where we're already using it programmatically just by shelling out to it. Um uh But we think we can, we can take that a lot further by kind of supporting uh Jason output on a bunch of these things. Ok. Let me see. I think maybe there's some additional discussion here. Uh I was just curious, are you guys planning in the long term to create your own providers like the S one instead of depending on the terraform ones? Yes, this is a great question. Um You know, we uh we do today for, for several of the providers like AWS A or GCP, uh we currently kind of sit on top of the Terraform providers. And so while Pulumi doesn't actually use Terraform for doing deployments, it does use the Terraform providers which have a nice kind of crud interface to those cloud platforms um and have great open source uh you know, contributions to them from, from many users. Uh We sit on top of those and provide access to those via the Pulumi Aws package and the Pulumi Azure and Pulumi GCP package. Um And so this, let's kind of uh Pulumi users use the exact same capabilities that are available uh to kind of terraform users. Um uh But we also do have our own Pulumi uh provider model. Um And so we have this bridge layer that, that the terraform ones kind of plug in through. Um uh but we also have some native ones like the provider that we actually found to provide a really great experience for Cotis, we, we needed to build that provider um ourselves and tie it really directly to the open API specs uh that um that TTI um provides. And so we're actually um a direct, you know, directionally, I think we, we think that the, the way to make uh the Pulumi experience, the richest is going to be to build on top of those direct Pulumi providers over the long term. Um And so we are kind of talking to each of the cloud provider platforms about the kind of things that um that we would need to be able to do a really great job of, of targeting the platforms directly without having to sort of manually maintain a lot of the stuff that that is sort of custom in the current terraform providers. Um But the cloud platforms are actually really moving in the direction of making this a more automat thing. I think they're really excited about having more tools to be able to plug in and automate uh these API S. And so, for instance, uh GCP has been doing some work recently on magic modules which is a way to kind of of automatically generate um you know API S and SDKS on top of uh the Google API specifications, including understanding what the, what the ready uh what the weight logic is effectively um understanding when a resource operation is sort of complete. Uh And what, what properties to, to test for, to, to know that. Um That's another thing. Um Azure with the arm model is also has some pretty good foundation for that, that's almost automat. Um There's still a number of things that are not fully automate. Um And then A W is the one where we're talking with, with some of the teams there uh to see if there's uh there's things that they could expose um that would help make this, make this an easier process directionally. We want, we want to go that direction so that we can take advantage of the full breadth of kind of the capabilities of the Pulumi prior model. Um But pragmatically um using the telephone providers is actually a really great way to get access to um a lot of the platform and to, to, you know, build on top of the great open source work that's being done um in those existing provider ecosystems. Um So conversation is definitely happening there, I think directionally we're going to be investing a lot in that. Um, um But right now, uh the experience is actually really, uh pretty good for folks kind of building on top of the existing providers we have, uh from Terraform. Ok. Uh I'll jump back into, uh, some of the questions over here. Um So, uh, speaking of, of Terraform, I'll kind of jump to this one. Just not because I have a particularly great answer to the question. But um uh just to kind of give a, a pattern for how kind of we, we, we think about some of these sort of questions. And so uh uh grid I knock, grid, I knock uh who is that Lorian? OK, Lorian had a question about uh is there an app sync example somewhere? Um So we have, we have tons of, of examples for folks who, you know, haven't uh um gone and checked it out. We have, you know, get up dot com Pulumi uh examples uh which has examples of sort of all sorts of different uh you know, kind of things we can do uh with Pulumi and different, you know, across, not just Aws but Azure and GCP and S and, and other platforms that we support. Uh And so, um you know, so we, we have a lot of these examples, but of course, these platforms are enormous and so we don't necessarily have examples for every single one of these things yet. Definitely something that we're kind of working on how we can build up sort of more long tail of examples to, to show to bootstrap folks in a bunch of these domains. But when we come up with something like app sync and this, we have heard a lot of folks kind of asking about app sync. It's always interesting to look at the kind of like, how would we go think about kind of doing this? Um So the first thing is, you know, hey, we can come in here and just say, you know, uh you grab the A provider uh and just say, you know, let's, you know, appsync equals new, we're gonna see what we have, right? Uh So appsync, there is a name space for app sync. So we do have some stuff projected here and you can see there's three API S that we have available. Currently, we have graph QL API data source and API key. Um And these are three key pieces that you need for working with appsync. Um But uh when I went to kind of go look at some of the docs when I was looking at answering this question, uh you know, you quickly notice that there's actually a few other pieces that you really need to end to end um make appsync work. Uh There's some schemas that you need to be able to, to create um a few other things. And so today uh you could kind of do these three pieces of that process using Pulumi. And so I could create my graph QL API uh you know, come over here and just say there's only a couple of things needed to name, all of which well, name and user pool configure are optional. So I can go and see what my authentication types are and so pick like API key. Uh And so there we go. Now, I've created a graph QL API object and I could go ahead and deploy this and have that allocated, but I'd actually need to configure this and, and create sort of a scheme and a bunch of other things in there. And, and so I won't go through and do all those pieces. There's two things that you can do at this point. So one is um when there's pieces that aren't available. So like in this case, uh that schema piece was not available on app sync. Um Let me go back to with that. Uh But because that scheme piece wasn't available, uh you know, I could do a couple of things. One I could go check out because this Aws library is ultimately building on top of what's available in the Terraform provider. I can go check out kind of where Terraform is at on that. And so if I come into the Terraform Aws provider, um you know, we can come over here and look at appsync. Um and there's, there's a sync resource proposal, we still see that still open. So there's still some work on going on this. Um And the latest on this is actually uh you know, he's looking at, we're looking at 48 40. Uh and this is actually a schema, which is one of the key missing pieces that still is, is Ava is still not available. Um This has been APR that's been worked on for a while and you can see this conversation that's still going on even just today. Uh So I think this, this is progress in progress as soon as this is available inside the Terra provider and gets merged, you know, we'll pull it into the, the, um Pulumi provider and then it'll be available there as well. Um But in the meantime, if there's holes where there's any piece of functionality in verse, that's not yet available and there's actually fairly few of these holes, most of them are available within a week or so of the features being available in the cloud providers, but where there are holes, um the, the typical is to work around that is to just kind of shell out, you know, because this is a programming language, you can sort of uh mix into this any logic you want, you can shell out to the Aws cli you can use the AWS SDK to make calls. Um It's a little bit more kind of grungy in a sense to to do that. Um But you can, that lets you be fully unblocked, do anything you want just by, you know, importing the AWS SDK. So I can come over here and M PM install, you know, eight SDK. Uh and this is the run time made of SSDK. And so I can just say something like this. Yeah, I made them at tapes as well. I don't actually know what this is. Sorry. But yeah, now I can sort of do a decay dot You know, um And I can actually access, you know, the app sync uh capabilities in the A SSDK. Uh And so I could actually now use this SDK as part of my deployment and I could string this in amongst these things. So that after this appsync thing is created, I actually go and verify that uh that I've created a scheme as well. So I won't show that here but, but the ability to mix and match shelling out the things and uh calling runtime API from any N PM package means you have a ton of flexibility and they're never going to be blocked by a particular missing library capability. OK. Uh Let me just OK. Uh I'll jump over to, to one or two more of these. Um uh I, I won't talk about provisions more. This has come up a couple of times kind of, you know, the notion of provisions um really provision you can, you can handle kind of either with that, what I was just talking about with, with kind of shelling out to something or using an SDK, um a bunch of different like that or we actually have a concept called dynamic providers. And I'll probably actually spend more time talking about dynamic providers in a follow on session. Um The providers are a very powerful tool um for kind of arbitrarily plugging into the Pulumi deployment pipeline. Um And so a really kind of uh uh interesting tool to use if you want complete control over um over things even kind of more so than what the telephone provisions uh would allow. Um I'll just cover a couple of quick, simple ones that I think are kind of interesting here. Uh This is a question from Casey who I think we covered a question from him earlier as well. Um But it was just, you know, hey, we have this kind of pattern from, from Terraform. We've seen questions like this from both Terraform and from sort of some of the DS L kind of syntax that folks use in uh in cloud formation as well. You know, I've got something like this. Uh I always find these DS L is kind of interesting there, there's a lot of, a lot of stuff going on in this in this spring here. Uh But uh but yeah, this was, you know, the, the way that, you know, he using, I think this is using the GCP uh provider. Uh And you know, he's creating a bunch of different health check objects and then uh on the load balancer wants to sort of aggregate those health checks together um and provide an array of health checks to uh to the provider. And so here I, I, you know, uh he's taking the, each of those health checks um and getting their self link property and then uh projecting and in over that array with that index uh in this position and then putting that inside this health checks array. Um And so he's asking me kind of how do you do that in Pulumi? Pulumi, you know, you can do uh this is sort of the answer to that. And one of the interesting things here is um Pulumi has these kind of uh Combinator that allow you to uh work with the outputs from uh various resources. And so for each, you know, if you have an array of health checks, you can just do a map over those um for each of those uh health checks that comes back, you just get a self link property and then you say I want to combine all those together into a single output. And so it can effectively replace kind of this sort of thing uh with, with something like uh like this. And so this is a, a common thing in Pulumi is kind of how to uh how to do these sort of Combinator as you combine together various resources um into inputs and outputs for uh a new resource. OK. Uh Let me grab one more of these uh that came up. Um So this one is sort of an interesting one. Doctor Shams here, uh Eric uh was asking about um is there a way to just deploy, you know, uh Pulumi supports doing KTIS uh deployments? And so, as well as targeting kind of A and Azure and GCP infrastructure, you can deploy KTIS uh resources and you can even deploy Helm charts. And so you can use Pulumi to manage the deployment of helm charts. Uh And so we have this, you know, uh home V two chart. Uh And uh the question was, is there way to specify latest chart version uh when I'm doing this? And so if I come over here, for example, uh I can say, and just install that. All right. And so now if I say, you know, let charts equals new, uh You see, I've got a bunch of options I can specify here, so I can, you know, specify the chart name. Um But you see the version is actually required uh property here, so I can say, you know, chart and I forget what the name of a group I think is a node chart. Uh um But I have to actually specify a version. And so, uh and, but the way that, that Helm actually does this under the hood is that its way of doing latest is just to not specify a version that will implicitly pick up, uh, the latest, uh, version of things. And so what I need to, we know what we need to do is not pass any version and it turns out where we have an issue open to make sure that we actually make this version property optional. And so we're gonna, we're gonna, um, fix that and make that sort of the default thing that you can just leave that off and we'll pick up the latest. Uh But, uh, interestingly this also kind of pointed out, uh uh an interesting thing about this being typescript. So the, the error that you get here and errors are really important part of Pulumi because they are a way of you getting that feedback really quickly about what's legal and what's not legal to use with the API but this is actually a case where our errors are a little bit too eager. Um, strictly, we didn't have to have this be an error. You could have sort of passed, uh, you know, you want to pass undefined here. Uh But we're telling you're not allowed to do that. Uh And so what you can actually do is just something like, uh, I need to pass repo or something, I guess as well. Uh But if I do this and just say cast to any, uh, now I get rid of that error and that error was only a typescript error. And so, uh you know, by doing this, I kind of work around that error and say no, I really mean it and it turns out this will actually work fine today. So this is a nice workaround for that. Um But as I said, we're going to fix that and make that a truly optional property so that you don't get the typescript error in this case. But to me that really just highlights the kind of the benefits we get from that, that error checking. Um And that we can then go and like if we ever find these places where it's a little bit too uh too strict, we can go and loosen it further. But uh in the meantime, users can easily work around anything where it's just type script being a little too strict um by kind of putting in a cast and just saying, hey, I want, I want to treat this as a legal value uh in this context. OK? Uh So probably just about out of time. Uh um Thanks everyone for, for joining again. Um uh If you have any questions, any other topics you want uh uh feedback on, uh you have questions about uh feel free to join us in the community. Slack. Great place to uh to join and ask questions and chat with other folks who are using uh Pulumi. So thanks again. Uh We'll see you again. Soon for another episode of Pulumi TV. Thanks everyone.

---
