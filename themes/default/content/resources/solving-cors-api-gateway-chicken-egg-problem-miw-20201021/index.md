---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Solving the CORS API Gateway Chicken and Egg Problem | MIW 2020-10-21"
title: "Solving the CORS API Gateway Chicken and Egg Problem |..."
meta_desc: |
    A community member recently asked about how to solve the "chicken and egg" problem between standing up an S3-backed website with CORS on API Gatewa...
url_slug: solving-cors-api-gateway-chicken-egg-problem-miw-20201021
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Solving the CORS API Gateway Chicken and Egg Problem | MIW 2020-10-21"
  description: |
    A community member recently asked about how to solve the "chicken and egg" problem between standing up an S3-backed website with CORS on API Gateway. The website needs to know the API's endpoint URL, but the API needs to know the website's URL to setup CORS correctly. What to do? Automation API to the rescue! In this episode, we go over how we can build multiple Pulumi programs together and orchestrate them with Automation API.  Code for this episode available here:  https://github.com/pulumi/pulumitv/tree/master/modern-infrastructure-wednesday/2020-10-21  Today's example is in TypeScript, but Pulumi makes it easy to stand up infrastructure in your favorite languages including JavaScript, Python, C#, and Go - saving time over legacy tools like CloudFormation and Hashicorp Terraform.  https://www.pulumi.com/docs/get-started/?utm_campaign=PulumiTV&utm_source=youtube.com&utm_medium=video
  sortable_date: 2020-10-21T03:10:57Z
  youtube_url: https://www.youtube.com/embed/N6Wn8dKgJ34
transcript: |
    Hello, welcome to another episode of Modern Infrastructure Wednesday. I'm your host, Lie Zen. We're gonna be covering a ton of topics today. So let's jump right into it. Really. We're gonna be covering setting up a single page web app with S3, setting up an API on API gateway and then connecting the two using automation API one of the new released features in Pulumi. And this is really motivated by a github issue that came up recently. Uh You know, someone said, hey, I have this uh S3 backed web front end, it calls API gateway. It's a pretty ubiquitous pattern and like how am I supposed to solve this chicken and egg problem where the web app needs the backend API URL. But the back end API URL needs the we the front end web uh websites uh domain in order to do cores. And so how do we, how do we make that all work together? So we're actually gonna cover exactly that. Uh So after this is over, I will, I will answer with the link to this video uh in this github issue. So let's jump right into the code. I have it all written already. Um It's, it's a decent amount of code but really not that complicated, but I, I wanted to have it all prewritten so we can kind of just go over how it works and then see how it runs and then uh really just explore the solution around using automation API and how easy it is to actually just write in line code in Pulumi to, to wire all these things together. So yeah, let's hop right into it. Um What are we doing? We have a, a single command that basically we, we first have a command line thing and you can actually notice like unlike other programs, there's no YAML files in here, there's no project configuration. This is all being done in a single program. And in our program, we're gonna take a couple of arguments uh the name of the stack. Uh Here I call it environment and also the name of the project. So kind of what we want to name this thing and then whether or not we want to destroy it or not. So very simple. And then the code is super simple. We set up an API stack uh giving it the name that I specified earlier on the command line. And then we have it run a program. In this case, it's the API program to set up the API. And so we create a select the stack, we install some plugins, we set the configuration. And so again, you know, no yellow files is all done in line in code. Uh And then once that's done, we also set up a website stack. So we have a website, we have an API uh and then once those are set up, uh by the way, all this code is on github. Uh So you can, you can check it out. It's in the, in the description below while you're going to the description below, Make sure you hit that like button because you know you like this and to subscribe to Pulumi TV. So you can continue to get all the great content uh notification, make sure you hit that notification button. So you get alerted to new episodes of modern infrastructure Wednesday. So yeah, we get all these, we got all these things set up and then, you know, if it's, if it's, if it's destroying, you know, if we, if we have to destroy command uh on the command line, then just destroy these two stacks. So we say, hey, destroy the stack, destroy the stack. And so we can kind of do this orchestration between these two different stacks between our web API uh between our API stack and between our web app stack. And if we're doing an update, uh if we're, if we're not destroying things, then we, we kind of want to do a sequence of orchestration steps here. We want to first update the API. So you can, so we call Pulumi up uh on this API stack and then we pipe all the, the output to a console info and then uh we output this value on, on the command line just so we can see what it looks like. And then we actually shell out to yarn build uh to build our, our actual web app. And as we're doing that, we can pass in this environment variable which includes uh our API end point. So if we just kind of take a quick look at the API program, you can see here that really, you know, it's a normal polling program. We create a provider, we set up a dynamo DV table, we create uh an end point and then you can see here we have a little bit of a magic quote unquote where if we have the cores domain, then we do set it up. But if we don't, we don't and kind of the, the headers are, are just uh you know, just empty. Um And so, you know, what ends up happening here is we create a path called counter where we have a get uh method. And when we do a get, you know, we, we, we look up that table and then we basically fetch the, the current counter value from that table and then we, we put it back with a plus one. So, and then we're just returning that count. Um So it's a very simple API and then also we have an options, uh, method. This is to support, uh, preflight cores. And here we would just return the headers if they're defined. So really simple, we just set this up all using, you know, a few lines of code. And then we have this API gateway object. And the website program is also very similarly simple. Again, this is all defined in line all within the same Pulumi program in the website, create an S3 website bucket, uh, set up the website parameter on it. And then we basically crawl the, the application build directory, uh you know, crawl that thing and then basically create, uh S3 bucket objects off of each of those files. And those are all then uploaded into uh into S3. So fairly simple there as well. And so our automation API program here, which is using uh the automation API in Pulumi, you can see that's how we get these workspace, uh stack selections. That's how we get, you know, the ability to manipulate these stacks. Uh those API that, that automation API is the one that's coordinating both first running Pulumi up on the uh actual API gateway. And then we show it to the, the yarn bill to create our web app using the API gateway end point value. And then finally, we, uh, then, uh, push the website. So now all this is this is where actually the, the up happens on that website stack that pushes all the contents of the website. And then finally, now, at this point, we do have the website endpoint URL. And so we can feed that back uh as the cores domain configuration, which is going to be passed through uh to here. So this is the second update on that same stack. And that second update as part of this orchestration, then updates uh the, the, the URL value there so that cores is set up correctly. And so after that update, everything is wired together and everything will quote unquote uh just work. So let's let's watch this, run in action. Uh So if I run uh TS node, so I'm running this index dot TS uh application, I'm defeating it uh lead test app and a FO stack. I'm just calling it the stack fo and actually run, ran this before. So there's really nothing like extra special that's gonna happen here. You know, some, you know, just gonna, this is the typical output being piped to, to the console. Uh And then if we kind of go look at um our stack information, if we kind of pop these guys open, we can see, you know, we're, we're, we just, we just ran this update a few seconds ago, same thing on the website. And you can see here's our, our, our website URL. So we go to that URL. Uh we get this little, you know, end point. Uh This is, this is, this is the actual value that's passed and then, you know, we end up calling the API and the API runs and the API is able to respond because we have cores set up all nice and correctly uh in, in our stacks. So yeah, really, um you know, like I said, just a few lines of code to kind of wire all that together. Automation API really helped us here in terms of making sure we were able to coordinate the deployment between the stacks and, and break the quote unquote uh chicken and egg problem. So, yeah, I hope you enjoy today's episode of Modern Infrastructure Wednesday. Um Like I said, you know, please make sure to follow us on social media, hit that subscribe button for Pulumi TV. And we'll see you next week on Modern Infrastructure Wednesday.

---
