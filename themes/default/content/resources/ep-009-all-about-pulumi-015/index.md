---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Ep 009: All About Pulumi 0.15"
title: "Ep 009: All About Pulumi 0.15"
meta_desc: |
    Pulumi 0.15 is here! http://blog.pulumi.com/announcing-pulumi-0.15-kubernetes-cicd-openstack-and-more 
url_slug: ep-009-all-about-pulumi-015
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Ep 009: All About Pulumi 0.15"
  description: |
    Pulumi 0.15 is here! http://blog.pulumi.com/announcing-pulumi-0.15-kubernetes-cicd-openstack-and-more  ✅ Support for @kubernetesio  ✅ Parallelism ✅ First Class Providers ✅ Native TypeScript Support ✅ Support for @OpenStack ✅ More support for @GCPcloud and @Azure @AzureFunctions  ✅ CI/CD Integration with our new GitHub app
  sortable_date: 2018-08-15T19:13:42Z
  youtube_url: https://www.youtube.com/embed/s-fwmyuMBv0
transcript: |
    All right, good morning, everyone and welcome to today's episode of Pulumi TV. Uh My name is Luke Hoban, uh CTO at Pulumi. Uh Today, I'm gonna be talking about uh Pulumi 0.15. Uh So we just today uh released uh the, the most recent update to the Pulumi uh tools. Um And that's version 0.15. Um So it's hard to believe it's just been about a month and a half since we uh publicly launched Pulumi. Um We've gotten great uh feedback. A lot of uh folks jumping on and using uh Pulumi over the last month and a half. Uh And really, this is the first kind of big release we've done uh since the, the initial public launch. Uh and it has a lot of uh features which are both things we've been working on beforehand uh with folks in the Pulumi Beta, uh but also tons and tons of things that uh we've worked with folks uh in the, the Pulumi community uh to build out over the, over the last month or so. Um Including many great contributions from uh from folks who have been contributing to the open source project And so today I'm gonna use uh the next 30 minutes or so to talk about kind of some of the things that are new uh in Pulumi 0.15. Uh So for folks who haven't joined us before, um Pulumi is a new approach to a cloud native development platform. Um So a new way to uh take uh cloud native applications applications that are built to, to sit on top of uh the the major cloud providers um and take advantage of uh of the resources and capabilities of those providers and make it really easy to deploy and manage and code up applications on top of these. Uh And so I'll show you some examples today um of kind of some of the new things we've added. But for folks who, who haven't worked uh looked at Pulumi before I also encourage you to go check out some of the previous videos or check out Pulumi dot com uh to get more details on uh on Pulumi. So uh Pulumi uh O doc 15 has uh has new features across the sort of whole breadth of the uh Pulumi user experience. Um So everything from uh the core kind of authoring code experience, uh Pulumi is now faster uh is a bit, you know, simpler in some key ways uh and has richer support for some of the existing platforms uh that Pulumi targets like Aws and Azure and GCP. Uh But we also now support some new platforms uh like Kubernetes. Uh we've significantly enhanced the, the support that Pulumi has for Fortis. Um We've also added in open stack support uh as well. So you can target not just the major uh public cloud providers, uh but also some on premise uh solutions and knees which uh can sit on top of both. Uh We've also sort of extended uh Pulumi support for integration into this sort of application life cycle into the C I CD uh flow uh to also include a github application. Uh Many of our users of, of Pulumi have been uh have the source code on github. Um And so the github application for Pulumi uh makes it easy for those users to actually uh integrate uh Pulumi into their C I flow and get the feedback about what the previews and updates uh that they're doing uh are going to do to their infrastructure. So I'll dive into all of these areas a bit more uh in detail um over the next 30 minutes. Um And uh we're gonna have follow up posts as well over the next uh next, probably a week or so to go deeper into several of these topics. There's a lot of interesting uh content in each of these areas. Um And so we'll, we'll, we'll have some more content to talk about uh there very soon. So the first and probably the biggest uh um new capability is really the Cober Netti support. Um And we actually had at launch, we did have some initial Cotti support. So you could use Pulumi with Kubernetes. But we've really enhanced that in, in almost every way. Um as part of this 0.15 release. Uh And that sort of starts with the raw ability to use Pulumi with Cober Netti, uh we built our own uh provider for uh for talking to a Kubernetes cluster. Um That's this at Pulumi KTIS package. And uh in that package, one of the really important things about it is it gives you access to 100% of the capabilities of the underlying Cober API. Um So you can use every feature of the uh Cober API on the cluster that you're targeting and we'll expose all of those into the Pulumi uh programming model so that you can work with them and deploy applications against them. We've also added um uh really rich status updates and so the ability to actually see the progress that's happening when you're deploying some of these more complex objects, like when you're deploying a deployment or a service which themselves have lots of internal pieces that they're managing. Uh it turns out there's many things that can go wrong in that process um and understanding and having visibility into uh what's what's happening as those progress is really important to be able to reliably and repeatably deploy uh your applications. And so with the Pulumi provider for Kubernetes you can now get insight into uh those things as you deploy the application. Another key thing we've done working with uh a bunch of uh customers and users over the last month or so. Uh We've heard that, you know, many, almost everyone using coupons today is relying on uh home charts, both ones they develop themselves and uh as a repository for existing applications and existing components from third parties that they want to bring into their cos cluster. And so we've added uh first class support for Helm charts as well so that uh you can describe not just uh co uh objects directly in Pulumi, you can also point at a helm chart and say I want to import all of the content from that HELMM chart and deploy that using Pulumi. Um And so this means there's a much easier way uh to work with existing assets and bring them in and manage them and deploy them uh using all the features that Pulumi brings uh the, the last thing and the thing that I think is sort of uh really um sort of interesting to think about from a Pulumi perspective is that Pulumi, because Pulumi lets you manage uh existing uh cloud resources in Aws or Azure or GCP. Uh you can manage both the uh the cluster, for example, you know, EKS or A KS or GKE uh in the cloud provider using Pulumi. And you can also manage the Kubernetes resources that are deployed into that. And this has been a pattern that as we've talked to folks, we've seen many people uh trying to manage sort of a combination of a kubernetes cluster and some core Kubernetes objects that need to live inside that cluster before it's really a fully configured and usable environment for them. And so this combination of being able to deploy both of those and manage them and version them in a single Pulumi program is something that we think is a really nice uh and fairly unique capability. Um Pulumi can Britain, this experience of course extends not just to managing the cluster but also potentially other cloud resources. So for example, managing some S3 buckets or a man hosted database inside a cloud provider and being able to access them and use them uh from within your Cober cluster. But being able to version uh both the resources and the cloud resources in the same file. I'll go and show an example of this in a little bit more detail in just a second, but I want to talk about a couple of other features that we've added that I'll highlight as part of that example um before I dive into that. So the first uh and these, these are things that uh are very useful generally, but also are are particularly valuable in the forti scenarios as well. So the first is parallelism. So when we launched uh Pulumi, uh we did not yet have paraly in our deployments. And so that meant that we would infer the, the, the, the graph of dependencies uh from the application and then deploy those in the order that was required to successfully uh match the dependencies that existed in a user program. Uh However, when we did that, we did it sequentially. So we didn't take advantage of the places where there were maybe many resources which were mutually independent uh but could be deployed concurrently. Um This made deployments uh slightly slower than they had to be in some cases. Um And so with uh Pulumi 0.15 we've added in support for para and that means that in general, every deployment you do with Pulumi is gonna run uh faster uh for some deployments that's a lot faster. Uh We default to up to 10, uh 10 wide paraly. And so you could see your deployments go as fast as 10 times as quickly as they did previously. Um But in general, even for small and targeted updates, um you'll see some amount of benefit here because some uh the, the those very frequently some amount of uh independent work being done. And so we'll typically see, you know, 50% to, to 2 X improvements uh on, on almost every uh deployment that you do. So this makes it just much faster. The inner loop for developing with Pulumi can be even faster than it was previously. Um And generally is a benefit for every user um of Pulumi. Um It's particularly important for KTIS where many of the dependencies uh are not explicit uh between kubernetes resources and is designed to be able to just throw a bunch of different resources at the um at the API server and it'll figure out how to make them uh uh you know, uh stand up uh as, as fast as they can. And so because of that, paraly is particularly important because the, the actual dependency management is all being done inside KTIS instead of inside uh Pulumi. So that's a great feature. I'm super happy that, that, that's available now for uh for all Pulumi users. Uh Another really important piece that we added um is uh something we call first class providers. Um And so in Pulumi, we have this notion of providers which is like the AWS provider or the coupon provider or the open stack provider. And these are um components that are able to uh talk to a particular cloud platform or talk to a particular um hosted environment and deploy resources managed by Pulumi into uh that environment. And uh prior to uh 0.15 you could use one, it was sort of always one ambient provider for every one of these different platforms. So if you imported the Pulumi Aws provider, you could talk to and deploy resources to Aws and you could configure that provider using whatever configuration you wanted the account credentials the region, other details like that, that you wanted to, to send. Um but there's many scenarios where you want to sort of have multiple providers. Um So for example, if you want to do multiple regions and manage resources in multiple regions from the same Pulumi program, you need multiple instances of the AWS provider each targeting one of these different regions. Um And so with first class providers, we can instantiate new copies of the provider with different configuration that's provided within the Pulumi program instead of externally via Pulumi configuration. And this uh opens up a whole bunch of new scenarios where you can mix and match um deploying into multiple regions or even deploying some uh infrastructure uh you know, in one cloud provider and then using outputs from that infrastructure to initialize a provider for some other uh uh capability. So for example, uh when we deploy a GKE cluster uh in in Google cloud, we might want to then go and deploy uh cumin objects into that cluster. And to do that, we need to initialize the CNES provider with outputs from that GKE cluster that describe the credentials for how to access it. And so these are the kinds of things now that we can do in a single program using Pulumi because of uh first class providers. Another one that's uh you know, we've seen is a lot of the users of Pulumi. Pulumi currently supports javascript and typescript and Python and go, um we've definitely seen a lot of users um choosing to use typescript. Uh so far in part because that's, you know, where a lot of our libraries have been designed. Uh But also because typescript gives users a lot of the nice error checking and tools benefits uh that uh are really nice to have in deploying and managing uh infrastructure. And so with this release, we've actually gone and taken our typescript support one step further and baked it natively into kind of the Pulumi deployment uh engine. And so previously, you know, you could use typescript and you could compile it and compile it down to javascript and, and run that in Pulumi. Um But now you can actually take dot TS files and use them directly inside your Pulumi programs. And this just makes it much simpler to get sort of the benefits of typescript without having to um burden your workflow at all around the compilation process and that sort of thing. Um And so we expect this is going to again make that inner loop just much simpler and make it much more attractive uh for those who want to use a typescript with uh Pulumi. So that's the first sort of batch of features that we've added. Um Let me show you a demo to kind of highlight all of these kind of working together. Uh So I'll jump over here into visual studio code and we'll look at um uh a simple Pulumi application here. And so this is kind of highlighting that scenario that I touched on a couple of times there where I want to both stand up a uh uh a coupon cluster in a cloud provider. In this case, I'll work with Azure and with the Azure Cup service. And then I want to go and deploy some uh resources into uh that cluster. And so let me walk through and kind of show you some of what I'm doing in this particular program. So first off, I'm importing from a few different places. I'm importing the Pulumi Azure package, uh the core Pulumi package, which just has some helpers that we can use with Pulumi generally and the Pulumi Kuti package, I'm then going ahead and um to accepting some configuration. So to run this example, I need an SSH key um that I want to use to be able to SSH into the V MS that are backing the cooperate cluster. And then I need the client id and a client secret to provide to the Azure community service so that it can go and manage resources in Azure on my behalf via the API. So things like allocating load balances or allocating storage inside inside Azure for me. And so I'll, I'll declare that stuff as Pulumi configuration, which means I can come in down here and say, you know, Pulumi config uh and I can set these um using Pulumi configuration and we can see for example that this, you know, client secret, I marked as a uh as a Pulumi secret. And so I don't echo it here. Um uh But the other ones are not secret. So I have them just available here so that I can see and make sure I'm working with the right values. Um But this is easy to now do uh through the configuration system. Uh in Pulumi, I then create a resource group uh in the West US region of um of Azure. Uh Then this is the resource group where all the resources are going to be allocated for this program. And then I go ahead and just create a Coase cluster and I'll just show this all on one screen. It's a little bit of configuration here that I need to create this but really actually surprising little. The Kina cluster API for A KS is very nicely designed and exposes a lot of nice options, but with good defaults for many of them. And in this case, I'm just going to create a fairly small Azure coup cluster. I'm going to provide that SS key and those client id and client secret. So I've run this program with, with just those components deployed. Um And what I can do is I can say fluy stack, I can come over here and do a couple of things. So one I can come and look at this uh deploy cluster inside the Pulumi service and so I can get all of the details of this deck. So those same configuration that we saw earlier, but also some of the outputs of this. So we see that I have a resource group and a cluster that I created. Uh We see also that I have a browse command. And so in this code, if I come over here, you know, I have a few exports. So I exported that resource group in that cluster. I also just exported a helpful browse command. And this uses the Azure cli use and exposes those um the outputs of this if I come over here and just run that. Um So sorry, I need to grab the actual one from here. OK. Um So that will actually run uh oh Did I already have this running somewhere? OK. I already had this running. Let me try that again. This will actually use the Azure um uh cli to launch a uh a proxy that lets me see what's running inside uh this cluster in the Cober dashboard hosted inside that cluster. And so we see it actually creates a proxy tunnel uh to that using the standard um uh Cobe control proxy uh mechanism. So now I can see what's actually running inside my uh environment here. And if I come over here, we can see just sort of the some of the standard things. So um you know, I've got the, the two nodes that I asked for that are running inside Azure. Uh I've got uh I come down here, I've got the, the core service, the API server running inside my cluster. But I don't have anything else. I don't have any deployments or any other custom services inside uh this cluster so far. Um So let's see what it's like to actually deploy something into this. And so in this example, I can take that uh K provider that we talked about this first class provider and I can create a new instance of it. So I can say new K dot provider. And this allows me to create a new instance of the K provider that's initialized with configuration that I get from somewhere else. And in this case, I'm going to get the cube config from the outputs of that cluster. And if I go to definition on this, we see that this is the raw knas config uh to be used with coup control or other tools. So this makes it really easy. I can take what I got as the output from this uh knas cluster resource and pass it directly into a core provider so that now I can deploy any resource I want uh within that um uh with, with the provider. This is exactly I could do this in exactly the same way with GKE or EKS or any of the other managed uh core services um using the equivalent packages for uh the Google cloud uh and for AWS. But for this example, I then want to go and use that um that new provider, this A ZKS to deploy a home chart. And so this example, I'm going to take the stable Kibana chart. I'm gonna take 0.8 0.0 version of that and I'm going to pass in some configuration for it. And so helm charts all have the ability to pass values in that override defaults. And so this guy's going to override the service type, which is by default plus story IP to be load balancer so that I can take advantage of getting a public publicly exposed load balancer for this Cabana instance. And I'm going to ask to provision that inside this provider that's going to be running inside my Azure service. And so let me uh save that. Now, one thing you'll notice I'm working in typescript here, um which is what gives me some of this nice intelligent and gives me this kind of error, you know, some of this error checking, um like uh like I misspell the name chart. Uh And so I'm working in typescript. And so, you know, previously, I would have had to make sure I was compiling or running some watch job or something. Um But now we've actually changed uh to use that first class support for um for typescript. And so here we see that my main just points at index dot ts instead of compiling and pointing at some index dot Js that's compiled. Um And we so we can just point directly at the next dot TS file. And if I come over here and run Pulumi update, after commenting, uh after uncommon that stuff, we will see that this will preview what changes are gonna be made. Uh And so, in this case, uh because I added this uh HELMM chart, we'll see that the preview says I'm gonna create three things. I'm gonna create this Helmm chart and that Helm chart is made up of uh a Cubana service and a Kibana deployment. And so those are the two pieces that, that Helm chart defines. And now we're gonna actually deploy those from that Hemm chart using uh Pulumi and we'll get a sense of kind of what happens while we do that deployment. So I'll go ahead and run this. Uh We'll see a couple of things here. One all of these are proceeding in parallel. Uh And so this is what we talked about earlier because we have parallelism. Now, we can uh run both that service and deployment in parallel. If we were creating many, many more resources in Cober days, we would uh try to uh deploy them all in parallel assuming there was no explicit dependencies between them. And in this case, deployment completed fairly quickly, it just had to pull down that darker image and, and, and deploy it into the cluster. The service takes a little bit longer because that needs to both allocate an endpoint inside the cluster. But then also needs to inside Azure allocate a load balancer to make it publicly accessible. And that process of provisioning the Azure load balancer can take some amount of time. So while this is going, let's pop back over to the dashboard here and we'll actually see that we can get insights into these things running so that Kibana deployment, we can see now here inside of the um uh inside of the Cuban dashboard. And if I come over here and look at the services, uh we see that uh the Kibana service uh is still in progress. Uh And I can see the status events of what's going on. But since we don't want to tell everyone to always be jumping over into the coop dashboard or running coup control or running queries to try and figure out what's going on during the deployment. You know, we're also providing more context on what's going on. So while this is creating, we're giving progress as we make uh as the service progresses towards being fully initialized. And so in this case, the Cabana service was uh successfully created the end points. And so if we come over here, we see these internal end points were allocated. Um But now we're waiting on allocating uh the load balancer and so that'll take a little bit of time uh to complete. Mhm The one other thing I'll show uh is when we're inside the uh dashboard over here. Uh ok. Um When we inside the dashboard over inside Pulumi and Pulumi gives it tracks the status of all of the different updates that have happened. And so here we can see all of the updates I've done to this stack. Um As I've changed it around and this is the, the deployment that's currently in progress. I mean, you see all the details of what's going on as this thing is being created. So we can keep track of also the status of the deployment from within uh the Pulumi console here. We can also see all of the resources that are being managed by this stack. And we can even see a nice graph here where we can see that we have this Pulumi example, a KS stack, it has a resource group and a Cobert cluster that are in Azure. So there are this orange color and then it has the Cober resources for the Kibana chart and the deployment that are in green and soon we'll have a service as well. So we can get a sense of all the different resources being managed by this stack all from within this console. OK. So this should take only a couple of minutes. Uh Azure sometimes takes more or less time uh to deploy the load balancer. Uh But we'll give it a couple of seconds just to finish. OK. There we go. Just finished. Um So, uh now we should be running that Kibana cluster inside um inside. So we refresh this, we should have an externally visible end point and sometimes on the first hit, this takes a second to load up. Uh So I'll give it time to load. OK. But this should uh once this loads for the first time, we should see a Kibana dashboard running inside our cluster uh on, on top of uh Azure. There we go. So we're loading up a dashboard, uh sort of a cabana dashboard. Um So great. So we were able to deploy a helm chart onto uh an A KS uh cluster all within a single uh Pulumi program. So, OK. So that's a really nice quick tour of some of those capabilities. Um Let me jump back over in the blog post and highlight just a few of the remaining things that we did in this uh in this release are the most of which are supporting existing um use cases. Um And these, again, we'll have more details on some of these use cases uh in, in follow up blog posts and, and videos here. So uh one thing we heard a lot of feedback on, you know, a bunch of the examples that we have for, for Pulumi and a bunch of the use cases that are really exciting, I think uh for Pulumi are places where we stand up. Uh You know, where we use uh javascript functions as callbacks which get used at run. So in this case, we have a little example where we create a cloud dot API, which is going to be sort of an API gateway in AWS. And then we uh host a route on the route, uh which is just going to run this simple amount of simple command. It's gonna get Pulumi I uh and return the status tax for you. So this is, you know, this little program here actually stands up, you know, a bunch of resources in AWS to create a managed API gateway, some lambda, a bunch of other things to make sure that I have a hosted public endpoint for this particular API. One of the nice things is I can just write this code right in line. There's lots of places where I have just these very simple Lambda functions which I don't want to go and manage a whole separate project and, you know, figure out how to upload that into an S3 bucket and wire them together. Instead I can just write this code in line like this. And so I've seen a bunch of people take advantage of this um across a bunch of different platforms. However, people frequently wanted to write code like this, they wanted to import some library uh in their Pulumi program and then use it from within their uh their, their, their call back here. And previously, uh this uh was an error and we actually did not allow folks to do this. Uh because this meant that you were capturing this whole uh package and we would have to serialize that and, and make that available inside the runtime environment of the, the Lambda function with Pulumi 0.15 we've now enabled this and we actually make it work sort of in the, in the way that uh users just expect that this becomes a require at run time just like this does. And that library will get loaded at runtime and packaged up into the, into the deployment package dot Jason, everything will, will just work kind of as you expect. Um And so this makes it so the simple code you want to write to enable these kinds of scenarios just works and you can use these sort of cloud callbacks. Um in a really natural way. We've also extended that support for kind of using javascript functions as uh you know, as handlers for A S LAMBDA. And we've also enabled it um in a really nice way for both Azure functions and Google cloud functions. Um And so yeah, in these examples, you see we've done that for, you know, Azure and here we've actually hooked up some nice, you know, um uh blob events. Um So using Azure blob storage as an event source, um you can just say serve dot storage on blob event and then pass one hit end points that you have running in or uh in V MS. Um but it's a way to just inject these little event handlers into your infrastructure in really convenient ways. And so we now have an a sort of an Azure service package which gives you a bunch of these kind of abilities to, to use service events and event sources inside Azure in this really, really simple way. But with the full capabilities of the underlying Azure platform, similarly, we've gone and added a new GCP dot serve dot function, which again is our sort of wrapper around uh you know, creating the creating a bucket, a bucket object and our storage account of storage object and a Google cloud function um and wrapping that all up so that you can write just the simple callback and use it as a Google cloud function. And so, in particular, because Google cloud functions can support HT P by default, we can just create one of these functions and get the H two P as trigger RL and now use this directly as an API. And so just this really simple piece of code here gives me an API exposed directly to the internet uh that is uh managed in Google cloud functions and can scale up uh you know, effectively arbitrarily. So again, really simple ways to use these capabilities uh inside the applications. And this uh particular feature was one that uh one of our users and, and uh frequent contributors, Mikhail Koff contributed. Uh so I do want to call out um his, his great work on this and, and several other things over the last uh couple of months uh in um uh in the Pulumi community. So uh one other huge thing that we uh released as part of 0 15 is support for open stack. Um And so open stack is obviously an open kind of API for um talking to and managing cloud resources that's supported by a variety of different public and private cloud vendors and is usable in a bunch of different sort of private data center environments. And so we now support this and this opens up the ability to use Pulumi to a whole bunch of uh additional users who are working with open stack deployments. And so uh the Pulumi open stack uh package uh supports the breadth of the capabilities of the open stack API and we, for example, are using it in uh in our testing uh mostly with, with OVH uh which is one of the many providers who supports open stack. And so within OVH, for example, I can run something as simple as this to stand up a new uh a new VM uh in, in OVH. And this deploys in just a couple of minutes. I think in the last video we did, I actually showed um kind of working with this example and, and uh in the Pulumi side and in the sort of upstream uh open stack support this builds on top of and so really uh happy to have not uh not least. Um um and you can just integrate it by running, you know, Pulumi update and Pulumi preview commands as part of uh as part of your, the deployment step in your C I CD system. Uh One of the things we extended uh in this, in this release is we introduced a new github app and that github app will actually, if you install it into your github account, we will now be able to actually um have Pulumi push comments into your pr s uh about the status of those previews and updates. So if one of your pr s is a pull request to merge into your staging branch and you want to run a Pulumi preview of what that update is going to do to the staging branch. We will uh into the staging bridge. And so this gives you a really visceral visibility into the impact the proposed changes to your infrastructure are going to have before you merge those or without having to go in and um and dig through your C I CD logs or whatever. Um And this, we found super useful. We've been using this ourselves uh for a bunch of our uh work. Um several uh the customers we've been working with have been previewing this over the last few weeks. Really excited to get this out there and get uh more folks to, to install the app and, and start taking a look at that um to make it really easy and productive to use Pulumi uh inside their C I CD systems. So that's a quick tour of the release, tons of stuff here. Uh We're going to dive in more in a lot of these areas over the coming weeks. Um And we're just really still getting started. Um A lot of these uh our capabilities which, which enhance uh what's already there with Pulumi. We've got lots more to come uh over the next few weeks and months. So, really excited uh to be working with everyone in the Pulumi community uh to, to develop um all these features and everything else that we've got coming down the pike. I do want to call out um uh all the folks who have contributed to Pulumi uh in this release. Um I talked about Frasier and Mchale's great contributions. We also had uh some really important contributions in the AWS providers and in a bunch of other places from uh James Nugent, uh who's kind of interested in contributing interesting in uh working in or uh you can come and join us in our Slack channel. Um And so our Slack Channel, we've got a bunch of folks who are working with Pulumi uh um asking questions, answering questions and uh working on contributions. Uh So anyone who wants to jump in and, and help out um or, or just learn about how to get started. Uh Feel free to join us in Slack. Ok. So that's it for me uh for today. Um Definitely encourage you to try out the new 0 15 bits. Uh give us feedback uh and let us know what we should be working on next. Um Thanks again. Uh We'll see you next time. Bye.

---
