---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Using TypeScript with Pulumi"
title: "Using TypeScript with Pulumi"
meta_desc: |
    Luke talks all things TypeScript: from getting setup in your IDE, through to programming with Pulumi.
url_slug: using-typescript-pulumi
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Using TypeScript with Pulumi"
  description: |
    Luke talks all things TypeScript: from getting setup in your IDE, through to programming with Pulumi.  Links: * Get started with Pulumi: https://pulumi.io/ * Language docs: https://pulumi.io/reference/languages.html * Multi-language strategy: https://github.com/pulumi/pulumi/issues/2430 * Node.js docs: https://pulumi.io/reference/javascript.html * Outputs: https://pulumi.io/reference/programming-model.html#outputs
  sortable_date: 2019-02-06T20:19:15Z
  youtube_url: https://www.youtube.com/embed/O0qe4cWPpBs
transcript: |
    All right, good morning, everyone. And welcome to this week's episode of Pulumi TV. Uh My name is Luke Hobin, uh CTO at Pulumi. And here today I wanted to spend some time actually talking about uh using typescript with Pulumi. Uh So over the last few weeks and months on this show, we've uh we focused a lot on sort of the cloud side because that's really the kind of thing that Pulumi is enabling us to work with your cloud native infrastructure. Um And we haven't spent as much time talking about kind of just the languages that you can use and how you can use the most effectively uh as part of that. Um And that's actually sort of a thing that uh is a bit of a myth because we, uh you know, really the languages are the thing that we're bringing that really empower you to do so many new things uh with your cloud infrastructure. Um So I wanted to spend a little bit of time today just focused on kind of how to use typescript in particular. That's the language that um you know, was one of our first supported languages and the one that still has sort of the most uh examples and, and things you'll see uh in Pulumi. Um And so, really to go deep on that, uh walk through all the bits and pieces of that experience, um and highlight some of the, the key things you'll want to be aware of as you uh start using typescript. Uh if that's the language you're choosing to use with Pulumi. So, uh so as usual, um you know, for folks uh who haven't checked out Pulumi before you can check it out at uh Pulumi dot IO. Uh and you know, get started um installing, getting started learning about uh the, the product. And uh for those who haven't followed along in our documentation, you can come in and see supported languages, you can see we generally support kind of three platforms today uh for running your programs, no, which can mean deva script or typescript or any other language that can compile down and run on. No Js. And that's what I'll kind of focus in on today. Uh Python, uh which we've actually done a lot of work to improve the, the support for Python recently. Um And there's some, some great uh capabilities there as well and I'll probably in the future uh um talk, go through some more details on Python support and then also finally uh go uh and so we have a bunch more languages coming uh coming kind of down the pipe. Um there's kind of two things related to the additional languages uh that I'll just talk about before I dive deep into no jazz. Uh One is uh we've had some great work from uh some folks in the community on uh on implementing uh dot net support, for example. Um And so if I come over here, we'll see there's a, there's APR open uh for a dot net language provider uh that uh uh here has been working on. Uh And it's a really great uh you know, implementation, it's already got a bunch of the stuff up and running on that. Um And so we're looking forward to seeing that kind of progress. Um But as well as just supporting more languages, one of the things we're really interested in is making sure that you can interoperate between these language as well so that someone builds some rich components that are really valuable for Pulumi in typescript. For example, that folks using that dot net provider can take advantage of that. It's actually just yesterday. Uh Sean uh on the team here at Pulumi uh posted this, this issue, a multi language strategy and interrupt, which really walks through how we're thinking about going after that and enabling a rich ecosystem of languages to all uh interoperate. Uh And so this is something that we're, we're putting a lot of effort into right now so that we can sort of maximize the benefit of having multiple languages on the platform. And definitely if you're interested in that, uh check out this issue. Uh But for a lot of folks today in practice, uh the place where you're gonna get the best experience with, with uh Pulumi right now is, is using no JAS and using javascript and typescript. Uh And so I want to spend a little bit of time talking about that. Probably the easiest way to do that is just gonna be to jump in, uh start using it and show you kind of highlight a few of the different things that, that are going to be interesting uh to pay attention to uh as, as you're looking at javascript and typescript. OK. So let me uh check that out. Um Let's come over here and we'll go to, uh you know, an empty project that we have uh in a folder here. And I'm just gonna say Pulumi new and we'll start off with one of the templates. And you'll see, we obviously have javascript and typescript templates for almost all the platforms that we support. So for example, AWS dash typescript, I can just come in here create this. I'll just take all the defaults and I'll just hit enter. Now, immediately, you see one of the things about uh using no Js is that we're using uh N PM to install these dependencies. Um So this is actually running uh an MC M install to install all the dependencies we need for our project. Uh And then we're gonna go ahead and uh just automatically deploy it. So I'll say yes. So let me first talk about some of the files that we got from this kind of template that we installed over here. Um Just to give you a sense of kind of what the project layout looks like when we're using. Uh no JSU. So every Pulumi project uh has a Pulumi dot Yao file, which is sort of the root of uh that tells Pulumi how to get started, what program to run, how to run it, that sort of thing. Um And so a couple of things you'll note uh this file is actually very simple. It just has a name, which is the name of the project, uh which is this name I created. And you'll see actually down here, for example, the, the link to the uh to the project is my organization, which is just my name and then the name of the project and then the name of the stack. And so right now, I have just a DEV stack created by default by this template and I could create additional stacks if I want additional copies of this project to be stood up. Second thing is we have a run time and this uh tells Pulumi how to go and try and run uh the, the program that's going to try and build my infrastructure. So in this case, we're saying we want to use no Js to run my my program and that will let me use javascript or typescript uh to write them if I had Python here. Uh Pulumi would try and find a Python entry point to invoke instead of a javascript entry point. Yeah. And that's really it, the description is just a sort of helpful description that can show up in a few different contexts as well. Um So once I've got that Pulumi dot Yam, well, now, uh if I specify node Js, it's gonna expect to kind of find a typical uh nude uh project here. In particular, it's gonna expect to find a package dot JSON file which describes kind of what the the node project looks like. And uh if I wanted to, I could specify kind of the main entry point here. So I could say, you know who? Right. So I can that my main column and this would tell me that it wants to use a file food dot TS as the entry point into the project. But by default, no GS uses index as the entry point into the project. And so that's why we have an index dot TS file here. Uh Node will know immediately to uh load that index file if there's no other main entry point specified here. Additionally, uh I could come in here for example and say main uh and specify some other folder. And that would actually allow me to point at a package, Jason and index dot TS that were in some totally different folder than my Pulumi. And so I have configurability uh over those things and just to, to kind of highlight that let me just quickly show a couple of things in here. Uh We can find out about some of these things like the main entry point in Pulumi dot Yaml uh here in the docks and we can also find out a little bit about uh the no jazz support um uh in here in the package Jason Independency Fund, ok. Uh So the other thing to note is that my package, Jason has my dependencies. And so it uh it has my uh dependencies on uh node. Since we're gonna be running this program inside node dot Js, we want to make sure that typescript has the types, it needs to have a rich experience with node. Uh Similarly, uh we want to have the packages for working with Pulumi generally and working with aws and Pulumi specifically and these were installed as part of my template. But of course, I can come in here and also say things like Pulumi, you know, TTI uh if I do this um and we can see kind of what version is available here. OK. Well, let's just go ahead and do it. Uh So now I, now I'm saying I also want to install Pulumi Cotis and so I can make that change and I can say N PM install and this will now pick up COTIS as well. Now, so this is going to fetch all the dependencies of that and install them. And as usual with no GS and those will all be under my uh node modules folder. And so we can see under Pulumi, I've got a Scutti and Pulumi. So there's libraries are installed. Now, one note about the versions here for node um I've specified latest here which is just going to pick up whatever the latest is. Um Let's see if this will connect and tell me, uh not sure why that wasn't working. But uh let me just come over to M PM GS dot org and we can see kind of what versions of these libraries are available. Uh So if I go to cnet's, for example, I can find that we can see there's a lot of versions published. Um And so in particular, there's sort of a few different tags we have available. So the latest actually kind of released version. So with a real tag, like this is 0.20 0.0 and that's marked with the latest tag. And so if I specify latest, it'll pick up the latest uh officially released uh build of this. We also publish a DEV tag which gives you the sort of nightly build. And so every, well, it's actually the, every build we do, every build we do of the provider, uh actually gets tagged with a DEV tag. And so you can use the latest thing that we're in development by attaching to the DEV tag or by picking one of these DEV tags in particular, uh and aligning to that, we've also started using a feature tag. Um So for some cross cutting features that we're looking at doing, uh we'll often publish an additional tag that is marked against uh against some particular feature branch. Um And so those are ways uh if you're testing out some capability along with us, um we might ask you to tag, to grab a feature uh tag uh to test out that capability. But in general, you can sort of see the full history. Um we use semantic versioning. So in general, the change from 0.19 to 0.20 indicates there was some breaking change. Uh uh there, we're still pre 10 though for these packages, um So expect to see that uh that breaking change indicated by that minor uh version number for now. OK. So that's some sort of core M PM stuff uh that we have enabled there. Uh And that's, that's a good, you know, that that's a way that by using N PM, we're able to distribute these packages and have a lot of different packages, not just the core in communities, but for example, if I come in here and do at home, uh you know, we have an EKS package for example, or we have uh cloud package or a Docker package. So lots of these packages that are available underneath this Pulumi name space in. No that I can pull in and use within my program. And the ability to version those using N PM is actually a really powerful ability to version the way that I'm updating my infrastructure. So I can lock in to very specific versions and avoid any potential breaking changes uh or even subtle changes to semantics or I can float and use the latest and then use the preview capability to see what changes are going to happen to my code. One last file that we we added here before I jump into the actual code itself is uh Ts config dot Jason. And we admit in the template, we just provide a basic file here, excuse me. Uh This tells Pulumi uh you know, this tells typescript, how to compile your code. Um And so this is just some defaults that, that we happen to find useful that we admit here. You actually don't need this file at all. You can just, you know, you can leave it empty and that will just indicate this is the root of your project. Um But uh but we put some useful defaults in here in case you want them. Um But if you want to learn about this, uh you can go and read about the TS config file in, in typescript and it just controls how typescript does. Uh does its compilation to javascript. Now, speaking of that, uh one interesting thing that we did uh uh a while ago uh was actually make a change to make it. So you don't have to compile your text script code. Uh yourself, we, you see we have an index dot TS file and I can just come in here and Pulumi up. And so uh Pulumi version of node Js actually understands text files natively And it does this by installing some uh some hooks that allow the node Js uh module loader to load files with TS extensions. And when it loads them, it'll actually compile them on the fly and then take the Js that comes out of that and run it through the node engine. So we, we seamlessly let you use TS files as well as Js files as part of your project. This means you don't have to sort of manually run a typescript compile like TSC or a bill step or something like that. Uh You can just write your code in the TS file and use it directly. And this might be for folks who have used no jas a lot. This is different than a lot of the standard, no S setups. Um But in particular because we control the execution environment for this code. Um It's a really nice and easy thing that we can enable and just one final note on that. Uh I'll mention that there are steps if for whatever reason that uh causes Trump object if you have files that are expecting to behave in a very specific way that don't work in the environment. Uh There is the ability to specify um options to call false, which will turn off this, this ability to, to do that. And then you'll have to manually compile it and point out where your files are uh in the compiled source code. OK. Uh So that's just all of the sort of housekeeping on, on all the different files that are just part of a standard kind of no S and typescript uh project. But where it really gets interesting in the place where most folks are kind of focused is on uh is on the actual uh code itself. So one thing to note uh just first off is, but I have full access to everything from uh no, so both things that are built into. No, just like, you know, there's an HDP library that's built into the no API and so I can come in here and, you know, import that and co create server and I can get my, you know, my help text and, and I can command, click on it to, to go and view this uh in, in uh the help uh environment here. And so I get all the capabilities of no Js, all the libraries, all the, you know, building base 64 encoding and Jason stringify and just all these things that I would uh expect from a compute environment. I don't have to, I'm not constrained to what my DS L may have offered. I have the complete capabilities of no S and that includes actually importing third party libraries. So I could, you know, N PM install, you know, my favorite package. Uh And now I can get that package out of N PM. Uh It may do parsing of some file format or, or whatever it is I need to do. And now I can use that directly from within this environment as well. And so this gives you access to a huge set of libraries and capabilities that you can just immediately integrate into your programs. But as well as all the standard node jazz libraries, uh you get access to kind of Pulumi uh libraries that are specific to using uh using no jas in the context of a Pulumi deployment. And those are things like Pulumi, Pulumi and Pulumi Aws. And so in this example, um this is sort of just the simplest possible example of standing up a a resource in Pulumi. Uh And I'll just highlight a couple of things about this. So the first one is, you know, we obviously get, and I've highlighted this a lot, we obviously get all the sort of completion list and that sort of thing uh inside the environment here. Uh And in fact, now we're kind of getting some code samples as well. We added these recently. So uh some code examples that you can get in line off of these and I can go and command, click on on bucket, for example, uh to go to definition on that and see all the details about the API that's available here. Uh And what I can do with it, every uh every resource that we create in Pulumi uh kind of has two things generally. Um And so if I come over here and just retype this, you'll see, I have, I take a name uh which is a name that the resource is gonna have the arguments which are gonna be the, the parameter, the the configuration for this particular resource. And then uh and options, which provides some additional just general Pulumi options available for this. So let me talk through a couple of those uh steps here. So the first one is the name uh and this is uh this is gonna serve two purposes in general. Uh The first purpose is to be the Pulumi name of the resource, which means this is the name that we're gonna track in Pulumi and associate between two different uh deployments of your program. We're gonna use to understand whether there was a change or whether that the resource has been deleted or been added. And so if I have a my bucket and then I change the parameters to it, I know I need to update that in the second deployment. Um but if I had a my bucket in my first deployment and then don't in my second deployment, I know I need to delete uh that my bucket from the first deployment because this is really the identity of the resource as Pulumi understands it. Pulumi also in general use this as a default name for the resource. Uh and it will add some additional randomness at the end just to make sure it doesn't conflict with anything else. And so by default, if I say, you know my bucket here, uh we'll actually see, let me type in Pulumi stack. I forget what I originally called. This that was originally called my bucket. Yeah. Uh So we should see that there is a my bucket and if I show the I DS, we'll see that this was my bucket dash, you know, E one B, you know, whatever. And so this is actually the name of the S3 bucket that got created by this. It has some randomness on the end because of course, my bucket wouldn't be a valid. I'm sure that name is already taken in the global name space of S3 BS. So, OK. So that's the name. Uh The second is the options back. And so here I can pass all the various things that are available for me to pass. And I can just do, you know, I can do command space to get a completion list and, and ID like to code I can see all the different things are available on here. Uh So that, you know, I can specify the hosted zone id, I can specify policies or regions, um a variety of different things available and I have access to all of that APR and I can similarly, I can sort of come in here and go to definition and see the details about, about that API including some help text. And so for instance, in this example, you know, can be enabled or suspended really easy way to know that, you know, what are my values I need to put in here. So that completion list is a really nice thing as well. The other interesting thing is to sort of do something like, you know, if I do this, you know, if I miss, if I do something incorrect, like I specify cores rules here and I specify it in array. And I specify that the, the first one is this is this empty object, but it tells me that I don't, I haven't specified all of the right properties. And so if I command and click, I can actually see uh this uh see what's available here to use. And this squiggle immediately tells me that I've mis configured this object. And so I get this really quick feedback about that. Um And that's one of the real benefits of kind of using uh types here. OK? So that's a very simple uh kind of example of that. Uh And then the last thing is I have this options bag. And this lets me specify some general things like I can specify the parent. So if I want to make this part of a component to make it owned by a parent, I can specify that if I want to protect this so that I can't delete it without changing the value, I can say protect and true. And this will mean that I will not be able to delete this thing unless I first do an update that says protect back the holes and then do an update that deletes it. So this is a really nice way to prevent, you know, for something that has uh has state backing it like a database or, or maybe an S3 bucket like this. This is a way to really uh make it very hard to accidentally delete that resource. And then finally, provider is a way of overriding which provider I can use uh in uh for that resource. OK? And so that's, that's really kind of how we can create resources. And I'll just go back to this example here. Now, one of the probably the most interesting things, the most things you get questions about the most here is actually if I go and look at this, uh let me just type this again and I come to one of these like uh you know, Loggins and I go to definition on this, you'll see that this is a Pulumi dot input. Uh And you'll see that in fact, everything on this force destroy Pulumi dot input, hosted Pulumi dot input. So every one of these is not just a string or boolean, it's a Pulumi dot input of a string or, and so this is actually one of the core things that in Pulumi, Pulumi that crosses everything that you'll kind of interact with in terms of Pulumi resources is this notion of outputs and inputs. So what this does is this is the ability uh to specify like actually, I'll just write a simple example that takes advantage of this. So I can create that bucket and then I can say bucket object because new A dot s3 dot bucket object and bucket object will just put a bucket uh in the uh put an object into that bucket I discussed. And so here I can say bucket, OK. And uh up the content is how the world. And so what this will do is actually upload into the bucket that I just created an object. And I probably need to specify a key uh specify the key, my photo text and then, and then specify this content that's going to go inside that uh inside that key again, go and click and see what these things are. Now, the interesting thing here is that this bucket uh has not been created yet. And so I actually don't know what its ID is going to be. Well, in fact, actually, it has been created because I deployed it earlier. Uh but had I not deployed this yet, I wouldn't know what its ID was and its ID might change if I make some change that requires replacement. And so here I'm referring to saying this bucket object will use whatever bucket was created by this line of code and it'll use its ID. Uh And so this is, you know, this is a output of string because it's an output from that bucket and then the bucket takes an input of string. What that means is that uh I can pass anything that's an output as an input. If I want to. In fact, if you go look at Pulumi dot input of T, you notice that this actually allows three things. It allows A T. So if, if I have an input of string that will allow a string to be passed, or it'll allow an output of string to be passed. So it either allows a literal, raw string value or something that is going to be produced by the output of some other uh resource. And then it also allows a promise of T and that's not used as often. Um But if you do happen to be writing a code, uh you can easily pass in a promise as well. And these outputs and inputs, the key thing that they do is they track the dependencies between resources and So the fact that bucket uh here, this bucket object has a property that depends on this bucket here, that dependency information is going to be tracked by Pulumi and it is going to be used to make sure that we create this bucket first and then only after it's created, do we try to create this bucket object? It also makes sure that when we delete our resources, we'll make sure to delete this resource first before trying to delete this because doing it the other way around would fail to delete the bucket because it would have uh objects within it. And so this is really uh you know, this, this the ability to track the dependencies between resources through this notion of outputs and inputs is really key to the whole notion of uh maintaining this uh desired state of our resource graft with Puu. And so it's very useful to understand this notion of inputs and outputs. Now, in the common case, you can just do exactly like this, you can take a bucket and you can take a, an output property on it and pass it as an input directly. Uh But sometimes you might need to sort of change something. Uh So for example, maybe I need to take that bucket. Uh you know, uh which one should I take here? Uh Look at our region? Maybe I want to uh maybe I want to change that in some way. So I want to take our region and, you know, prefix it with something else. Um And so you'll see on any output, I have two things I can do. And really, there's only one of these I can do most of the time that's called apply. What this does is, it says when the value is available, transform it in a certain way and to produce a new value that's also going to be an output. And so here I can say, you know, I wanna apply region and then maybe I'll create um so I'll just concatenate uh the, you know, prefix to that region. And this would be the same as you know, I could say prefix plus I want to just do kind of simple stuff. So you'll see now that this my region text is also a Pulumi output of string and it will actually be computed by when this region is available. After that bucket gets created, then we'll run this code to compute this kind of transformed value. And we'll make that the my region text. And now I can use that as an input to something else as well. So very easy to transform the values of these outputs as they come back from the underlying cloud provider. Now, I've actually recently added a couple of things that are, that are interesting. So we can say Pulumi dot interpolate as well and this is actually a a feature that uses some kind of new javascript capabilities to add a uh what's called a tag template literal. And so if I do this, I can say something like prefix colon uh buckets dot region. And this Pulumi dot interpolates if I put that right in front of the back texts, uh that will allow me to embed Pulumi out output values inside the string literals. And you'll see that the result of this is again a Pulumi out output of string. So this will do that string concatenation that string templating. Um But uh but using the ability to embed outputs in there and returning back an output. So this is a handy feature uh to use as well. Now there's a handful of other things you can typically want to do with uh with outputs. And if I come over here, uh there's a lot more details on what I can do. Um You know, I talked about apply, but there's also the ability to combine multiple outputs into a single one to convert inputs to outputs a variety of other things you might want to do with these that are, are useful to go and look at here. Uh And so definitely uh folks are interested in that, take a look at the documentation. Now, one of the thing I wanna kind of briefly touch on uh is um I mentioned kind of kubernetes and I think I imported the package here. So let me just say, so I can say, you know, let me. Bye. Uh So I can do something like create a pod. And one of the things that is interesting here is, um, and one of the reasons why typescript and javascript are generally kind of nice for this kind of thing is that because javascript and typescript are sort of the basis of Jason and many of these kind of uh API S, whether it's the A I or the C API S are actually sort of specified in terms of uh Jason API under the. So the raw API S that are documented by the cloud provider are actually kind of Jason based, uh you know API S. It's because of that, the projection into javascript tends to be very 1 to 1, the names all kind of fit the casing kind of matches very well like API version here in the same casing. It's not sort of snake cases or capital case during those sorts of things. Uh And so we can project a very sort of direct version of that API into the kind of javascript and types of experience, which means that you go and look at docs on how to use cotis or you go look, look at docs and how to use A W in general. Those names are gonna fit really well uh and map very 1 to 1 with what you're gonna use on inside here. And so these, for example, are exactly what you kind of expect if I was to come. I don't think I can click on that. Unfortunately, if I was to come in and go and look at the. Uh So let me just close this and see. It looks like uh maybe the ID E lost track of things there. So the TS config file specifies some of the language settings I'm allowed to use and it looks like it wasn't allowing me to use this kind of AYN keyword there. Uh initializing Js and Ts language features. OK? So now we see that this works. So, so this example is uh is something we have supported in our AD BS package. For example, where from all the things that can be kind of event sources for LAMBDA, for example, uh we have these, these sort of functions which let me hook up a call back to that. And so when there's an object created inside this bucket, I'm gonna run this little piece of code here. This is using a few features that are available kind of in the javascript typescript space to, to take this block of code here and actually turn it into a uh a, a lamb um that we can run and hook up to this event source. So there's a couple of things, I mean, there's a lot of sort of stuff that's interesting that's going on behind the scenes there to make that work. And for folks curious about how all that works, um you can read this kind of run time code section uh in the documentation. And then we have this content on um how we serialize out functions. And this goes into a lot of details about sort of some of the um capabilities and how that works. Um Just in case uh you want to understand that thing is in general, uh you can just take any code you want to run here and run that as part of the event. There's a couple of things specific to typescripts that are worth noticing here though. Uh The first one is uh we actually pass in the, the strongly typed uh bucket event. And so this means even if the code that's running at run time, uh that's gonna execute whenever an object is created, we can, we can get strong typing over that. And so for example, here, I can say EV dot And I can see the details of what that record is gonna, what that um payload is gonna look like. So we know that whenever A S lambda sends us an event uh for this bucket on decorated, it's gonna have a certain shape and it's gonna have, you know, records at zero dot It's gonna have an S3 uh thing. It's gonna have the bucket, it's gonna have, you know the name or the object that is gonna have the key. And so all of this method about what's available inside here is, is available. But yeah, so you can you can see right, easy to split code up into multiple files. Uh using just the standard approach to um to new uh modules. Uh I won't show it here, but of course, the next step of that is it's also impossible to take those files and separate them into separate nude packages. And here we have just one big, uh you know, we have one big package. Do Jason. So, you know, I'm not that big but it's got these two files. I could actually, if I have some reusable component that I want to version independently, I could separate that into its own package. Publish that to M PM or to my local M PM registry. Uh And then version that independently and reference it from my main code using a dependency like this. And so all those capabilities to version code are available uh are available just uh by using the standard no features. OK? Uh That was it then for today. Um If folks have other topics that they're interested in uh covering in, in coming weeks, definitely, let me know. Uh I think we'll, we'll do a drill down on Python soon uh to talk about some of the capabilities there and similar to what we.

---
