---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Ep 000: Pulumi Prolog"
title: "Ep 000: Pulumi Prolog"
meta_desc: |
    Here, Luke Hoban walks through the Pulumi framework and tools building serverless apps, container apps, and configuring infrastructure and services...
url_slug: ep-000-pulumi-prolog
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Ep 000: Pulumi Prolog"
  description: |
    Here, Luke Hoban walks through the Pulumi framework and tools building serverless apps, container apps, and configuring infrastructure and services from cloud providers.   Need an intro to Pulumi?  Watch this episode!
  sortable_date: 2018-06-05T17:46:26Z
  youtube_url: https://www.youtube.com/embed/DM8Wd4f1MNA
transcript: |
    Switch session. Uh My name is Luke Hobin, uh one of the part of the founding team uh at Pulumi. Uh and I'm gonna spend the next, you know, 45 minutes or so, just kind of giving folks uh introduction to Pulumi showing off some demos, just kind of playing around with some code um showing kind of all the fun things Pulumi uh is capable of. Um Thanks for joining us, I think this is our first attempt at a, at a Twitch stream. I think we're gonna plan to do more of these in the future, but definitely uh give us feedback about uh what you like and don't like and want to see more of uh and we'll make sure to incorporate those uh in the future. Um So, uh so first, I wanted to give a quick kind of introduction to what Pulumi uh is all about and then I'll jump into code and spend most of the time uh just kind of playing around uh in code uh to give you a feel for, for what the offering uh actually looks like. So Pulumi is a way to uh get code uh and infrastructure into the cloud faster and collaboratively. And so our goal is to make it really easy to take advantage of all of the amazing technology that's available in sort of the modern cloud, whether that's containers or serverless or managed services in the cloud provider, take all of that good stuff and, and really take advantage of it as an application developer or as a DEV OPS engineer. Um We find that the cloud platforms today have incredible capabilities, uh you know, just tons and tons of new features that they're delivering. Um But in general, those features tend to be fairly cumbersome to actually take advantage of, you have to stitch a lot of different things together. You have to write some, some complicated uh YAML or JSON files to describe all the different resources you need and especially for application developers who are needing to integrate these at a faster and faster pace. Uh It's, you know, it's, it's a lot of work there and we want to make that really easy to use. Um So I'll start by just kind of giving a really quick uh 0 to 60. Um uh going from nothing to having a running Pulumi program and then I'll kind of step back and show a bit of of what's really going on under the hood. Um One thing I should note uh Pulumi is in private beta uh right now. Uh So, uh for folks who are interested in, in kind of playing around with Pulumi. Um definitely just drop us a note, uh, go to Pulumi dot com sign up. Uh, and we'll get you uh into the beta. Um We're going to be opening up more broadly um in, uh, in just a little bit here. Um But for now, uh if you do join the beta, um you can come to docs dot Pulumi dot com, uh um get come to the landing page, just go ahead and download Pulumi. Uh And then you can get started and follow along with some of the demos. I'm about to do. OK. So let me just jump over here uh into uh command prompt and uh I'll create a folder for our Twitch demo and then I'll just type Pulumi new uh to go and create a new Pulumi project. Now, Pulumi lets you use kind of uh any variety of different programming languages uh to author your cloud applications. Um And here we're gonna go ahead and use the hello aws javascript, which is used as javascript to define our project. Um I'll pick Twitch demo. Uh No description. I'm gonna use Twitch Demo, dev. And just because I'm over here in Seattle, I'm gonna pick uh us two. Uh We'll go ahead and get the dependencies we need for this uh node program. Uh And then let me just show you uh what uh this looks like. So because we're using uh program languages like javascript uh in this case. Uh you know, we can show that to you inside a developer tool here, I'm using visual studio code. Um We can see this simple kind of program um shows off a few kind of simple things you can do at a high level uh using Pulumi. Um So here we're creating a H TB M point. This is just a public H TB M point that we want to expose to the internet. Uh And then we're going to host some static content from this www folder. Uh So as you can see here, we have an index dot html and if I ever come there, uh and we're gonna host a rest API route. So this slash source route will run some code uh when we invoke it and then we're gonna publish that and get back to URO. Um So I'll get into kind of what's really going on with this code in a second. But let me show you the full end to end kind of experience here first. Uh So I can type Pulumi update uh in this folder. And that will go ahead and tell me uh what kind of infrastructure Pulumi uh thinks it needs to create to uh deliver the application that I wrote in that javascript program. Um And so that javascript program turned into uh the following 17 resources that we want to create. In this case, we're targeting aws. Um So we're going to create an aws S3 bucket to host that static uh content. We're going to create an AWS lambda function to host that rest API uh call back that we had. And we're gonna create an aws uh API GWAY rest API um to host the public facing HDP endpoint. Um And then the rest of this is just sort of the various things I have to do in AWS to stitch those pieces together the permissions, the roles uh what have you. Um But uh we've hidden all those that, those implementation details away behind these simple abstractions in this case. Um And so you saw there, I got a preview of what was going to be created. I got to decide whether I want to do that or not. And then when I said yes, we're now gonna go ahead and actually um uh create all those resources in uh the cloud provider. And so here we're going and we can see how um these resources are getting created um in Aws. Uh And it should take just about a minute or so to create all of these. Uh And then we'll dive into what we created one quick thing to notice here. Um There's a few interesting things about this code one is we didn't have to reference all those individual pieces of the individual A S lambda function, the individual aws three bucket, we're able to use just higher level kind of frameworks. And this is a key thing we'll see repeatedly kind of with Pulumi is uh we provide access to some raw building blocks, but then we let people build various components that create new abstractions, new capabilities um that are made out of lots of those different cloud capabilities. And so here this H DB M point is is I can something I can program against it will under the hood create some other AWS resources. Um But from a developer perspective, I can stay with this very simple uh output. So uh I'm just gonna quickly take a look at um what the outputs were from that stack. Uh Just going back here really quick. You see I did exports dot URL equals uh And so now I have an output property called URL. Uh And then I can go and uh hit this end point here. Uh And you see this uh bump up the phone a little bit, this just returns some basic HTML. Uh And it says served from aws. Uh And if we just go back to our code, we see that aws is coming from this rest API call. Uh And the rest of that content is coming from uh this simple index at HTML. So there we go, we were just in uh with a very small amount of code able to uh deploy a uh sort of full working Urus application that hosts some static content uh and hosts a rest API. So I'll go a lot more into details of how this particular example works. Uh In a second. Um There's two more things I wanna quickly kind of um highlight uh here. So one, you see, we've got this Perma link here. Um So when I deploy things using Pulumi, um as well as going into deploying some resources uh into your target cloud provider. Um In this case, uh AWS, uh we're also gonna um uh keep track of the resources you created in the Pulumi backend service. And this ensures that after you do multiple deployments, you can see what the state of the deployment is after each one of those. And then we can track how your cloud infrastructure has evolved and you can see that history over time. Um So here, you can see, I can see the full details of what uh what resources were created. But even more interestingly, I can see all of the resources that make up my application. So for example, if I look at my function here, I can see my Lambda function open that up in the A DB console. Uh And uh if I go to monitoring, for example, we see we have one hit against that uh that LAMBDA. Um And so when I went to that web page earlier, uh that caused that to get invoked. Um But we can see we can go and deep dive into the underlying Aws resources uh from within here. I'll show you some more of this a little bit later as well. Ok. Um So that was a quick high level view. Uh In that example, I showed off using javascript, um using aws and using a high level um uh high level framework for HD PM points. Um as we'll see through some of the other examples uh today, uh you can use Pulumi with a variety of different cloud providers. Uh you know, we can support aws, we support Azure GCP. Uh and uh even targeting um directly in any cloud or on Prem. Uh And then you can also use a variety of different languages. So, uh we support javascript and then typescript as well. Um We also support Python today and we're expecting to um add additional languages um in the future. Um I'm going to focus mostly on javascript and typescript today and, and I'll start with some demos on aws. But if folks are interested in uh in demos on any of the other pieces here, we'll definitely uh dive into those as well. Ok. So let me uh kind of start um that was kind of a high level thing. Let me start down at the sort of the, the base level of uh of working with um aws and show kind of how some of this stuff works. So here I'm gonna show uh an example of just a simple kind of infrastructure uh demo. So um just deploying some basic aws uh infrastructure um in this case, uh that's gonna be an EC2 security group and an EC2 uh instance. And so this is the kind of code if you've ever done sort of raw AWS infrastructure. Um This is the kind of thing that you'd be familiar with from your cloud formation experience. For example, um the key difference here is that we're, we're doing this in, in javascript. Um And in fact, in this example, we're doing it in typescript um that has, you know, a few benefits one, you know, we obviously get, you know, simple things like if I mistype the name of my instant size, I get a squiggly and I get told that there's an error, I can get things like, you know, intelligent, I can see the full list of APIS, this sort of things are actually pretty amazing. There's, there's something like 500 APIS available in this AWS library that we project here and getting intelligence, getting completion lists, getting error checking against those. Um is a really nice way to be able to explore and understand and rationalize the amazing surface area that these cloud providers have without having to just sort of guess the right strings and copy paste from, from documentation. So in this example, um we're just creating these two resources, the security group in this instance. Um And then we're going to um go ahead and export the public IP address from that. And so let me just show you kind of what happens when I, when I run this example? Uh let me just see uh what stack I have. So Pulumi has a notion of um stack. So I can take my program that I've written here and I can deploy any number of instances of this program and each one of them is sort of isolated from the others. So for example, I could have uh one instance which is my production environment, one instance, which is my DEV environment in a team setting. Each one of my developers could have their own uh instance of this uh of this program running um as their own development stack. Um And so I can create one of these stacks, I guess right now, I have a little Twitch uh stack that I've created. So I'll just go ahead and use that I can set config on that stack. And so I've set the AWS region to be uh us west two for this stack and then I can go ahead and uh run Pulumi update. Um You'll see that had zero resources in this stack currently, so I hadn't deployed it yet. Um When I do go and try and deploy it, we will see uh creating a couple of resources. So you see a deploying executives who resource they asked for the uh EC2 security group uh in the EC2 instance. Um You see also there's this Pulumi Pulumi stack which is just a um a parent for all of the resources that are part of uh the stack. So you'll see that in any stack that you create with Pulumi. So go ahead and do that. Um It'll take a couple of seconds to spin up uh that EC2 instance. Um One of the key things here is that uh this Pulumi Aws library um projects the entire surface area of um of Aws. So every API that's available at A BS, um we're gonna, we already are revving this frequently to take uh inputs from new API S that have been uh been delivered in A U BS. Um And so we can use anything that's available in Aws and the API for using it is sort of the, the basic API that you'd expect um you know, looking at these resources. So here you can see all the different properties that are available um on a EC2 instance, for example. And so at this level, you can work with any of the raw infrastructure here from AWS, but also from Azure or GCP or Cotis. And so Pulumi gives you access to all of the resources that are available in those platforms. I've now created this. Uh And I can sort of say, let me stack output uh and see that I have now a public IP address and public DNS and similar to before, if I click on this Perma link, come into my resources and click on this A S instance. We'll see that I can get directly into my uh ec2 instance and see that it's running in aws and still initializing right now. Um But the, the instance has been created and is is running. And so I was able to just write that bit of bit of code and declare that and run it now in uh in AWS. Now, one thing that's really important to point out about Pulumi is even though you're using javascript to describe this, this is still sort of immutable infrastructure. This is a, you know, declarative form of describing the infrastructure. So what I, what my program here is is describing is the state that I want my application to be in. And so what I'm saying is I want my application to have a security group with these parameters and an instance with these parameters. Uh And if I change one of those, so like, let's say I want to um cut off ssh access into this. And when I come back over here, I'll because I'm using TED script, I'll just build that real quick and then I do plume update. What we'll see is that this instead of recreating all of my infrastructure for this application, Pulumi is going to compute the minimal di it needs to uh provide uh to make the change to my target infrastructure. And so in this case, I can just go and do an update in place to my security group to change my ingress rules and I can even see the details and see that the change I'm going to make is to remove that site, that mapping for port 22. And so if I go ahead and say yes, I'll do make that change notice. I don't have to update my EC2 instance. Um The So this was really quick to complete it in about three seconds there. Um And in fact, if I go just back into this console and look at my security group in Aws, uh we can see that now this doesn't have access to port 22 anymore. So we made that change in our target infrastructure immediately. And so the key thing here is that with, with Pulumi programs, you're using javascript to describe the desired state uh of your application. And so then when you're iterating on your application, you can make uh local changes and those will have only the targeted impact they need to uh on your cloud infrastructure. And so in a sense, a Pulumi program once it's deployed runs forever uh until you decide to tear that piece of infrastructure down. Uh And every time you do a Pulumi update, we're patching in the changes that you've asked for in your program. And that's part of why we give you that preview is so that you can see what are the changes that Pulumi is going to make to your infrastructure? And do you want to make sure that uh those are the right changes that you expect. Um And that you're prepared uh to for, for any updates that are going to make uh to your infrastructure. So as a quick kind of uh view of what kind of Pulumi um can do at the very lowest level. Um and we can make a variety of different changes here. One of the things that's most uh kind of interesting in terms of taking advantage of javascript though uh is uh let me open this up, let me see if I have one open here. OK. Um Let me go over to another example that's kind of related to this. Um So when we have a, a programming language like javascript, um as well as just the constructing the raw objects from aws, we can use all the other features of uh programming language. So we can write four leaks, we can write if statements, uh we can write arbitrary code and use node packages to uh to do whatever logic we want. And this lets us sort of mix in a whole bunch of interesting capabilities into our infrastructure uh programs. But the most interesting thing really is that program languages give you is the ability to create new uh abstractions and new components. Um And so I'll start with a very simple example of that and then we'll show some of the really interesting kinds of components uh that, that we've been building uh with Pulumi and that others uh in, in the private beta have been new building and using as well. So in this example, um instead of me directly constructing my EC2 instance and security group, I'm going to instead construct a web server dot micro and a web server dot nano. Um And this, you can imagine instead of me just copy pasting a whole bunch of cloud formation around or, or whatever else I might have done to describe my infrastructure, I might instead want to just use uh something that my team had built or just abs away and give a name to a common pattern that I want for this subset of infrastructure. And if I go to definition on this micro web server instance, we can see kind of how we implemented uh this component. And so you see a couple of things, one, it's really kind of the same thing we had in our previous example. Uh We have an EC2 instance here. Uh And we have that security group as well, but there's two differences. One is that the security group is, is a, just a module uh variable in javascript. And so this is encapsulated within this module and not exposed out to the rest of the world. So this is sort of showing off kind of the benefits of encapsulation that we get uh within uh traditional programming languages. And then I've created a new class called server, which sort of gives a name to this pattern. Of constructing this kind of shape of EC2 instance with a shared backing security group. And so instead of me exposing all the different parameters that are available to a EC2 instance, I can just expose a couple of simple parameters that I want for within my organization to parameterize my server by. So this case, we'll just give it a name and we'll give it a size. And in fact, then we can create some base classes. And of course, these are, you know, these are a little silly uh just as examples, but you can probably imagine how a similar sort of abstraction might make sense inside your infrastructure deployments where you have a certain shape that you use typically. Uh And so here you have create a micro instance which just bakes in T two dot micro. Um So the, the, the key at the end of this is uh should I go back to my that index at TS? Um But now my sort of my uh development team can sort of write code like this. Uh And my core infrastructure team can manage those components taking that a step further because this is all javascript and we have access to kind of N PM or in Python, we have access to Pipi, we can go and share those components with others in the community or with others inside our organization. So we can build and share and reuse components that describe cloud infrastructure through the popular package managers. And so we'll see a bunch of examples of some of the packages that um that we at Pulumi have built um as examples of this. OK. Um So, so that's a quick sort of uh view of kind of the beginnings of what we can do in terms of building our reusable abstractions. Um Let me go back up and show, uh let me actually show one that's a one step kind of up from this. Let me see if I've got it open here. No, I don't. OK. Um OK. So let me show you another library. We have called Pulumi A S uh Infra. And so, you know, when, when folks, when we see folks doing infrastructure programming uh in Aws, for example, uh one of the patterns we see frequently is people copy pasting, you know, tons and tons of boilerplate uh to create um uh simple uh to create simple uh you know AWS network infrastructure or A S ECs instances to run all of their compute. Um And so in this example, uh let me just show real quick. Um We have uh in a Infra package, we have some abstractions which let you sort of immediately create uh a baseline sort of A W BS network infrastructure. Um And so here a S info dot network is a component we've built, which lets you to specify how many availability zones you want to create subnets in whether you're not, you want private subnets associated with those. Um Anything you want in terms of sort of the core patterns for describing an A W network. And then you can easily go and use this, just write new Aws info dot network. You don't have to worry about all the little details of that, that 90% of the time you're not worried about. Um If you do need to tweak some additional setting, you can go and uh tweak that either by, you know, adding that capability as a parameter on network or by going and rolling that um and using some of the underlying pieces of Pulumi us directly. But this gives you a really easy way to get started to build a network. And so we have a few of these kind of building blocks um in this library. But let me go back to sort of something more like um kind of the, the first example I showed where we do sort of a bit more high level, a bit more kind of application developer, um sort of things and all of that is really built on top of the same foundation of composing together um aws uh resources and other cloud resources. So let me go uh into our examples folder and actually let me just quickly show uh show this um github. Um uh So I'll just pump up the phone a little bit. So we have uh examples folder. So folks who uh who join the private beta um uh will have access to the examples folder and we're gonna open this up more broadly uh soon. Uh Here, there's a bunch of examples of how to do a number of different things uh with Pulumi. Uh And the one I wanna um start by showing off uh is this Pulumi cloud JSH TB M point. Um So let me just uh open that up here. Yes. OK. So this is an example that's a little bit like um uh a little bit like that. First example we showed where we're using a H TB M point to expose a public API. And as we talk about back then, you know, this is really just a wrapper over creating uh this is really a component that we've defined uh in this Pulumi cloud Aws package uh which, which builds together a bunch of things to make it really easy to deploy um serverless API. Um So if you've used tools like serverless framework or things like that, you can think of this as being sort of similar to what some of those tools enable, except it composes with all the other sort of uh aws primitives you might want to use or Azure or primitives. Um And so you get the sort of same to define really simple serverless applications. Um But where you can peek beneath the hood and, and work with the Agra resources as well. Um So in this example, we have this HBM point, um, we define a Get handler. So we're gonna accept any, uh, any route off of the get handler. And then this is sort of a really interesting thing which uh we showed in that first example, but I didn't go into much detail on. It's really sort of one of the, um, kind of interesting things that you can do, um, in Pulumi. So here you see that we actually write the code for handling this route right in line here. And so instead of me having to define a separate aws lambda somewhere and build a zip and put my code all in some other folder and things for these little pieces of code that I might want to run just as part of my my infrastructure application. We can go ahead and define that right in line if we want to. Um So we can still define it as a, as a Lambda written in any language we want. But if we want to just write a little piece of code to handle this, we can write it uh right in line here. And so in this case, we are writing a handler um uh that handles any of these routes and just goes and runs uh this code here. Oops. Um And so let me just uh come over here and look at what stacks I have. OK. So I have this Twitch HBM point stack with no resource in it. Let me just see what config I have set good. So I'm, I'm deploying it into uh us West two. So let me just take a look at um what happens when I Pulumi update this. So it's one of the quick thing that I um I glossed over here. Um This example also highlights using a cloud dot table. Um So as well as me defining a um H TB M point to host uh this public API and a handler to host this rest uh route. Uh We also want a place to store the state associated with our application. So we're going to use a cloud dot table. Uh And this table is just going to keep track of for every route that gets requested. How many times has that route been requested? And so we're going to update that in the table every time this gets called. And one of the sort of really key things you can see here is this is an example where I'm defining both some of my sort of what you think of as your infrastructure, your, your dynamodb table in this case, an AWS um and your application code sort of all um together. And so I can version those things if I want to add A Q in here and then version how I uh I write things into that queue if I want to add some buckets. Um I can do all of that and, and all of my code uh um versions together. And so here you see, I got that Abu Dynamo DB table is going to get created that a Lambda function that's defined by this code right here is going to get created and I'm going to create a uh a, a API gateway rest API. So let me go ahead and create that. Um this again will take maybe 30 seconds to a minute to deploy. Um And this will deploy sort of a running application that keeps track of uh of these counts. Um You see again, uh similar to the previous example where you can publish that input and then get the URL property. And this is actually an interesting thing. Um uh You know, many of these uh resources have output properties on them. And so these are properties that will be available once the resource gets created and we want to go and take those outputs and expose them uh to the uh the developer who's running this program. All right. Just give it a few seconds to, to complete deploying that function. All right, cool. I've uh hit the limit of the number of uh API gateways I can have in this account. So let me uh let me actually show off doing Pulumi destroy. So um I'm gonna go back to that example, I deployed earlier, I'll just type Pulumi destroy. Um So Pulumi destroy is what I want. Like I mentioned earlier when we run one of these Pulumi applications, it's sort of gonna run forever. Uh And when I do plume update that's gonna patch in, uh, the new changes I want to make. Um, but if I do Pulumi destroy, uh, that's gonna tear down all the resources associated with the application. Um, so that I don't have those in Aws anymore or in my cloud provider. Um, so here I'm tearing down all those resources. Um, in part, I'm tearing those down so that I don't hit my limit of breast api si think Aws has a limit of about 50 of those. And we must have been doing a lot of demos recently. Uh So I've torn that down now, uh took 11 seconds to do that. Um And in fact, I'm just gonna go ahead and do um cleaning stack RM to delete uh the stack. OK. So now if I come over here, one interesting thing, this actually gives a chance to show off. Um kind of another capability here, you see that during this deployment, we uh we created a lot of the resources, but then we failed kind of three quarters of the way through when we were creating this rest API. Um So you see, after the rest api we still need to deploy these additional resources, but we failed part way through. What's nice is that when I do plume the update um because we had already created all those initial resources, we won't have to create those again. Um And so you'll see there are no changes to these components, but then we still need to create these four. And so this is sort of when you're iterative developing, sometimes you will legitimately hit these kinds of errors where you try and describe some structure that isn't uh isn't, you can't create that in AWS or there's some uh constraints um that you haven't applied correctly. And so you'll get errors as you're kind of developing your code just like you'd expect in, in any kind of uh programming environment. Um But because you're describing your desired state, um you won't have to do everything from scratch. You'll just be able to iterative uh move forward and fix those issues and continue with, with the deployment. And so this should complete reasonably quickly and just create those four resources. So you see now we've created that rest API because we've opened up some space and this is now available. So let me just type, let me stack output to see uh that and we get that URL. Uh Actually, this is a little bit this, this, for example, we want to get different routes on this thing. So let me just uh actually do, you know, curl, let me stack output end point and then I'll say A um So I'll get the, a route on this thing and this takes a second while lambda warms up for the first time can do B and get both of those a one and then we'll just do lots of hits on a and we'll see each time we count, uh that route up. So you see this was keeping track, this is a state full API we've now built, um that has a backing data store behind it. Um And we're able to do that again in just a small amount of code there. Um And we're able to do that using a real Aws resources. So this is not just a uh A no GS program kind of running on a single VM somewhere. This really is a managed service running in, you know, a W A API gateway dynamo O DB. Um This is a robust uh kind of managed piece of infrastructure. Um But we were able to write the code for it in the same way that an application developer might write a simple express application, for example. Um And so that's sort of one of the, the key things that we uh we think is nice is being able to combine uh the sort of real cloud infrastructure benefits of using um A S primitives and Azure primitives and human, a primitives with the programming model of uh what people expect as sort of node application developers or Python application developers. But uh here, so I wrote, I, I um hit those routes a couple of times. Let me just show uh we had a, a link up here uh into the database console. Um a couple of things to note one, you know, we can obviously see the details of that deployment. So all the details of that race API um you know, I can see the create a date on that race api all the details I might want if I want to go and Splunk in and really get details on that. Um I can also see the whole list of activity that's ever happened to this stack um in the Pulumi console here. Um So you see earlier today, I guess I tried out this demo and then just five minutes ago, there's that failure and then the success, if I come in here, I can then go and see. Um like if I look at my dynamo uh table, I can click on that go to Aws and we'll see here. Um I have exactly the rows I expect in my data store and so I can go and look at my, my data store behind the scenes and see those details. Um And if I need to go and sort of look behind the scenes on any of these Aws resources that were created, I can do that through the A BS console and Pulumi gives you really easy access to that stuff. One other kind of fun thing um is the ability to do Pulumi logs. And so Pulumi logs um shows me uh all of the logging from any of the sources of compute that are in my application. And so in this case, if I just go back to that code real quick, we'll see there's only one route, there's this, uh, there's this handler right here. It's the only piece of code. Um And when I look at this piece of code, you'll see it has a few console dot logs getting count dot count. Um And you see that those are getting printed out here. So every time we hit that route, um All of the examples above we see the logging from those. The nice thing though is Pulumi, lets me aggregate those logs into one place and just type Pulumi logs. I don't have to know, go to each one of my different resources and see its logs inside Aws. Pulumi gives me the ability to pull out the information, see it centrally in one place. OK? Um So that, that's, that's a sort of a little bit more detail on how to use some of these higher level kind of serverless uh examples. Um One more thing I want to really spend some time on is uh kind of containers and, and taking advantage of managed container services uh as well. Uh So let me come over to another example uh in here actually, let me just go back in, I'm not sure if this thumbnail or example. So let me just open this up. OK? So um this thumbnail example, um let me just quickly show a diagram that kind of shows what this application is going to do. So this application really takes advantage of sort of all three of the things that that Pulumi can really help you with managing your infrastructure, managing serve application code and managing containers. And so with containers, we're going to use the EC2 container service and in particular, we're going use far which is the ability to run containers without having to manage any infrastructure in Aws. And so these services are great. Lambda is amazing. Fargate is amazing. S3 obviously is amazing. The thing. That's a challenge today for folks who want to stitch all these together is that there's a quite a lot of work to really take advantage of these to the baseline amount of cloud formation, you have to write to use LAMBDA is, you know, a page of cloud formation to really use Fargate, you've got to write several pages of cloud formation to set up all the right resources and things. Um and really then to stitch all these things together is even more complex um to, to hook up the event handler that make sure that when something gets put in the bucket, it invokes this Lambda is some sort of somewhat arcane uh API calls. Um and similarly how to launch a task from a Lambda. All these things are um are a little bit of uh a little bit of work to do. And so one of the things we really want to make uh easy is for Pulumi developers to take advantage of all these great capabilities from these services, but do so in a much, much easier way. So in this example, what we're going to do is show off um taking a, taking a video and whenever a video gets dropped in a bucket, uh we will go and fire off a Lambda uh on new video and that LAMBDA will launch an Fargate task. And this Fargate task will run FFM peg um inside a Linux container and FFM peg will extract the key frame from the video and then write that into a peg. And the reason we're using both Lambda and Fargate here is because Lambda has a constrained amount of time that it can run and is a certain kind of sandbox where getting FF peg running inside that sandbox may not be as easy as writing an arbitrary docker container. And so in this case, I can take advantage of the best of both the fact that Lambda can be hooked up as an event handler for a bucket really easily. And the fact that Fargate lets me write an arbitrary docker container and run that and run it for as long as that job takes to do that keyf frame extraction. And then finally, that Fargate task will write into a bucket and that will fire another Lambda, which will just let me know that that uh JPEG file was uh was written and one thing I should note really quickly, we actually took inspiration from this from actually a really great blog post that was put out about how to use fargate and lambda together to build sort of a serverless application that took advantage of both containers and serverless capabilities. And one of the things, I mean, this, this blog post was great and the example was sort of inspired by this. One of the things that was striking when we, when we kind of looked at this example was just the amount of the amount of complexity there is in getting all this stuff set up manually, right? There's a lot of, you know, this example is kind of pointing and clicking around in the in the ecs console to set up Fargate and configure all the different pieces of Fargate. And this thing goes on for, you know, like 30 pages or so of, of things. I've got to kind of manually configure and Yaml, I've got to write and a variety of different things to go and use these where the actual example, if you look at that diagram feels like it should be a really simple application. Um And so our, our goal kind of with Pulumi is to really make these sorts of things as simple as you think they should be. And so let me show you kind of what that ends up looking like um as a Pulumi program. So uh here's this code, it's about 40 lines of code um in Pulumi. And I'll just walk through kind of some of the key things that are going on here and how we implemented uh what you saw in that diagram. So, uh here we see this cloud dot bucket, um which is that, that bucket I'm gonna use for both where I uh take in my videos and where I output the, the key frames from those videos. And then there's a couple of other things. There's a cloud dot task and cloud dot task is just a, a container that I can run at any point in time that I want to. And I'm just going to describe what container that should be. And I'm going to describe some key characteristics of the container. So the first thing I'm going to describe is is this memory reservation. So I want 100 and 28 megabytes here for this container. Uh And then I'm going to describe build colon and I'm going to point to a local folder on my disk. Let me just show what's in this folder. So this folder has a darker file in it and a couple of uh bash scripts and this darker file is just a really simple thing. It's gonna um just gonna say no. Um This is uh using a base image that uh has a FFM PEG uh installed in it. Uh And then it's gonna run a couple of bash scripts. Um So this, this darker file could be anything this could be implemented in, in C# or in rust or in go or in whatever I would want. Um In this case, it's even simpler. It's just FFM peg and a bash script. Um And so, so uh it just really showing off that we can do anything we would want inside a darker um environment. Um And so I can, I can create this sort of docker container and I can run it using this build colon. Now, the interesting thing about this is when we say build colon and then this file, what that actually means is we're going to, we're going to run a docker build of that folder as part of the Pulumi deployment. And then we're going to allocate a registry inside aws where we're going to push that built image to that registry and then we're going to hook up that registry to this cloud dot task so that whenever you ask to run that task, you're going to run an image from that registry. And so all of that machinery behind the scenes is a lot of what if you looked at that um That blog post I linked to about two thirds of that blog post was just configuring all the different machinery you need in S and in Fargate to handle effectively what's done in this one line of, of your, your program here. So we're really trying to take those patterns of how I how I manage the life cycle of this stalker image as part of my application and make that really simple. Turn that into sort of one line of code you can use, of course, you could still go and use the underlying primitives directly. Um But if you want to use it in this much simpler way, we we give you some high level building blocks for doing that. So let me just uh see what stack I'm on here. So put me stack at West to see my stacks. Um I got this thumbnail or Twitch. It has 32 resources. So I guess I already deployed this. Um Let me just uh let me just see what's in that right now. Um So you can see all of these resources uh are available here. Let me just go and look at that in um in Pulumi. So we can sort of see what some of these resources are. So there's a couple of interesting things here. I mentioned that that um build colon uh created a uh uh ECR registry ecr repository. Um And so here you can see, I actually have that repository um uh hooked up. We can also see that we have a um a task definition uh for this task. So a ECs task definition. So all the underlying pieces that I might expect there. Well, let me keep going with, with this example. Um and show you uh some of the other pieces we, we've got um here. So um after we create that task, uh then we want to actually hook up some event handlers. Um So here we're gonna say bucket uh dot input and we're gonna say when someone puts uh something into this bucket, I want to run this uh piece of code here. And again, this is a nice piece of code just put right in line here because it's a really simple uh piece of code. All this is doing is extracting a few parameters out of the, the arguments uh out of the data about that um uh the bucket event and sending those off to this uh task to run it. Um And so this is the kind of thing. I really just want to stitch these things together. I don't want to create a whole another lambda and a whole another file and manage that all separately. I just want to say, I want to stitch my bucket and my uh my ec task together and I can do that really simply and we can of course, provide the key suffix dot MP four to say only fire this on files which are of type MP four. Um Similarly, I can then go and say when I put a JPEG. Um So this is when that task completes. Uh I want to um uh I want to see that um as well. I'm just gonna print out a message saying that I'm done. So when I deployed this, uh you'll see that it deployed a bucket name uh with this bucket here. And so I, I can go and say, let's see what's in that right now. Um So see there's actually two files in here because I already ran this one. So at um you know, 10 54 I uploaded an MP four file and at 10 55 this cat dot Jpeg got written. So this is like uh me testing this out um uh earlier today. Um And so you can see and I could do the same thing again, but I'll, I'll just uh I'll just leave it as it is. Um But this shows off just, you know, I can, I can really simply go and uh build an app that takes that MP four file, extracts the key frame and dumps it into a JP. The other interesting thing just to build on what I showed in. The last example is here, we can run Pulumi logs and uh and we'll see a couple of interesting things here. One, when I run Pulumi logs, there's actually three different sources that I can see. So I can see my on new video, which was one of my little lambda functions that ran when that S3 bucket uh was uh a new video was added. There's that on new thumbnail when the process is completed and then there's the actual ecs task. Um But the key thing here is we're getting an aggregated log stream across all of those different components all in one place. So as I'm developing this application, I can get the logs from each part of that. Uh and see, see those together, I could also go directly into the A S console or the cloudwatch or whatever and see, see some of those examples as well. OK? Um So I spent a lot of time today kind of showing off uh a variety of different levels of abstraction and some of the, the cool things you can do in terms of components. Um One thing I just want to quickly show off um before uh before I jump off line is um is a couple of the examples of using uh technologies uh other than uh aws and javascript uh to, to work with Pulumi and I won't go through the full life cycle of these. Um We can definitely do that in the future uh switch sessions if folks are interested, but just to give you a sense of kind of what some of this looks like um in other systems. So first off uh for Azure, uh you know, this is an example of creating um a uh A VM in Azure. So a similar kind of thing to that first example I showed with creating a EC2 instance, but here we're using the Azure API. So this is the Azure compute virtual machine. API creating a network interface, a public IP all different pieces of the core networking and infrastructure service offering from Azure. And so we again have access to all the underlying capabilities of the Azure platform and we can build the same kinds of abstractions and reusable libraries on top of Azure as well with Pulumi. Um we also uh have support for um Cotti. Um And so let me actually just quickly open up a um so for folks who have done anything with Kubernetes, you've probably seen the Kines guest book example, which is sort of the hello world of uh of Kubernetes. And I'll just show you really quickly kind of what that looks like um in Pulumi as well. Um And so here we have uh a projection of, of, of Kubernetes into Pulumi. Um This exposes sort of all the core capabilities of um of. So here we can just say like, you know, new K A dot co 0.1 and then we have all the different uh API S that are available and we actually automatically project this out of the um uh metadata. And so here I can go and write, you know, the same sort of thing I might write using YAML or Jason, but I can write it using javascript and so I can pose these things together. I can build reusable abstractions on top of them however, I want. Um And so this is uh you can see an example of creating the full guestbook application that's running red and running. Uh So he's running red, it's running uh engine, uh running a variety of other um containers and services uh all in. Um And this is one final example uh to quickly highlight before we go. Um um I want to show off just quite on what some of this looks like in uh in Python. Um So if we want to use Python, very similar kind of experience, um Here's that first web server example written in Python looks almost identical um except uh with sort of a natural kind of Python feel to it. So Pulumi takes all those underlying uh resources and exposes them, uh you know, as part of a, a language neutral platform for composing and deploying applications. Um And then you can, you can use those from uh from uh currently javascript and Python, but we're going to expose those into other languages as well. Um So that folks can do that in other languages. So with that, um let me just jump back uh to the, the home page. So, um again, uh feel free if you're not yet in the private beta, um go to Pulumi dot com sign up. Uh We'll make sure to, to get you uh you get, you added to the beta um Soon uh once you get into the doc dot Pulumi dot com site, um you can get started just by um downloading the Pulumi cli and then everything else will go from there. Um You can get started with sort of core containers, server and infrastructure examples. Here. We have a great uh tour that walks you through all the core features of the, of the Pulumi product and experience. Um And uh we're excited to come back and do some more of these in the future. So let us know what you'd like to see uh for next time. Um So with that, I'll, I'll finish up for now. Uh And thanks everyone who joined and we'll talk to you later.

---
