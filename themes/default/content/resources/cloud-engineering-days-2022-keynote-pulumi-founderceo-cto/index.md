---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Cloud Engineering Days 2022 | Keynote with Pulumi Founder/CEO and CTO"
title: "Cloud Engineering Days 2022 | Keynote with Pulumi..."
meta_desc: |
    Joe Duffy and Luke Hoban kick off Cloud Engineering Days with exciting new Pulumi announcements.
url_slug: cloud-engineering-days-2022-keynote-pulumi-founderceo-cto
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Cloud Engineering Days 2022 | Keynote with Pulumi Founder/CEO and CTO"
  description: |
    Joe Duffy and Luke Hoban kick off Cloud Engineering Days with exciting new Pulumi announcements. ► Pulumi Templates: https://www.pulumi.com/templates/ ► Pulumi Deployment: https://www.pulumi.com/product/pulumi-deployments/ ► Pulumi YAML GA: https://www.pulumi.com/blog/pulumi-yaml-ga/ ► Project Level Config: https://www.pulumi.com/blog/project-config-mvp/ ► Enhanced Kubernetes Support: https://www.pulumi.com/blog/pulumi-kubernetes-new-2022/  00:00:00 Introduction 00:00:33 5 Years of Innovation 00:01:40 Pulumi Momentum 00:05:15 The Pulumi Approach 00:14:30 New Infrastructure as Code Features 00:16:22 Beginning of Tour through Pulumi's IaC 00:16:48 Pulumi Templates 00:17:54 Demo 00:32:19 Overview 00:32:53 Kubernetes Support 00:33:16 YMAL is GA 00:34:25 Typed Config 00:35:10 Infrastructure Enables Innovation 00:35:54 Pulumi Automation API 00:38:29 Open Source Meets SaaS 00:39:04 Introducing Pulumi Deployments 00:41:30 Demo: Deployments 00:51:29 Swag giveaway 00:51:44 New Features Recap 00:56:38 Customer Story: Starburst 00:59:58 Why People Love Pulumi 01:01:44 Cloud Engineering Days - The Day Ahead  ✅ Get Started with Pulumi: https://pulumip.us/Get-Started ✅ Create a Pulumi account. It's free: https://pulumip.us/Sign-Up-OpenSource
  sortable_date: 2022-11-29T20:22:51Z
  youtube_url: https://www.youtube.com/embed/9B19Vuaq40A
transcript: |
    Hello, everybody and welcome to Cloud engineering days, 2022. Super excited to, to have you here today. Uh We're actually doing this live today, believe it or not. Um From Seattle, Washington. Uh My name's Joe Duffy, I'm the founder and CEO of Pulumi. Um And I'm joined with Luke Hope in our CTO. And today we're gonna go through a bit of an update on Pulumi, what we've been up to what we've been building. Uh We're also gonna talk about some exciting uh customer stories we're gonna hear from several key customers of ours. Uh And we're gonna cap it all off with some fun new launches that are available starting right now. Um So let's uh dive straight and, you know, I think earlier this year, uh for folks who might have missed it, we actually hit our five year anniversary as a company, uh which is really exciting. I can't believe it's uh we've been, we've been on this journey that long, um you know, started in 2017, um and really launched great open source technology with their flagship infrastructures code in June of 2018, uh followed pretty shortly thereafter with Pulumi 1.0 you know, we heard from a lot of enterprise customers that stability and having that 1.0 promise of no breaking changes and having a stable foundation for your infrastructure was very important. So that was a key milestone for all of us. Uh As a company, Plumy 20 wave of innovation was more around sort of adjacent, you know, things like policy is code, the ability to test your infrastructure is code, the ability to ship your infrastructure in uh C I CD uh Plume 30 Universal, introduce some additional languages um with, you know, C# and, and the rest of the dot net family Java um More recently YAML, and we'll talk a little bit about that uh later today. So just continuous steady drumbeat of innovation year over year. Pulumi is also open source, you know, everything is about community for us here at Pulumi. Uh And we've seen a huge increase in just contributions across the board recently hitting 14,000 github stars, almost 3000 contributors to the core of Pulumi open source project. And for us again, we lead with community um because what we see is as that community grows, the community helps uh other community members with education and content. And there's just sort of a network effect that kicks in at certain scales. So for us, we love seeing all of these uh metrics up into the right. Also been seeing great community me momentum in general, uh in terms of users of Pulumi and customers and the depth of usage. Uh We recently surpassed 100,000 community members that we've touched with the Pulumi story. Uh We've seen just over 1000 customers uh becoming a commercial uh relationship with us where it's a great partnership and we can help them in their, their journey to the cloud. And we've seen an increase in depth of usage as well. You know, we we we our North Star metric is resources under management for every one of those is live resource in a or Azure Kubernetes Google cloud, any of our 100 plus uh partners that we have providers for every one of those is a live resource. And so as we see that increasing recently surpassing 5 million, that tells us a lot about the depth of usage. There's just a lot more resources being managed, the complexity of environments is increasing, there are more projects. And so we love seeing that uh that metric growing as well. It tells us that customers are being successful with polluting. And I mentioned over 100 different uh cloud uh providers in our registry now. And you know, here's a a sort of a snapshot of some of the key ones from obviously the major cloud database, Microsoft, Google cloud, the CNCF with Great Cober, Netti support and helm but also folks like cloud flare and uh Kong and Digital Ocean and Data do these all are providers of infrastructure. And although many times we think of infrastructure as code, we think about the major clouds and we think about things like managing serverless applications. The reality is all these other providers offer infrastructure as a service as well in various forms and all of that needs to be managed uh very much like the, the major cloud resources. So it's been great to partner with these folks, lots of shared customers to get together. Uh We're frequently doing workshops and helping each other's uh mutual customers be successful. And for Pulumi, we're all about just making all of these different platforms as accessible and as easy to use as possible. I mentioned the customer moment momentum. It's really amazing. You're gonna hear some great stories from, from some of these key customers today uh with Panther labs and Altana Dutchy um and, and, and others. And I think the key theme here, you'll notice that there's, you know, a lot of um different variety of customers here from small customers, early stage startups, like chain guard all the way up to some of the largest organizations in the world like Mercedes Benz. I think the key trend here is customers are picking Pulumi because it gives them a competitive advantage in the cloud. They can move a lot faster, then get more done with less uh and empower developers while doing so. And we'll, we'll hear a little bit more about that part. Of the story uh in the customer's own words um later on, but really amazing to crack the 1000 customer uh account just recently. And really, we're, we're only just getting started. So taking a step back, let's, let's talk a little bit about the founding story of Pulumi. You know, what was the vision of the company? What are we trying to do? Why are we here? And that will set the stage for some of the new announcements that we'll then jump into and I'll, I'll sort of get out of the way and let Luke uh show some cool demos and, and jump into code. Uh very shortly. I think, you know, our observation with Pulumi was that the modern cloud really changes everything about software development. Um You think about, you know, 20 years ago, we were building simple client server applications. Uh There was a hard divide between the, the the infrastructure side of the team, the operation side of the team and the developers. Um you know, developers could easily write simple three tier applications and then file a ticket, get some infrastructure and then have the the infrastructure team sort of install it into virtual machines and manage it. But the modern cloud is so different from that, we're shipping daily multiple times a day. In many cases, not, you know, once a month or even once a week, the pace of innovation is just so much greater. Um the complexity of the cloud is also so much greater you think of, we've gone from a world of two virtual machines and a database to a world of hundreds, sometimes thousands of moving pieces in a single uh project. And that's because, you know, aws for example, and many of the cloud providers provide these rich building block services that we can stitch together in infinite ways to create new solutions. And although it's changed everything, it hadn't changed very much in terms of the fundamental software development life cycle. Um We still find that many times developers struggle to make the most out of the cloud. We find that infrastructure teams are maybe not working with tools that are helping them scale and deal with the complexity of the modern cloud. And so at Pulumi, we, we took a step back, we said, hey, we're fundamentally entering a new era. That era is the the modern cloud era and it's an era of real distributed application architectures. Uh the cloud isn't an afterthought anymore. It's really part of the the core fabric of how we build modern software. And that's really exciting. You know, you look at some of the most innovative companies, you know, five years ago when we started, we'd say, you know, air BNB lifts, Spotify these companies that are really disrupting entire industries thanks to the cloud. And since then, we've just seen an acceleration of that, the cloud is touching every one of our businesses in a in a key way. And so our new reality that we realized was that all software is cloud software. Um Every application we're building these days is touched by the cloud in one way or another. Maybe it's a uh we're using a data lake. Maybe we're using A I services. Maybe it's a serverless application that needs to be broken apart into lots of little pieces. Maybe it's a containerized micro service where I need to think about service discovery and how to connect to other uh bits of of services and, and software that my team is building. If you believe that, which we very much do at Pulumi, that means all developers are cloud developers and that's really exciting. It means developers can really think of the cloud as really a a superpower that if they can just harness that they can build increasingly powerful capabilities into the applications they're building and really transform the business. And that's the the final point here is that infrastructure enables this new way of building, infrastructure enables innovation. It's no longer a tax, an afterthought or a cost center. It's really central to how the entire organization operates. So Pulumi, we, we like to say we're we're here to democratize the cloud. And by that, we mean make the cloud as accessible as possible to as many builders out there in the world as possible. So we started with infrastructures code. Um That's our flagship technology. We've since launched a lot of new capabilities. You'll see some new ones today. But really, that's what we're all about is infrastructures code. And why is that? Well, infrastructures code gives us this programmable surface area over the modern cloud. It gives us all those cloud providers that we saw earlier and it allows us to program them. We sometimes say program the cloud. It's sort of our, you know, Nike just do it for us here at Pulumi. Um And why is that important? Well, as we want to build bigger experiences out of smaller things, we need some compos programmable model that understands resource lifetime in the cloud. And that's what Pulumi infrastructures code gives us. But we took a different approach to infrastructures code. Um We like to say universal and by that, we mean, we wanted to support all the different cloud providers that we saw earlier. Um we want to support every language as well. So when I think of infrastructures code, there's really two parts, two key parts, there's the expression language and then there's the execution engine, the the thing that understands how to do declarative infrastructures code with Pulumi. We said, bring your favorite language for the expression part. It will marry that with great declarative infrastructures code. And so you get your choice of language as well. We know that developers are increasingly getting into the driver's seat when it comes to cloud infrastructure. So we wanted to support developers, but we also see that infrastructure teams had um burning needs as well that we could solve with this approach. And so we really wanted to bring the same solution to the entire team and really break down some of those, those barriers every architecture. When we started, we saw that there were many people trying to solve the problem just for containers or just for servers or and, and oftentimes forgetting the fact that we have many, many workloads still running in virtual machines. And so Pulumi took out an approach of supporting every architecture with one common approach and all of the cloud resources that go into those architectures. So we like to say your cloud, your language your way. Um You know, if you look at the languages, we support any node, js language, javascript, typescript, Python, um any dot net language. So C# or F sharp, we support go great for distributed systems. We've recently launched support for Java earlier this year and it's not just Java, it's any JB M language. So Sla Cole closure groovy um we launched YAML support earlier this year and we got some exciting news today about that for, for when the simple things are simple. Um You know, Yaml, YAML is a fine solution. And because of that, we were able to bring Q into the ecosystem as well. An important thing about the languages is it's not just the language itself. Of course, it's great that you get four loops and if statements, it, it's funny how many times we hear people coming from other infrastructures code tools, they say pain killer feature was that I actually just get a four loop um which we can easily take for granted, but it is very powerful to have that capability combined with declarative infrastructures code. Um But you get the whole ecosystem around the language as well. You get great editors and ID ES roo factoring support test frameworks, static analysis tools package managers. So we can actually codify best practices and share and reuse them. It's not just the language, it's the whole ecosystem around it. And by the way, uh great stack overflow support, community support, people graduating from college, know a lot of these languages, it's a great ecosystem uh to be able to tap into. I already mentioned all these different cloud providers. Um you know, we, we expose the entirety of each one of them uh in its raw form so that you have full access to all of the features and functionality and all these different cloud providers. And then we wanted to meet folks where they are. So if you are already using, you know github actions to do application deployments, you can now easily plug in and uh do the same for infrastructure deployments or Spinnaker Azure pipelines, any of the, any of the supported uh providers. And of course, we integrate with your ID identity provider of choice so that you get full uh integration across all of your tool, an important point that I'll pause and I've sort of made this point already, but it's an important point. Um That's easy to miss is Plume's approach gives you the flexibility of languages which sometimes those languages are imperative, sometimes they're functional, sometimes they're declarative as in the case with the YAML. But it takes all the things we know and love about those and marries that with everything we know and love about declarative infrastructures code. This is why I mentioned the expression language is different from the execution engine itself. Um What this means is you get all the benefits of infrastructures code, you can preview changes before you make them. You can easily do C I CD. You get full change, history of who made what change to what resource when uh you can automate the work flows, you can enforce security and compliance and best practices. So it's really the best of both worlds. And that's what Pulumi um sort of brought to the table with our initial flagship infrastructure is good technology that allows us to go from manual steps and markup languages. How many of us have, have found ourselves, uh you know, waiting in 6000 lines of of this PC. It was a very common common problem for, for many of us. But now we get to go beyond that to built in best practices. So this is an example of spinning up A EK cluster in, in Amazon. And yes, it's really that simple. Just a few lines of code in which whichever language uh you'd like to use. And we're gonna see that in action in just a minute. And along with a bunch of new features that we're happy to, to, to to launch today, which is Plumy architecture templates. Um is the first one which make it really easy to get started with infrastructures code. What we heard from users was, hey, there's 80% of the scenarios um where all I wanted was to start with a microservices service app, static website, VMK, et cetera on Aws or Azure or Google Cloud or Kubernetes. And so we took those common patterns and we now have these architecture templates that are available to get started much more easily. We've improved our KUTI support pretty dramatically by redoing a lot of the architecture of our uh Kubernetes operator to bring GIT ops uh style of deployments to the forefront of, of our Kubernetes support. We've actually integrated with the CNCF flux project. Uh So really great things to do there if you want cnet's control planning to be the center of your universe, um easy to support that with the plume infrastructures code. And we've also introduced support for server side applied. Pulumi is now G A. So we've actually taken a lot of the feedback from our early preview this year, addressed the feedback really improved, uh the support there and then project level and type config which I think you'll see in in the demo momentarily. But this really helps to manage complex projects that scale and it's really a core feature that is is gonna be um useful for any Pulumi infrastructures good project. And with that, I'm gonna hand it over to Luke to, to demonstrate some of this new functionality take away Luke. Awesome. Well, thanks Joe. It's great to be here uh to get a chance to give a tour of uh Pulumi Universal infrastructures code platform. Uh I think you'll need to stop sharing so I can uh share mine. There we go. All right. So let's get started. Uh And I'm gonna start just on the Pulumi uh home page here. So here we are on Pulumi dot com. And, and one of the things that we've really invested in pretty heavily over the last few years has been developing a whole lot of different learning resources to enable teams and individuals to sort of get up to speed on infrastructures code on how to apply infrastructures code uh to the problems that they want uh to work on. As Joe mentioned, one of the things we've introduced recently is a new set of uh Pulumi templates. And so these Pulumi templates, uh we've expanded from just a blank uh blank application that we have today for our templates to now with these architecture templates. Uh things that take common patterns that we've seen many of our Pulumi users uh look for as they get started with Pulumi making those available out of the box. And so as Joe mentioned, things like containerized services, serverless applications, static websites, virtual machines, cnet's applications and Kubernetes clusters. And each of these templates is available across all of the different clouds. We support Aws, Azure and Google cloud as well as Pune for the ones that, that applies as well as all the different languages we support. And so for example, you can come in here, look at the A DB service application and get an overview of what the architecture is, some details of that and how to configure it. I'm gonna just go ahead and get started with this here. Uh Let's come into our terminal. I'm actually just clean up the, let's just go ahead and do this. Make sure we don't have something already here. OK. Good. So we've got uh we're in this temp the folder here. What we'll do is just type Pulumi new uh to go and create one of these templates. You can see when we type Pulumi new. We see all the different templates that are available uh for Pulumi. And this includes uh more than 100 templates. I think 203 templates are shown here. Uh And I can do something like look for those serverless templates that we just saw on the website. And so for server list, we see we've got these for Aws, Azure and DC P and for all the uh languages we support. Now as Joe talked about, we support a variety of sort of existing well-known languages like typescript Python go and C# to enable you to use all the richness of the languages you're familiar with, along with your cloud infrastructure. Um But as we also introduced last spring, uh support for YAML and I'm gonna show that off and show off some of the things you've done as part of the Yam LG A. So let me just accept all the defaults in this Pulumi new prompt. And there we go, we've created our own project and I'll just open this up inside my ID. So we can see that uh in this case, we, we are using the YAML version of this template and each one of these templates is designed to be a fairly small program. In this case, about 40 lines of, of code that has an out of the box working example that puts together the building blocks that we need for a simple serverless use case and gives me something working that I can start with and then iterate on from there. In this particular example, we see that Pulumi Yaml format allows me to specify that my run time is YAML instead of no Js or Python or go. And if I do specify YAML, instead of me providing my program in separate files in that other language, I can instead provide my resources and my outputs directly in line inside my Pulumi Yao file. So resources and outputs in this case, we just have three resources and a DB im roll a slam to function and a component which makes it really easy to work with ASAP I gateways rest API S. Now Pulumi YAML format allows me to do simple things like reference, the result of this role that was created, grab its A RN and use that as the input to our function. And similarly to pass that function as an input into the rest API S handler. So we can do simple things that compose together infrastructure and have access to all of Polo's programming model. Let me open up a terminal and I'll just see what it looks like to deploy this application so we can type Pulumi up to deploy this into the cloud. We'll see that as usual um pulling me up starts by showing me a preview of what's going to happen when I deploy my application. And so in this case, we see sort of what we expect those three resources we just talked about, but we notice as well that this rest API as I mentioned is actually a component. It's a component that puts together a variety of other building block pieces to make it really easy to deploy a rest API. And so in this case, we see that it's an S3 bucket, a bucket object role policy attachments and permissions to allow the API gateway to access the function and a variety of other components. Now stitching these all together yourself and copy pasting this around is maybe the the normal thing that gets done in infrastructures code. But with Pulumi, we make it really easy to build these reusable abstractions and take advantage of them in other components. And so in this case, this abstraction, this rest API abstraction was actually built using typescript, using all the rich capabilities of Pulumi typescript support. But once we've built that and made it into a simple component, we can now use it from YAML and have a simple interface to this component. Let me go ahead and say yes uh to deploy this. And one of the things you'll immediately see uh is that we recently added uh some really nice features to the CLI display. And so, for example, here we see the progress indicators telling me how long it's taken to deploy each one of these resources. So they can see which pieces of my infrastructure take the most time and how the, how the parallelism is allowing me to deploy various pieces of this at the same time. And so while this is running, it'll just take about 30 seconds, but we'll, we'll take a look at a few other features uh of the gloomy Amal that's now available uh in G A. So one is uh that we've actually introduced ID E support and So while other languages for Pulumi get ID E support sort of for free, because there's amazing Python support and amazing types of support and go support inside most ID environments. Pulumi, uh We wanted to introduce more support than you get out of the box from just a raw YAML format. And so we added a Pulumi uh uh language server protocol for Pulumi uh and how have extensions available in VS code and emacs uh to go and use that. And for example, we can see things like if I hover over the rest API here, uh I get help text that shows me all of the information about this rest API from our Pulumi registry. We also see that if we make a mistake in our code and have a Typo, we get that feedback immediately that this property was named incorrectly. And similarly, if we reference a resource that doesn't exist like I reference role and RLE instead of role, I get that feedback immediately. And so getting some of these benefits of ID integration and productivity even uh for this simple support. OK. So this was deployed in about 37 seconds. We can go ahead and open this up and we'll see that this is just a simple static website. Um But the static website is now calling into a function here that's running in Python. And so that's the simple website here that we're serving and the simple function handler that we're running to compute the date and return it back to the code. OK? So that's a simple example of uh using uh Pulumi YAML support. Now, one thing I should also mention just a nice uh cli benefit here. Oops if I come over here and type Pulumi up again, after I make a small change, we'll see that this actually shows me because we're using desired to infrastructures code, we're gonna see just the diff that's gonna happen here. And so just this function is changing and only its runtime property. But the really nice benefit we got here from some recent work was that we have a much nicer display of some of these diffs. And so, for example, when the runtime changed, we see this really clear indication that the only part that changed was that last digit. And this is especially useful for large and complex strings where it may be hard to identify where the change is or for um el or a Jason literals that maybe uh encoded these strings. And we might want to be able to understand where exactly the changes were happening. So some nice improvements to just the day to day uh experience using the plume CO I OK. So we've talked about Yaml here. Um But one of the really important things about our Pulumi Amal support is that you can start with YAML and still scale up into uh the full breadth of what's available in the Pau platform. And so you can do that um by using the plume convert command. So what I can type is I can say Pulumi convert and then pick a language. And this will take my existing application that I've written here in Pulumi and already deploy it and have running and it'll actually convert it into another supported Pulumi language. And so in this case, we've turned our application into uh Python. And so there's two things that happened as part of that. Uh The first was that we actually removed all of that code that described uh this application inside the YAML file itself. And we changed the run time to the Python. And then we came over here and actually created a Py main dot P file that has the exact same resources with the exact same properties uh defining the exact same application. I'm gonna make one simple change here just to make it uh a little bit easier uh to get all of our Python dependencies. Yes, this will make it mean that we can uh automatically have Pulumi acquire our virtual environment and uh dependencies. And there's just one small change, I'll, I'll make it to the generated code. So if I now run Pulumi up and we'll see is that we're now deploying this Python version of the code, but we're deploying it to the same stack that we already had deployed. And so after this goes and acquires all the Python dependencies, we should see that it'll say that there's no GIF required and that we can continue building this application. Now, in Python, give it a second to download some Python dependencies. OK. And there we go 12, unchanged. Uh We're able to continue moving on from here and evolve our application using Python. Now, now, of course, using Python means we get abu access to a bunch of additional features and some of those features are like the ability to use classes and build reasonable components. And for example, here, uh we can see that we actually get some autocomplete. This is because I have a co pilot turned on. And so I'm able to actually get these A I driven recommendations for how to write my code. And so here I can create a component resource in Pulumi and get a copilot will actually even tell me sort of what it thinks my component might look like and give me some, some hints about how to create a reusable component built out of an S3 bucket and some other resources. And so these are the kind of features that we can get for free because we're building on top of the software ecosystem like the Python ecosystem that has so much rich support, including support uh from tools like github copilot. OK. So won't actually go and build that right now. Um But that was a quick example of that. But even with this, this example has still been fairly small and simple just to highlight some of these basic uh aspects of Pulumi. But let's jump over to a much more complex example to get a feel for what Pulumi looks like at real scale that real teams are working with today. And so in this particular example, we're, we're looking at uh a multi stack uh project. And so this is two projects. Uh one is a eks based infrastructure layer that's gonna deploy managed KTIS on AWS with some supporting infrastructure. And then we also have a guestbook application which is going to be an application, we want to deploy into our knas cluster using uh kubernetes resources. Now, we can see that in this case, we're authoring this in C# and we're taking advantage of lots of capabilities of uh the, the fact that we have a full programming language here. And so, for example, uh we're able to take advantage of things like four loops, we're able to take advantage of strong typing. So if we have to get the type of one of these things wrong or get one of the properties wrong, we'll get that feedback immediately. We get inte sense and all the features we expect from as, as a dot net developer. And then finally, we get support for first class secrets. And so Pulumi built-in support for secrets ensures that this cube config which may have some sensitive data in it, we can mark it as secret and make sure that that sensitive data doesn't leak out into any other part of my system. Once we've deployed our base infrastructure layer, we can now work with actual, actually, there's one more thing I wanted to mention there as well as actually defining this code once we actually also have three stacks. And so we have a developer development environment, a staging environment and even a per developer environment which lets me for each developer on my team, stand up an individual environment that that developer can work with. And one of the things that we can do in Pulumi is once we have infrastructures code, we can stand up the same program in multiple instances, but each one of those instances may want to have some slightly different configuration. And today, what we find is that we, we typically have to sort of copy paste some of this configuration between those different stacks. For example, if I want the A DS region to be set, we we notice that we're setting that across each one of these stacks but to the exact same value. And so one of the features that we've uh released uh today is actually support for adding configuration to the project file. And so in this case, instead of me adding it to one of my individual stacks, I can define that I want my A region to be US S two and I can do that just once in my project file and then remove it from each one of these stacks. And so now I don't have to repeat myself and copy paste. And I can have configuration that lives in one place and is also copy and is inherited into all the projects. I can also um be more explicit and say I just want that to be the default. And I can also say things like I want the type of this to be a string or I want the description to be something helpful. And this will allow the Pulumi cli to provide more guidance and more help for users as they configure new stacks and new instances of the application. So some nice improvements uh to configuration and projects. But now let's look at KTIS itself. Uh So this example uh is deploying, as I mentioned, a simple kubernetes based application onto my cluster. And we'll see that this uses a couple of things, it uses raw kubernetes resources. So in this case, the Kubernetes core B one name space, which is an exact 1 to 1 mapping of the KTIS resource models, name space object. And I can deploy one of those into my Cobert cluster. And then we also see that we, we're taking our application and deploying it using these three pieces of code, which are each one creating a service deployment component, which is a simple abstraction over the raw kubernetes service and deployment objects, which lets me to specify what name space, what image, what ports and optionally whether I want a load balance service to be exposed with this component, I can reduce a lot of the boil plate of managing knas resources but still work with the full capabilities of the platform underneath the hood. And so in this case, uh each one of these, this component is something that I actually built as a reusable component. Um And even though I have access to it here from my dot net program, I actually see that it's, it's defined below inside this uh multi-language package and it actually happens to be implemented uh in go. And so here we can see the implementation of that component. Now, the one last thing I want to mention uh just before wrapping this up is one other nice enhancement. Uh We've made to our support. Although Pulumi Cober A support has been sort of the best in class option for applying infrastructures code to the Cober platform for some time. One of the things we did recently was sort of take that further with support for server side apply and uh patch resources. And so we can now create uh namespace objects in another way as well. So we can say, you know, new Kate dot co dot V one dot namespace. But instead of me just saying namespace, I can also say namespace patch. And so for every resource that we support inside the Kubera platform, we now support a patch version of that resource which allows you to not just create a new resource that's managed by Pulumi, but to actually make edits to existing resources that are defined inside the Kate uh cluster that we want to manage those edits with Pulumi but not the full resource. And this allows you, for example, to add tags to resources, to add uh add values into a config map. Lots of different scenarios where typical use cases require you to be able to patch existing objects instead of create just create new ones. And so with this patch support, we actually have really rich capability to sort of get the best of both worlds of Pulumi. This is our state infrastructures code and the Kubernetes uh control plane model. And so lots of interesting things there around our base platform. So that's it for this first demo, a quick tour of Pulumi modern infrastructure platform uh and some of the new features that we have been able to deliver. Let me hand it back to Joe Perfect. All right, back, back in business. Um So yeah, so we saw some really cool things there. Um Honestly, the the ability to start the L and then as you hit complexity just uh you know, run Pulumi convert and inject into whatever your your destination language is and and just run from there is just really mind blowing. Um And I think the architecture templates are really gonna help folks get up and running much more quickly. We saw that, you know, rich support across a lot of different common scenarios across every single language. That was something that I think we all take for granted now with Pulumi that every one of these is now available in all those, you know, seven different languages that we the deeper and richer support for Kubernetes. We definitely see that a lot of folks are using Pulumi for infrastructures code with Curtis. Um you know, folks that are all in on sort of cloud native, uh really want to do that more cnet centric, get style of deployments. And so all of this stuff is available in the open source project uh as of today. And, and yeah, Yaml, I think, you know, when we launched YAML, um a lot of folks were, were kind of confused, hey, isn't Pulumi the like anti Yaml company, it's all about, you know, languages and you know, it turns out the L and Yaml stands for language. Um you know, for us, what we want to enable is the right tool for the right job. And, you know, sometimes Yaml for very simple use cases as we saw, you know, the the starting template that Luke showed it is the right solution. Um And honestly YAML is also easier to, to build tools around. Sometimes if you're doing something that's, you know, generating YAML, uh it's easier to generate AAA bit of YAML than it is maybe some uh properly parable Python for example, um it's definitely much more um machine friendly uh of a format. And frankly, you know, some, some folks who are coming from a background that may not have as much experience in programming languages, it, it may be less intimidating to start with YAML and, and an easier solution. And so honestly, uh you know, come one come all, we're all about, you know, uh supporting every, every language out there in the ecosystem. And so really excited that YAML is, is available as G A today is another tool in the tool belt and tech config you know, this is something that's gonna really help manage configuration at scale. We find uh you know, it's a very different ball game to go from managing, you know, 12 or three stacks to managing 100 or 200 stacks which, you know, really can't happen here at Pulumi. We actually use Pulumi to, to build the, the A S product that that many of you use on a daily basis. And every developer on the team has their own private developer stack. We've got multiple staging environments and test environments and managing that scale. You know, these sorts of uh features are a big deal to, to managing that complexity. So let's move on to the sort of the next uh segment of of today's announcements, which is, you know, even though Pulumi gives you these great foundations, we still find that infrastructure is often still a bottleneck. We find that developers are not empowered and infrastructure teams can, can really start feeling burnt out because you know, they're really uh the ones carrying a lot of the burden and a lot of the load in this modern cloud era to to take the responsibility of making sure infrastructure is reliable, robust, correct and able to keep up with the the increasing demands of the business. And so Pulumi really does give us these great uh building blocks, these great programmable foundations with infrastructures code to to be able to empower developers with guard rails like policies, code and, and built in best practices and really level up our game and ship infrastructure faster. And many of you out there, you know, honestly, 80 plus percent of our, our um largest customers use this automation API capability. We shipped this um a little over two years ago and initially in preview and last year we we hit G A on this. It's been one of the most highly adopted features. Uh That's sort of Pulumi best kept secret to be honest. And the idea behind the automation DP I was what if infrastructure's code was, was a library in your favorite language and not just the command line tool. Uh What that does is enables you to really embed infrastructures code as a capability into a larger software system, enabling advanced automation. We see incredible scenarios like complex deployment orchestration, maybe you have multi stack deployment workflows or maybe you want to do sort of some canary uh deployment and then scale that up over a period of time. Um maybe blue green deployments uh self serve portals. You know, many folks out there really want to, to enable their developers to, to log into a portal, click a button and get a micro service environment. For example, um custom tools and frameworks we've actually seen in entire companies and open source projects built on top of the automation EP I. In fact, cockroach labs is an amazing customer of ours when you log into their product and you click a button to spin up a a cockroach database as a service in the back end is actually spinning up KTIS clusters across AWS and Google cloud and, and managing that software using automation EP I so incredible capabilities um really advanced scenarios. An interesting piece of data that we discovered recently is that organizations that are currently today using automation EP I are able to manage 10 times more infrastructure per engineer than the typical cli driven approach. And it makes sense because the software is doing the automation instead of human beings having to run a tool. But it's just an example of uh you know, a piece of data that demonstrates the incredible uh scale and capabilities that the automation API has given us. And remember, Pulumi is not just the open source project. Pulumi has the Pulumi service which adds all these adjacent capabilities like uh policies, code identity C I CD integrations to really give you that cloud engineering platform built on top of our flagship infrastructures code technology. Pulumi is open source and you can use Pulumi without using the Pulumi service. We find that two thirds of our community elect to use it with the service just because it's so much easier. An analogy I draw sometimes is just as you can use Git offline, it's so much easier to use with github or Git lab. Um But Plum is fully open source, you can use it for free uh and manage your own stacks and state files and S3 or Azure Blob storage or Google cloud uh object storage. And the community is growing fast as we talked about earlier. Um But Pulumi service really is the the best in class way to get security reliability, ease of use out of the box. Uh And we've continued to improve the functionality available in the service. In fact, we're excited to announce some really key uh new capabilities today and that's something called Pulumi deployments. So Pulumi deployments is available as of this morning. Um It's in preview and what Pulumi deployments is is that deployments as a service technology, it takes everything we learned about automation API and the scenarios that, that unlocks and enables and makes that available as a service. Uh then enables some key features like click to deploy, you can now log into the plume console, click a button and trigger a deployment. Uh You can rotate your A S credentials in the U I and click a button to, to redeploy those changes without having to go make any code changes or manually run AC I. Uh For example, you get great rich observable for those deployments with logs, deployment history and full integration with the Pulumi identity and policy uh systems. So that's one example, you, you also can click to refresh your stack and destroy your stack. Anything anything to do with a plumy um deployment action, you can have trigger from the U I. The second key scenario as it enables is get pushed to deploy. And what that is is out of the box, get up support. Of course, we still support over a dozen different uh CS CD uh providers and you can still use those just as you could previously. Uh This is all additive beyond everything you could do previously. But what get push de deploy gives you is out of the box support today on github and in the future, get loud and bit bucket. Uh support will be coming. You you can open a pull request, get that pull request automatically and have a preview enlighten the pull request with what changes will happen when you can click that merge button. So you can actually do a full code review of the infrastructure changes and the impact of that deployment when you click the merge button. Pulumi automatically is gonna make that deployment happen. And again, this is really taking our lessons learned from automation API to the next level. In fact, all of this, even though these two key scenarios are available out of the box on day one, this unlocks a ton of new scenarios, uh drift detection and remediation, ephemeral stack environments, automatic time bomb stacks, everything is exposed through a rich rest API where you can build custom tools, custom workflows. Uh yourself. In fact, we've added remote deployment support to the automation API itself. So plumbing deployments is actually built on top of automation API. And now you can program plumbing deployments from the automation API which is gonna use the automation API. So a lot of inception, really exciting things going on there. And with that, I'm gonna hand it back to Luke uh to give a demo of what deployments looks like in action. Excellent. Well, I'm, I'm especially excited to get a chance to, to show off uh some of what we're doing with the plume service and uh Plumy deployments. So let me just switch over into my browser here. So uh like, like I mentioned, all of this is sort of capabilities that are enabled through the Pulumi service. And so let's start here in the Pulumi service console and the Plume service offers an end to end management experience for infrastructures code using Pulumi. And earlier this summer, we actually made a pretty big overhaul to some of the sort of core UX for this, the console that included moving our, you know, navigation over on to the left. Uh having a much richer kind of dashboard here with a lot of access to latest stack updates and first count over time. And my personal favorite uh new feature here was the support for favorites. Uh So the ability to mark a subset of my stacks as favorites using this little star right here. Uh And now getting access to those from anywhere I am within my experience using the Bloomy service. And so these features just really helped to give me access to the things I care about most when I care about them and be able to navigate easily throughout the console. Let me drive into uh one of these stacks in particular, one of my favorites here, which is the service uh app uh stack, uh service app slash de stack. Now, this stack is an instance of that same application, that same template that I showed you in the first demo. And so we can see here, for example that the outputs this is running. Uh oh, it looks like it looks like the application stopped running. So I will uh I will not try to run it. Uh I think we have some stuff that cleans up our resources in our, in our development sandbox and looks like that maybe happened here, but I could still come over to the stack. Uh and uh look at all the information about the stack here. Now, one of the things that we've had for a long time is uh integration with lots of different C I services. And one of the reasons why we really want to integrate with whatever continuous delivery uh option platform you use is because we know that to sort of fully get the benefits of infrastructures too, we want to automate the delivery of those infrastructure changes. And so we have partnered with uh all of these providers uh to make it really easy to integrate with them. But with Pulumi deploy, we've also made it really easy to go and just do this directly from within Pulumi itself. And so we've added this new deploy uh tab here and the Pulumi deployments tab allows me to configure how, how I will actually take actions inside the Pulumi service to deploy um my infrastructure. And so in this case, we'll see, um I'm looking at this loob slash CE D 2022 repo, the main branch and the serverless app folder. And so let me just go over to that uh that repo here. Um We've got our repo uh in our folder called Servo and here is the code that we're actually deploying. And so I've set this up, I've also configured some environment variables so that I can have access to AWS resources. And then after I set this all up, you'll notice that there's this new button here that wasn't available previously, that lets me take actions on this stack now that I know where its source code lives and how to go and deploy it. And so with this, uh with this button, we can now create an update a preview, a refresh or destroy for my stack. And each one of these will actually run inside a Pulumi cloud service. And so when we click the button to run a preview, we'll actually see we come over here and start running a preview of a Pulumi deployment from within the Pulumi service. Now, traditionally, this was something I would have run on my local machine and my, you know, my laptop or my desktop or I'd run inside AC I service. But here we can see that now, Pulumi is actually able to run these deployments itself and this allows Pulumi to take action on my behalf uh in lots of interesting ways in this case, just by clicking a button. Um But we'll see later some of the other ways we can wire this up. So as this progresses, we'll see eventually the Pulumi operation, this Pulumi preview is running. And as soon as that started running, we saw that a sort of a standard preview was displayed here. And so, uh in just a second, this will complete and we'll actually see that the Pulumi preview uh indicates that it completed, we'll just jump over here and watch this maybe let's just go back into our deployment. So this diploma is running should finish in just a second here. OK. The, the preview succeeded in just a few seconds. So there we go. We ran the Pulumi preview. Uh In this case, we saw that no resources need to be changed. And so uh everything is up to date inside our environment. Um But all of that ran inside the Pulumi service now clicking to deploy is one thing and being able to come in here and take these actions is really useful. In fact, doing a refresh to understand whether there's been drift on my stack, doing a destroy to go and take care of cleaning up all the resources that maybe I don't have the code for anymore. Uh These are all really valuable uh you know, actions to be able to take here. But what's even more useful is to be able to come into my application and actually make some changes. So for example, if I come over to this index file and just go ahead and edit it, I create a new branch and open up a poor request against uh that branch. And so because this is a poor request that wants to merge into the main branch. And because I set up the main branch as my target, uh before we'll see that when I create this, if I come back over here, we'll actually see that the deployment started just a few seconds ago and this deployment was triggered by that github pull request. And we'll see as this runs that it's actually also going to show, uh, that a Pulumi preview is gonna run in just a second. We'll see. This preview is being started to preview what that pr is gonna do. In this case, it won't show an empty deployment. It'll actually show that it's gonna change the contents of that bucket. And so I'll give this just a second to complete. In fact, this time we can come over here and we should see uh when it completes, we'll actually see it be posted onto the github pr. There we go. So Pulumi came back and posted that it's going to update this bucket object um as part of merging this when we try to decide to merge this into that main branch and now we can go ahead and click, merge, I'll just squash and merge and there we go, we merged that in which is going to trigger yet another update over here. We'll see that. Now there's a deployment happening which is actually going to be the update that actually applies that change to infrastructure. And so now we get that full gets flow just driven off, uh just driven off of the uh get up changes, get up changes. OK? So let's jump over uh and look at one more example. So C I is one really important use case uh for infrastructures code uh for for Pulumi deployments. Uh But we know that as Joe mentioned automation API and being going to embed uh Pulumi deployments into other software applications is a really important use case for this as well. And so one of the things I want to show is sort of a a simple automation API use case and then how we can go and extend that using uh Pulumi deployments. And so this case, we have a simple application built on top of automation API. And this is a Python flask application. So it's a little web service that lets me to build a self service provisioning portal. And it uses the Pulumi Automation API as just a Python library. So this is just a normal piece of Python software, but that uses Plume's automation API I can run this to go see how this works. So I'll open it up and we see we have just a really simple uh uh plu self service potty form uh application here which is a self-service visioning portal. And I can go ahead and create something like create a website, go here to get started, give it a name and give it some content. Now, when I hit create on this, if we come back over to our application, we'll actually see that um that what happens is this triggers a Pulumi deployment. No, actually I I I'm showing the uh the after version of this. So this is actually now running that deployment and it's running it inside uh the Pulumi deploy. And so this is using the Pulumi deployment support. So if I come over here, we'll see that automation API has been enhanced to be able to use, create or select remote stack from GIT with GSO. And so this is actually going to create that stack in the cloud at using Pulumi deployments and focusing on the code that lives inside this examples branch. And so now we can use automation API both to run deployments locally within our software and also to run those deployments inside the cloud with plume deployments. Now, I'll just go ahead and uh cancel this because we won't wait for that whole thing to deploy. But the one last thing I wanted to show about deployments is that all of these capabilities we showed whether it's to click to deploy the github push to deploy or the automation API support, they all build on top of the same foundation, which is this raw uh rest API for triggering deployments. And this rest API uh is available just as one of the uh API s on API dot plume dot com. And just Ava makes available this deployments verb on stacks for any deployment, I can just trigger it using a source context which is a GIT repo uh and some details about that GIT repo and operation context. For example, that I want to run an update and that I want to use these environments variables. And if I run this, we'll see that when I uh the run this curl command, the response is actually that I've kicked off a deployment and I give get back the URL and I can now yet again see this deployment running, but this time just triggered by a simple Kerl command and rest API call. And this can be now embedded into all sorts of other use cases. Um And so, for example, in our deploy demos project, we show off a handful of use cases for what we can build with this, like a drift detection feature that automatically runs refreshes on a timer or time to live stacks, uh which we're gonna, you know, they're gonna self-destruct after a certain number of hours based on a tag that you apply to them. And so many other kinds of use cases that you can build on top of this foundation. That's a quick tour of the Pulumi service and Pulumi deploy and I'll hand it back to Joe. All right. So, um Pulumi deployments is available as of uh this morning. So feel free to check it out. In fact, for the 1st 100 people that give it a try and successfully deploy something, uh You'll be getting some free swag in exchange for, for trying it out and we'd love to hear your feedback as well. You know, what are the sorts of things that, that work? Well, what is the sorts of things that you'd like to see, maybe improve down the road. Um So just to recap, you know, you'll see deployments in the A S, you'll see this nice new uh button in the upper right hand corner when you've been able uh deployments for your staff, um This rich rest api we have documentation available now out in the plume documentation that describes all of the new API end points and how to use them. Um Programmatic deployments, you saw Luke both directly go against the rest API if, if that's, you know, just uh curling an API or programming against it is preferable. But you can also do remote deployments in the automation API itself. Now get pushed to deploy the way that sort of works. You saw, you saw that in action, but to configure it, you'll first install the Pulumi github app and then configure it to point at the, the repo and branch that you want to deploy. You'll put environment variables uh in, in there as appropriate, you know, especially if you're uh using that to manage cloud resources, it needs a way to authenticate from the server to your cloud account. And um and uh we have secrets built into that as well for encrypted uh sensitive information and then go code away and as you open pull requests and merge uh magic is gonna happen. So really exciting features, you know, the the team is really hard to work on, on this stuff. It's, it's really been magical, seeing it all come together and I hope everybody, uh gives it a try and, and loves it. And again, you know, if you prefer using Pulumi the same way that you did previously, you know, maintaining your credentials on the client so that the Pulumi service doesn't need to know how to talk to your cloud account. You all of that, all of that stuff that you just saw is additive to the existing support for existing C I CD choices or just running the command line. Um In the traditional way, if you're curious sort of what the architecture behind Pulumi deployments is, uh you know, you can think of uh the diff the main difference is where does the compute run for the program? So here's a little diagram just so you have a mental model of this, you know, previously the pro the plume program always ran wherever the command line ran or wherever the C I CD integration runs. So if you're using the Kubernetes operator, you know, the, the, the, the Pulumi engine is running in the context of wherever that is running, which means that any communication from that client to the cloud provider happens between the client and the cloud provider and the Pulumi service is really orchestrating um you know, state management, concurrency control identity, uh things like that through its rest API and a hosted service. But push to um sorry, what Pulumi deployments brings to the table is, well, a new rest API and a new set of client side functionality. But more fundamentally on the server, we now have these workflow runners that can actually run Pulumi compute Pulumi programs. And that's really exciting because it really unlocks not just the initial features that you're seeing on day one, but a long list of exciting functionality that you'll see in the, in the coming months that today you can build on your own like drift detection and remediation time bomb stacks, things like that through the rest. API but lays the foundation for a lot of new exciting functionality down the road. So I'm uh close to wrapping up here. I really, really appreciate everybody's time today. Um I wanted to just celebrate, you know, some of the ways that we're seeing customers innovate with polling. You know, I think across a lot of different dimensions, we're seeing just customers taming cloud complexity and how are they doing that? Well, they're, they're automating a lot more with things like the automation api they're empowering developers with guard grows so that the infrastructure platform team can build out their platform to find their best practices and their policies uh using things like components and packages. But then turning around and letting developers self serve some of the infrastructure, you know, should a developer need to file a ticket to create a serverless function, for example, or would it would it be better to just empower developers to be self served and build some portion of the infrastructure. We find a lot of these customers want to want to go down that path and yet the infrastructure team of course, wants to maintain control over things like virtual private clouds, kubernetes clusters and some of the more complicated aspects of the infrastructure that need to be secure, cost effective and reliable. But we just hear incredible stories of, you know, being able to deploy 10 times faster, reducing the amount of time spent on maintenance by more than 50%. In the case of Atlassian, uh reducing lines of code by 98%. Like some of these numbers are just mind blowing. And it's no surprise that people picking Pulumi are way more productive than typical infrastructures code solutions. And with that, I'd, I'd like to invite uh Larry and Matt to talk a little bit about how Starburst is uh using Pulumi. How does bloomy impact the company beyond just your development team? Yeah. Um For me has a pretty big impact beyond just developers. I mean, it's all rooted in developers, but it helps a whole lot with um allowing cross team uh collaboration. You don't necessarily have the problem that you have with uh other tools in the space where there's specific subject matter experts that only know how to use um that specific tool or write code and that language that that tool needs like hashi config language for terra form, right, which allows uh a broader set of engineering to be able to solve problems, which allows uh at levels of leadership to be able to make better decisions about like allocating teams, allocating resources to problems and being able to take advantage of all of the resources you have in your organization. Um And it also unlocks people who are say building product features that need support from infrastructure to self serve them their own needs, which gives them a better work environment allows them to be engineers and you know, hack on the things they want to hack on. It allows for more innovation as a result. And that means that we get a lot more potentially great ideas going into the overall planning process. So from the perspective of like planning a large like planning the construction of the product of a company like Galaxy, we've been able to do a lot more with taking advantage of cross team resources and taking advantage of um having engineers be so self empowered that they just push through problems. They're not waiting on another team to, to solve a problem for them. That's awesome. And do these product teams know that Pulumi is behind everything or it kind of just work like magic or, or maybe just talk through. Yeah. Yeah, I think that actually they, they absolutely do and they're very comfortable working in the code. So, you know, they see in the typescript code that for importing Pulumi, they know that to include that in their pr, that they, if they need to make an infrastructure change, they just make a change right there in the Pulumi code, get their pr out there. And, uh, we still have somebody from the infrastructure team kind of like, take a look because we're pretty new with Pulumi. But, um, that just, they know exactly what it is and they have no problems making the changes themselves. Oh, um you know, Matt Matt is an engine of Starburst and it's been a great partnership helping them build, build their cloud platform and their, their product. And so um really awesome to hear, you know, from, from an end user's own own words, why, why they love bloom. Um And I think, you know, just to summarize, you know what we're seeing, why do people love bloomy? You heard Matt talk about this? It's for the entire team, it's not. So, you know, we often hear that there's a, you know, a couple uh terraform experts over there that, you know, uh that understand everything, but maybe the whole team isn't empowered or don't understand how the infrastructure works. And really with Pulumi developers can get more involved, but infrastructure teams can also up level their game and have great uh tools that work at scale and uh with modern cloud complexity. Um It's a standard workflow for any cloud, so public private or hybrid rather than having one tool for AWS, one tool for Azure and uh trying to bash script, everything together with co co co control in the mix somehow it's one workflow that works for any cloud. Um You tendex your productivity, you saw that automation api uh users are able to manage 10 times more infrastructure than typical uh infrastructures code scenarios. You get real sharing and reuse so that we're not copy and pasting scripts. You can use real software engineering practices uh to share and reuse those best practices across the team. You can embrace cloud native architectures from containers to server list, to manage services and everything in between and really scale from very simple cases to the most complex and ship faster with confidence and do an hour is what what used to take weeks to get done and we love the community. You know, I thank you to everybody here that has joined us today. Uh You know, really you are why we do what we do. Um I, this is one of my favorite tweets of all time. You know, Nino uh says, you know, something special comes along sometimes that makes you feel like you have superpowers, enables you to do more and less time. And Pulumi is that special thing. And I think that just summarizes uh you know, everything very succinctly in, in uh a nice heartwarming way. So with that, um we're we're done with the keynote. Uh So thank you again. I hope you enjoyed what you saw. Definitely check out some of the new features, everything's, you know, up on plume dot com. Um Eager to hear what you think about Pulumi deployments. We've got a ton in store for you today. Next up is a deep dive into the new features with Megan and Bryce largely focused around Pulumi deployments. So you get to see some, see some exciting scenarios that, that uh that we alluded to. We'll see infrastructure software, you know, taking some of the core infrastructures, princip code principles and using them at scale to tame complexity with Luke and Mitch. We're then gonna have a really exciting segment which I can't wait for. Um talking about some of the folks from the Pulumi community, some of our customers um Dennis at Panther is gonna talk about how they went from cloud formation to Pulumi at a very large scale and got tons of uh engineering and performance wins. As a result. Dan at Altana A I is gonna talk about creating business logic interfaces with Pulumi automation API really taking that automation api and weaving it into the fabric of everything that they're doing. Uh Jeff at Fauna is gonna talk about how the fauna product is, is built on top of Pulumi at scale and how they built out a global data platform and their own SAS product using infrastructures code. Colin at Dutchy is gonna talk about how they took Pulumi and confluent cloud and kind of married those together to, to enable Kafka at scale within their organization. We're gonna come back to main stage and see automation api under the hood with Evan and Casey see how, how the nuts and bolts of how all that works. And then I'll be back for some closing remarks at uh 11:50 a.m. pacific time. I also just wanted to remind folks that we've got some great workshops going on uh both today and tomorrow from Gloomy 101 today, building containers on Azure uh Pune service and, and uh with Ringo Tomorrow seeing how to build shared code with ploy packages and abstractions. And so these are free workshops, feel free to join in, get some hands on coding time and, and learn some of these concepts firsthand with some of the amazing leaders on the ploy team. I do want to thank our partners that, you know, help make this event today possible, a Microsoft and Google Cloud in particular um And uh from there, thank you so much and have a fun time and I'll see you back in a few hours.

---
