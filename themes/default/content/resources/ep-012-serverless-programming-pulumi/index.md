---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Ep: 012: Serverless Programming with Pulumi"
title: "Ep: 012: Serverless Programming with Pulumi"
meta_desc: |
    In this episode, Luke examines all the new features of the latest release of Pulumi to code for serverless environments.
url_slug: ep-012-serverless-programming-pulumi
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Ep: 012: Serverless Programming with Pulumi"
  description: |
    In this episode, Luke examines all the new features of the latest release of Pulumi to code for serverless environments.
  sortable_date: 2018-10-03T18:45:10Z
  youtube_url: https://www.youtube.com/embed/k8ceyQuJiVM
transcript: |
    All right. Hello everyone. Welcome to this week's episode of Pulumi TV. Uh My name is Luke Hobin, uh CTO at Pulumi and I'm really excited to be back again this week uh to talk about uh serverless with Pulumi. Uh So last week, if you joined us, we kind of talked about KTIS and a bunch of the new things we've done uh to support Cotti and make that a really great experience uh within Pulumi. Um But as we talked about, uh Pulumi, really kind of allows you to do a variety of different tasks in terms of uh managing cloud infrastructure. So, as well as doing, you know, managing your kubernetes resources, you can also manage raw cloud infrastructure and aws or Azure or GCP, you can also do serverless and containers directly against these platforms. And so today, I kind of wanted to go and do a deep dive in the serverless part and show some of the new things we've done, show some of the things that you can do using Pulumi in terms of deploying serverless applications. Now, one thing to note is, you know, that's really interesting. I think here is although a lot of developers are doing just or just service or just infrastructure. One of the things we increasingly find when we kind of go and talk to folks is that people are doing a combination of these three. So they're really combining in the same application doing plus infrastructure or infrastructure plus service. And it's these combinations where Pulumi can be really powerful and really open up new possibilities for how you think about uh developing and deploying your applications. So today, I'll really do that dive on services. But the thing, one of the key things to keep in mind for Pulumi is that you can combine all the things I'm showing today with the kind of things we've talked about around infrastructure and, and other things uh in the past. So with that, let me dive straight in and I'll kind of uh uh do a tour through, kind of getting started from nothing to kind of some working server option and show some of the building blocks of how you can inject uh serverless features into your cloud native uh applications uh with Pulumi. OK. So here I am on the uh Pulumi uh home page. Um And uh and you can see as we kind of talked about the, the areas that we focus on in terms of service infrastructure. And uh one thing I just noticed we just hit 1400 stars. So thanks everyone who's gone out there and uh and, and been uh participating in the github project. Uh Pulumi is open source. And so we've had a bunch of folks jumping in uh sending contributions, opening up uh bugs and issues in the, in the bug tracker there. Uh So really, really having fun with the, the community uh that's building up around the open source project. Um But to get started, I'm gonna go ahead and click sign in here and this takes me into the uh into the Pulumi um uh portal in this Pulumi portal, I can sort of manage my uh my Pulumi applications. And so one of the things we recently added was actually the ability to create a new project directly from inside this portal. So previously, you could go in and create a new project from the Pulumi uh cli um but we didn't have a, an entry point here to sort of walk you through that process. And so now we do and this makes it really easy to kind of get started uh with Pulumi. And so for today, I'm gonna focus on AWS and I'm going to use Typescript Pulumi, of course supports a variety of different platforms, Aws, Azure GCP S open stack. Uh We recently added uh vsphere support for, for VM Ware uh and also a variety of languages. So, Typescript javascript, Python and go uh and there's a recent community contribution to add dot net and we're continuing to add those as well. Uh Today, I'm gonna start just with this aws typescript example. Uh And I'm gonna create it in my account. Uh Just use this simple name here. Well, let me just call it serverless since that's what we're talking about. Uh And I'm going to do it in Us West too. And let's create a project. So this has gone ahead and created the project for me and just given me the command, I can type here to go ahead and create that. So first, I'm gonna create a um demo today and then I'll just paste that command in to go ahead and create that project. And this will actually bring down the source code of one of our templates and then ask me for any information I need. Since I ported that in on the website, I don't need to provide any. It'll go ahead and preview what's going to happen when I deploy this application. In this case, the template just deploys an S3 bucket. I go ahead and say yes to accept that. And we'll actually deploy that directly into AWS. OK? So there we go. We have our first uh Pulumi application uh deployed uh right there. So I'm gonna open up this folder and see kind of what we've got uh in this application. So the core of it is just this simple index dot TS file that we see here. Uh We've got a bucket uh and that bucket has uh and then we expose the bucket's domain name out here. And you see, you see that over here. When we, uh when we stood up this stack, we got this bucket name called this. OK? So we've got a very simple piece of infrastructure that's deployed. Um That's just creating a bucket that I'm going to manage with my Pulumi application. And so when we think about serverless applications, we often think about sort of the ability to have little pieces of code that we can write that are run in a serverless fashion. We don't have to deploy a heavyweight VM or container. We can just say here's some code run this on these events that might happen inside my infrastructure. And these kind of serve patterns can be tied to, you know, building full sort of API gateways and we'll show you some examples of that later, but frequently they're actually tied just to pieces of my infrastructure. And so in this example, for instance, I have this bucket uh and I might want to do something on an event. So when a new object is, is added to that bucket, I might want to do something. So one thing I'm gonna do is uh for the demos today, I'm actually going to uh use some new features of uh that we've recently added in uh that aren't yet available. And so what I'm gonna do is is use the DEV package instead of the latest package and this will pull in the um the not yet released version of this. All the demos I'm gonna show today are available uh to, to use on top of some of the released packages as well using a um some libraries like the A W services library. We're actually moving to make a lot of this more first class. And so I'm going to show that experience today uh using the very late packages. So now that I have that I'm just gonna run N PM install to update uh my dependency to that latest package. Um And since uh Pulumi is using uh just regular N PM uh packages uh to deploy these things, I am just able to say DEV and use the N PM tool chain to go and get that latest package and update it. And now my uh system is, is using uh the latest packages with the latest features and among them is the ability to say bucket dot on event or on object created or on object removed. And so these are new API S that we've added that give you the ability to hook up event handlers when uh something happens in this piece of infrastructure. And so for example, when this bucket that I created gets a new object created, um I just call this new object. Uh Now I can run uh a handler. Uh and so on for this example, I'll say, let me just write it like this. Um So what I'm gonna do here is say when an object is created uh on this bucket, I want to handle it with this event. And so let me just go ahead and write console dot log ev console dot log CTX. So one of the things you will notice here is when I hover over these because I'm using typescript here. I actually get sort of a lot of the information inside my editor. And this is one of the really nice things about using Pulumi to define my infrastructure and to define my sort of these, these serverless handlers is that I get all the sort of typing information, I get the error handling, that sort of thing from, from a real programming language. And so here, for example, I get told that this event is actually going to be a bucket event. Um So because this is an event handed on a bucket, I'm going to get back a strongly type of bucket event. And so I can actually see what that's made up of. Uh you know, we can see this is the details inside there, you know, I can get the bucket and the object that was impacted that sort of thing. But for now I'm just going to print it out. And similarly, this c is a well defined object that Lambda, a Lambda has. That is the context that the Lambda is executing within. So I'm just going to print both of those out to the console and the nice thing is here that I'm kind of combining the ability to create and manage my infrastructure, this bucket along with the ability to find some code that's going to run when things happen with my infrastructure, being able to define these in one place and version them together is a really nice capability, especially for kind of building serverless applications. So let me come over here and just say Pulumi update um Pulumi update And I'm just gonna say Pulumi dash oops on the up dash Y. I'm just gonna say this to go ahead and accept the um the update, pick that same stack that I just deployed. And this will show us first a preview of what changes this is going to make and then it'll go ahead and apply those changes because I said dash Y. And so we see a couple of things. First off, we're creating this uh bucket event subscription which has a function associated with it and some roles and permissions to assign to that function. And then second, we're, we're attaching to this bucket of bucket notification. So we're saying that we want that um bucket to be notified whenever uh that changes. So this is go ahead and deploying those uh those resources to AWS. Oh And there we go. I just finished a second ago. So it took about 22 seconds to deploy that and we, we created several different resources. So there's a couple of nice things here one, I'm using a slightly higher level pattern for doing this. I don't have to think about all the different details about how I create the bucket subscription objects and how I create the permissions for the lambda and how I create the, the A lambda object itself. Doing that, you know, raw against the ABIs Apis is possible, but it's a fair bit of boiler plate that you kind of have to do every time. And so here we're giving you a really simple way to hook those up in sort of the canonical way. If you need to hook them up and control every detail, you can of course fall through to the underlying Apis. But the result is that with just a couple of lines of code, I can sort of create the various resources I need in native us to handle this. And so now I can do something glycare S3 LS S3 colon, colon. Uh Let me just see. Um Let me actually, first, I'm gonna do one thing. I'm gonna make my default stack be this one that I um I created. So Pulumi has a notion of stack so I can have multiple instances of my application that are stood up at once. Um In this case, I'm just working with one instance of this application and it's this one that I created in uh us West two. So I'm gonna pick that one. And now I'll just say uh Aws S3 LS, let me stack output. Let's grab the name of this bucket name. So this will make sure that whatever the name of my bucket is I just insert right in here. Um Now there should be no objects. Uh uh Sorry, I'm I'm exporting the uh I'm exporting the uh the DNS name of that bucket, which is not the, the right thing to use for this. So let me just do a quick Pulumi up dash Y to um export the, the um bucket name itself. OK? So we don't have to make any actual changes or infrastructure, but we see now that the export is not this DNS name but the actual bucket name. And so now let me just try that one more time. OK? Great. So there's no objects in my bucket right now. Uh But let me uh put, put some uh object in there. So I'm gonna take the package Jason file. That's right here. And I'm gonna put that in that same uh location. OK? So this is taking that bucket that we just created using Pulumi and putting a file up into the bucket uh manually. And what they should do is actually trigger that event that we saw that on object created event. And so to see whether that's created, there's kind of a couple of ways I could do that. So the first and also to show the, the, the um more involved way first is to come over here and look at the details of my um my application inside the Pulumi console. And so the Pulumi console kind of gives me the whole history of what the deployments I've done of the outputs of the stack including uh including this bucket name here. But importantly, it then also has this resources tab where I can drill down and sort of find all the details of of these resources. And in particular, I can see this Lambda function and click on this and come over into my Aws console. And so here I can go to monitoring and I can see that this was actually hit once. So that means that this this function I created was actually triggered when I plugged that in. And if I come over to view the Cloudwatch logs, I can actually see the, the logs that I just ran. So that's one way I can do this. Um But I Pulumi actually also has built in a really handy command, Pulumi logs. I'll just do logs, dash F to follow the logs. And what this does, it shows me that same information but directly from the Pulumi cli. And so because I deployed this application with Pulumi, we know what all the different resources inside it are and we can provide an aggregated logs over all those resources. And so this shows that same thing, it shows the, the two things I console logged the event uh and the context object Um And so here, uh here's that event object, obviously, there's some inner structure that we, we didn't print out here. And here's the, the context object with all the details of my um my lamb execution context. So here we go, we've just deployed a really simple service application uh to Aws um using these really nice uh built ins like on created. Um Of course, we can go a lot further here if we want, right? So we can do things like inside here, we could go and use the Aws SDK. Um And we could use that to, to get the, the contents of that object and do something with it. Uh We can also, of course, because we're uh you know, we have full access to everything in Aws. We could do something like, you know, create a new um Aws dot Dynamo DB dot C and I won't fill in the details of this right now, but we could create a Dynamo DB table. And then inside this event handler, we could put information about that into dynamo. We could create a Aurora serverless table or instance and use that from within our serverless function here. So the ability to combine all of the infrastructure in Aws with the serverless functionality really handy way to kind of combine the best of infrastructure with the best of these serverless things. OK. So in this example, uh I did this by just writing a little event handler right in line here uh in javascript, but you may sort of have a couple of questions here. One is what if I want to control some of the characteristics of how this piece of code runs? So maybe I wanna run with more memory or I want to uh run with a particular uh I am role that is very specifically tailored to uh my organization or the needs of this application. And so what we can also do here is we can create uh the, the, the sort of uh Lambda functions in a more explicit way. So I can say something like new Aws dot uh lambda dot function. And there's actually two kinds of functions that we now support. So we support uh LAMBDA function, which is the full capabilities of the underlying um the underlying A S LAMBDA API. So the ability to wrap up any other language, zip file and upload it and use that as my function. But if I still want to use this capability to provide a little call back in line, I can use this uh callback function overriding. So let's just call this F. You see, there's a few things here. So one I can provide my callback back and so I can just take the same uh call back I had down here. And in here instead of me passing that call back directly, I can pass this F which is my callback function. The benefit of this of course is that now I can do things like say memory size 2048 right? So maybe I want this thing to be a much bigger memory size by default. If you looked at uh what we printed out over here, by default, this was using a 128 megabyte instance. So very small, not much compute and this may not work for my needs. So I can just write it like this to override the memory size and now I can pass that object in here. And so now I can do Pulumi up dash Y and we'll see that this will actually propose a set of changes to my application. And so a variety of different things. A we're going to create some of these new roles and functions. B we're going to delete some of the old ones and then we're actually going to replace the permission that gives, that gives this new lambda access to my function. Um And so Pulumi figures out all the changes that needs to make to the infrastructure in the most minimal way. Uh And it will just go ahead and, and make those changes. So you see some of these things are created, some of these things are being replaced. Uh And everything else is being updated once those changes are made, uh my application is now in this new form. And if I go ahead and uh you know, copy some of this thing in there again, I can type Pulumi log dash F and we should see now another event in my stream. It might take a second for this to show up because we got to warm up a new, uh a new Lamer. There we go. Ok. So that time we saw, um it took a second. It took a little while to run that. Actually, it says it only took 16.83 milliseconds, but it felt like it took a little above maybe that was just a cloudwatch, taking a while to get the logs. Um But we'll see that this time when we ran, it was uh 2048 megabytes. So we actually ran with that new context that we provided um within the, the callback function. OK? So this is a really nice way to just fully control the context. So I could also pass up the role that I want to use and manually create an IM role. If I want to just define the policies, I can say, you know, hey, I want the aws dot im dot um Maybe a lambda dynamo, I DB execution role um or I could define my own so I can use any existing policies that I want or create my own policies. And there's a whole bunch of other properties that are available here if I want to set up the dead letter configuration, uh If I want to set up the km key to encrypt my environment, anything I want like that I can go ahead and do uh from these, as we mentioned. Of course, I could if I want to actually use the a Lambda function and then I can provide the code and I can just, if I have an existing, you know, Python application that I want to host inside this function, I can do that by just pointing at the location of that of that folder and zipping that up and sending that up to LAMBDA. So the full capabilities of just taking existing serverless kind of apps to support Lambda and deploying them this way and hooking them up to events using functions like this is also all all available as well. One other kind of uh nice thing that we added um recently that that helps with a few different patterns. We've seen folks using uh kind of some of these service capabilities with is actually the ability to specify not just a callback but a callback uh factory. And so a callback factory is just uh effectively a function which uh looks like this. Um So I just wrap that uh that event handler that I wanted that, that just prints out uh the results of the the event in context. I just wrap that in a function which is called and then returns uh the inner handler. And the key thing is this gives me a chance to um to put some code that runs before the actual function is returned. And so this is really handy because in most of the service platforms today, when they run your functions for you, they'll actually stand up an instance of your function and keep it warm for a period of time. And then they'll invoke that function, that same instance of the function multiple times every time a new request comes along. And so as well as having access to what runs when that function gets called, you sometimes want to be able to control the code you run once per warm up. Um And so this may be code like, you know, hey printing out some context about the the instance and when that warmed up, it may also be something like, you know, connect to my sequel um uh database. And then maybe inside my hand or I want to actually, you know, make a sequel query and the cost of connecting a SQL database may be, you know, non trivially high. And so I want to do that only once per instance of my uh function that gets warmed up, not every time a new request comes in. And so for high performance kind of applications of uh servers uh infrastructure, this is super important and we now support that directly using this kind of callback factory mechanism. So I'll just uh just to show this, I'll um do the same thing. Uh Let me up, dash why go ahead and uh deploy that new function. So we change the code a little bit. Uh Now if I uh you know, copy that thing in again and look at my logs this time, you see, I actually got this uh message saying warming up. Uh And so it does a warming up once and then we will not say that we get run again. Uh Every time the function gets cold. So it looks like the function is being called right now. Uh We got run once if I come over here and copy that in again. Uh We actually see now we've got two of these, uh there's the warming up there and then there's one instance of it running and we're about to see the other instance of it running, uh get logged in just a second. Ok. There we go. So I just finished running. Ok. So there we see, we can kind of uh uh also do this pattern of kind of doing warmup tasks as well and completely control what gets run as part of the uh lambda function. OK. Uh So one of the key things here, I've talked a lot about kind of this on object created on buckets, but we really support sort of a wide variety of this sort of thing. So there's, there's many patterns that we can support here. So like Aws dot Cloud Watch, uh uh has a Cloudwatch events. So I can say on schedule for instance, and I can say you know, uh every minute and then I can pass a, a pattern. And so um I can pass a pattern like this and now I can just write a little function. Uh And again, this function, uh this function will actually get run every time, every minute. Um And so again, we see this is actually a, a, you know, a, a cloud watch uh event target, so we can get the details of, of when that was run, the time that it was executed. Um And that sort of thing. Um But this is another example where I can just hook up into my infrastructure, something like a, you know, something to kick off a task every minute or every night or anything like that. Similarly, we can do things with sort of API gateway. And so uh another really uh popular use of sort of um service is to create simple rest API S uh that we want to support um that are tied into our infrastructure in some way, maybe they give us uh access into our front end over uh some containers that are running in our or some BM that are running inside our back end systems. And so in the same program that deploys my V MS or my containers, I might want to just create a simple little API that maybe is, is exposed um only who sort of a management endpoint. And so I can do something like uh let API equals new aws dot um In this sense, we put under API gateway, this one's actually in a new sort of experimental name space because we're still kind of working on the design of this. Uh But I'll show you kind of what this looks like. Um And what I can do here is I can specify a few things, the main one being routes, so I could actually specify a swagger string. And this would just let me take uh the existing swagger specification of the A API gateway and, and automatically create an API for me that's managed. I don't have to think about all the different deployments and stages and all these different things. Um But I can make it even simpler and just do something like routes, I can specify a set of routes. So here I'm gonna say my path is, you know, on the route, my method is get and my handler is, yes, let's do it like that. Um And maybe here I'll say uh turn status code 200 body. Hello. OK. So what this will do is it'll actually uh create a handler which uh takes an event. And again, this is an API gateway uh dot X dot request. So this is the, the pattern that the API gateway will pass as a, as a, as a typed object. An API gateway expects me to pass back something with a status code and a body um indicating what the HTP response should be. So now I can create that and I can just come down here and say export and constant end points equals API dot URM. And so this should expose a new rest API uh that on the route of its API, I will, will serve. If I make it get to the root of its API, I'll get back 200 in Hello world. And so let me just come over here and do my same Pulumi up dash Y OK. So this is actually going to create several things. And this is again another example where I can write some very simple code. That kind of makes sense in terms of what I want to do and I can get back sort of the, the reasonably complicated set of a address primitives that I need to make that really happen. And so in this case, that's a few things I need to create this API gateway, rest API this deployment, this stage, I need to give the lamb the permission uh to be invoked by that API gateway. And I need to um create that default role. So we go ahead and can create all those things. It's very fast to create these resources. But there's a lot of different resources I've got to stitch together in a very particular way. And so all of that is what we've wrapped up behind this little um helper API. And we see now that we have this uh this end point here. And if I hit that, you'll see that I actually get back this hello world. Um And so we actually were able to successfully deploy that API and uh and run that code. So one other thing to note um about these kind of little callbacks is and I haven't really emphasized this here is that I can, of course, inside these um inside these API S here, I can write any code I want to use uh um functionality of my uh of my infrastructure. And so in this example, I have this bucket that I created. And what I could do here is instead of just saying hello world, I could say um I could say something like hello and then I could say bucket dot uh id dot get. And so I want to get the, the id of that bucket and embed it in here as a print. So what it's gonna do is it's gonna have my API now tell me where that bucket is. Um And so actually I'll just put it S3 co slash in front of it. And if I come over here and just deploy that, we'll see that all we're gonna need to do is update the actual function that was deployed into this infrastructure. Uh So it's very quick to update that. It only takes a couple of seconds. And now if I come over here and, and hit this end point again, we'll see Hello. And now we have my S3 bucket and this is really valuable because I've actually had the same piece of code where I'm versioning both the bucket and the API I'm defining, I have access to that as information and so I can embed in here or anything like that. I could also, you know, write new objects into that bucket as part of this API I could, when this, when an event happens on that bucket, I could trigger putting something in dynamodb or in my SQL database, I can sort of hook all these things together using these little pieces of serverless functionality. So there's quite a few more of these uh pretty much every place where AWS exposes some event handler, some capability to, to run a Lambda as a result of one of these things, we have the ability inside the AWS API S now to write these very simple callbacks that hook up to that and make it really easy to, to, to add some of this rich functionality into your cloud infrastructure. So, OK. So I've really focused in this demo so far on kind of some of the primitive building blocks we have available uh both in Pulumi uh to kind of use these callback function, that sort of thing and in AWS specifically to hook up uh some of those event handlers and those are both really important building blocks. But there's two key additional things that that are worth calling out. The first is that we kind of support the same functionality for all the cloud providers. So if you're on Azure, we also have similar functionality and we're working on adding even more of these uh these event handler hooks into Azure on GCP. We have the ability to kind of create wrappers over functions and do things like this as well. So over time, we're gonna be adding the same level of richness you see here across all those platforms. Um So that if you're using GCP, Azure, A BS or even if you're doing kind of service things on, on KTIS um that you have access to the same kind of simplicity of API in all of those places. The second thing though is for many users, they actually want to go kind of a step further and think about how to um how to build these sort of applications in more of a, more of a cross cloud way. So how do I take, you know, instead of me having to specify this is in terms of API gateway, can I specify this in terms of just, hey, I have this express application that I want to run in the cloud and I want to describe how that's going to run in a way that I could deploy to AWS or to Azure or to GCP or somewhere else. And so one of the things we've done in our, in our, in one of our packages called cloud package is really enable that kind of scenario. And so I wanted to quickly show that just as an example of how we can take some of these patterns and move them to kind of multi cloud. So to do that, I'm actually gonna use an additional package. Uh So I'm gonna say M PM install dash or save and I'm gonna say alu cloud and app glu cloud aws because I'm gonna be using the this cloud package to target Aws while I'm at it, I'm also gonna install um express and types express because I'm gonna use that in my uh in my demo. OK? So now I've got all of those I can come over here and say I'm just gonna actually delete all of this stuff. And while I'm doing that, I would say Pulumi destroy it or Pulumi solu up dash y uh to, to remove all that existing stuff from this application, ok? We'll let those all delete in the background and we'll come over here and just write a little bit of new code using this uh using this new package. So in this Pulumi cloud package, we give you access to some of the some similar building blocks, but these building blocks are not tied to any particular cloud platform. And so I can say something like new cloud dot And I get access to some higher level concepts. So, you know, cloud dot table, which is a, you know, no sequel data store that can map to something like dynamo to B on AWS, but also can map to something like Azure table storage on uh uh no on Azure and similarly a bunch of other things buckets and um H TB M points, et cetera. So the one I'm gonna highlight today is actually uh the ability to say um a new cloud that HTP server. And so when we showed the example of kind of exposing an API in the previous example that was really specific to uh API gateway and the the objects we got passed, you know, the event and context objects were the, the API gateway ones. And those are obviously going to be different on every different cloud platform. And for most users, they don't really want to think about those things. That's sort of just something they've got to do to make it work on AWS. They really want to think about just building their express application or building their node HDP server. And so one of the things we support at this uh in this cloud package now is the ability to create a little API and this API uh just has a little uh factory here, which lets me create my own uh HTP server uh using node and return that. And we're just going to serve that using whatever cloud platform technology uh we have under the hood. And in this case, I'll just say, you know, constant uh let me just get express here. OK? And now I'm gonna say constant uh app equals uh express and now I'm gonna say return apple, OK? And now we see my error squiggles went away. So uh what this uh what this expects is to, to be to have return something which uh supports the node HTP server pattern. So the uh request response uh call back and the express is one example of something which does support that. And so I can just create a new express app in here. And now I can say something like app dot get. And for those who have used express, you know, this is, this is very uh familiar kind of, I can do something like Res dot Jason, you know, hello or OK. So there we go. I just created a little uh express app and now I'm gonna say export, constant end points equals API dot Ur. OK. So this is another way to do kind of something similar we were looking at before but where I get to use the full capabilities of of node and express in this case. So let me know. Oh, so this uh previous destroy actually failed. Um And it, it failed actually in a really uh nice way. I'm, I'm very thankful that it does this um it says error deleting S3 bucket, uh the bucket tried to delete is not empty and that's because we did put some objects in there. So what I can do is come in here and say a three RM uh grab that bucket name and then it's called package Jason. So this will actually delete that thing. And now I believe if we uh Pulumi up dash why we should continue the deletion of those remaining uh resources and now stand up all of the stuff that we need. Uh But one additional thing here, it's telling me I actually need a new configuration setting. So right here it tells me that I need to set the cloud provider. Uh And so here I'm gonna set the cloud provider to AWS. And the key thing here is that this cloud package, as I mentioned is, is neutral to the different clouds and so I can use it on any different cloud. So here I need to tell it that I want to target Aws and create resources inside uh AWS. Let me go ahead and say, um Pulumi up dash Y. So we'll see it's going to create all these new resources and then it's gonna clean up the old ones uh that were there from before. Um So it's gonna go ahead and create some similar code to what we saw before. Um But now we see it's doing that uh to create this cloud HTP server, uh We'll give it a second to deploy that function, ok? And now it's cleaning up after itself. Ok. Great. Um And so now if we hit this end point, uh we should see hello world. Um So just like we expected, we're now serving that API um using uh using it a bit. So another pattern for doing this. But of course, the, the key reason we moved over to using this, well, there's 21 is that we get to kind of use the full express and we could take an existing express application, just run it right inside here. Um really flexible in terms of uh running sort of node code here. But the other reason is that this cloud package is is cloud neutral. And so we can also do something like say Pulumi stack and KN um Azure. And so I'm gonna create another stack um using the same program um in this stack uh to run this, I'm gonna have to do Pulumi install that just save at Pulumi Cloud Azure. And for this stack, I'm gonna need to, well, I'm just gonna try and run it and see what happens. Um So in this new stack, I'm gonna stand this up and I'm gonna say uh blew me up. So the first thing it says is because in this new stack, I haven't provided that configuration, I need to tell it which cloud in this stack do I want to target? Instead of me saying A W BS here, I'm just gonna say Azure. Now, if I run Pulumi up, it's gonna try and deploy all this stuff using Azure. But that means it's going to mean we need to set some additional settings. So for example, it's asking me to set the uh Azure location. And so I'll just say us West sure. If I do pull me up one more time, uh we should actually try and deploy. Oh, I'm not logged in right now. So let's log in to Azure and we'll go ahead and do Pulumi up. The key thing here is I'm taking that exact same application that I just wrote no changes to my application code and I'm deploying it just with a change of a couple of configure variables. I'm going to deploy it into Azure. And so we see here, we're creating the same cloud hphp server, but because of that configuration, we're actually going and creating resources in Azure instead of in uh I, I got us West BROM. OK? Uh It's, I'm, I'm getting my clouds con uh confused. It's West Us. OK? Uh Let's try that again. So one of the nice things you see there is even when things like that fail, like I got, you know, I got the name of that thing wrong, which is sort of a typical mistake because you're kind of developing these applications. Uh One nice thing is that it did actually succeeded in creating several of the resources um that did not depend on that. Uh And so you'll see that there's no change to those and we're just able to continue going from where we got to. And so every time this sort of one of these failures in, in Pulumi, uh we make as much progress as we can, we hit that failure and then we kind of can keep going towards the new desired state um that we want to deploy to. And so here we see, we create a bunch of these objects to support that. We create a storage container to upload the source code into and a zip blob port. And now we're actually creating that function app inside Azure to host to, to run our function that's going to handle this HDP API. And so all this is sort of beneath the hood stuff uh that you can use. But um but the key thing here is that using the same, very simple uh front end to uh to this, I can run and deploy a server application to either of these platforms. OK? So there we go. Now, we've got this thing running on Azure. It might take a second to warm up this first time. Uh But there we go. Uh we're serving it off of Azure website slash API that exact same uh API there. And of course, the, the benefit of this is that uh as well as me just serving an HP server, I can also do things like say, you know, let bucket equals new uh data or new cloud dot bucket. So I can create a bucket in a cloud neutral way I can also create a new uh table so I can get, you know, if I want to uh have some table storage, I can do that. And so, uh so this will now go and create either my uh cloud storage in Azure cloud storage or my dynamo TV table. And over time, we're going to add more things here. So we were thinking about kind of adding the ability to have a mysql store that's, that's implemented in the various different ways that managed mysql is supported on different cloud providers or adding uh you know, managed reddi in the various different ways that that's supported. So it's really easy to take advantage of these building block components of the cloud without taking a hard dependency on any one of the particular cloud platforms. OK. So that's a quick uh kind of overview of uh of some of those pieces. One of the things I want to kind of do before I finish up here is just show uh point us to a couple of other examples that build on top of this that uh you might be interested in sort of taking a look at to go a little bit uh further. So one that's uh kind of interesting here um that builds on top of what I just showed is um cloud GHTP server. Um And so in this example, we can see a slightly richer version of the same thing we just showed where we have an HP server that creates an express app. But in this case, we handle all routes and then just write some code to count how many times that route has been hit and to store that in a cloud dot table. And so this has a um and this has a backing data store associated with it. Uh and it manages the state of those routes for you. Um But again, this can be deployed to any client.

---
