---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Crosswalk for AWS 1.0: Modern Infrastructure"
title: "Crosswalk for AWS 1.0: Modern Infrastructure"
meta_desc: |
    Explore how Crosswalk for AWS with Pulumi can clean up your code in this episode of Modern Infrastructure. We explore the difference in code that t...
url_slug: crosswalk-aws-10-modern-infrastructure
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Crosswalk for AWS 1.0: Modern Infrastructure"
  description: |
    Explore how Crosswalk for AWS with Pulumi can clean up your code in this episode of Modern Infrastructure. We explore the difference in code that the awsx library can bring to a Python Pulumi program.  Learn more about the general availability of Crosswalk for AWS in https://www.pulumi.com/blog/crosswalk-for-aws-1-0/.  ✅ Get Started with Pulumi: https://pulumip.us/Get-Started ✅ Create a Pulumi account. It's free: https://pulumip.us/Sign-Up-OpenSource  00:00 Intro 02:32 Comparing Python Code 03:14 Fargate with AWS Classic 07:23 Fargate with AWSX 12:50 Conclusion
  sortable_date: 2022-12-02T22:48:05Z
  youtube_url: https://www.youtube.com/embed/gi9ZoZwzHAM
transcript: |
    Hi there folks and welcome to another modern infrastructure. I'm Laura, a developer advocate here at Pulumi. And today I want to talk to you a little bit about crosswalk for Aws, which is just now going into general availability or G A for Pulumi. So we're at 1.0 for the library. It's pretty cool. The reason for crosswalk is that if you've ever stood up any infrastructure on Aws or any other cloud provider, you'll know that there's a lot of different things you have to remember to set up, not just setting up, let's say a cluster, but you also have to set up all of the role bindings, maybe some networking, all kinds of various bits and pieces that you might not necessarily know what to do with if you're setting it up for the first time or maybe you don't know what best practices are. So you're not quite sure what pieces you might be missing. So what crosswalk does is it's a library that encapsulates some of these components and makes it easy for you just to call one library one resource and create multiple resources out of it. So it's, it's a way to get basically the opinionated version of your Aws infrastructure so that you can actually run any of your standard systems or your standard architectures that you're interested in running today. I want to give you a sense of what the code difference looks like because there's a lot of different things that go on here. Now, we recently have released some templates for all kinds of different architectures, some very common ones. And in this case, we're going to take a look at the comp the container template uh for Aws, which will be doing Fargate on ecs. So we're gonna be setting that up with Python and I'm gonna show you what it looks like with the classic version. And then we're gonna go take a look and see what the template shows us with the Aws X version or the crosswalk version, we shortened it to Aws X. So crosswalk for Aws, that's where it comes from. So if you're wondering what that Aws X is that is crosswalk for Aws with Pulumi. So we're gonna take a look at setting up Fargate with Python and then we're gonna look at setting up Fargate with Python with Aws X. So let's head over to the ID E and take a look at what the differences are. All right. And here we are in the ID E. So in this case, we have on the left, the Aws classic version of our Python code that is going to set up a very basic Fargate system on Aws and then on the right, we have our crosswalk version. Now, the crosswalk version is Aws X for crosswalk for Aws. Um And I'm just using one of the three libraries that are released to general availability today. So Aws X is the one that I'm using. There's a couple of others that you can find in the blog post that I'll be posting in the description. So let's go through the classic one. First, that's the one here on the left. So first things first, we have our standard imports and then we have our configuration values. These configuration values are the ones you get when you run Pulumi config set. So that's those values there. And then I have an ECs cluster that I'm creating here on line 19, the ECs cluster is what you need to be able to run all of your container services. Next up on lines 21 and 22 and 23. Actually, we have our default virtual private clouds. So this is the default information for all of your networking that you're going to get. So we have our virtual private cloud, just get the default one and then grab our subnets within that virtual private cloud or that VPC to be able to run all of our systems. For Fargate. Next up, we have to create a security group that allows you to actually bring in data into our containers and then have some egress or external output from those containers. So this is all the kinds of stuff you need to be able to run all of the systems with the security group. So, and on this VPC to be able to run all of your Fargate containers, so there's a lot of different little bits and pieces here that you need. And then as we get down here, let's go all the way down here. We are with line starting on line 45 we have our application load balancer. This is the load balancer that we're going to need. You'll notice that it actually brings in the security group and the subnets along with the load balancer though, we have to have a target group which is saying, how are we connecting to our container? Our listener that says what traffic is coming in to this load balancer that we're willing to accept and how, how do we send that out to the container itself? So we need all of these bits and pieces to be able to run our application load balancer. Continuing onward as we continue down here and I'm gonna come right all the way back up here to line 70. Line 70 is where we start to get into our access controls. Saying what roles do we need for this task, this Fargate task to be able to execute and what roles do we need to attach to it. We'll see there is on line 88 down here, the actual policy that we're running, which is the task execution policy for ecs. So we have to set up that role so that the bot user that's running the tasks for us is going to actually be able to do all of the things it's supposed to do. Then finally, on line 92 we start talking about the task definition for Fargate, which is our actual container that we're running and all of the various bits and pieces we have there. You'll notice on lines 101 and 102. This is where we really get into just having a very basic engine X system running. I'm not really doing anything special with it. I'm not rolling my own image or anything like that in this older code that I have. So we have some just information about the application that we're running. And then last, but not least on line of 1 11, we have our service. This is the Fargate service that's running and actually running the task. So we can see we have the cluster that we need our network configuration that gives us all of the information around the subnets and the security group. And then the load bouncer. This is where the load bouncer connects in to be able to run our application and connect it out to the internet. And then finally down here on line 30 this is where we get into all the exports so that we can just click it in our terminal and be able to get there to get the information we want and go see our little basic engine X page. So this is the classic version. Let's go all the way up here. Now, let's compare it to the crosswalk version, which is over here on the right. So our crosswalk version and you could ignore the the definition there on line four, the crosswalk version is going to be a lot shorter and we're going to see why it looks pretty much the same to start a couple of different import statements here. And then the basic configuration values are the same. The creation of the cluster is the same. And then here on line 29 only because there's just a lot of comments in the way online 29 is the creation of our load balancer note that it's only one single line and one single call to a resource. So this is the application load balancer resource in the load balancer section of the AWS X library. When you call this resource, this is a custom resource that actually generates other resources. So in this case, it's gonna make that call to create a best practice security group, a best practice target group, a best practice listener and the best practice application load balancer. So it takes some sensible defaults, puts them in and sets it all up for you without you having to add all the stuff and remember all the various pieces that you need to run an application load balancer. It's also gonna call that default virtual private clouds, that default VPC and set up those virtual subnets to just use all of that stuff all together with one line of code. So the comments are in here mostly just to let you see all the things that it adds in. So if we were looking through the equivalent over here on the classic side, that's all of lines 22 all the way down here through line 67. So that's everything that you need to actually run your application load balancer. Pretty cool. Then we continue on. Now if you were looking at this, this code on the right actually comes from that container template from AWS that I was talking about earlier. So when we run the Pulumi new template for containers on Aws with Python, this is actually what we get. So I commented out a couple of lines, I added some comments obviously. And in this case, since I'm using the default and Genex container, I don't need a repo or an image because I'm not using them. I'm not really doing anything that is doing that. But if you were going to take this template and then build an application inside of it, so you're gonna have a Docker file or whatever else you want to run and have that image get built and then pushed up to a repo on Aws. This code you'd want to uncommon and actually use. So if you're using the template straight up, don't comment this code out, you will need it. But in this case, because I want to show parody between two different code, two different code bases, you can just see the difference right here. Now we are going to then add in starting here online 50 our actual fargate service. So this Fargate service call on the AWS X library, it actually creates the task definition, which also creates the role and the role policy bindings that we have as well as the service. So it's taking up everything we needed from lines 70 over here on the left all the way through. Let's see, we're gonna continue all the way down line 70 through 1 28. So that's all of it instead of it being in 70 to 1 28 that's what 40 lines you end up with just about 10, maybe 15 lines over here on the right with uh starting here at line 50 through 66. So that's the Fargate service. Everything's already there. Line 54 is where we actually create that task definition to be able to run everything. And if you are running this directly from that template again, note I left a little note here on line 56 that I did change it so that I can just run engine X and then last but not least is this export right here? You can ignore the return that's actually from uh because I actually have this wrapped up in a function. The export is the same as the one that's on line 1 30. Except we're just exporting the URL from the load balancer instead from the load balancer class instead of the A lb class that we have online 1 30 on the left. So really, you'll know that if, if I were to take all these comments out, it's a lot smaller and you're using best practices and you have less to do. And if you actually were to run these two side by side, what you'll notice is that they're creating the same resources. The graph may be a little bit different because we're using custom components. But otherwise it's all there. There's nothing really extra you need to do to stand up your first Fargate system on Aws. So you don't have to go through and figure out how all of this works. Instead, you just use the library and it's all set and ready to go for you so that you can get started and get moving a lot faster. Let's head back. This is actually the really nice thing about crosswalk. You can just get started and it's done and you can just build what you need to build and keep on moving. There's a lot more to crosswalk than just the little bit that I showed you today. There's a bunch of templates that now use it. There's a bunch of information in the blog post which I'll link down in the description that announced the 1.0 release or the general availability release of crosswalk itself. Now, the thing to know is that this is available to anyone using Pulumi, whether you're paying for it or not. So if you're running this on your local system, if you're running an open source version, if you're just toying around with it and you want to see how Pulumi works and try out crosswalk for Aws for yourself. You certainly can. It doesn't really matter where you're doing it from as long as you're using Pulumi to do it. So just something to go check out when you get a moment to go explore the new crosswalk version, our general availability of it, crosswalk for Aws with Pulumi and that's it for modern infrastructure for this week. Y'all take care if you enjoyed this video, please do like, subscribe and you know, let me know in the comments what you thought and on that note, y'all take care. Have a good day. Bye. If you have a topic, you would love to have us cover here on Pulumi TV. All you have to do is go to github dot com slash Pulumi slash Pulumi TV. Thanks so much.

---
