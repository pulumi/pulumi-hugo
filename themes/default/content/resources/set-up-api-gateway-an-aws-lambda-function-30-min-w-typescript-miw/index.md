---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Set Up an API Gateway for an AWS Lambda function in 30 min w/ TypeScript | MIW"
title: "Set Up an API Gateway for an AWS Lambda function in 30..."
meta_desc: |
    For our Inaugural Episode, we’ll show you how to set up an API Gateway for an AWS Lambda function in 30 minutes using Pulumi with TypeScript. You’l...
url_slug: set-up-api-gateway-an-aws-lambda-function-30-min-w-typescript-miw
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Set Up an API Gateway for an AWS Lambda function in 30 min w/ TypeScript | MIW"
  description: |
    For our Inaugural Episode, we’ll show you how to set up an API Gateway for an AWS Lambda function in 30 minutes using Pulumi with TypeScript. You’ll learn how to wire this up to a domain name and secure it using an API key for authorization. Finally, we’ll show you how to store the API key in a secrets manager.  Code for this episode is available at: https://github.com/pulumi/pulumitv/tree/master/modern-infrastructure-wednesday/2020-03-18/echo  The examples are in TypeScript but Pulumi makes it easy to stand up infrastructure in your favorite languages including Python, JavaScript, Go, and .NET - saving time over legacy tools like CloudFormation and Terraform.  Get started for free: https://pulumip.us/Get-Started
  sortable_date: 2020-03-18T16:04:25Z
  youtube_url: https://www.youtube.com/embed/yYWqcgs6FlA
transcript: |
    Hello and welcome to a new episode of Modern Infrastructure as Code Wednesday. I'm your host, Lee Zen from Pulumi. Today we're gonna be building an API gateway and adding some snazzy things to it like authentication. Uh We'll also talk about having multiple providers and, and hooking up API gateway to a domain. Uh And then we'll also talk through some Pulumi programming model stuff. So that's what's in store for today's episode. Let's get started. Uh We'll start with a super simple example. Uh And for those of you unfamiliar with Pulumi Pulumi is a way to actually define infrastructure as code in real programming languages. So you can see here we're just using typescript. Uh and we can, uh start start this project up very easily on the Pulumi Pulumi command line. If you haven't downloaded Pulumi before, you just go to Pulumi dot com, you get the, get the, uh, the cli and then you can uh start a new Pulumi project with Pulumi new on the command line. So you can do you know Pulumi New. Uh Obviously I'm already in a Pulumi project, so I don't have to do that. Uh But, uh yeah, So let's get started here. We'll have uh some imports. This is pretty standard. We have the Pulumi uh import, which lets us use some of the runtime stuff. Uh You can see here, we actually just get the name of the project through, uh the Pulumi SDK. Uh We also use A BS X and AWS uh in our project. Uh These are libraries for uh using AWS via Pulumi. Uh Aws X offers a lot of various convenience uh functionality. And then uh yeah, so let's build the A P gateway. You can see it's actually all of 31 lines of code super easy. Uh We'll first start by defining a route and our A P A gateway today, we're gonna do a really simple example. We're gonna have uh an API that just basically returns back whatever we pass to it. Uh So here in this example, we start with a path of echo. So this basically means we're going to respond on this path and we'll accept this method uh post and uh we'll get rid of that. We don't shoot an er examples, 30 lines long. Um And we can actually what's cool about some of the ways uh this works is you can actually just in line uh the code directly. So here you can see we're in line the Lambda function uh that we wanna use for our API. Uh It's a very simple uh piece of code. It's basically just getting the event checking if it's uh basic C four encoded and if it is, we'll convert it to, to string. Uh And then we'll just return it right back. And um here we create the actual API using that route. Uh This is also left over from a previous example. Uh And then uh we basically give that uh give this route to the API uh And then we export the URL. So let's actually run this. So we can run Pulumi up. And this will uh you can see uh the name of my stack is simple uh Because we're doing a very simple thing today. And uh oops, I forgot to configure the Aws region. So let's do that. Let's do that. So we'll do Pulumi config Aws region us west two. Of course, I didn't type set. All right. So now we can actually run blu me up and you can see it's gonna ask us, hey, do you want to create all this stuff? And you can see what's really cool. Alix went ahead, created the LAMBDA function. It's gonna create the lada function, the role, the role attachment, you know, and wire everything together for us. Uh Without us having to really lift a finger here, we just, we just really, most of the code is the Lambda function. Um And then some setup and very, very little actually. So you can see now uh we're making calls to Aws. I had previously already set up my environment with uh the AWS CLI credentials. So it's going ahead and using those and in just a few seconds, we should have our API and so we can actually call uh this particular URL that uh that got spat out and we should be able to see this actually work. So let's try it. So we'll use our handy friend curl. Uh We'll give it uh this particular URL and we'll feed it some data like a little world of course. And oops, I forgot the path which was echo and hello world. All right, great. So it works. So you can see we were able to quickly write some code and actually get that deployed in like a couple of minutes. So super easy to get an API gateway up and running. Uh Let's make this more interesting. So you can see, I, you probably saw I had some other tabs open here. Let's let's add in uh some providers and you'll see why in a second we're gonna do this, but I'm just gonna, I'm just gonna copy and paste this in uh to the top of our program real quick and I'll talk through it and then uh add in some additional code for this. So, uh the first thing you can see is um we, I have this variable that's not defined here and that, that's because it was coming from configurations. So let's bring that in and we can do that with uh Pulumi config and we can read this value uh by getting this value from config. And the, you can totally imagine why you would do this. So in, in, in the earlier case, what I was doing from an authentication perspective is uh Pulumi was using uh the AWS API SDK and the SDK underneath is really just checking to see if I have uh a local credentials file in my home directory. And you can imagine maybe I uh you know, don't want to use that particular credential. I want to use a specific role and we can actually pass that role on. And in assuming we have it configured uh such that the provider uses that role. And so, uh if we wanted to use this particular provider, all we'd have to do is then say, uh down here, when we create the resource, we can just say uh provider is AWS provider. And now that would use uh whatever role we've assumed. Uh from here, we also uh actually create a provider uh for us East one specifically. And that's gonna lead into the next part of our example where um we actually want to wire up our, our API to DNS. So let's copy and paste all the other stuff and we'll put that here. And so you can see, I have a couple of the configurations, domain name and host and zone that I have in defiance. So let's uh bring those into and here, we'll use choir. So we're basically saying, hey, you have to have that and we'll go to our command line and actually configure those, these are just some existing resources I already happened to have. All right. So what do we do now? So we have this Aws East provider and the reason we have that is because we're actually gonna DNS lives in Route 53 which lives in us East one. And so we want to spec and same thing with AC M, we want to use the certificate managed in US East one because for a public facing thing that's gonna be connected eventually to cloudfront. Uh You have to have a certificate that lives in us East one. And so we specifically create this certificate uh in Us East one and then we give it the name of the domain name we want to use and we tell it that we want to validate that fact that we own this domain name using DNS. Uh Then we're gonna get the zone that we're gonna create this name in and then we're gonna create a validation record. And so here we actually need the outputs of the certificate that we created earlier. And so you can see we have these certificate, domain validation options and we gonna, we wanna, we wanna pick a specific option off that here we use, apply and we'll, we'll come back to how apply works um later. Uh but suffice to say, basically we grab the, the record name type and value and uh stick that into 53. And then we have the certificate validation, which is a special resource, which actually doesn't really exist in W in AWS. But we're using it here to effectively uh wait on the validation of that, of that domain name so that the certificate is valid. And then we, you can see here, we actually then wire up that domain name to A P A gateway uh with the certificate and the domain name. And we depend on having this validation complete. So that's what this depends on clause does. And you can see here we, we use this provider. So here this is in the region that we're creating the, the API gateway in and then we, we map uh that domain uh to the API and then finally, we create a record uh that points uh route 53 to that specific uh API through cloudfront. And then finally, we use uh this little interpolate uh helper to uh spit out the, the actual URL. So let's let's run this and this will take a little bit of time uh because uh what's gonna happen is it's going to uh actually have to create that, that particular um certificate. And uh you can see actually I had run this earlier. So it's, it's gonna uh replace some stuff here because you can see. Er so this is actually interesting. So earlier, right, we ran this, right? And so we created this these particular resources using uh the default provider. And now because we're actually, we're actually giving it a a we're actually passing in an explicit provider. Um You know, we can't predict ahead of time what's gonna happen necessarily could maybe the providers in a different region or something else. So you can see these replaces show up in addition to the creates. So, you know, we know it's gonna be ok. So let's run this. Uh while this runs, I think this is probably a really good time to uh talk about outputs because uh while this runs, we're actually gonna have to wait for uh the certificate and a bunch of other stuff to, to show up. So let's close that for a second. So what, what, what are outputs? So as I mentioned earlier, uh when we create the cert this certificate, you know, we don't necessarily know uh within, within the Pulumi program yet, um what the values underlying it are. So, for example, like domain validation options, you know, we don't know what AC M is gonna turn back in terms of the resource record value or anything else. Uh And so basically outputs represent promises about, you know, uh of, of what, what's going to be returned. And so we don't know what's gonna be returned. But once we know what's returned, uh we can basically have this, you know, you can, you can imagine the, this is almost like a promise uh in terms of output and then apply it almost like then from a typescript perspective and we say, hey, for that value, uh we, we then want to, you know, take the, the, the zero with the, the, the, the first element of that particular thing and grab the resource record value off of it. So one way to think about outputs in Pulumi is that they're basically promises uh inputs uh to arguments uh to resources are, are basically can take a promise or taken away. Um or, or straight up value. And in our case, uh we're giving it this output uh value that is, that is transformed uh by, by, by this particular uh apply. So, you know, you wouldn't be able to, for example, uh do uh records, you know, certificate, domain validation options zero here. Uh Because domain validation options, as you can see is an output of those things. And so it's, we have to actually uh operate within that promise. And I'll show you some other examples of this later on if that's a little confusing. Um I think it takes a little bit of getting used to it first. Uh But once you kind of start understanding how you know these things are, there's a dependency graph and we don't necessarily know uh what the values and outputs are gonna be at run time or rather at compile time. Um Then, then it, it kind of starts to make sense. So let's see how we're doing here. Uh OK, we're almost done. You can see um we created the certificate, uh we validated that we actually own the name. And then finally, we map the name to uh the domain name. And then uh finally route 53 is going to uh have that name point at uh point out that uh API gateway. So as soon as this is done, we will uh try it out. So what are we gonna do next after this? So after this, uh you can see actually very quickly, we've first, we've, you know, the original set of code was really just this block right here, right? We, we created the API gateway. Then we created the certificate, we found the Hoen zone, we wanted to create the domain names in, we created some names to validate that we own this name. And then we mapped that name to API gateway and then we pointed Route 53 at uh API gateway. And so, you know, what could be fun is let's make it so that other people can't use our API unless they have an API key. So that's what we're gonna do next. Uh Before we do that, let's make sure this worked. So you can see we have this URL API test here. So let's copy this and we will run curl again that oops, I need the path. Let's not forget that this time and we'll give it. Uh, hello, World again. Oops, sometimes, uh, this happens where, um, let's do this. Sometimes there's a weird local DNS cashing issue where if you get an NX then, uh, it gets cashed for a long time. So let's try this. No, still. No. Ok. I think sometimes we have to wait for, um, DNS to propagate. So let's come back to this and do this one more time just in case. Um while we wait for deus to probably get, let's start wiring in the uh the key stuff. And then we'll, we'll come back, make sure that works. Uh Make sure and then, and then add the key in to make sure that we can't actually talk to the API without the key. So how do we add the key? Um What we do is we first uh come here and we say uh API keys source. And so there's two key sources for API gateway. One is either an authorizer or a header. The authorizer basically requires you to have something check if the request is OK. We're gonna use the header because that's simpler. Uh And so basically what the header option says is uh when we require an API key, we expect the, this particular X API key header and it has to match the value that we set on the API and we'll, we'll do that in a second. So uh we also tell API gateway that we want this route to be uh uh required to have an API key. So we'll add true here. And then now all we have to do is wire in the API key. So let's make that. And you can see we can, we have all this nice type completion. So let's do A P OS API. Hope not. I don't want you to do this. Excellent A gateway. Yep. There we go API key. and we can actually use the same name. The names are, you know, as long as they're unique uh by resource type, it doesn't actually matter uh if it's the same as another resource. And um we can actually do the autocomplete to see what options we have. Uh You can actually give it a value if you want to pre specify the API key value. We're not gonna do that. You can see that A W BS actually creates it. We don't need to provide any of these arguments. And so we're gonna give it nothing and it's gonna give us an API key and we have to connect this API key to the site. So let's do that. So that requires actually API K which requires a usage plan uh to do that. So we'll create the usage plan and this, we actually have to wire in some options. So you can see we wanna basically connect uh the usage plan to a particular API, set of stage or set of stages in in this case, we really just have one stage. Um So there's an API V. So we got that from earlier and we have a stage, which is just the name of the stage. So that's just, that's the site uh stage, stage name. All right. So that's pretty simple. And then finally, we have to add the key to this plan. So usage plan key. And so here you can see we give it the key. Uh And that was earlier, we had uh API key, right? And it's gonna want the key type. And you can see if we, you can see there's only one type API key. And then finally, uh we're gonna give it the usage plan we created earlier. So usage plan ID is the usage plan. I think that's simple as that. All right. So after, if we run this, then we'll basically have an API that requires an API key. Um And uh we probably need to know what the API key is if you want to do anything. So we can do uh this, the, it's called OK. So let's try uh our curl command again from earlier. All right. So the NS finally propagated and we can see hello world. All right. So now let's let's add our API key and see what happens. So um just to refresh, the only thing we changed since we last deployed uh via Pulumi up was we basically added uh this, this particular API key required along with this particular um this particular, this particular indicator that we're gonna get it from the header and then we create a usage plan and then associated a API key uh with that usage plan. So let's go back down here. We can see that's what's gonna happen. We're gonna replace the deployment uh and then update uh the stage and then also attach this, this usage plan with this key. So let's, let's do that. Yes. So you can see nothing else changed. Um You know, you don't, you can see we don't, we don't change route 53 nothing else gets touched here. Uh Because we know that, you know, those resources don't need to change uh to perform the things that we, we just did. All right. That was very fast. So we're done. Now, you can see we have this key that we got output. It's probably not good security practices to do that normally. But uh for the purpose of the example, we're just gonna do that. Um So now let's try. Oh, no forbidden. All right. So, so that's, that's what we expected, right? So let's give it the header. Uh And the header was uh X API key and we can copy and paste this key. Let's see if this works. Oh What do you know? So with the API key, you know, we can go ahead and actually get access to this um this particular uh API gay weekend So that's pretty cool. So what if we don't want this API key, you know, just shoved out here like this. Well, what can we do? Um There's a number of options. One is obviously you can always refer to within the Pulumi program this value. Uh But let's say like we wanna, you know, stick it somewhere for other people to use for whatever reason and, you know, we wanna, we don't wanna do this. That, that's a bad idea, right? Um So let's stick it into the secret store. So how do we do that? Uh Let's go down here, let's do this down here. So, well, we can just stick it into uh let's say we don't wanna stick that secret along with some other stuff into our secret source. Let's let's set that up. So how do we do that? We have, we have a, we have a secret um And uh there's a secret manager service in Aws. So we'll create a secret, give it a name, we'll just call it, we'll just use our default for now and we have to give it some arguments and you can see um we can actually skip pretty much all these for now, let's, let's just give it, this is how we actually define the metadata for the secret. So we don't need anything in particular and then there's the actual value uh that we're gonna give it and so we can create a secret version is what it's called. And now we do need to give it some values. So first we're gonna, you know, say, hey, this is this particular secret and then we're gonna give it a secret string and here, you know, we could just give it api key value, but let's do something a little fancier here. Um We're going to actually uh give it adjacent uh uh string and so we could, you know, you can see this actually takes a string, right? So can we have, you know what, what we would like to do is do something like this. Um And let's say we also want to give it not just the API key, but we also want to give it um uh the, the name of the domain that it's associated with. So, so let's say we wanted to do that way. So in an ideal world, we, we would want to do this. Um But this is not gonna work, let's see what happens. So we're gonna run blu me up and it's gonna give us an error. And the reason it's gonna give us an error is because we're trying to uh use Jason stringify on um we're trying to use Jason stringify on these particular values which are outputs. And I'm, I'm gonna guess uh well, actually it works, but that's for the, for the wrong reason. So here this is an output. So it's not gonna give us the right, the right thing. So what we really want to do is actually uh we actually want to do this. And so what we're gonna return here is we're gonna return uh Jason and the name. So now this will actually do the right thing in terms of uh stringify uh this particular API key now that it's an output. And so what place that secret version and Voila? All right. So let's talk through guys, what, what we kind of did here. Um And, and I'll briefly talk about this again. So, so why do we do this um with, when we tried to Jason stringify the other way around. Uh What we ended up doing is we ended up stringify the actual output um which at the, you know, at the time is potentially not known. Um And what we really want to do is is stringify the actual string value. So you can see here it's actually a string um as opposed to earlier, it was gonna stringify this like output uh object, which would not have been the right thing to do. Um And so here, you know, V is a string in, in the previous, in the previous example. Uh before we did this this way, uh it would have been an output of string uh which is not what we wanted to have stringify. So here, this is the right, the right approach. Um And uh uh now this is actually stored in our secrets manager and we can actually go and access this particular, this particular value. So let's do that. So we can actually uh get these values too. We can say, um, to actually get an existing stupid version. And uh this is not how you would normally do it because, um, you wouldn't have the previous stuff. You would, you would just use this to get our, a specific resource. Um But let's do this, let's, let's get some eggs and you can see here it's expecting a string. So we're gonna, we're gonna actually do this. Um So we're gonna basically Pulumi all says, hey, wait for these to be available and then now we're gonna apply them to again, can I think of these as promises? Um And, and you know, normally you wouldn't have to do this because you, you know, earlier, we already, we already have all these values um as outputs but, but just for the purpose of demonstration, just kind of want to show you how this might work. There we go. And so we're going to uh missing a friends. And so you can see here, we want Secret ID to be and this is now S ad and this is on a PV ID. And interestingly enough return here is going to be a promise so we can just, you know, do a quick side effect here for, for show. OK. So let's run this and see what happens. And so there should be no changes to our program here. We didn't change, you know, there's no underlying changes to any of the resources that we made. Oops. Uh oh I think I forgot to give it the, the version ID is not the right thing here. This is the, I gave it the value ID, but I need to give it the version ID. So you can see actually we, we have this output here now. So we got, we got back our, our object. Um So we'll say no, we don't perform, there's no update to perform it. All we've had is a message and to show you kind of the other, the, the way we had it the other way around, we go back to the other way. Uh So this was the uh uh api key value. Let's see what happens when we do this. So now we will, we will have an update here because we're causing the, the program to change the secret string value. So you, we, we, we compute that this has changed and we'll say yes. And then you can see we actually get this very interesting output here called, you know, and this is not, you know, this is, as I said earlier, this is not what you want. Um in terms of, in terms of, you know, we really wanted the app apply, right? Um So we can go back to the way we had it. So you can see here, we actually have this apply on the value to create this, this Jason object that we actually want to stringify. Cool. So just to run through again, what we ended up doing today, we, we started with a very simple API. Uh We then took that API and uh wire that up to uh a domain name. Uh We use some, some uh we use a different provider. We use a separate provider to talk to us East one. And then using that provider, we able to create a certificate valid that we owned the domain name and then connected that to our, our API gateway. Uh we were able to, you know, curl that and, and get back our echo response. And then we said, hey, let's add, let's add some secrets to it. So we basically added this, this, this header uh secret um and then uh plumbed that through into the API with just a few lines of code. And then finally for just for fun, uh we decided to store that secret that, that API key in the secret store. And then we talked about kind of how to make sure that we're using uh a ply uh in the right way to get to get what we wanted. Cool. Well, I hope that was uh informative for you. Uh Thanks for watching Modern Infrastructure as Code Wednesday and we will see you next week.

---
