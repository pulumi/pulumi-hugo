---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Ep 003: Multi Cloud with Pulumi"
title: "Ep 003: Multi Cloud with Pulumi"
meta_desc: |
    This week Luke covers serverless programming across clouds: AWS, Azure, GCP, and talks Kubernetes.
url_slug: ep-003-multi-cloud-pulumi
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Ep 003: Multi Cloud with Pulumi"
  description: |
    This week Luke covers serverless programming across clouds: AWS, Azure, GCP, and talks Kubernetes.  -- Join us on Slack: http://slack.pulumi.io/ -- Try Pulumi, find docs, examples etc at: https://pulumi.io/ -- Get the code at Github: https://github.com/pulumi
  sortable_date: 2018-06-20T19:12:13Z
  youtube_url: https://www.youtube.com/embed/Mt7Sr4_5TBk
transcript: |
    Mhm. All right. We're just about to ready to get started. Uh, let's just make sure everything's working and we'll, uh, we'll kick off in just a minute. All right, I'm just about ready to get started. Uh, just make sure everything's working. Mhm. All right. Great. Uh, well, I'll just, I'll just go ahead and, and kick things off and kind of, um, uh, get started. So, um, yeah, so for those who haven't joined us, uh, before on, uh, kind of our Pulumi TV, uh, series, um, my name is Lou Coin, uh, CTO at Pulumi. Uh, and we just, um, we just launched, uh, Pulumi publicly, uh, earlier this week. So we're all, uh, pretty excited about that. Um, so definitely hope that, uh, a few folks, uh, here are joining us for the first time, uh, and, and eager to kind of get a little peek at some of the things we're doing with, with Pulumi. Um, so, uh, yeah, so we, uh, we have been in a kind of a private beta for, for several months now. Um, but with the launch earlier this week, um, I think we've opened that up, uh, to, to a lot more folks and really excited to see the, the kind of reception we got uh over the last, you know, 48 hours or so. Um Lots of folks coming in and, and trying things out, lots of folks um building things on top of Pulumi, um and lots of folks interested in how they can kind of extend Pulumi into some interesting uh new spaces. So, um but as you aren't already uh uh in our Slack channel, um uh I definitely encourage you to, to jump in there, um If you have any questions or just want to kind of hear about what other folks are doing uh in and around. Uh Pulumi. Um uh we'll add a link there uh in the, in the notes afterwards. Um uh but uh but otherwise, um today I'm just gonna spend maybe 30 minutes or so. Uh and uh do a couple of things first, I'll just kind of do a little quick because you were a 60 with Pulumi just for folks who haven't kind of seen uh Pulumi before. Um And then I'll spend the rest of the time kind of talking about like multi cloud uh with Pulumi and what that means for us in some of the different uh ways that uh Pulumi can sort of be used um uh to target a variety of different cloud platforms and to uh to take advantage of some of the unique features of Pulumi to uh to target uh sort of build abstractions which can be used uh in a multi cloud kind of way. Um This is something that I think is, is sort of uh uh a bit unique uh to, to kind of the way we think about Pulumi. And so it's an interesting topic uh to dive into a bit more deeply. So, uh yes, let me get started by just doing a quick uh kind of introduction and, and 0 to 60. Um So, uh I'm here on the Pulumi dot IO uh site. Um This is a great place to get started as all of our documentation tutorials, that sort of thing uh to get you information about Pulumi, uh you can come in here, just grab uh the cli and, and download it. Um If you want to go and install that manual instead of using this curl script, there's some install instructions uh right here as well. And then once you've done that, uh you can come in, uh you know, say Pulumi, um you have the cli installed and this is sort of the the main interface for uh actually kind of running and deploying and managing uh Pulumi applications. And so I'm in here and I'll just create a new application and I'll set a, you know, uh Pulumi TV demo and then I can pick one of my templates to get started with. Um And so here, I'm just gonna take this, hello, aws javascript it is kind of a very little but end to end working example and I'll just go and create that template and pick a name. I'll leave the description empty. Um Pulumi as a concept of stacks which are sort of individual um uh instances of my application that I've got running in the cloud somewhere. And so I'll take this stack name to create a new stack and then I'll just say I want to deploy this into us West too. Uh Because I'm out here uh in Seattle and uh and then we'll go ahead and uh install all the dependencies. I need uh to run this program. Uh And ultimately, I can just come in here and open that code. Uh oh Actually, I'm in the wrong folder. Let me just go into, where did I create that Pulumi TV demo? OK. So let me just open this up here. OK. So when we created that template, um it created this application for me and this application is really just uh you know, five or six lines of code. Um But this five or six lines of code creates a little application that's gonna run in this case in uh in a US. Uh And so this uh kind of highlights a few of the, the really core uh things of about Pulumi right off the bat. Uh The first is we're of course using in this case javascript. Um But that is we're using uh general purpose program language. Um we could be using typescript or Python or go or a variety of other things that we've got kind of in the works now. Um But the core thing is I get to, I get to interact with the cloud platform directly from uh general purpose programing language. And so for application developers, you're used to working in javascript or Python. Uh this is a, a really familiar interface that gives them all the tools that they expect uh kind of from those sorts of languages. Uh The second is that I can use uh packages. Uh So in this case, because I'm using javascript, I can use packages from N PM. Uh And we have some packages that we've provided uh that give uh folks access to a variety of the cloud uh capabilities of the cloud platform. And in this case, I can use, you know, app Pulumi slash cloud dash AWS to, to get access to uh a bunch of handy features to, to work with uh uh aws. The next thing is that um you know, there's sort of two things I can do. One I could actually come in here and, and work with directly with uh Pulumi Aws, which gives me the raw capabilities of the AWS platform. Uh And so I could use that to, to create every single uh uh resource that's available inside Aws. But instead of using this Pulumi cloud Aws, which is sort of a a package of some higher level concepts uh for working with uh AWS and deploying higher level uh ID uh things. And these are sort of the the standard ability to sort of take some common patterns and make them available as new kinds of components that the folks can work with. And this makes it much easier to use these capabilities of the cloud platform than it might be if you were going and doing it all from scratch every time. And so in this particular example, I'm using this cloud dot API, which is just the ability to expose a an HTP API to the internet. Um And this ultimately for folks who we're familiar with sort of all the AWS features in this space, this is ultimately going to use API gateway and, and S3 and LAMBDA and a variety of features of, of aws uh to, to power this. But as a developer, I don't need to know all of those different details and how to stitch all them together. I don't need to copy, paste all that code. I can just use this component uh to do that. And this program just creates that API and then does a few things that hosts a static route on the route and points at this www folder which has, you know, my my static content and this could be my, you know, react app or it could be any piece of static content that I want to host and then it hosts a route here which has some code. And so in this case, it's just gonna be some code which returns the string aws when it's invoked. And so this is just our rest handler. Um uh very simple piece of code that I just want to run in line here. So to get a sense for, for kind of how this works, I can come over here and I can say uh Pulumi update now and this will go and try and deploy that application that we uh we just templated uh up into AWS. And so first off, uh we'll see that it does a preview uh I, when I do an update and this tells me what is going to happen when I deploy this application. And you'll see that even though it was a simple application, it's a few lines of code. And even though it only created this one sort of top level resource H to P API, it actually created a lot of other granular resources underneath the hood. And these are all the things you sort of would expect to need inside Aws to build this kind of application. You need an API gateway rest API, you need an A BS slam to function, you need an A S S3 bucket, you need some bucket objects for each of those files that you want to upload, et cetera. So sort of the things you might expect. But uh you can kind of see here how much work you'd have to go through to have done this uh directly. So I can say, yes, uh go ahead and deploy this and this will uh just go ahead and deploy all of those different uh things into Aws. And so right now, we're actually calling AWS uh for each one of these, um uh and uh registering each of these resources in the, um in the Aws US West two region. This should take just a couple of seconds. Um For those of you who tuned in a few weeks ago, I, uh I was, I was lamenting that this took a little bit longer than, oh, I was lamenting. This took a little bit longer than, uh, than, than we wanted. And we actually made uh a great improvement last week to, to make this a much faster. So, um, uh, this function now, you know, last week I think that was taking about a minute to upload. Now it's taking, you know, five seconds or so. So I'm really happy with that. Oh, ok. Apparently folks can't see the bottom of my screen, which is kind of important since that's where all the action is happening. So, uh, let me just try and pull that up. Yeah. All right. Yeah. All right. Let me pull that up here. Is that better? Is that better? Ok, great. Um All right. So, unfortunately, uh I got an error here. No. Ok. Great. Um So unfortunately I did get an error here. Uh, when I was playing, this is actually a common thing to happen. Kind of as I'm, as I'm developing my app, uh you know, the A DB, uh, um the back, a back end has a variety of restrictions and just like in any kind of programming task, as I'm building my app, I may have, I may have errors in how I'm using one of the underlying API S. And, and here, the error is actually, you know, fairly clear, maximum of API S has been reached. Um And this is an error from uh the ASAP I gateway service, uh API Gateway for folks who have used it has a limit on the number of um um of API gateway services we can deploy. Um And so let me actually come into my aws console here. Uh go to API Gateway, turns out we do a lot of demos. So we have a lot of these, uh these apps deployed. So let me just come in here and I'll blow this guy away. All right. Um So now if I come back over here, you see, there's a couple of interesting things to note one. I was halfway through kind of deploying this application, I deployed the function I deployed the bucket, I put the bucket object, but then there was a failure of creating one of the pieces. And this is a sort of very normal thing to happen as you're sort of iterative developing your applications. Um One of the nice things is when I come over here and say Pulumi update now, uh what we should see happen is we'll actually kind of pick up where we left off all the stuff that we already were able to deploy, um, won't be need to be deployed again because it's already up there in the native. Um But starting with that rest API and then a few other things that need to get built off of that rest API like the deployment in the stage. Um Those will now get created. And so if I go ahead and say yes, um we should now be able to succeed in creating uh that rest API and then the deployment in the stage. There we go. So, so this time we, we succeeded in creating uh that application. Uh I can then go Pulumi stack output to kind of see uh what the outputs are. And there was this output which is a URL, I can come up here and hit this and then we see our static content here and then that was served from AWS and that AWS string came from uh that lamb. Now, of course, I can change that to, you know, something else so I can change that to Pulumi TV, for example, uh come back over here and say Pulumi update and this will now go again, go and say, hey, what are the changes I need to make to deploy this? Uh And you notice again, we don't have to change most of our application. Um Just the, the function object needs to change because its code got updated and then uh we're being a little bit pessimistic here and saying, because that function changed, we may need to update some of these other resources as well. Um But if I go ahead and just say yes, true, true, I go ahead and just say yes. Uh this will go and uh and, and deploy those deltas. Um But the key thing here is that we don't have to deploy the whole application. So in just about 4.5 seconds there where we were able to update our application. And that means that I can sort of iterative, develop very tight interloop on my application, even though I'm deploying this to the, to the cloud and running a real application in the cloud, I can have that really nice sort of interloop developer experience as I'm as I'm writing my code. And if I go and hit that same URL again, we should now see that it's serving Pulumi TV and not from AWS. So uh so that's a quick uh quick little tour. The one thing I I showed very briefly uh as I was uh troubleshooting there is I can come in to uh click on this permit link that's available and I can come in and see sort of the, the activity that I've done in my stack. And so for example, with that last update I did, I can see exactly the changes that I made as part of that update. And it was really just to replace this one string in that, in that code there, I can see the details of all the other properties of this uh of this object that I created. And then I can even come into this resources tab and see details of every one of the resources that I've gotten. So for instance, I've got this uh lambda function here, click on that dive right over into the AWS console and we can see that that was indeed hit twice because I just visited that site twice. Um So really easy to go from Pulumi and then dive right back into the underlying cloud provider to get all the details that are available in that cloud provider. But end of the day, uh make it really simple to kind of offer these sort of applications and take advantage of all all those features of of the cloud provider. Um But using just a very small amount of code kind of written at the level of abstraction that that an application developer often thinks about uh doing that. OK. So that was a a really quick intro. Um uh There's a couple of things kind of I wanted to focus on uh for the rest of the time around uh kind of how, how Pulumi works in kind of multi cloud environment. Um So I think for me, there's sort of three aspects of what multi cloud uh multi cloud can mean. Um I think Pulumi has sort of an interesting story for for each one of these. Um the first is just the ability to use Pulumi and use, you know, programming languages to target any cloud platform. So, you know, here we are targeting aws. Um but as we kind of talked about, we can also target Azure or GCP or, or any other cloud platform uh down the road. Uh and, and that ability to sort of have a single way of, of um of, you know, sort of single model for how you think about programming cloud platforms, but apply it to each one of the different cloud platforms. Uh is I think really important if you look at the sort of native technologies available for each uh cloud platform, they tend to have diverged quite a lot. You've got, you know, cloud formation in AWS, you've got Azure resource manager in, in Azure. In each of these, there are some similarities but a lot of differences and to become an expert in one or the other is really a fair bit of work. Whereas with something like Pulumi, um there's one model that then exposes the API S from every one of these different uh platforms. And I think that level alone is really interesting because in practice, uh you know, when I go and talk to sort of an individual developer, they're at that moment in time, they're really focused on one cloud platform. So the applications they're developing or maybe I'm 100% Azure right now, because the project I'm doing is, is, is on Azure and that's where sort of everything I'm doing is, but maybe in a year I'm gonna be switching over and doing AWS and now I'm gonna be 100% aws. And because of that, like at any given point in time, I'm really focused on one, but it's really useful for my skill set to transfer between those two. In terms of how I think about authoring uh my, my cloud software, the uh the kind of second component of uh of multi cloud is I think the ability to create um create abstractions that are useful across clouds. So for me to write um write software which can run on multiple different cloud platforms. And this is where things like this Pulumi cloud uh abstraction here become kind of interesting. Um because Pulumi fundamentally allows you to kind of create new uh components um in in code, uh you can use those components to create an interface which is a, which is cloud agnostic, which doesn't expose details of aws or Azure or GCP and then is implemented differently on each of the platforms. Um And this is sort of a standard technique in, in uh in software generally. Um you see, you know, for operating systems, there are many, many, even though there's great API S available in each operating system, there's many, many, many libraries out there, like like the JB M or dot net or, or the go standard library that are actually available across these platforms and that, that are a bit higher level, but then give access to the features of the operating systems independent of any given one. And so we think that there's, there's opportunity to do that sort of thing as well and it really does depend on having the capabilities of sort of a cloud provider to do that. So, oh, sorry, I just uh I just got past the question that I'm seeing uh come up. So, um I think it was where does the abstraction fall apart if it does? OK, great. Um Yeah, so uh these abstractions, you know, like obstructions aren't uh aren't perfect ever. Um abstractions always sort of have benefits and costs associated with them. And so they always, they always makes sense to sort of uh use them when, when they make sense and not use them when they don't. And one of the, one of the great things that I think about Pulumi is that uh the sort of the continuum is fully available. So, um if you want to program AWS directly and I'll get into this in some demos in a second, if you want to program aws directly and just use all the, all the raw capability of A S, you have all of that available, but where you want to work at a little bit higher level of abstraction, you can do that as well. And if that abstraction ends up sort of not having the capabilities you want, you can fold back down into an AWS specific thing. And I think of this a lot like, you know, what the experience is, uh, you know, when you're using, you know, the JVM or, or any, um, any platform, uh like that, you don't always need to go and use raw, you know, operating system level things. But sometimes you do because there's a capability of the file system on Linux that, you know, is different than the capability of the file system on, on windows. And sometimes it matters to work with those things, but a lot of the time it doesn't. And so the, the, where that line is, is a little bit different for the cloud providers than it is for operating systems right now. But we think sort of over time it's actually going to become more like the experience you have kind of with operating systems and differences there. Um And so right now, we're, we're not opinionated on this, you know, we, we kind of want to let folks do both cloud specific stuff, which is sort of where a lot of the cloud application development is today, but also start giving folks the tools to think about how they can build abstractions that make sense across clouds. And so again, this is, this is not saying, hey, we need to all be building cloud agnostic software today. Um It's just saying that this is a, this is a set of tools that I think are going to be increasingly valuable and important uh as we move forward. And I think there's something that Pulumi sort of uniquely uh helps to, to enable um the, the kind of the third category uh of multi cloud, I think speaks to another aspect of that same aspect of where these abstractions can be make sense and that is sort of kubernetes. Um So in some sense, Cobert is, is an answer to this exact question. It is a set of abstractions, a set of uh kind of uh resource model and an object model uh that can be used uh in, in any environment. Um And so it can be used in uh aws or Azure or GCP, but it can also be used inside your own uh on your laptop or in your own on premise uh data center. Um And so Cobert has gone and defined, you know, here are some abstractions which are generally useful. And then many of those abstractions are actually implemented differently on each of the cloud platforms. So when I stand up a load balance here in ktis that's going to do different things if I'm running on uh Aws or on Azure on GCP. And so it's a similar kind of thing, but that's a formalized uh formalized uh sort of object model that exists already today outside of Pulumi. And so one of the things we, we also can do with Pulumi is is let you work with um and let you sort of build things on top of that uh abstraction. And so I wanted to spend a little bit of time just a few minutes kind of touching on some code examples that highlight kind of each one of these uh each one of these areas. So uh so kind of first off, let me just show um uh in our documentation, I can come over here and I can um I can see sort of the, the raw platforms that we support. And so uh in terms of sort of core platforms today, today, we, we have existing libraries for aws, Azure and GCP. Uh We also have a library for Cober days and then we have this cloud framework that I kind of talked about, which is, which is not its own cloud platform, but it is a, a framework that can apply across multiple. Uh In principle, there's no reason why we couldn't have, you know, effectively infinite uh of these uh of these cloud platforms. Um It's very easy to go and add a new one. So we've had folks over the last few days, ask about Digital Ocean and ask about cloud flare and ask about, um, other, um, other sorts of cloud providers and, and we absolutely can and expect over the, over the next few weeks and months to, to add support for more of these and, and folks actually, because everything here is open source, folks can go and build that support themselves as well if, if they're really interested in, in, in doing those things. Um One of the interesting things is this A S provider if I come over here and go into its docs uh and kind of see the full API, it's an amazing API in fact, let me just come over here and, and go ahead and use it. Um uh Let me just come into some examples here. I'll just go to uh Yes. So if I come over into this code here, I can just take a look at kind of what it looks like to, to use this. So if I say Aws dot um you know, I get, you know, a huge number of API S. Um So just, you know, this list is, is enormous and this is all the API that are available inside um inside aws. Um And the same thing is available for, for Azure, same thing is available at GCP. And as we expose others looking at that too, one of the key things that we do here for folks who are familiar with uh the telephone provider uh ecosystem, the, the Aws Azure and GCP uh providers for Pulumi are actually built on top of those existing open source projects. And so when you type Aws dot Here, this is actually a projection into uh into Pulumi of the underlying Aws telephone provider. And that's a provider that has, you know, hundreds of, of developers sort of uh collaborating on uh on, on contributing to that and, and building up a really great representation of the um of the Aws surface area. And this often moves really fast when a new feature is available inside A W BS, it's often within a day. Um There is a, there's APR open and that's being integrated into the, the, the framework. And so that means from Pulumi, we can get access to all those capabilities of the AD BS platform really quickly as they're being deployed uh by the underlying cloud providers. Um The last one I mentioned there was was the support. Um And that one, we actually, for Kubernetes, we actually found um that we really needed to have our own provider for that. Um And so for, for Kubernetes, uh we've gone and built a provider that's, that's unique to Pulumi and that talks directly to the Kubernetes object model. Um And you can check that out if that one's open source as well. So we'll come over here um can check that out at uh Pulumi dash KTIS um and this is a uh a library which lets you uh use the exact uh object model of. Uh So we actually uh uh project the API directly from the um the API specifications uh that are published by the KNAS project. Um And so you can get a full fidelity access to everything that's available inside, but you can then use javascript or Python or whatever to program against that. And so you can, you can do a lot more compositional things. You don't have to write giant YAML documents and copy paste and all that sort of stuff. And so I found this to be really uh really handy to use. OK. So, so we have access to all the, the sort of core underlying platforms and that's really the first piece is just, you know, you can do all this stuff, but I thought I'd show some, some simple examples of kind of what that looks like in a few different things. So we saw on that first example, kind of using um uh using lambda and using uh serverless capabilities in AWS. Um But it's actually interesting to go and take a look at that in some other platforms as well. So if I come over here, uh let me just switch over to uh switch over to this folder. So I'm gonna go to, what was this Azure TS functions. OK. So this A RT S functions is uh is a little example that shows how to use uh um Azure functions um which is sort of Azure's equivalent for tourist uh functions. Um And this uh you know, this example, just kind of shows off. Uh you know, here, I've got a handler which is just um gonna implement the, the kind of interface that that um that Azure expects. So it expects a context object and our HB request is parameters and then runs some code at run time and now I can go and create one of those. And here we've created this Azure function dot HTP function, which is itself just a little uh you know, a little abstraction, little wrapper that we've built um over some of the underlying resources and I'll dive into some of the details here. Um The nice thing is, you know, in general, don't have to worry about these if you don't want to, but, but just to give you a sense of kind of how these things are built and I'll give you a feel for it. Um So here you see inside this, we actually go ahead and, and create a variety of Azure resources. So a resource group and storage account storage container that can store some objects. And then we put up a blob into that storage account, which is the code that we're going to want to upload into our Azure function. And then Azure functions run inside Azure app service. So we go ahead and create an app service plan and a function app. Um And we point that function apps website run from zip at that code blog that we uploaded. And so there's a bunch of moving pieces here and uh really to, to, to use Azure functions sort of programmatically, you kind of have to do all of this work that we saw here. The really nice thing is that we've gone and you know, uh written this code here. Uh In this example, we, we, we spent some time talking with folks from the Azure team to make sure that we were kind of stitching all these pieces up together correctly and, and, and uh make doing this in the way that works best with, with Azure itself. And the end result though is that now uh uh as a user, I can just come up and write this one line of code and I've got an Azure function stored up running some code and um on the internet and so I can come over here and take a look at this. Um And I've got uh that Pulumi stack, I asked to see all the different copies of this that I've got running right now. Um And you see, uh I've got one running, it looks like Joe had one running as well. Um uh So I've got this stack here and if I say, let me just come up here and, and make a change. So, um I'll say greetings from Pulumi uh in this code body. And I'll just say Pulumi, well, first let me, I, I'm using typescript here, so I've got to build that. Um And then I put the update um and this will go ahead and try and apply that update that I just made to the program. And again, sort of just like we saw in that first example, even when, you know, even when it's Azure, it's a different set of resources that are changing. But it's a similar kind of thing here. We see the zip blob uh that has the, all the code we need is going to be replaced because the, the contents of that changed because the, the code I wrote there was different and then we'll see that function app object is gonna need to be updated. And so that update is what's gonna cause the function that's running uh to uh run new code instead. So if I say yes, I'm gonna go ahead and make those changes. Um This should take uh I think this takes, you know, 10 seconds or something uh when I run this. Um and this will actually go up to Azure again and deploy just those deltas um into the cloud provider. Um And so if I do Pulumi stack outwards, we see we get this and if I go ahead and hit that uh cold start time when Azure is a little bit longer, so this takes a couple of seconds. Uh to um to, to run. Um But we'll see, uh once it does, we'll see that this runs that code and has that same string that I just uh changed the code to, to print. And so again, it's a very simple way to uh to deploy uh Azure functions just like we were able to deploy um uh in uh LAMBDA. And also one more just because, uh you know, we talked about GCP as well and we haven't done many GCP demos here. Uh Let me see if I can find this, the eye open. All right. So let's go over here and uh and we'll look at GCP. So um we also have a Pulumi GCP repo um uh in github that uh folks can look at and, and this has a few examples in it. One of the examples we have here is, is also um just using uh uh uh Google Cloud functions. And so just like we saw in the other kind of examples here, we're using those underlying pieces um in Google Cloud, it's similar, we have to create a bucket, we have to create a bucket object which contains our index dot GS file uh that's built up out of this uh this little handler here. Uh And then we've got to create a GCP Cloud functions function object. Um And so we can do the same thing uh in this example, let me just go to that oops. Uh So this Ok. So here we are in that. Um, I can do again, Pulumi stack VLS to kind of see what stacks I've got uh, running for this. I've got just this one. If I, well, let me see if I can make a change in here. Uh, let's make a change. Uh Do Pulumi update. Actually, this is gonna be type trip as well. So, yep, that, um, NTM run builds. Yeah. Ok. Now I'm running Pulumi update. Um So again, we're gonna change uh that bucket object and that function. So very similar experience here is what we saw with Azure where the, the, the sort of object and the and the function are changed. But here it's a completely different set of resources. These are resources in GCP that are defined, you know, by a completely different organization with a completely different surface area. But the Pulumi experience for working with both is is very similar in terms of kind of what needs to be updated. Um And so here if I go ahead and do this, uh we'll update that function. Mhm And this takes a second as well. One thing I will do uh just while I'm waiting on that is actually come over here and, and show you uh so we can see that cloud function actually in the Google cloud platform uh console. Um So if I refresh this, I think this was version five, we should be seeing version six once this gets deployed. Yeah, so there we go. Now we're on version six, deployment started at 11 28 56. That sounds like I was right about now. Um And so I guess it's still knows it's still up. There we go. Now, it knows it was deployed. Um And so this should have finished. Yep, there we go. Um And so, so that function we can see kind of the, the, you know, the diagnostics about when it was run and all that sort of stuff um in the in the Google Cloud console. Uh And then if I do again, let me stack outputs and I can even do, you know Pulumi curl, get that URL. Um And then I say hello, Pulumi TB. So exactly that string which I, I just changed a second ago and if I come over here, I would expect that uh I don't know how frequently this thing updates, but if it was updating fast enough, we should see this uh um this invocation that just uh came in against that. Um Give it one more chance. Oh Not to worry. I'm sure I'm sure they have a couple of seconds of delay uh reporting. Oh, there we go. Uh So there's, there's that invocation that I just, I just did and we can see all that uh get all that insight uh directly in Google Cloud. Um So, yeah, that gives a sense of kind of like uh the raw capability to, to do some of the servers stuff in every one of these platforms. So we have access to the ability to sort of manipulate the underlying uh underlying resources to kind of work with the serverless capabilities of Azure A S and GCP. Now, uh we have some layers on top of that. So uh one interesting kind of layer um that we have today for AWS is this uh Pulumi Aws serve and this is a library we found kind of useful for just doing general service uh application development um on top of um on top of Pulumi. So like for example, here, I can do things like um you know, I can create an A S S3 bucket and then using this serverless library, this a service library, I can say serve dot bucket dot IUT. And this just gives me a really easy way to hook up an event handler to that bucket without having to know all the details of, of what I need to do to do that. And so it's fairly cumbersome to kind of put together all the various Aws resources that are needed to do this. So we can provide just a very light but helpful set of API here that, that, that do those sorts of things. And one of the things that we're really eager to do um uh in the next few weeks is to expand this kind of library to Azure and GCP as Well, um on top of the features that we kind of just show in the last two demos to give these really simple, higher level ways of working directly with uh Azure and GCP. But for some of these service those capabilities. And so if folks are interested in kind of uh working on any of that stuff, uh let us know, uh we're gonna be doing some work here and we'd love, we'd love folks to, to help out um as we go and flesh out some of those libraries as well. And of course, those kind of then speak to this Pulumi Cloud uh capability where we have some high level concepts which are, which are independent of cloud platform. And based on those building blocks, I think we're really looking to flesh out that support for Pulumi Cloud to also cover Azure and GCP and other platforms. Uh Over time, we got a request for uh supporting uh cloud flare uh workers as well. We're definitely excited to, to kind of do some of that. Um And so we'll uh um well, that's an area that we'll be exploring uh soon. Uh the question dynamo streams is that OK? Um We did a similar thing for dynamo to B streams. Yeah, absolutely. So, in this a serverless library here, I think we have a handful of things in this library already today. We have sort of cloudwatch timers. We have uh SNS topics, we have buckets, we have H API gateways. So those are, those are four very common sources uh for kind of serverless events. Um We fully expect this library over time to expand to cover every source of uh of event, you know, event source for LAMBDA, which is A, which is a large set and a growing set B streams. Absolutely is, is one of the probably, probably the next most common uh after those four. And so, uh we definitely want to support that if, if folks are interested in adding that support, um feel free to just open up an issue in the A R service rep, uh we can discuss kind of the approach that we would take there. Um It should be a really simple thing to take this kind of same approach that we've taken in libraries like uh you know, here it's like 80 lines of code or so to make this work with cloudwatch timers. Um We'd expect it to be a similar thing to, to make uh to expand this, to cover more and more of the database event sources. So we're definitely definitely interested in um in folks helping to flesh out some of those libraries um as well. Um OK. Uh So I'm already uh past the 30 minute mark. Um I did wanna also chat a little bit about kind of kubernetes and uh and how we, how we do that from a um uh a sort of cross cloud perspective as well. Um I won't have time to dive deeply on that and I want to spend more time on that. So maybe I'll postpone a real deep dive into Kubernetes until next week. Um, uh I think that would be a good topic to spend some more time on. Um, but one thing I will show just because it's sort of more at this uh cross cloud uh layer. Um, you know, the first part, the sort of two parts to Coates, one is actually kind of using and, and, and um you know, deploying uh deploying coin objects like services and deployments and, and what have you, um That's what I'll focus, focus on next week. But one thing that's uh kind of fun also is that, you know, kind of makes sense from a, from a cloud provider perspective, like on each cloud provider they offer, you know, there are now managed services available for, for every one of the cloud providers. Um you know, EKS uh from A to BS just launched last week. Um You know, uh there's a KS, the Azure Azure service which has been available for a while and just uh just ga I think last week as well. Um And uh and then there's, of course, uh GKE and so uh one of the things we can do with Pulumi is to stand up cos clusters. Um and so we, we support standing up cos clusters in any one of those just by building on top of the the raw capabilities of the cloud provider. Um And so this, in this example, you know, this is just a little uh you know, 20 line kind of program here and this this program uh stands up a Azure cluster. So uh with this program, I run this, deploy this and I've got a managed cluster running inside Azure um that I can now manage as sort of infrastructures code and uh and now deploying my applications into. So I think this is a really nice thing. Uh The Azure has actually designed a really nice simple API for this, really easy to get started. Um And so, uh um uh but some of the things are available for um GKE and uh and uh EKS as well. Um And we'll be sort of flushing out some more examples of that sort of thing in the future. One of the really fun things, this is sort of a um a teaser for, for kind of the future. Uh because you can describe both your cnet's cluster uh inside Pulumi. But also you can describe your Cumin's apps in Pulumi. Uh we can actually mix and match these so we could write a single program that stands up by Kate cluster and deploy some of my applications into it. And this uh this may or may not be what you want in a given setting in a real production environment. You probably are going to want those to be separate and managed in on different kind of cadences, but it does let you coordinate changes across them. So if you want to also allocate some additional maybe um you know, roles and policies uh in your cloud provider that are relevant to the behavior of your uh the pods you're running inside cori you can sort of do that in one unified way and think about your entire application infrastructure um as, as one component. Um So that's a sort of just a kind of a teaser for some of the things that we're, we're thinking about um there as well. So, uh so yeah, some overtime. Uh Thanks so much for, for joining us. Um uh It's been fun kind of showing off some of the stuff. Uh We'll be back kind of next week, same time. Uh If folks have anything that they would love to see us kind of go into more detail on. Uh Let me know um uh we're on our Slack Channel, we're here on youtube. Um And uh and we'll see you next week. Great. Thanks a lot.

---
