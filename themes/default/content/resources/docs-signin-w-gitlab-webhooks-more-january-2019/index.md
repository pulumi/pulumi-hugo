---
preview_image:
hero:
  image: /icons/containers.svg
  title: "Docs, Sign-in w/ GitLab, Webhooks and more | January 2019"
title: "Docs, Sign-in w/ GitLab, Webhooks and more | January 2019"
meta_desc: |
    Join Luke as he discusses some of the top issues and debates from the Pulumi community at 
url_slug: docs-signin-w-gitlab-webhooks-more-january-2019
featured: false
pre_recorded: true
pulumi_tv: false
unlisted: false
gated: false
type: webinars
external: false
no_getting_started: true
block_external_search_index: false
main:
  title: "Docs, Sign-in w/ GitLab, Webhooks and more | January 2019"
  description: |
    Join Luke as he discusses some of the top issues and debates from the Pulumi community at  â–º Join the Pulumi Community Slack: https://slack.pulumi.com/
  sortable_date: 2019-01-23T20:15:07Z
  youtube_url: https://www.youtube.com/embed/6x4FxKWH6pI
transcript: |
    Yeah. So one of the biggest things we've really done in the New Year so far has been to uh really uh kind of revamp some of the, the onboarding uh um information. And so really uh taking the Pulumi uh documentation and some of that content and really uh kind of uh revamping it, making it easier for folks to get started and, and learn the product. Um And so that's really helping the open source project and, and folks who are coming in and, and getting started with that um to uh to learn about Pulumi um to get started quickly and to find all the different documentation around it. Um I'll go in a little bit deeper on some of the changes we've made there recently. Um But let me also just quickly touch on a couple of the other big things from, from last year. Uh One was we um we launched the kind of team tier uh of the, of the product. And so, um for folks, we've had a bunch of folks now who have been using Pulumi for a while or, or graduating to use it in production environments um and have been actually jumping over to using uh kind of the team tier um and using some of the additional features there and we'll talk about some of the new things there in a second as well. Um And then finally, it's been just the sort of growth of the, the um uh user based ecosystem. Really excited about that, really excited the Pulumi community Slack um that I'll jump over to and, and, and look at some questions from um It's been great. Tons of folks jumping in there asking questions, building, really cool things. Um On top of Pulumi, really excited to see the, the growth in that uh in that community uh over the last uh last few months. Um So I'll jump in all of those a little bit more in detail in a second. Um The one other thing that was kind of fun in the end of last year since we did the live stream. Uh Last was we actually spent a bunch of time out at uh conferences in uh in December and, and uh talking about Pulumi with a whole bunch of users. Um Both folks who are already using Pulumi and a lot of folks who, who aren't yet using Pulumi and uh spent all the time at Reinvent at Coupon uh at EU um a number of these different conferences and it was amazing. Uh One of my big takeaways from that was just, you know, almost everyone we talked to at those conferences um was really having kind of some of the core problems that, that Pulumi helps with managing the, you know, enormous complexity of their cloud infrastructure, bringing that under control, applying software engineering practices to it, avoiding just sort of the out of control copy paste. Um These were things that really were resonating. Um And uh and it was really great to sort of hear all the different stories of how folks were, were, were, you know, trying to tackle those problems and how Pulumi was positioned to kind of help them out. And so really want to uh talk uh first of the time about some of the different uh ways in which Pulumi uh helps out with that and then some of the specific challenges that that folks have seen. So, uh so, yeah, so, um just to get started, um we've done a bunch of things in the product and then sort of the overall experience over the last few weeks and I wanted to just touch on a few of the most interesting things there and then I'll talk a little bit later about some of the things that are coming up soon. Um So the first thing that we've done that I think is really notable is uh spent some time kind of improving uh the doc site. And this is a thing where, you know, a bunch of users have, have given us feedback. Hey, you know, we need to have you know, some of this information be a little bit easier to find. Um And so I've spent some time uh uh working on that and for those who haven't tried yet, you can go to Pulumi IO click install, you know, go through the steps to, to get in to get started. Um One of the major things we've changed over here as well is just improving the sort of navigation and things. So if I come into documentation, I can drill in, I can go and look at, you know, all the command line capabilities, the team and collaboration features that Pulumi offers um as well as things like going to architecture and concepts and doing a deep dive into each of these uh into each of these areas. One of these pages in particular, we did a, you know, a big uh revamp over is the program model page. This is, you know, from our um you know, community slack and a bunch of the other forums where we're working with users and answering questions for them as they, as they sort of um build up um larger and larger Pulumi uh code bases. Uh There's a bunch of questions around the program model which come up, you know, regularly. And so we really wanted to put some effort into making sure that uh but these pages had really good examples and a lot more detail on kind of how to do some of the core things with inside your Pulumi program. And so you can come into this page, you can take a look at, you know, hey, if I want to work with creating resources, how do I do that resource outputs is a key thing in Pulumi. That is kind of how you can stitch together the outputs of one resource to the inputs of another um Generally, really important. Um We have here examples now in all the different supported languages. Um and a whole bunch of details of uh of how to do a variety of different tasks with that. So a lot more detailed documentation there, a really great resource. And then finally, we um you know, our API reference uh uh we've expanded a bit. And so, for example, um you know, if I come over into the AWS documentation we have here and you want to go and learn about what you can do with Aws using Pulumi. Um We have now, you know, uh these things are collapsible so you can quickly go and look at just the pieces you care about. Uh Here, you can see just all the capabilities of Aws that are exposed into Pulumi. And there's a couple of interesting things here. One, you can see several features that are sort of new things that have been released since reinvent. And so just in the last, you know, few weeks that we have exposed through to Pulumi users like a mesh I think was announced at Reinvent. And uh um a document DB was announced even more, frequently, frequently, just a couple of weeks ago. So these capabilities are all here for Pulumi users of aws. But the interesting thing is I can come in here as well and dive into, you know, class table. We've actually now added examples into a lot of the documentation here. And so here's an example where I can get, you know, documentation of what it looks like to use a dynamodb table in one use case. And this sort of just gives me a simple access to, you know, a working example of, of the full thing, a very, very important something that users have asked us for for a long time, I can also go and do things like billing mode, I can go and search for that property. Um And you know, one of the other things that it announced reinvent was the sort of on demand uh pricing model for for dynamo DV. And this is something that a lot of um I was very excited about. A lot of users were very excited about. Um we can go. And so you see that that's now available as the pay request option on billing mode. And we can also see from this, that we can do things like, you know, hover over and click on Pulumi dot output to go and learn about what Pulumi dot Output does. And that links us to that Um So we've made just generally this documentation quite a bit um easier and richer to use. We can also do things like say, you know, we have the on event handler on tables. Um This is, you know, lets me fire an event any time uh any using dynamo TV streams and so I can do things like click on this to go and see what that signature looks like. Find this table event, uh you know, which, which has all the details of the structure of these events and I can click through here, get all this information uh right inside the documentation. So a lot of work on the API documentation make that uh really um really great. Another thing that we did recently was uh was bring in support for additional um uh you know, login options. Um And so uh you may have seen in the past we supported github as the way you can sort of log in to uh the Pulumi back end. Um And so if I go to app dot Pulumi dot com in fresh window here, um you'll actually see we can now log in with both github and GLAB. And so we've had many users now who had been asking us about GIT lab, who are using GLAB as their primary kind of source control and identity. And so now folks who have GLAB identities can also sign in here working on as well right now. And that should be available very soon. And so we're trying to make it so it's really easy to log in here and we're not just tied to kind of github. We have a variety of different providers. And of course, in our, um you know, uh folks who are using Pulumi inside an enterprise setting can use kind of the SAM L um sign on as well. Um So I think that's, that's really nice and then I'll show what kind of one other feature which we just kind of announced today. And I'll just go over to the blog to uh um to show a little bit about that is, is webhooks. Um And so this has been in the product for about a week. We just kind of put out a blog post that really walks through kind of some of the um how you can use uh webhooks um earlier today. Um And Webhooks is a feature we've had quite a lot of asks for. Um It's just the ability to uh hook up a um you know, hook up a web, hook to your stack so that you get events uh sent to you every time there's an update or preview or any of that kind of those kind of actions on your stack. So you can do additional things. Um You can either, you know, log that into Slack or some channel like that, you can do additional work that you might need to do in your um in your, you know, sort of deployment and processing stack. Um It's a variety of different scenarios that we've seen, we've seen folks try to use for webhooks. Um But this provides a key point of extensibility for uh for use with, with the Pulumi back in. Um And so this is a really nice uh kind of feature. One of the things I thought I'd do is just really quickly show the end to end because it also shows off kind of using uh building a Pulumi program to uh to, to hook up webhooks. So I can go over to app dot Pulumi dot com. Um, go log in and I can go to my Pulumi account. Um This is uh our internal uh account for the Pulumi team. And so we've got, you know, a whole bunch of uh examples deployed here. Um And I can come over to settings and actually now have this new webhooks, uh pain. Uh And so we, you see, we actually have ourselves for our own team. We've got to post updates to Slack Web books. So we've got this hooked up uh for some of our own webs in for our own sort of use case internally in our team. Um But we have a number of Pulumi customers who are doing similar things to this as well, who've helped get set up on top of this. Um But I can go and create a new one as well. Um And so I can say, you know, Luke's demo web book. Um and then I need to payload URL. Um And so, uh to do this, I need sort of some uh web api, you know, some HDPN point on the internet that I can send these requests to. And of course, that's something that Pulumi is, is great at doing. So, uh I'm gonna say a demo web book, I'll just go and create this and then I'll just say Pulumi to create one. Let me just come over here and do uh AWS typescript. Let's just pick all the default options here. And this is just gonna template out a new Pulumi project and I'm gonna use this project just to really simply create uh a um a web API that I can run that can handle this and then I can go and make that richer over time if I want to. Um So let me just go ahead and create this and say, yes, you know, some of these warnings are actually just because I'm, I have a DEV build installed locally. And so I'm getting some warnings. Um but they shouldn't, uh end users wouldn't see these things. This is just because I'm working on uh recent bits. So, OK. So I've got this created. Um In fact, you know, if I come over here and click on this, you can see, uh I've already deployed a very simple uh app to this demo web book um thing. But let me just open this up in visual studio code and let's just look at this program. OK. So I've got this little program right now. It's just got a S3 bucket exposed. I don't need that. So instead I'm going to do something simple. I'm gonna say, uh constant um uh API equals new AWS dot API gateway. We've got this handy, you know, uh API gateway dot X API, which makes it really easy to stand up a new API and it's got a few different things I can set, I can pass the swagger string that I build out myself or I can just pass a set of routes. Um And so in this case, I'm going to pass a route and I'm going to say, you know, when I post because I think the web books use post uh to uh to the root path, then I want to run this event in. Um And so for right now, I'll just say console dot log ev. And then I actually need to return the, the, the shape that it requires. So I'm gonna say status code 200 body. Yeah. Ok. So I think the web books expect me to return a 200 or else they'll try and, you know, do some retries and things. Um But this is a simple uh handler and so now I'll just say exports constants uh URL, api dot URL. OK. So this is a very simple Pulumi program, just exposes a rest A P at this URL that we we export and post a single A P on that post to the root path that's going to run this code. It's just going to console that, log the event and then, and then grab this. OK? So let's come back over here and just say Pulumi up and we'll see as usual Pulumi will do a preview of this deployment. OK? So it's gonna create these eight resources associated with this. So some uh some A BS resources to make that API gateway. Um And it's gonna delete uh the bucket that was there temporarily as part of the simple thing. So let's go ahead and do that. OK? This will just take uh probably 2030 seconds. Um There we go. Yeah, 21 seconds. And so now we've updated that we can see over here, we did this, we did this update. Um We can see all the details of what was changed there so that we actually now have a simpler view here and then the, all the details of the resources um there as well. Um And finally, the links over until I can go and see these resources in Aws. But the really important thing is that I have this URL here now. Um And so if I, if I uh curl this URL, for example, you'll see we get back that hello world that we uh we wrote in the code. So this is now an endpoint exposed on the internet that we can send requests to. Uh and I can just uh also go and do something like Pulumi logs and Pulumi logs dash F. This will actually give me the logs from this application. And so since I hit that end point and I console dot log, the event we see here, that's actually gonna that console dot logged event payload is all going to be in my los here. So I can actually see the logs of what requests have been made um to my endpoint. So I'll just hit cancel there. OK? But the key thing is now I have that uh that end point here. Um So this end point right here. So I'll go back to my web book. Uh where was my web book right here? And I'll just go and say I want the payload URL to be that. And I'm not going to set any secret right now. We do have the ability to kind of set a, a sign a secret which will then ensure that we pass a sort of um H mac digest of that to your handler. So you can verify that it was really sent from Pulumi is is correct. Um This would be since this endpoint is something which you know, any of you could right now be sending requests to. We want to be able to make sure eventually that if we're getting the request that there are things that are guaranteed to be from uh from Pulumi. And so you can definitely do for this simple example, I won't, we have an example in the link from the blogs that shows how to, how to hook that up correctly as well. OK. So, um right, so now I have that set up. Um And what I wanna do is um what I'll actually do is I'll create another instance of this same stack. Um But I'll create an instance of this. If you look at my Pulumi stack, LS, I'll actually see that this is um this is in my Luke Hoban organization, my own personal organization, but I can create an instance of this stack uh in Pulumi. So I can say Pulumi Web. So now I'll have two different stacks. And if I do Pulumi stack, LS, you now see, I've got two different stacks, the Luke Open Web DEV, and the Pulumi demo web DEV. And so if I do Pulumi up here, this will actually deploy uh this app into uh the, the new, the new stack. So I'll just go ahead and say yes, since now, I've got two copies of this stood up. Um And the reason I'm doing this is because this will actually uh trigger uh those web books because I'm creating a stack. I'm, I'm doing some events on it. And so if I come over here, uh we'll now see uh if I refresh this page, I can actually see the events that have been sent to it. Um And so here, if I click on this, uh we'll actually see that this was a uh update succeeded uh with creating nine resources and we'll see that my uh web book. Um oh, actually, this is not the web book I was looking at. Uh but uh but I can see if I come over here and I go to my other stack. Uh So I'll go over to Web DEV. And now if I do Pulumi Log Chef, we actually see we got quite a few uh hits here. So we got um uh this kind of body that's uh encrypted here. Um Actually, since I want to show the body, well, I could, I could actually go and grab the body. This is, it looks like it's uh um a 64 encoded or something here. So, uh I um I could uh un en code this and we'd see this was actually the payload, the same payload that we got sent over here. Um But the key thing is here, we're actually getting to this end point that I created, we're actually getting these things delivered on every time I do some sort of update. And so each of these is a different, you know, an update, succeeded, update, succeeded. And this one is a, you know, created a new stack. And so each of these different events with their payload is being sent to my handler. So two key things I think showing off there one is, you know, this ability to have webhooks and the ability to sort of manage them. And a bunch of different integrations we can do with those including like slack and workflows and that kind of thing. Um But the the other is just the ability to really simply stand up a rest API kind of using Pulumi um both uh stand up the infrastructure for it in this case, the API, but then also write the code that's going to be implemented in here. And of course, I can then go and, you know, sort of say, you know, constant table there, new A 0.0 DB dot table. Um and I can set that up as well uh to be a, you know, a data store. And then if I want, I can actually keep some, you know, store some data into that using the AWS SDK um as part of my implementation of this LAMBDA. So I can actually have a state full application here as well. Um Really simply kind of using polluting, we can dive into that more uh if folks are interested at some other point. Um But anyway, that was, that was a quick tour of kind of using web books, both uh using web books in the service and uh in the back end. So if there are any questions uh, that have come in. I'll definitely, uh, jump over and kind of look at some of those right now. Otherwise I'll, uh, I'll answer, uh, a couple of, uh, other things that have got backed up. All right. Uh, I don't see any questions right now, so I'll go back to a few of the things that have come up over the last, uh, you know, week or so that I thought were kind of interesting um and spend a little time talking about those. Um So one of them was uh got some questions about um uh about auto naming. Um And in particular, let me see where those were back here. Um Yeah, so I think, uh you know, Felix had asked these questions about, you know, pulu these adding random numbers to the adverse resources. Um And, you know, is there any way to prevent the sort of random number, you know, in this case, my table 314142, is there a way to prevent that from happening? And so let me just talk a little bit about that and about kind of why um why that is and why it's interesting. So we see in this piece of code here, we created a Pulumi resource called, you know, API um the uh and when I look over at what I did in the, in the cli here, uh you can sort of say, you know, Pulumi actually what I'll what I'll do is just jump over into the web console. Mhm. Um And we can see these resources. Uh Yeah, it might be the, you do. Yeah. So these resources each, you know, have a Pulumi name like API, but then they also, you know, have a generated name for their ID. So, you know, in this case it's API dash and then some, you know, some uh random digits here as well. The reason why we do that uh is to make sure that uh when you create one of these resources, we want to make sure it's, it's unique uh inside the cloud provider. We want you to be able to deploy this same uh program multiple times uh without conflicting uh on the names. And we also want uh to be able to make sure that when we replace one of these resources, if you make some change that requires us to replace it, uh that we can cleanly create the new one before we delete the old one. And this is actually a really important uh capability to be able to create uh the new one before the before I delete the old one. For example, in this API case, um if I would make a change to this, like, um you know, this will, this will, well, actually, why don't I just uh you know, let's, let's imagine that I add a new handler here. Um I'll just kind of do the exact same thing here. Um So if I do this now, I've, I've updated the handler and I come down here and I say Pulumi update, we'll actually see, uh, we'll see, we'll get a preview of what changes this is gonna make um to my stack. And you see it's doing actually quite, you know, a few different things inside the implementation of this API and in fact, it's replacing the deployment, it's replacing the permissions and it's gonna update then the rest API and the stage to kind of point to that. Um And because we're, because we create on all these replacements, like the replacement of this deployment because we do that replacement, uh uh we do the creation before the deletion, it means we can actually create the new deployment, update the stage to point to that and then delete the old deployment without any downtime on that API. And that ensures that any time anyone hits that in point, they're going to get the correct result. Um We're gonna, you know, correctly shift over to the new one only after it's completely stood up um where we have to uh you know, create a new one. you know, with a, with a new name, we wouldn't be able to do that, that coordination. And so it's actually very important, this ability to generate a unique names for these is actually very important to be able to have really good up time uh during updates. And that's why we do that by default. Now, it is possible though to, to, uh you know, pick that name explicitly yourself. And so if I go back and do that table, uh a 0.0 DB dot table, uh I can come over here for example and uh and say name colon, I think there's some other, let me just make this correct, so I can show you what this does uh attributes and hash keys. So I wanna do attributes. OK? Let me just put the attributes and hash key. It's going to be ID. OK? So there's a minimal and I'll just say billing mode um a curve. So I get to use the nice features there. OK? So this is a Dynamo DB table. I'm gonna create in this case, I'm gonna say name uh hello. So the Pulumi name for it is going to be table, but I'm gonna say its name is hello. And what we'll see if I do this is uh when I do Pulumi up, um This will actually show in the preview. It will actually show that the research I'm going to create for this dynamite table is actually going to be named exactly how low it's not going to have the, the randomness added to it. Hm I'm not sure why this is ticking to. I'll just uh uh well, let me see. Let me start with the All right. So we're gonna create a table uh way up here. Uh Yeah, here's the table. Um So we're gonna create this table and we'll see that its name is actually hello. Um And so it's going to be created with that name. Uh If I went ahead and create this, I'd actually create that table. Well, uh with that name, let me actually just move this and I'll just go ahead and do it. Yeah, I'll go ahead and create this. Um And we'll see this will create the dynamo DB table. Um It shouldn't take very long and then if you go over to the data console, we'll see it's actually named uh actually named hello. So we'll come in here, go to resources, find our table, uh click over to the data, this console and we're on the hello table. So it's name is exactly hello. You'll see a lot of these other ones, we have, have these sort of random hex at the end, but this hello table was exactly named hello table. Uh If we come and remove that though, uh then I'll do a Pulumi update now because this is changing the identity of this thing. It will actually require that we replace it. Um And so we should see a replacement looks like it didn't see the change at all. Uh Not sure what went on there. Um But anyway, I think folks get the point that we were able to use the explicit name column to name the table. Um In this case, um we could do that for any averse research, really, any research we want if we want to explicitly name it and get a specific name. But for the most part, we encourage folks not to do that because that does make it harder to get zero downtime replacements. OK. Let me just jump over. Um See if there's any other questions here. So one other uh question we had uh just in the last couple of days uh was about using kind of get output. And so let me talk a little bit about that as well. Let's see where that was here, right? So we, we had someone asking about using a new feature that we actually deployed called stack reference. Um And uh one of the things I'll just quickly show off kind of how that works. Um So we added this new feature, we've got a number of users have pointed out they're kind of using multiple Pulumi stacks and each stack is sort of one deployed and versioned kind of unit of of code. But many folks want to split up their applications into multiple stacks. So they'll have one which is maybe their networking layer one, which is their um you know, core infrastructure, maybe their cluster and then one which is their sort of each, each of their applications maybe is its own stack. But as they do this, they kind of want to reference things from the lower layer. So they want their application stack to reference the outputs of the, of the maybe the community cluster stack. So they can figure out which cluster to deploy into. Um And so they want to actually have links between different stacks they have deployed. And so actually added uh the ability to kind of do that. And so, um you know, if I want to say base stack um equals new Pulumi dot stack reference. Um And so this will now be a kind of reference to that underlying uh that, you know, the stack that's stored somewhere else. And I can go over and pick anything that I have to find inside an organization. So anything I have access to from within Pulumi I can reference. And so I can say, you know, maybe I want to take this uh Luke airflow stack. Uh So I can just grab its name, I can say name colon uh and grab that uh if it was something in the Pulumi organization. So for example, if I had it in an organization I own, uh I could just, you know, grab over this and I could grab Pulumi slash. Um And so now I can reference, you know that example as well. Uh And so this lets me to just say I want to grab a reference to that thing. And now I can look, you know, this, this particular example has a bucket name output. And so I could then say base stack dot get output uh fucking name. Um And this is now going to be a reference to this value. And so if I updated that underlying stack and then redeployed this, we would see a delta there and then we'd have to then go and push that delta through our stack as well. This is a way of sort of chaining stacks together in kind of a really nice way. Um And so now I've got, you know, my bucket name. Uh And now I could use that, you know, maybe in here I can then go and, you know, uh it was a test decay. Uh I could use that to sort of, uh uh you know, I could put a, you know, put objects. Um, so I could call three do, put object and pass in that bucket name and put an object into that bucket every time this event gets fired or something. And so this is a way of me chaining together research, defining multiple stacks in a really convenient way. Something we added, I think in December, we've seen a lot of folks picking that up and using it since then. And so I had a few questions of folks kind of troubleshooting, how to do things there. Um We had other questions. I think there was one this morning about kind of how to do some uh event driven serverless solutions on A S. Uh I think this is always a really interesting thing. I think this is a place where Pulumi is can be really nice. I mean, this example I showed with the web book is actually kind of kind of like that it's event driven in the sense of creating this rest api um But it's also kind of amazing, you know, I created this table here. You can also do things like say table dot on event uh you know, um And this is using the, the streaming. Um And so I think I have to turn on streaming, it says Dream enable troop. Um But now I can say, you know, on events. Um uh And again, I can do sort of a sync uh ev, you know, and just with, just with this code. Uh oh actually, I need one more thing. I need uh I need to say starting position, I have to pick whether a starting position is either trim horizon or latest. This is just part of the dynamo to B streams model is I need to pick kind of how to, how it sees the, the stream. Um But just with this, you know, a couple of lines of code, I've actually hooked up a callback at lambda to, you know, what, whatever is happening at a table. So every time uh some operation happens to modify that table, I'm getting an event and I can go and do interesting things with those, I do some post processing uh do some, you know, whatever it is. I want to do um it's really easy to get into kind of using event driven servers, things either this kind of event driven on tables, event driven on buckets, event driven on timers, just any of the kind of standard event driven things and also very easy to just incorporate this into existing infrastructure. And so I think this is, this is kind of a really nice um scenario. All right. Um And then the, the last thing uh I want to talk about, I kind of briefly we had a couple of questions just in the last few days, just about working with, with outputs. Uh I think there's this one here. Um uh You know, someone's looking for, how do I do kind of Jason stringify but do it when I'm trying to stringify something that has outputs inside it. Um This is actually something that we now do have a lot more kind of documentation and things on um inside this programming model section. Um And so resource outputs. Um So a lot of different examples kind of hear of how to do various things. But let me just show kind of a couple of those in the context of this program that we have here. Um Just to give a sense. So for folks who are kind of new to Pulumi, um one of the things that you'll see a lot working with Pulumi is this notion of Pulumi dot output. Um And that is sort of, um this is something that we, we expose in all the different languages um that we, we have in, in javascript Python and go. Um And of course, it's more explicit in, in typescript here where it's in the, in the types of the thing. And basically Pulumi our outputs are the way that we take, you know, when I create this API there's going to be some properties of it like the URL, they're not known until it actually gets deployed. And so they're not known right away, but they will be known as the program kind of deploys itself into your infrastructure. And so if you want to write arbitrary code, uh that sort of operates in here, you need to be able to do that um as you know, only once that value is available. And so if I want to do something with that, URL, I need to go do it only once it's available and this is where apply um comes in. And so you'll see for something that's an output, we've got this apply method on it. And I can just say, you know, URL goes to maybe a console, don't log it. And so what this will do is when that URL becomes available, uh We'll go ahead and run this console dot log. And so the first time I deploy the application, it won't be available until it actually deploys that. And in later times, if it needs to replace it, this will wait until it replaces it. Otherwise it'll, it'll use the existing URL. And so this is a, you know, this is a core thing you need to be able to do to compose values together. But a really common thing that folks want to do is, is sort of uh uh you know, compose more interesting things. And so, for example, they might want to say, you know, um uh I don't know what they wanna say, lets um other URL equals um you know, and they might want to say something like this. Um They don't want to do some string concatenation, for example, where they can ate, you know, hello and then put the URL inside it. Um And so that's another case where you can use, apply. And similarly, you might want to do, you know, Jason dot Spring Aly and maybe this URL is uh is actually a rich object in this case. Uh You know, it's a, it's a string but maybe uh there's the one on here that is not. Uh Yeah. So, I mean, stage, for example, well, stage, I guess none of these are, are that uh interesting of objects. Um But if I, if I did have a self rich object, I might want to adjacent stringify it, for example. Um And so I can do that as well kind of inside and apply. Um And so you can learn a lot about the different ways you can sort of use apply and some of the other um building blocks around that um inside these documentation pages here. Um But that's a topic that, that comes up a fair bit here as well. OK. Uh So that I think may be it uh for today covered a bunch of different uh topics about what's new and some of the kind of questions that have come up recently. Um If folks have any, any other questions or things they're interested in, uh, definitely drop us a note in the, in the community slack. Um And, uh, we'll be excited to come back next week and, uh, and talk about some of the new things that we're doing um with Pulumi. Great thanks to everyone for joining us. We'll see you again next time. 51.

---
